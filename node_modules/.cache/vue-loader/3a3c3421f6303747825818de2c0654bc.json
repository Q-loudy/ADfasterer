{"remainingRequest":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\@vue\\vue-loader-v15\\lib\\index.js??vue-loader-options!C:\\Games\\ADFasterer\\ADfasterer\\src\\components\\tabs\\automator\\AutomatorBlockEditor.vue?vue&type=style&index=0&id=b7af5a1c&scoped=true&lang=css&","dependencies":[{"path":"C:\\Games\\ADFasterer\\ADfasterer\\src\\components\\tabs\\automator\\AutomatorBlockEditor.vue","mtime":1745241597060},{"path":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\css-loader\\dist\\cjs.js","mtime":1745242216572},{"path":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\@vue\\vue-loader-v15\\lib\\loaders\\stylePostLoader.js","mtime":1745242222796},{"path":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\postcss-loader\\dist\\cjs.js","mtime":1745242214022},{"path":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1745242214069},{"path":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\@vue\\vue-loader-v15\\lib\\index.js","mtime":1745242220175}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCg0KLmMtYXV0b21hdG9yLWJsb2NrLWVkaXRvciB7DQogIGRpc3BsYXk6IGZsZXg7DQogIG92ZXJmbG93LXk6IGF1dG87DQogIHRhYi1zaXplOiAxLjVyZW07DQogIHdpZHRoOiAxMDAlOw0KICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1ibG9ja21hdG9yLWVkaXRvci1iYWNrZ3JvdW5kKTsNCiAgYm94LXNpemluZzogY29udGVudC1ib3g7DQp9DQoNCi5jLWF1dG9tYXRvci1ibG9jay1lZGl0b3ItLWNvbnRhaW5lciB7DQogIGRpc3BsYXk6IGZsZXg7DQogIG92ZXJmbG93LXk6IGhpZGRlbjsNCiAgaGVpZ2h0OiAxMDAlOw0KICBwb3NpdGlvbjogcmVsYXRpdmU7DQogIGJveC1zaXppbmc6IGJvcmRlci1ib3g7DQp9DQoNCi5jLWF1dG9tYXRvci1ibG9ja3Mgew0KICB3aWR0aDogMTAwJTsNCiAgaGVpZ2h0OiBtYXgtY29udGVudDsNCiAgcGFkZGluZzogMC4zcmVtIDAuNnJlbSA1cmVtOw0KfQ0KDQouYy1hdXRvbWF0b3ItYmxvY2stZWRpdG9yLS1ndXR0ZXIgew0KICBoZWlnaHQ6IG1heC1jb250ZW50Ow0KICBtaW4taGVpZ2h0OiAxMDAlOw0KICBwb3NpdGlvbjogcmVsYXRpdmU7DQogIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWF1dG9tYXRvci1jb250cm9scy1iYWNrZ3JvdW5kKTsNCiAgYm9yZGVyLXJpZ2h0OiAwLjFyZW0gc29saWQgIzUwNTA1MDsNCiAgLyogbGVmdCBhbmQgcmlnaHQgcGFkZGluZ3MgYXJlIDEgdG8gbWFrZSBzcGFjZSBmb3IgdGV4dCwgYm90dG9tIHBhZGRpbmcgaXMgMjAgdG8gbWFrZSBmb3IgYSBidWZmZXIgKi8NCiAgcGFkZGluZzogMC4zcmVtIDFyZW0gMjByZW07DQp9DQoNCi5jLWF1dG9tYXRvci1ibG9jay1saW5lLW51bWJlciB7DQogIGRpc3BsYXk6IGZsZXg7DQogIGhlaWdodDogMy40NXJlbTsNCiAganVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDsNCiAgYWxpZ24taXRlbXM6IGNlbnRlcjsNCiAgZm9udC1zaXplOiAxLjRyZW07DQogIGNvbG9yOiB2YXIoLS1jb2xvci1hdXRvbWF0b3ItZG9jcy1mb250KTsNCn0NCg0KLm51bGwtYmxvY2sgew0KICBkaXNwbGF5OiBub25lOw0KICB2aXNpYmlsaXR5OiBoaWRkZW47DQp9DQo="},{"version":3,"sources":["AutomatorBlockEditor.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA","file":"AutomatorBlockEditor.vue","sourceRoot":"src/components/tabs/automator","sourcesContent":["<script>\r\nimport draggable from \"vuedraggable\";\r\n\r\nimport AutomatorBlockSingleRow from \"./AutomatorBlockSingleRow\";\r\nimport { blockifyTextAutomator } from \"@/core/automator\";\r\n\r\nexport default {\r\n  name: \"AutomatorBlockEditor\",\r\n  components: {\r\n    AutomatorBlockSingleRow,\r\n    draggable\r\n  },\r\n  computed: {\r\n    lines: {\r\n      get() {\r\n        return this.$viewModel.tabs.reality.automator.lines;\r\n      },\r\n      set(value) {\r\n        this.$viewModel.tabs.reality.automator.lines = value;\r\n      }\r\n    },\r\n    numberOfLines() {\r\n      return this.lines.reduce((a, l) => a + BlockAutomator.numberOfLinesInBlock(l), 0);\r\n    },\r\n  },\r\n  mounted() {\r\n    BlockAutomator.initialize();\r\n    AutomatorData.recalculateErrors();\r\n    BlockAutomator.editor.scrollTo(0, BlockAutomator.previousScrollPosition);\r\n    BlockAutomator.gutter.style.bottom = `${BlockAutomator.editor.scrollTop}px`;\r\n  },\r\n  methods: {\r\n    update() {\r\n      if (AutomatorBackend.state.followExecution) AutomatorBackend.jumpToActiveLine();\r\n      const targetLine = AutomatorBackend.isOn\r\n        ? BlockAutomator.lineNumberFromBlockID(BlockAutomator.currentBlockId)\r\n        : -1;\r\n      AutomatorHighlighter.updateHighlightedLine(targetLine, LineEnum.Active);\r\n    },\r\n    setPreviousScroll() {\r\n      BlockAutomator.previousScrollPosition = this.$refs.blockEditorElement.scrollTop;\r\n      BlockAutomator.gutter.style.bottom = `${BlockAutomator.editor.scrollTop}px`;\r\n    },\r\n    parseRequest() {\r\n      BlockAutomator.updateIdArray();\r\n      AutomatorData.recalculateErrors();\r\n      BlockAutomator.parseTextFromBlocks();\r\n    },\r\n    updateBlock(block, id) {\r\n      this.lines[this.lines.findIndex(x => x.id === id)] = block;\r\n      this.parseRequest();\r\n    },\r\n    deleteBlock(id) {\r\n      const idx = this.lines.findIndex(x => x.id === id);\r\n      this.lines.splice(idx, 1);\r\n      this.parseRequest();\r\n    },\r\n  }\r\n};\r\n\r\nexport const BlockAutomator = {\r\n  editor: null,\r\n  gutter: null,\r\n  _idArray: [],\r\n\r\n  initialize() {\r\n    this.editor = document.getElementsByClassName(\"c-automator-block-editor\")[0];\r\n    this.gutter = document.getElementsByClassName(\"c-automator-block-editor--gutter\")[0];\r\n  },\r\n\r\n  get lines() {\r\n    return ui.view.tabs.reality.automator.lines;\r\n  },\r\n\r\n  set lines(arr) {\r\n    ui.view.tabs.reality.automator.lines = arr;\r\n    this.updateIdArray();\r\n  },\r\n\r\n  get currentBlockId() {\r\n    if (AutomatorBackend.stack.isEmpty) return false;\r\n    return this._idArray[AutomatorBackend.stack.top.lineNumber - 1];\r\n  },\r\n\r\n  // _idArray contains a mapping from all text lines to block IDs in the blockmato, where only lines with\r\n  // actual commands have defined values. This means that every time a closing curly brace } occurs, all further\r\n  // line numbers between on block will be one less than the corresponding text line number\r\n  lineNumber(textLine) {\r\n    const skipLines = this._idArray.map((id, index) => (id ? -1 : index + 1)).filter(v => v !== -1);\r\n    return textLine - skipLines.countWhere(line => line <= textLine);\r\n  },\r\n\r\n  lineNumberFromBlockID(id) {\r\n    return this.lineNumber(this._idArray.indexOf(id) + 1);\r\n  },\r\n\r\n  // This gets called from many places which do block editor error checking for the purpose of a responsive UI, so\r\n  // we use checkID to distinguish between scripts to check. When not given, we assume it's the currently-displayed\r\n  // script; otherwise we need to be careful because we're in the process of changing scripts\r\n  parseTextFromBlocks(checkID) {\r\n    const content = this.parseLines(BlockAutomator.lines).join(\"\\n\");\r\n    const automatorID = checkID ?? ui.view.tabs.reality.automator.editorScriptID;\r\n    AutomatorData.recalculateErrors();\r\n    AutomatorBackend.saveScript(automatorID, content);\r\n  },\r\n\r\n  updateEditor(scriptText) {\r\n    const lines = blockifyTextAutomator(scriptText).blocks;\r\n    this.lines = lines;\r\n    return lines;\r\n  },\r\n\r\n  hasUnparsableCommands(text) {\r\n    const blockified = blockifyTextAutomator(text);\r\n    return blockified.validatedBlocks !== blockified.visitedBlocks;\r\n  },\r\n\r\n  generateText(block, indentation = 0) {\r\n    // We add an extra trailing space here and remove double-spaces at the end because this makes some conversion\r\n    // errors slightly less harsh; some errors which wiped entire lines now just fail to parse arguments instead\r\n    let parsed = `${\"\\t\".repeat(indentation)}${block.cmd} `;\r\n\r\n    parsed = parsed\r\n      .replace(\"COMMENT\", \"//\")\r\n      .replace(\"BLOB\", \"blob  \");\r\n\r\n    if (block.canWait && block.nowait) {\r\n      parsed = parsed.replace(/(\\S+)/u, \"$1 NOWAIT\");\r\n    }\r\n    if (block.respec) parsed += ` RESPEC`;\r\n\r\n    const propsToCheck = [\"genericInput1\", \"compOperator\", \"genericInput2\", \"singleSelectionInput\", \"singleTextInput\"];\r\n    for (const prop of propsToCheck) {\r\n      if (block[prop]) parsed += ` ${block[prop]}`;\r\n    }\r\n\r\n    if (block.cmd === \"IF\" || block.cmd === \"WHILE\" || block.cmd === \"UNTIL\") parsed += \" {\";\r\n\r\n    return parsed.replace(\"  \", \" \");\r\n  },\r\n\r\n  parseLines(l, indentation = 0) {\r\n    const lines = [];\r\n    for (let i = 0; i < l.length; i++) {\r\n      lines.push(this.generateText(l[i], indentation));\r\n      if (l[i].cmd === \"IF\" || l[i].cmd === \"WHILE\" || l[i].cmd === \"UNTIL\") {\r\n        lines.push(...this.parseLines(l[i].nest, indentation + 1));\r\n        lines.push(`${\"\\t\".repeat(indentation)}}`);\r\n      }\r\n    }\r\n\r\n    return lines;\r\n  },\r\n\r\n  blockIdArray(blocks) {\r\n    const output = [];\r\n    for (let i = 0; i < blocks.length; i++) {\r\n      const b = blocks[i];\r\n      output.push(b.id);\r\n      if (b.nested) output.push(...this.blockIdArray(b.nest), undefined);\r\n    }\r\n    return output;\r\n  },\r\n\r\n  updateIdArray() {\r\n    this._idArray = this.blockIdArray(this.lines);\r\n  },\r\n\r\n  numberOfLinesInBlock(block) {\r\n    return block.nested ? Math.max(block.nest.reduce((v, b) => v + this.numberOfLinesInBlock(b), 1), 2) : 1;\r\n  },\r\n\r\n  clearEditor() {\r\n    // I genuinely don't understand why this needs to be done asynchronously, but removing the setTimeout makes this\r\n    // method not do anything at all. Even setting the array in the console without the setTimeout works fine.\r\n    setTimeout(() => this.lines = [], 0);\r\n  },\r\n\r\n  previousScrollPosition: 0,\r\n};\r\n</script>\r\n\r\n<template>\r\n  <div class=\"c-automator-block-editor--container\">\r\n    <div\r\n      ref=\"editorGutter\"\r\n      class=\"c-automator-block-editor--gutter\"\r\n    >\r\n      <div\r\n        v-for=\"i in numberOfLines\"\r\n        :key=\"i\"\r\n        class=\"c-automator-block-line-number\"\r\n        :style=\"{\r\n          top: `${(i - 1) * 3.45}rem`\r\n        }\"\r\n      >\r\n        {{ i }}\r\n      </div>\r\n    </div>\r\n    <div\r\n      ref=\"blockEditorElement\"\r\n      class=\"c-automator-block-editor\"\r\n      @scroll=\"setPreviousScroll()\"\r\n    >\r\n      <draggable\r\n        v-model=\"lines\"\r\n        group=\"code-blocks\"\r\n        class=\"c-automator-blocks\"\r\n        ghost-class=\"c-automator-block-row-ghost\"\r\n        @end=\"parseRequest\"\r\n      >\r\n        <AutomatorBlockSingleRow\r\n          v-for=\"(block, lineNum) in lines\"\r\n          :key=\"block.id + 10000 * lineNum\"\r\n          :block=\"block\"\r\n          :update-block=\"updateBlock\"\r\n          :delete-block=\"deleteBlock\"\r\n        />\r\n      </draggable>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<style scoped>\r\n.c-automator-block-editor {\r\n  display: flex;\r\n  overflow-y: auto;\r\n  tab-size: 1.5rem;\r\n  width: 100%;\r\n  background-color: var(--color-blockmator-editor-background);\r\n  box-sizing: content-box;\r\n}\r\n\r\n.c-automator-block-editor--container {\r\n  display: flex;\r\n  overflow-y: hidden;\r\n  height: 100%;\r\n  position: relative;\r\n  box-sizing: border-box;\r\n}\r\n\r\n.c-automator-blocks {\r\n  width: 100%;\r\n  height: max-content;\r\n  padding: 0.3rem 0.6rem 5rem;\r\n}\r\n\r\n.c-automator-block-editor--gutter {\r\n  height: max-content;\r\n  min-height: 100%;\r\n  position: relative;\r\n  background-color: var(--color-automator-controls-background);\r\n  border-right: 0.1rem solid #505050;\r\n  /* left and right paddings are 1 to make space for text, bottom padding is 20 to make for a buffer */\r\n  padding: 0.3rem 1rem 20rem;\r\n}\r\n\r\n.c-automator-block-line-number {\r\n  display: flex;\r\n  height: 3.45rem;\r\n  justify-content: flex-end;\r\n  align-items: center;\r\n  font-size: 1.4rem;\r\n  color: var(--color-automator-docs-font);\r\n}\r\n\r\n.null-block {\r\n  display: none;\r\n  visibility: hidden;\r\n}\r\n</style>\r\n"]}]}