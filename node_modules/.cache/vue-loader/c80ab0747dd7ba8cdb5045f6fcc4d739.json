{"remainingRequest":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\@vue\\vue-loader-v15\\lib\\index.js??vue-loader-options!C:\\Games\\ADFasterer\\ADfasterer\\src\\components\\SliderComponent.vue?vue&type=script&lang=js&","dependencies":[{"path":"C:\\Games\\ADFasterer\\ADfasterer\\src\\components\\SliderComponent.vue","mtime":1745241596803},{"path":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\babel-loader\\lib\\index.js","mtime":1745242219290},{"path":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1745242214069},{"path":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\@vue\\vue-loader-v15\\lib\\index.js","mtime":1745242220175}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:DQppbXBvcnQgUGx1c01pbnVzQnV0dG9uIGZyb20gIkAvY29tcG9uZW50cy9QbHVzTWludXNCdXR0b24iOw0KDQovKg0KKiBUaGlzIGlzIGJhc2VkIG9uIHZ1ZS1zbGlkZXItY29tcG9uZW50DQoqIGRvd25sb2FkZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vTmlnaHRDYXRTYW1hL3Z1ZS1zbGlkZXItY29tcG9uZW50DQoqIEl0J3MgbW9kaWZpZWQgdG8gc3VwcG9ydCBzaG93aW5nIHRoZSBzbGlkZXIgdmFsdWUgaW4gdGhlIHNsaWRlci4NCiovDQovKg0KVGhlIE1JVCBMaWNlbnNlIChNSVQpDQoNCkNvcHlyaWdodCAoYykgMjAxNiBOaWdodENhdFNhbWEuDQoNClBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkNCm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlICJTb2Z0d2FyZSIpLCB0byBkZWFsDQppbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzDQp0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsDQpjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMNCmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6DQoNClRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbA0KY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS4NCg0KVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICJBUyBJUyIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1INCklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLA0KRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFDQpBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSDQpMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLA0KT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUNClNPRlRXQVJFLg0KKi8NCg0KLy8gVW5zaGFycCB0ZXh0IFsjMTY2XShodHRwczovL2dpdGh1Yi5jb20vTmlnaHRDYXRTYW1hL3Z1ZS1zbGlkZXItY29tcG9uZW50L2lzc3Vlcy8xNjYpDQpjb25zdCByb3VuZFRvRFBSID0gKGZ1bmN0aW9uICgpIHsNCiAgY29uc3QgciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSA6IDENCiAgcmV0dXJuIHZhbHVlID0+IE1hdGgucm91bmQodmFsdWUgKiByKSAvIHINCn0pKCkNCg0KZXhwb3J0IGRlZmF1bHQgew0KICBuYW1lOiAiU2xpZGVyQ29tcG9uZW50IiwNCiAgY29tcG9uZW50czogew0KICAgIFBsdXNNaW51c0J1dHRvbg0KICB9LA0KICBwcm9wczogew0KICAgIHdpZHRoOiB7DQogICAgICB0eXBlOiBTdHJpbmcsDQogICAgICBkZWZhdWx0OiAnYXV0bycNCiAgICB9LA0KICAgIGhlaWdodDogew0KICAgICAgdHlwZTogU3RyaW5nLA0KICAgICAgZGVmYXVsdDogIjZweCINCiAgICB9LA0KICAgIGRhdGE6IHsNCiAgICAgIHR5cGU6IEFycmF5LA0KICAgICAgZGVmYXVsdDogbnVsbA0KICAgIH0sDQogICAgZG90U2l6ZTogew0KICAgICAgdHlwZTogW1N0cmluZywgTnVtYmVyXSwNCiAgICAgIGRlZmF1bHQ6ICIxNnB4Ig0KICAgIH0sDQogICAgZG90V2lkdGg6IHsNCiAgICAgIHR5cGU6IFN0cmluZywNCiAgICAgIHJlcXVpcmVkOiBmYWxzZQ0KICAgIH0sDQogICAgZG90SGVpZ2h0OiB7DQogICAgICB0eXBlOiBTdHJpbmcsDQogICAgICByZXF1aXJlZDogZmFsc2UNCiAgICB9LA0KICAgIG1pbjogew0KICAgICAgdHlwZTogTnVtYmVyLA0KICAgICAgZGVmYXVsdDogMA0KICAgIH0sDQogICAgbWF4OiB7DQogICAgICB0eXBlOiBOdW1iZXIsDQogICAgICBkZWZhdWx0OiAxMDANCiAgICB9LA0KICAgIGludGVydmFsOiB7DQogICAgICB0eXBlOiBOdW1iZXIsDQogICAgICBkZWZhdWx0OiAxDQogICAgfSwNCiAgICBzaG93OiB7DQogICAgICB0eXBlOiBCb29sZWFuLA0KICAgICAgZGVmYXVsdDogdHJ1ZQ0KICAgIH0sDQogICAgZGlzYWJsZWQ6IHsNCiAgICAgIHR5cGU6IFtCb29sZWFuLCBBcnJheV0sDQogICAgICBkZWZhdWx0OiBmYWxzZQ0KICAgIH0sDQogICAgcGllY2V3aXNlOiB7DQogICAgICB0eXBlOiBCb29sZWFuLA0KICAgICAgZGVmYXVsdDogZmFsc2UNCiAgICB9LA0KICAgIHRvb2x0aXA6IHsNCiAgICAgIHR5cGU6IFtTdHJpbmcsIEJvb2xlYW5dLA0KICAgICAgZGVmYXVsdDogJ2Fsd2F5cycNCiAgICB9LA0KICAgIGV2ZW50VHlwZTogew0KICAgICAgdHlwZTogU3RyaW5nLA0KICAgICAgZGVmYXVsdDogJ2F1dG8nDQogICAgfSwNCiAgICBkaXJlY3Rpb246IHsNCiAgICAgIHR5cGU6IFN0cmluZywNCiAgICAgIGRlZmF1bHQ6ICdob3Jpem9udGFsJw0KICAgIH0sDQogICAgcmV2ZXJzZTogew0KICAgICAgdHlwZTogQm9vbGVhbiwNCiAgICAgIGRlZmF1bHQ6IGZhbHNlDQogICAgfSwNCiAgICBsYXp5OiB7DQogICAgICB0eXBlOiBCb29sZWFuLA0KICAgICAgZGVmYXVsdDogZmFsc2UNCiAgICB9LA0KICAgIGNsaWNrYWJsZTogew0KICAgICAgdHlwZTogQm9vbGVhbiwNCiAgICAgIGRlZmF1bHQ6IHRydWUNCiAgICB9LA0KICAgIHNwZWVkOiB7DQogICAgICB0eXBlOiBOdW1iZXIsDQogICAgICBkZWZhdWx0OiAwLjUNCiAgICB9LA0KICAgIHJlYWxUaW1lOiB7DQogICAgICB0eXBlOiBCb29sZWFuLA0KICAgICAgZGVmYXVsdDogZmFsc2UNCiAgICB9LA0KICAgIHN0b3BQcm9wYWdhdGlvbjogew0KICAgICAgdHlwZTogQm9vbGVhbiwNCiAgICAgIGRlZmF1bHQ6IGZhbHNlDQogICAgfSwNCiAgICB2YWx1ZTogew0KICAgICAgdHlwZTogW1N0cmluZywgTnVtYmVyLCBBcnJheSwgT2JqZWN0XSwNCiAgICAgIGRlZmF1bHQ6IDANCiAgICB9LA0KICAgIHBpZWNld2lzZUxhYmVsOiB7DQogICAgICB0eXBlOiBCb29sZWFuLA0KICAgICAgZGVmYXVsdDogZmFsc2UNCiAgICB9LA0KICAgIGRlYnVnOiB7DQogICAgICB0eXBlOiBCb29sZWFuLA0KICAgICAgZGVmYXVsdDogdHJ1ZQ0KICAgIH0sDQogICAgZml4ZWQ6IHsNCiAgICAgIHR5cGU6IEJvb2xlYW4sDQogICAgICBkZWZhdWx0OiBmYWxzZQ0KICAgIH0sDQogICAgbWluUmFuZ2U6IHsNCiAgICAgIHR5cGU6IE51bWJlcg0KICAgIH0sDQogICAgbWF4UmFuZ2U6IHsNCiAgICAgIHR5cGU6IE51bWJlcg0KICAgIH0sDQogICAgcHJvY2Vzc0RyYWdnYWJsZTogew0KICAgICAgdHlwZTogQm9vbGVhbiwNCiAgICAgIGRlZmF1bHQ6IGZhbHNlDQogICAgfSwNCiAgICB1c2VLZXlib2FyZDogew0KICAgICAgdHlwZTogQm9vbGVhbiwNCiAgICAgIGRlZmF1bHQ6IGZhbHNlDQogICAgfSwNCiAgICBhY3Rpb25zS2V5Ym9hcmQ6IHsNCiAgICAgIHR5cGU6IEFycmF5LA0KICAgICAgZGVmYXVsdCgpIHsNCiAgICAgICAgcmV0dXJuIFsoaSkgPT4gaSAtIDEsIChpKSA9PiBpICsgMV0NCiAgICAgIH0NCiAgICB9LA0KICAgIHBpZWNld2lzZUZpbHRlcjogew0KICAgICAgdHlwZTogRnVuY3Rpb24NCiAgICB9LA0KICAgIHRvb2x0aXBNZXJnZTogew0KICAgICAgdHlwZTogQm9vbGVhbiwNCiAgICAgIGRlZmF1bHQ6IHRydWUNCiAgICB9LA0KICAgIHN0YXJ0QW5pbWF0aW9uOiB7DQogICAgICB0eXBlOiBCb29sZWFuLA0KICAgICAgZGVmYXVsdDogZmFsc2UNCiAgICB9LA0KICAgIGVuYWJsZUNyb3NzOiB7DQogICAgICB0eXBlOiBCb29sZWFuLA0KICAgICAgZGVmYXVsdDogdHJ1ZQ0KICAgIH0sDQogICAgdmFsdWVJbkRvdDogew0KICAgICAgdHlwZTogQm9vbGVhbiwNCiAgICAgIGRlZmF1bHQ6IGZhbHNlDQogICAgfSwNCiAgICBwbHVzTWludXNCdXR0b25zOiB7DQogICAgICB0eXBlOiBCb29sZWFuLA0KICAgICAgZGVmYXVsdDogZmFsc2UsDQogICAgfSwNCiAgICBzbGlkZXJTdHlsZTogW0FycmF5LCBPYmplY3QsIEZ1bmN0aW9uXSwNCiAgICBmb2N1c1N0eWxlOiBbQXJyYXksIE9iamVjdCwgRnVuY3Rpb25dLA0KICAgIHRvb2x0aXBEaXI6IFtBcnJheSwgU3RyaW5nXSwNCiAgICB4Zm9ybWF0dGVyOiBbU3RyaW5nLCBGdW5jdGlvbl0sIC8vIEdsb2JhbCBtaXhpbiBkZWZpbmVzIGZvcm1hdHRlcg0KICAgIG1lcmdlRm9ybWF0dGVyOiBbU3RyaW5nLCBGdW5jdGlvbl0sDQogICAgcGllY2V3aXNlU3R5bGU6IE9iamVjdCwNCiAgICBkaXNhYmxlZFN0eWxlOiBPYmplY3QsDQogICAgcGllY2V3aXNlQWN0aXZlU3R5bGU6IE9iamVjdCwNCiAgICBwcm9jZXNzU3R5bGU6IE9iamVjdCwNCiAgICBwcm9jZXNzQ2xhc3M6IFN0cmluZywNCiAgICBiZ1N0eWxlOiBPYmplY3QsDQogICAgYmdDbGFzczogU3RyaW5nLA0KICAgIHRvb2x0aXBTdHlsZTogW0FycmF5LCBPYmplY3QsIEZ1bmN0aW9uXSwNCiAgICBkaXNhYmxlZERvdFN0eWxlOiBbQXJyYXksIE9iamVjdCwgRnVuY3Rpb25dLA0KICAgIGxhYmVsU3R5bGU6IE9iamVjdCwNCiAgICBsYWJlbEFjdGl2ZVN0eWxlOiBPYmplY3QsDQogICAgZG90Q2xhc3M6IFtTdHJpbmcsIEFycmF5XQ0KICB9LA0KICBkYXRhKCkgew0KICAgIHJldHVybiB7DQogICAgICBmbGFnOiBmYWxzZSwNCiAgICAgIGRyYWdGbGFnOiBmYWxzZSwNCiAgICAgIGNyb3NzRmxhZzogZmFsc2UsDQogICAgICBrZXlkb3duRmxhZzogbnVsbCwNCiAgICAgIGZvY3VzRmxhZzogZmFsc2UsDQogICAgICBwcm9jZXNzRmxhZzogZmFsc2UsDQogICAgICBwcm9jZXNzU2lnbjogbnVsbCwNCiAgICAgIHNpemU6IDAsDQogICAgICBmaXhlZFZhbHVlOiAwLA0KICAgICAgZm9jdXNTbGlkZXI6IDAsDQogICAgICBjdXJyZW50VmFsdWU6IDAsDQogICAgICBjdXJyZW50U2xpZGVyOiAwLA0KICAgICAgaXNDb21wb25lbnRFeGlzdHM6IHRydWUsDQogICAgICBpc01vdW50ZWQ6IGZhbHNlLA0KICAgICAgZG90QXhpYWxTaXplUHg6IDEsDQogICAgfQ0KICB9LA0KICBjb21wdXRlZDogew0KICAgIHRvb2x0aXBGb3JtYXRIZWxwZXIoKSB7DQogICAgICBpZiAodGhpcy5tZXJnZUZvcm1hdHRlcikgew0KICAgICAgICByZXR1cm4gdGhpcy5tZXJnZUZvcm1hdHRpbmcodGhpcy52YWxbMF0sIHRoaXMudmFsWzFdKTsNCiAgICAgIH0NCiAgICAgIGlmICh0aGlzLnhmb3JtYXR0ZXIpIHsNCiAgICAgICAgaWYgKHRoaXMudmFsWzBdID09PSB0aGlzLnZhbFsxXSkgcmV0dXJuIHRoaXMuZm9ybWF0dGluZyh0aGlzLnZhbFswXSk7DQogICAgICAgIHJldHVybiB0aGlzLmZvcm1hdHRpbmcodGhpcy52YWxbMF0pICsgIi0iICsgdGhpcy5mb3JtYXR0aW5nKHRoaXMudmFsWzFdKTsNCiAgICAgIH0NCiAgICAgIGlmICh0aGlzLnZhbFswXSA9PT0gdGhpcy52YWxbMV0pIHJldHVybiB0aGlzLnZhbFswXTsNCiAgICAgIHJldHVybiB0aGlzLnZhbFswXSArICItIiArIHRoaXMudmFsWzFdOw0KICAgIH0sDQogICAgZG90V2lkdGhWYWwoKSB7DQogICAgICByZXR1cm4gdGhpcy5kb3RXaWR0aCB8fCB0aGlzLmRvdFNpemU7DQogICAgfSwNCiAgICBkb3RIZWlnaHRWYWwoKSB7DQogICAgICByZXR1cm4gdGhpcy5kb3RIZWlnaHQgfHwgdGhpcy5kb3RTaXplOw0KICAgIH0sDQogICAgZmxvd0RpcmVjdGlvbigpIHsNCiAgICAgIHJldHVybiBgbC1hZC1zbGlkZXItLSR7dGhpcy5kaXJlY3Rpb24gKyAodGhpcy5yZXZlcnNlID8gJy1yZXZlcnNlJyA6ICcnKX1gDQogICAgfSwNCiAgICB0b29sdGlwTWVyZ2VkUG9zaXRpb24oKSB7DQogICAgICBpZiAoIXRoaXMuaXNNb3VudGVkKSByZXR1cm4ge30NCiAgICAgIGNvbnN0IHRvb2x0aXBEaXJlY3Rpb24gPSB0aGlzLnRvb2x0aXBEaXJlY3Rpb25bMF0NCiAgICAgIGlmICh0aGlzLiRyZWZzLmRvdDApIHsNCiAgICAgICAgY29uc3Qgc3R5bGUgPSB7fQ0KICAgICAgICBzdHlsZVt0b29sdGlwRGlyZWN0aW9uXSA9IGAtJHsodGhpcy5kb3RBeGlhbFNpemVQeCAvIDIpIC0gKHRoaXMuc2l6ZSAvIDIpICsgOX1weGANCiAgICAgICAgc3R5bGVbJ2xlZnQnXSA9IGA1MCVgDQogICAgICAgIHJldHVybiBzdHlsZQ0KICAgICAgfQ0KICAgIH0sDQogICAgdG9vbHRpcERpcmVjdGlvbigpIHsNCiAgICAgIGNvbnN0IGRpciA9IHRoaXMudG9vbHRpcERpciB8fCAodGhpcy5kaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcgPyAnbGVmdCcgOiAndG9wJykNCiAgICAgIGlmIChBcnJheS5pc0FycmF5KGRpcikpIHsNCiAgICAgICAgcmV0dXJuIHRoaXMuaXNSYW5nZSA/IGRpciA6IGRpclsxXQ0KICAgICAgfSBlbHNlIHsNCiAgICAgICAgcmV0dXJuIHRoaXMuaXNSYW5nZSA/IFtkaXIsIGRpcl0gOiBkaXINCiAgICAgIH0NCiAgICB9LA0KICAgIHRvb2x0aXBTdGF0dXMoKSB7DQogICAgICByZXR1cm4gdGhpcy50b29sdGlwID09PSAnaG92ZXInICYmIHRoaXMuZmxhZyA/ICdhZC1zbGlkZXItYWx3YXlzJyA6IHRoaXMudG9vbHRpcCA/IGBhZC1zbGlkZXItJHt0aGlzLnRvb2x0aXB9YCA6ICcnDQogICAgfSwNCiAgICB0b29sdGlwQ2xhc3MoKSB7DQogICAgICByZXR1cm4gW2BhZC1zbGlkZXItdG9vbHRpcC0ke3RoaXMudG9vbHRpcERpcmVjdGlvbn1gLCAnYWQtc2xpZGVyLXRvb2x0aXAnXQ0KICAgIH0sDQogICAgZGlzYWJsZWRBcnJheSgpIHsNCiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRoaXMuZGlzYWJsZWQpID8gdGhpcy5kaXNhYmxlZCA6IFt0aGlzLmRpc2FibGVkLCB0aGlzLmRpc2FibGVkXQ0KICAgIH0sDQogICAgYm9vbERpc2FibGVkKCkgew0KICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZWRBcnJheS5ldmVyeShiID0+IGIgPT09IHRydWUpDQogICAgfSwNCiAgICBpc0Rpc2FibGVkKCkgew0KICAgICAgcmV0dXJuIHRoaXMuZXZlbnRUeXBlID09PSAnbm9uZScgPyB0cnVlIDogdGhpcy5ib29sRGlzYWJsZWQNCiAgICB9LA0KICAgIGRpc2FibGVkQ2xhc3MoKSB7DQogICAgICByZXR1cm4gdGhpcy5ib29sRGlzYWJsZWQgPyAnbC1hZC1zbGlkZXItLWRpc2FibGVkJyA6ICcnDQogICAgfSwNCiAgICBzdGF0ZUNsYXNzKCkgew0KICAgICAgcmV0dXJuIHsNCiAgICAgICAgJ2FkLXNsaWRlci1zdGF0ZS1wcm9jZXNzLWRyYWcnOiB0aGlzLnByb2Nlc3NGbGFnLA0KICAgICAgICAnYWQtc2xpZGVyLXN0YXRlLWRyYWcnOiB0aGlzLmZsYWcgJiYgIXRoaXMucHJvY2Vzc0ZsYWcgJiYgIXRoaXMua2V5ZG93bkZsYWcsDQogICAgICAgICdhZC1zbGlkZXItc3RhdGUtZm9jdXMnOiB0aGlzLmZvY3VzRmxhZw0KICAgICAgfQ0KICAgIH0sDQogICAgaXNSYW5nZSgpIHsNCiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRoaXMudmFsdWUpDQogICAgfSwNCiAgICBzbGlkZXIoKSB7DQogICAgICByZXR1cm4gdGhpcy5pc1JhbmdlID8gW3RoaXMuJHJlZnMuZG90MCwgdGhpcy4kcmVmcy5kb3QxXSA6IFt0aGlzLiRyZWZzLmRvdDBdDQogICAgfSwNCiAgICBtaW5pbXVtKCkgew0KICAgICAgcmV0dXJuIHRoaXMuZGF0YSA/IDAgOiB0aGlzLm1pbg0KICAgIH0sDQogICAgdmFsOiB7DQogICAgICBnZXQoKSB7DQogICAgICAgIHJldHVybiB0aGlzLmRhdGEgPyAodGhpcy5pc1JhbmdlID8gW3RoaXMuZGF0YVt0aGlzLmN1cnJlbnRWYWx1ZVswXV0sIHRoaXMuZGF0YVt0aGlzLmN1cnJlbnRWYWx1ZVsxXV1dIDogdGhpcy5kYXRhW3RoaXMuY3VycmVudFZhbHVlXSkgOiB0aGlzLmN1cnJlbnRWYWx1ZQ0KICAgICAgfSwNCiAgICAgIHNldCh2YWwpIHsNCiAgICAgICAgaWYgKHRoaXMuZGF0YSkgew0KICAgICAgICAgIGlmICh0aGlzLmlzUmFuZ2UpIHsNCiAgICAgICAgICAgIGNvbnN0IGluZGV4MCA9IHRoaXMuZGF0YS5pbmRleE9mKHZhbFswXSkNCiAgICAgICAgICAgIGNvbnN0IGluZGV4MSA9IHRoaXMuZGF0YS5pbmRleE9mKHZhbFsxXSkNCiAgICAgICAgICAgIGlmIChpbmRleDAgPiAtMSAmJiBpbmRleDEgPiAtMSkgew0KICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IFtpbmRleDAsIGluZGV4MV0NCiAgICAgICAgICAgIH0NCiAgICAgICAgICB9IGVsc2Ugew0KICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmRhdGEuaW5kZXhPZih2YWwpDQogICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkgew0KICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IGluZGV4DQogICAgICAgICAgICB9DQogICAgICAgICAgfQ0KICAgICAgICB9IGVsc2Ugew0KICAgICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gdmFsDQogICAgICAgIH0NCiAgICAgIH0NCiAgICB9LA0KICAgIGN1cnJlbnRJbmRleCgpIHsNCiAgICAgIGlmICh0aGlzLmlzUmFuZ2UpIHsNCiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YSA/IHRoaXMuY3VycmVudFZhbHVlIDogW3RoaXMuZ2V0SW5kZXhCeVZhbHVlKHRoaXMuY3VycmVudFZhbHVlWzBdKSwgdGhpcy5nZXRJbmRleEJ5VmFsdWUodGhpcy5jdXJyZW50VmFsdWVbMV0pXQ0KICAgICAgfSBlbHNlIHsNCiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5kZXhCeVZhbHVlKHRoaXMuY3VycmVudFZhbHVlKQ0KICAgICAgfQ0KICAgIH0sDQogICAgaW5kZXhSYW5nZSgpIHsNCiAgICAgIGlmICh0aGlzLmlzUmFuZ2UpIHsNCiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudEluZGV4DQogICAgICB9IGVsc2Ugew0KICAgICAgICByZXR1cm4gWzAsIHRoaXMuY3VycmVudEluZGV4XQ0KICAgICAgfQ0KICAgIH0sDQogICAgbWF4aW11bSgpIHsNCiAgICAgIHJldHVybiB0aGlzLmRhdGEgPyAodGhpcy5kYXRhLmxlbmd0aCAtIDEpIDogdGhpcy5tYXgNCiAgICB9LA0KICAgIG11bHRpcGxlKCkgew0KICAgICAgY29uc3QgZGVjaW1hbHMgPSBgJHt0aGlzLmludGVydmFsfWAuc3BsaXQoJy4nKVsxXQ0KICAgICAgcmV0dXJuIGRlY2ltYWxzID8gTWF0aC5wb3coMTAsIGRlY2ltYWxzLmxlbmd0aCkgOiAxDQogICAgfSwNCiAgICBzcGFjaW5nKCkgew0KICAgICAgcmV0dXJuIHRoaXMuZGF0YSA/IDEgOiB0aGlzLmludGVydmFsDQogICAgfSwNCiAgICB0b3RhbCgpIHsNCiAgICAgIGlmICh0aGlzLmRhdGEpIHsNCiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5sZW5ndGggLSAxDQogICAgICB9IGVsc2UgaWYgKE1hdGguZmxvb3IoKHRoaXMubWF4aW11bSAtIHRoaXMubWluaW11bSkgKiB0aGlzLm11bHRpcGxlKSAlICh0aGlzLmludGVydmFsICogdGhpcy5tdWx0aXBsZSkgIT09IDApIHsNCiAgICAgICAgdGhpcy5wcmludEVycm9yKCdQcm9wW2ludGVydmFsXSBpcyBpbGxlZ2FsLCBQbGVhc2UgbWFrZSBzdXJlIHRoYXQgdGhlIGludGVydmFsIGNhbiBiZSBkaXZpc2libGUnKQ0KICAgICAgfQ0KICAgICAgcmV0dXJuICh0aGlzLm1heGltdW0gLSB0aGlzLm1pbmltdW0pIC8gdGhpcy5pbnRlcnZhbA0KICAgIH0sDQogICAgdXNhYmxlU2l6ZSgpIHsNCiAgICAgIHJldHVybiB0aGlzLnNpemUgLSB0aGlzLmRvdEF4aWFsU2l6ZVB4Ow0KICAgIH0sDQogICAgZ2FwKCkgew0KICAgICAgcmV0dXJuIHRoaXMudXNhYmxlU2l6ZSAvIHRoaXMudG90YWwNCiAgICB9LA0KICAgIHBvc2l0aW9uKCkgew0KICAgICAgaWYgKHRoaXMuaXNSYW5nZSkgew0KICAgICAgICByZXR1cm4gWyh0aGlzLmN1cnJlbnRWYWx1ZVswXSAtIHRoaXMubWluaW11bSkgLyB0aGlzLnNwYWNpbmcgKiB0aGlzLmdhcCArIHRoaXMuZG90QXhpYWxTaXplUHggLyAyLCAodGhpcy5jdXJyZW50VmFsdWVbMV0gLSB0aGlzLm1pbmltdW0pIC8gdGhpcy5zcGFjaW5nICogdGhpcy5nYXAgKyB0aGlzLmRvdEF4aWFsU2l6ZVB4IC8gMl0NCiAgICAgIH0gZWxzZSB7DQogICAgICAgIHJldHVybiAoKHRoaXMuY3VycmVudFZhbHVlIC0gdGhpcy5taW5pbXVtKSAvIHRoaXMuc3BhY2luZyAqIHRoaXMuZ2FwICsgdGhpcy5kb3RBeGlhbFNpemVQeCAvIDIpDQogICAgICB9DQogICAgfSwNCiAgICBpc0ZpeGVkKCkgew0KICAgICAgcmV0dXJuIHRoaXMuZml4ZWQgfHwgdGhpcy5taW5SYW5nZQ0KICAgIH0sDQogICAgbGltaXQoKSB7DQogICAgICBpZiAodGhpcy5pc1JhbmdlKSB7DQogICAgICAgIGlmICh0aGlzLmlzRml4ZWQpIHsNCiAgICAgICAgICByZXR1cm4gW1t0aGlzLmRvdEF4aWFsU2l6ZVB4IC8gMiwgdGhpcy5kb3RBeGlhbFNpemVQeCAvIDIgKyAodGhpcy50b3RhbCAtIHRoaXMuZml4ZWRWYWx1ZSkgKiB0aGlzLmdhcF0sIFt0aGlzLmZpeGVkVmFsdWUgKiB0aGlzLmdhcCArIHRoaXMuZG90QXhpYWxTaXplUHggLyAyLCB0aGlzLnNpemUgLSB0aGlzLmRvdEF4aWFsU2l6ZVB4IC8gMl1dDQogICAgICAgIH0gZWxzZSB7DQogICAgICAgICAgcmV0dXJuIFtbdGhpcy5kb3RBeGlhbFNpemVQeCAvIDIsIHRoaXMucG9zaXRpb25bMV1dLCBbdGhpcy5wb3NpdGlvblswXSwgdGhpcy5zaXplIC0gdGhpcy5kb3RBeGlhbFNpemVQeCAvIDJdXTsNCiAgICAgICAgfQ0KICAgICAgfSBlbHNlIHsNCiAgICAgICAgcmV0dXJuIFt0aGlzLmRvdEF4aWFsU2l6ZVB4IC8gMiwgdGhpcy5zaXplIC0gdGhpcy5kb3RBeGlhbFNpemVQeCAvIDJdOw0KICAgICAgfQ0KICAgIH0sDQogICAgdmFsdWVMaW1pdCgpIHsNCiAgICAgIHJldHVybiB0aGlzLmlzUmFuZ2UgPyB0aGlzLmlzRml4ZWQgPyBbW3RoaXMubWluaW11bSwgdGhpcy5tYXhpbXVtIC0gKHRoaXMuZml4ZWRWYWx1ZSAqICh0aGlzLnNwYWNpbmcgKiB0aGlzLm11bHRpcGxlKSkgLyB0aGlzLm11bHRpcGxlXSwgW3RoaXMubWluaW11bSArICh0aGlzLmZpeGVkVmFsdWUgKiAodGhpcy5zcGFjaW5nICogdGhpcy5tdWx0aXBsZSkpIC8gdGhpcy5tdWx0aXBsZSwgdGhpcy5tYXhpbXVtXV0gOiBbW3RoaXMubWluaW11bSwgdGhpcy5jdXJyZW50VmFsdWVbMV1dLCBbdGhpcy5jdXJyZW50VmFsdWVbMF0sIHRoaXMubWF4aW11bV1dIDogW3RoaXMubWluaW11bSwgdGhpcy5tYXhpbXVtXQ0KICAgIH0sDQogICAgaWRsZVNsaWRlcigpIHsNCiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRTbGlkZXIgPT09IDAgPyAxIDogMA0KICAgIH0sDQogICAgd3JhcFN0eWxlcygpIHsNCiAgICAgIGxldCByZXQgPSB0aGlzLmRpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJyA/IHsNCiAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCwNCiAgICAgIH0gOiB7DQogICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLA0KICAgICAgfQ0KICAgICAgaWYgKHRoaXMucGx1c01pbnVzQnV0dG9ucykgew0KICAgICAgICByZXRbdGhpcy5kaXJlY3Rpb24gPT09ICJ2ZXJ0aWNhbCIgPyAibWFyZ2luLXRvcCIgOiAibWFyZ2luLXJpZ2h0Il0gPSAiMC41cmVtIjsNCiAgICAgICAgcmV0W3RoaXMuZGlyZWN0aW9uID09PSAidmVydGljYWwiID8gIm1hcmdpbi1ib3R0b20iIDogIm1hcmdpbi1sZWZ0Il0gPSAiMC41cmVtIjsNCiAgICAgIH0NCiAgICAgIHJldHVybiByZXQ7DQogICAgfSwNCiAgICBzbGlkZXJTdHlsZXMoKSB7DQogICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnNsaWRlclN0eWxlKSkgew0KICAgICAgICByZXR1cm4gdGhpcy5pc1JhbmdlID8gdGhpcy5zbGlkZXJTdHlsZSA6IHRoaXMuc2xpZGVyU3R5bGVbMV0NCiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuc2xpZGVyU3R5bGUgPT09ICdmdW5jdGlvbicpIHsNCiAgICAgICAgcmV0dXJuIHRoaXMuc2xpZGVyU3R5bGUodGhpcy52YWwsIHRoaXMuY3VycmVudEluZGV4KQ0KICAgICAgfSBlbHNlIHsNCiAgICAgICAgcmV0dXJuIHRoaXMuaXNSYW5nZSA/IFt0aGlzLnNsaWRlclN0eWxlLCB0aGlzLnNsaWRlclN0eWxlXSA6IHRoaXMuc2xpZGVyU3R5bGUNCiAgICAgIH0NCiAgICB9LA0KICAgIGZvY3VzU3R5bGVzKCkgew0KICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5mb2N1c1N0eWxlKSkgew0KICAgICAgICByZXR1cm4gdGhpcy5pc1JhbmdlID8gdGhpcy5mb2N1c1N0eWxlIDogdGhpcy5mb2N1c1N0eWxlWzFdDQogICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLmZvY3VzU3R5bGUgPT09ICdmdW5jdGlvbicpIHsNCiAgICAgICAgcmV0dXJuIHRoaXMuZm9jdXNTdHlsZSh0aGlzLnZhbCwgdGhpcy5jdXJyZW50SW5kZXgpDQogICAgICB9IGVsc2Ugew0KICAgICAgICByZXR1cm4gdGhpcy5pc1JhbmdlID8gW3RoaXMuZm9jdXNTdHlsZSwgdGhpcy5mb2N1c1N0eWxlXSA6IHRoaXMuZm9jdXNTdHlsZQ0KICAgICAgfQ0KICAgIH0sDQogICAgZGlzYWJsZWREb3RTdHlsZXMoKSB7DQogICAgICBjb25zdCBkaXNhYmxlZFN0eWxlID0gdGhpcy5kaXNhYmxlZERvdFN0eWxlDQogICAgICBpZiAoQXJyYXkuaXNBcnJheShkaXNhYmxlZFN0eWxlKSkgew0KICAgICAgICByZXR1cm4gZGlzYWJsZWRTdHlsZQ0KICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGlzYWJsZWRTdHlsZSA9PT0gJ2Z1bmN0aW9uJykgew0KICAgICAgICBjb25zdCBzdHlsZSA9IGRpc2FibGVkU3R5bGUodGhpcy52YWwsIHRoaXMuY3VycmVudEluZGV4KQ0KICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShzdHlsZSkgPyBzdHlsZSA6IFtzdHlsZSwgc3R5bGVdDQogICAgICB9IGVsc2UgaWYgKGRpc2FibGVkU3R5bGUpIHsNCiAgICAgICAgcmV0dXJuIFtkaXNhYmxlZFN0eWxlLCBkaXNhYmxlZFN0eWxlXQ0KICAgICAgfSBlbHNlIHsNCiAgICAgICAgcmV0dXJuIFt7DQogICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnI2NjYycNCiAgICAgICAgfSwgew0KICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJyNjY2MnDQogICAgICAgIH1dDQogICAgICB9DQogICAgfSwNCiAgICB0b29sdGlwU3R5bGVzKCkgew0KICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy50b29sdGlwU3R5bGUpKSB7DQogICAgICAgIHJldHVybiB0aGlzLmlzUmFuZ2UgPyB0aGlzLnRvb2x0aXBTdHlsZSA6IHRoaXMudG9vbHRpcFN0eWxlWzFdDQogICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLnRvb2x0aXBTdHlsZSA9PT0gJ2Z1bmN0aW9uJykgew0KICAgICAgICByZXR1cm4gdGhpcy50b29sdGlwU3R5bGUodGhpcy52YWwsIHRoaXMuY3VycmVudEluZGV4KQ0KICAgICAgfSBlbHNlIHsNCiAgICAgICAgcmV0dXJuIHRoaXMuaXNSYW5nZSA/IFt0aGlzLnRvb2x0aXBTdHlsZSwgdGhpcy50b29sdGlwU3R5bGVdIDogdGhpcy50b29sdGlwU3R5bGUNCiAgICAgIH0NCiAgICB9LA0KICAgIGVsZW1TdHlsZXMoKSB7DQogICAgICByZXR1cm4gdGhpcy5kaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcgPyB7DQogICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLA0KICAgICAgICBoZWlnaHQ6ICcxMDAlJywNCiAgICAgICAgcG9zaXRpb246ICJyZWxhdGl2ZSINCiAgICAgIH0gOiB7DQogICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsDQogICAgICAgIHBvc2l0aW9uOiAicmVsYXRpdmUiDQogICAgICB9DQogICAgfSwNCiAgICBkcmFnZ2FibGVTdHlsZSgpIHsNCiAgICAgIHJldHVybiB7DQogICAgICAgIGN1cnNvcjogdGhpcy5ib29sRGlzYWJsZWQgPyAiZGVmYXVsdCIgOiAicG9pbnRlciINCiAgICAgIH07DQogICAgfSwNCiAgICBkb3RTdHlsZXMoKSB7DQogICAgICBsZXQgcmV0ID0gew0KICAgICAgICB3aWR0aDogdGhpcy5kb3RXaWR0aFZhbCwNCiAgICAgICAgaGVpZ2h0OiB0aGlzLmRvdEhlaWdodFZhbCwNCiAgICAgICAgcG9zaXRpb246ICJhYnNvbHV0ZSIsDQogICAgICB9DQogICAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT09ICJ2ZXJ0aWNhbCIpIHsNCiAgICAgICAgcmV0LmxlZnQgPSAiNTAlIjsNCiAgICAgIH0gZWxzZSB7DQogICAgICAgIHJldC50b3AgPSAiNTAlIjsNCiAgICAgIH0NCiAgICAgIHJldHVybiByZXQ7DQogICAgICAvKg0KICAgICAgcmV0dXJuIHRoaXMuZGlyZWN0aW9uID09PSAndmVydGljYWwnID8gew0KICAgICAgICB3aWR0aDogdGhpcy5kb3RXaWR0aFZhbCwNCiAgICAgICAgaGVpZ2h0OiB0aGlzLmRvdEhlaWdodFZhbCwNCiAgICAgICAgbGVmdDogYCR7KC0odGhpcy5kb3RXaWR0aFZhbCAtIHRoaXMud2lkdGgpIC8gMil9cHhgDQogICAgICB9IDogew0KICAgICAgICAgIHdpZHRoOiBgJHt0aGlzLmRvdFdpZHRoVmFsfXB4YCwNCiAgICAgICAgICBoZWlnaHQ6IGAke3RoaXMuZG90SGVpZ2h0VmFsfXB4YCwNCiAgICAgICAgICB0b3A6IGAkeygtKHRoaXMuZG90SGVpZ2h0VmFsIC0gdGhpcy5oZWlnaHQpIC8gMil9cHhgDQogICAgICAgIH0qLw0KICAgIH0sDQogICAgcGllY2V3aXNlRG90U3R5bGUoKSB7DQogICAgICByZXR1cm4gew0KICAgICAgICB3aWR0aDogdGhpcy53aWR0aCwNCiAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCwNCiAgICAgIH07DQogICAgfSwNCiAgICBwaWVjZXdpc2VEb3RXcmFwKCkgew0KICAgICAgaWYgKCF0aGlzLnBpZWNld2lzZSAmJiAhdGhpcy5waWVjZXdpc2VMYWJlbCkgew0KICAgICAgICByZXR1cm4gZmFsc2UNCiAgICAgIH0NCiAgICAgIGxldCBhcnIgPSBbXQ0KICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gdGhpcy50b3RhbDsgaSsrKSB7DQogICAgICAgIGNvbnN0IHN0eWxlID0gdGhpcy5kaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcgPyB7DQogICAgICAgICAgYm90dG9tOiBgJHt0aGlzLmdhcCAqIGkgLSB0aGlzLnVzYWJsZVNpemUgLyAyIH1weGAsDQogICAgICAgICAgbGVmdDogMA0KICAgICAgICB9IDogew0KICAgICAgICAgIGxlZnQ6IGAke3RoaXMuZ2FwICogaSAtIHRoaXMudXNhYmxlU2l6ZSAvIDIgfXB4YCwNCiAgICAgICAgICB0b3A6IDANCiAgICAgICAgfQ0KICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMucmV2ZXJzZSA/ICh0aGlzLnRvdGFsIC0gaSkgOiBpDQogICAgICAgIGNvbnN0IGxhYmVsID0gdGhpcy5kYXRhID8gdGhpcy5kYXRhW2luZGV4XSA6ICh0aGlzLnNwYWNpbmcgKiBpbmRleCkgKyB0aGlzLm1pbg0KICAgICAgICBpZiAodGhpcy5waWVjZXdpc2VGaWx0ZXIgJiYgIXRoaXMucGllY2V3aXNlRmlsdGVyKHsgaW5kZXgsIGxhYmVsIH0pKSB7DQogICAgICAgICAgY29udGludWUNCiAgICAgICAgfQ0KICAgICAgICBhcnIucHVzaCh7DQogICAgICAgICAgc3R5bGUsDQogICAgICAgICAgaW5kZXgsDQogICAgICAgICAgbGFiZWw6IHRoaXMueGZvcm1hdHRlciA/IHRoaXMuZm9ybWF0dGluZyhsYWJlbCkgOiBsYWJlbA0KICAgICAgICB9KQ0KICAgICAgfQ0KICAgICAgcmV0dXJuIGFycg0KICAgIH0sDQogIH0sDQogIHdhdGNoOiB7DQogICAgdmFsdWUodmFsKSB7DQogICAgICB0aGlzLmZsYWcgfHwgdGhpcy5zZXRWYWx1ZSh2YWwsIHRydWUpDQogICAgfSwNCiAgICBtYXgodmFsKSB7DQogICAgICBpZiAodmFsIDwgdGhpcy5taW4pIHsNCiAgICAgICAgcmV0dXJuIHRoaXMucHJpbnRFcnJvcignVGhlIG1heGltdW0gdmFsdWUgY2FuIG5vdCBiZSBsZXNzIHRoYW4gdGhlIG1pbmltdW0gdmFsdWUuJykNCiAgICAgIH0NCiAgICAgIGNvbnN0IHJlc2V0VmFsID0gdGhpcy5saW1pdFZhbHVlKHRoaXMudmFsKQ0KICAgICAgdGhpcy5zZXRWYWx1ZShyZXNldFZhbCkNCiAgICAgIHRoaXMucmVmcmVzaCgpDQogICAgfSwNCiAgICBtaW4odmFsKSB7DQogICAgICBpZiAodmFsID4gdGhpcy5tYXgpIHsNCiAgICAgICAgcmV0dXJuIHRoaXMucHJpbnRFcnJvcignVGhlIG1pbmltdW0gdmFsdWUgY2FuIG5vdCBiZSBncmVhdGVyIHRoYW4gdGhlIG1heGltdW0gdmFsdWUuJykNCiAgICAgIH0NCiAgICAgIGNvbnN0IHJlc2V0VmFsID0gdGhpcy5saW1pdFZhbHVlKHRoaXMudmFsKQ0KICAgICAgdGhpcy5zZXRWYWx1ZShyZXNldFZhbCkNCiAgICAgIHRoaXMucmVmcmVzaCgpDQogICAgfSwNCiAgICBzaG93KGJvb2wpIHsNCiAgICAgIGlmIChib29sICYmICF0aGlzLnNpemUpIHsNCiAgICAgICAgdGhpcy4kbmV4dFRpY2soKCkgPT4gew0KICAgICAgICAgIHRoaXMucmVmcmVzaCgpDQogICAgICAgIH0pDQogICAgICB9DQogICAgfSwNCiAgICBmaXhlZCgpIHsNCiAgICAgIHRoaXMuY29tcHV0ZWRGaXhlZFZhbHVlKCkNCiAgICB9LA0KICAgIG1pblJhbmdlKCkgew0KICAgICAgdGhpcy5jb21wdXRlZEZpeGVkVmFsdWUoKQ0KICAgIH0sDQogICAgcmV2ZXJzZSgpIHsNCiAgICAgIHRoaXMuJHJlZnMucHJvY2Vzcy5zdHlsZS5jc3NUZXh0ID0gJycNCiAgICAgIHRoaXMucmVmcmVzaCgpDQogICAgfSwNCiAgfSwNCiAgbWV0aG9kczogew0KICAgIGJpbmRFdmVudHMoKSB7DQogICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm1vdmluZywgeyBwYXNzaXZlOiBmYWxzZSB9KQ0KICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLm1vdmVFbmQsIHsgcGFzc2l2ZTogZmFsc2UgfSkNCiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuYmx1clNsaWRlcikNCiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMubW92aW5nKQ0KICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMubW92ZUVuZCkNCiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLm1vdmVFbmQpDQogICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlkb3duKQ0KICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLmhhbmRsZUtleXVwKQ0KICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucmVmcmVzaCkNCiAgICAgIGlmICh0aGlzLmlzUmFuZ2UgJiYgdGhpcy50b29sdGlwTWVyZ2UpIHsNCiAgICAgICAgdGhpcy4kcmVmcy5kb3QwLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLmhhbmRsZU92ZXJsYXBUb29sdGlwKQ0KICAgICAgICB0aGlzLiRyZWZzLmRvdDEuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMuaGFuZGxlT3ZlcmxhcFRvb2x0aXApDQogICAgICB9DQogICAgfSwNCiAgICB1bmJpbmRFdmVudHMoKSB7DQogICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm1vdmluZykNCiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5tb3ZlRW5kKQ0KICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5ibHVyU2xpZGVyKQ0KICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5tb3ZpbmcpDQogICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5tb3ZlRW5kKQ0KICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMubW92ZUVuZCkNCiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleWRvd24pDQogICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMuaGFuZGxlS2V5dXApDQogICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5yZWZyZXNoKQ0KICAgICAgaWYgKHRoaXMuaXNSYW5nZSAmJiB0aGlzLnRvb2x0aXBNZXJnZSkgew0KICAgICAgICB0aGlzLiRyZWZzLmRvdDAucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMuaGFuZGxlT3ZlcmxhcFRvb2x0aXApDQogICAgICAgIHRoaXMuJHJlZnMuZG90MS5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgdGhpcy5oYW5kbGVPdmVybGFwVG9vbHRpcCkNCiAgICAgIH0NCiAgICB9LA0KICAgIGhhbmRsZUtleWRvd24oZSkgew0KICAgICAgaWYgKCF0aGlzLnVzZUtleWJvYXJkIHx8ICF0aGlzLmZvY3VzRmxhZykgew0KICAgICAgICByZXR1cm4gZmFsc2UNCiAgICAgIH0NCiAgICAgIHN3aXRjaCAoZS5rZXlDb2RlKSB7DQogICAgICAgIGNhc2UgMzc6DQogICAgICAgIGNhc2UgNDA6DQogICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpDQogICAgICAgICAgdGhpcy5rZXlkb3duRmxhZyA9IHRydWUNCiAgICAgICAgICB0aGlzLmZsYWcgPSB0cnVlDQogICAgICAgICAgdGhpcy5jaGFuZ2VGb2N1c1NsaWRlcih0aGlzLmFjdGlvbnNLZXlib2FyZFswXSkNCiAgICAgICAgICBicmVhaw0KICAgICAgICBjYXNlIDM4Og0KICAgICAgICBjYXNlIDM5Og0KICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKQ0KICAgICAgICAgIHRoaXMua2V5ZG93bkZsYWcgPSB0cnVlDQogICAgICAgICAgdGhpcy5mbGFnID0gdHJ1ZQ0KICAgICAgICAgIHRoaXMuY2hhbmdlRm9jdXNTbGlkZXIodGhpcy5hY3Rpb25zS2V5Ym9hcmRbMV0pDQogICAgICAgICAgYnJlYWsNCiAgICAgIH0NCiAgICB9LA0KICAgIGhhbmRsZUtleXVwKCkgew0KICAgICAgaWYgKHRoaXMua2V5ZG93bkZsYWcpIHsNCiAgICAgICAgdGhpcy5rZXlkb3duRmxhZyA9IGZhbHNlDQogICAgICAgIHRoaXMuZmxhZyA9IGZhbHNlDQogICAgICB9DQogICAgfSwNCiAgICBjaGFuZ2VGb2N1c1NsaWRlcihmbikgew0KICAgICAgaWYgKHRoaXMuaXNSYW5nZSkgew0KICAgICAgICBsZXQgYXJyID0gdGhpcy5jdXJyZW50SW5kZXgubWFwKChpbmRleCwgaSkgPT4gew0KICAgICAgICAgIGlmIChpID09PSB0aGlzLmZvY3VzU2xpZGVyIHx8IHRoaXMuZml4ZWQpIHsNCiAgICAgICAgICAgIGNvbnN0IHZhbCA9IGZuKGluZGV4KQ0KICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSB0aGlzLmZpeGVkID8gdGhpcy52YWx1ZUxpbWl0W2ldIDogWzAsIHRoaXMudG90YWxdDQogICAgICAgICAgICBpZiAodmFsIDw9IHJhbmdlWzFdICYmIHZhbCA+PSByYW5nZVswXSkgew0KICAgICAgICAgICAgICByZXR1cm4gdmFsDQogICAgICAgICAgICB9DQogICAgICAgICAgfQ0KICAgICAgICAgIHJldHVybiBpbmRleA0KICAgICAgICB9KQ0KICAgICAgICBpZiAoYXJyWzBdID4gYXJyWzFdKSB7DQogICAgICAgICAgdGhpcy5mb2N1c1NsaWRlciA9IHRoaXMuZm9jdXNTbGlkZXIgPT09IDAgPyAxIDogMA0KICAgICAgICAgIGFyciA9IGFyci5yZXZlcnNlKCkNCiAgICAgICAgfQ0KICAgICAgICB0aGlzLnNldEluZGV4KGFycikNCiAgICAgIH0gZWxzZSB7DQogICAgICAgIHRoaXMuc2V0SW5kZXgoZm4odGhpcy5jdXJyZW50SW5kZXgpKQ0KICAgICAgfQ0KICAgIH0sDQogICAgYmx1clNsaWRlcihlKSB7DQogICAgICBjb25zdCBkb3QgPSB0aGlzLmlzUmFuZ2UgPyB0aGlzLiRyZWZzW2Bkb3Qke3RoaXMuZm9jdXNTbGlkZXJ9YF0gOiB0aGlzLiRyZWZzLmRvdA0KICAgICAgaWYgKCFkb3QgfHwgZG90ID09PSBlLnRhcmdldCB8fCBkb3QuY29udGFpbnMoZS50YXJnZXQpKSB7DQogICAgICAgIHJldHVybiBmYWxzZQ0KICAgICAgfQ0KICAgICAgdGhpcy5mb2N1c0ZsYWcgPSBmYWxzZQ0KICAgIH0sDQogICAgZm9ybWF0dGluZyh2YWx1ZSkgew0KICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLnhmb3JtYXR0ZXIgPT09ICdzdHJpbmcnID8gdGhpcy54Zm9ybWF0dGVyLnJlcGxhY2UoL1x7dmFsdWVcfS8sIHZhbHVlKSA6IHRoaXMueGZvcm1hdHRlcih2YWx1ZSkNCiAgICB9LA0KICAgIG1lcmdlRm9ybWF0dGluZyh2YWx1ZTEsIHZhbHVlMikgew0KICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLm1lcmdlRm9ybWF0dGVyID09PSAnc3RyaW5nJyA/IHRoaXMubWVyZ2VGb3JtYXR0ZXIucmVwbGFjZSgvXHsodmFsdWUxfHZhbHVlMilcfS9nLCAoXywga2V5KSA9PiBrZXkgPT09ICd2YWx1ZTEnID8gdmFsdWUxIDogdmFsdWUyKSA6IHRoaXMubWVyZ2VGb3JtYXR0ZXIodmFsdWUxLCB2YWx1ZTIpDQogICAgfSwNCiAgICBnZXRQb3MoZSkgew0KICAgICAgdGhpcy5yZWFsVGltZSAmJiB0aGlzLmdldFN0YXRpY0RhdGEoKQ0KICAgICAgdmFyIHJlY3QgPSB0aGlzLiRyZWZzLmVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7DQogICAgICByZXR1cm4gdGhpcy5kaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcgPyAodGhpcy5yZXZlcnNlID8gKGUuY2xpZW50WSAtIHJlY3QudG9wKSA6ICh0aGlzLnNpemUgLSAoZS5jbGllbnRZIC0gcmVjdC50b3ApKSkgOiAodGhpcy5yZXZlcnNlID8gKHRoaXMuc2l6ZSAtIChlLmNsaWVudFggLSByZWN0LmxlZnQpKSA6IChlLmNsaWVudFggLSByZWN0LmxlZnQpKQ0KICAgIH0sDQogICAgcHJvY2Vzc0NsaWNrKGUpIHsNCiAgICAgIGlmICh0aGlzLmZpeGVkKSB7DQogICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCkNCiAgICAgIH0NCiAgICB9LA0KICAgIHdyYXBDbGljayhlKSB7DQogICAgICBpZiAodGhpcy5pc0Rpc2FibGVkIHx8ICF0aGlzLmNsaWNrYWJsZSB8fCB0aGlzLnByb2Nlc3NGbGFnIHx8IHRoaXMuZHJhZ0ZsYWcpIHJldHVybiBmYWxzZQ0KICAgICAgY29uc3QgcG9zID0gdGhpcy5nZXRQb3MoZSkNCiAgICAgIGlmICh0aGlzLmlzUmFuZ2UpIHsNCiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWRBcnJheS5ldmVyeShiID0+IGIgPT09IGZhbHNlKSkgew0KICAgICAgICAgIHRoaXMuY3VycmVudFNsaWRlciA9IHBvcyA+ICgodGhpcy5wb3NpdGlvblsxXSAtIHRoaXMucG9zaXRpb25bMF0pIC8gMiArIHRoaXMucG9zaXRpb25bMF0pID8gMSA6IDANCiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRpc2FibGVkQXJyYXlbMF0pIHsNCiAgICAgICAgICBpZiAocG9zIDwgdGhpcy5wb3NpdGlvblswXSkgcmV0dXJuIGZhbHNlDQogICAgICAgICAgdGhpcy5jdXJyZW50U2xpZGVyID0gMQ0KICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGlzYWJsZWRBcnJheVsxXSkgew0KICAgICAgICAgIGlmIChwb3MgPiB0aGlzLnBvc2l0aW9uWzFdKSByZXR1cm4gZmFsc2UNCiAgICAgICAgICB0aGlzLmN1cnJlbnRTbGlkZXIgPSAwDQogICAgICAgIH0NCiAgICAgIH0NCiAgICAgIGlmICh0aGlzLmRpc2FibGVkQXJyYXlbdGhpcy5jdXJyZW50U2xpZGVyXSkgew0KICAgICAgICByZXR1cm4gZmFsc2UNCiAgICAgIH0NCiAgICAgIHRoaXMuc2V0VmFsdWVPblBvcyhwb3MpDQogICAgICBpZiAodGhpcy5pc1JhbmdlICYmIHRoaXMudG9vbHRpcE1lcmdlKSB7DQogICAgICAgIGNvbnN0IHRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5oYW5kbGVPdmVybGFwVG9vbHRpcCgpLCAxNi43KQ0KICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHdpbmRvdy5jbGVhckludGVydmFsKHRpbWVyKSwgdGhpcy5zcGVlZCAqIDEwMDApDQogICAgICB9DQogICAgfSwNCiAgICBtb3ZlU3RhcnQoZSwgaW5kZXggPSAwLCBpc1Byb2Nlc3MpIHsNCiAgICAgIGlmICh0aGlzLmRpc2FibGVkQXJyYXlbaW5kZXhdKSB7DQogICAgICAgIHJldHVybiBmYWxzZQ0KICAgICAgfQ0KICAgICAgaWYgKHRoaXMuc3RvcFByb3BhZ2F0aW9uKSB7DQogICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCkNCiAgICAgIH0NCiAgICAgIGlmICh0aGlzLmlzUmFuZ2UpIHsNCiAgICAgICAgdGhpcy5jdXJyZW50U2xpZGVyID0gaW5kZXgNCiAgICAgICAgaWYgKGlzUHJvY2Vzcykgew0KICAgICAgICAgIGlmICghdGhpcy5wcm9jZXNzRHJhZ2dhYmxlKSB7DQogICAgICAgICAgICByZXR1cm4gZmFsc2UNCiAgICAgICAgICB9DQogICAgICAgICAgdGhpcy5wcm9jZXNzRmxhZyA9IHRydWUNCiAgICAgICAgICB0aGlzLnByb2Nlc3NTaWduID0gew0KICAgICAgICAgICAgcG9zOiB0aGlzLnBvc2l0aW9uLA0KICAgICAgICAgICAgc3RhcnQ6IHRoaXMuZ2V0UG9zKChlLnRhcmdldFRvdWNoZXMgJiYgZS50YXJnZXRUb3VjaGVzWzBdKSA/IGUudGFyZ2V0VG91Y2hlc1swXSA6IGUpDQogICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICAgIGlmICghdGhpcy5lbmFibGVDcm9zcyAmJiB0aGlzLnZhbFswXSA9PT0gdGhpcy52YWxbMV0pIHsNCiAgICAgICAgICB0aGlzLmNyb3NzRmxhZyA9IHRydWUNCiAgICAgICAgfQ0KICAgICAgfQ0KICAgICAgaWYgKCFpc1Byb2Nlc3MgJiYgdGhpcy51c2VLZXlib2FyZCkgew0KICAgICAgICB0aGlzLmZvY3VzRmxhZyA9IHRydWUNCiAgICAgICAgdGhpcy5mb2N1c1NsaWRlciA9IGluZGV4DQogICAgICB9DQogICAgICB0aGlzLmZsYWcgPSB0cnVlDQogICAgICB0aGlzLiRlbWl0KCdkcmFnLXN0YXJ0JywgdGhpcykNCiAgICB9LA0KICAgIG1vdmluZyhlKSB7DQogICAgICBpZiAodGhpcy5zdG9wUHJvcGFnYXRpb24pIHsNCiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKQ0KICAgICAgfQ0KICAgICAgaWYgKCF0aGlzLmZsYWcpIHJldHVybiBmYWxzZQ0KICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpDQogICAgICBpZiAoZS50YXJnZXRUb3VjaGVzICYmIGUudGFyZ2V0VG91Y2hlc1swXSkgZSA9IGUudGFyZ2V0VG91Y2hlc1swXQ0KICAgICAgaWYgKHRoaXMucHJvY2Vzc0ZsYWcpIHsNCiAgICAgICAgdGhpcy5jdXJyZW50U2xpZGVyID0gMA0KICAgICAgICB0aGlzLnNldFZhbHVlT25Qb3ModGhpcy5wcm9jZXNzU2lnbi5wb3NbMF0gKyB0aGlzLmdldFBvcyhlKSAtIHRoaXMucHJvY2Vzc1NpZ24uc3RhcnQsIHRydWUpDQogICAgICAgIHRoaXMuY3VycmVudFNsaWRlciA9IDENCiAgICAgICAgdGhpcy5zZXRWYWx1ZU9uUG9zKHRoaXMucHJvY2Vzc1NpZ24ucG9zWzFdICsgdGhpcy5nZXRQb3MoZSkgLSB0aGlzLnByb2Nlc3NTaWduLnN0YXJ0LCB0cnVlKQ0KICAgICAgfSBlbHNlIHsNCiAgICAgICAgdGhpcy5kcmFnRmxhZyA9IHRydWUNCiAgICAgICAgdGhpcy5zZXRWYWx1ZU9uUG9zKHRoaXMuZ2V0UG9zKGUpLCB0cnVlKQ0KICAgICAgfQ0KICAgICAgaWYgKHRoaXMuaXNSYW5nZSAmJiB0aGlzLnRvb2x0aXBNZXJnZSkgew0KICAgICAgICB0aGlzLmhhbmRsZU92ZXJsYXBUb29sdGlwKCkNCiAgICAgIH0NCiAgICB9LA0KICAgIG1vdmVFbmQoZSkgew0KICAgICAgaWYgKHRoaXMuc3RvcFByb3BhZ2F0aW9uKSB7DQogICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCkNCiAgICAgIH0NCiAgICAgIGlmICh0aGlzLmZsYWcpIHsNCiAgICAgICAgdGhpcy4kZW1pdCgnZHJhZy1lbmQnLCB0aGlzKQ0KICAgICAgICBpZiAodGhpcy5sYXp5ICYmIHRoaXMuaXNEaWZmKHRoaXMudmFsLCB0aGlzLnZhbHVlKSkgew0KICAgICAgICAgIHRoaXMuc3luY1ZhbHVlKCkNCiAgICAgICAgfQ0KICAgICAgfSBlbHNlIHsNCiAgICAgICAgcmV0dXJuIGZhbHNlDQogICAgICB9DQogICAgICB0aGlzLmZsYWcgPSBmYWxzZQ0KICAgICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4gew0KICAgICAgICB0aGlzLmNyb3NzRmxhZyA9IGZhbHNlDQogICAgICAgIHRoaXMuZHJhZ0ZsYWcgPSBmYWxzZQ0KICAgICAgICB0aGlzLnByb2Nlc3NGbGFnID0gZmFsc2UNCiAgICAgIH0sIDApDQogICAgICB0aGlzLnNldFBvc2l0aW9uKCkNCiAgICB9LA0KICAgIHNldFZhbHVlT25Qb3MocG9zLCBpc0RyYWcpIHsNCiAgICAgIGNvbnN0IHJhbmdlID0gdGhpcy5pc1JhbmdlID8gdGhpcy5saW1pdFt0aGlzLmN1cnJlbnRTbGlkZXJdIDogdGhpcy5saW1pdA0KICAgICAgY29uc3QgdmFsdWVSYW5nZSA9IHRoaXMuaXNSYW5nZSA/IHRoaXMudmFsdWVMaW1pdFt0aGlzLmN1cnJlbnRTbGlkZXJdIDogdGhpcy52YWx1ZUxpbWl0DQogICAgICBjb25zdCBpbmRleCA9IE1hdGgucm91bmQoKHBvcyAtIHRoaXMuZG90QXhpYWxTaXplUHggLyAyKSAvIHRoaXMuZ2FwKQ0KICAgICAgaWYgKHBvcyA+PSByYW5nZVswXSAmJiBwb3MgPD0gcmFuZ2VbMV0pIHsNCiAgICAgICAgY29uc3QgdiA9IHRoaXMuZ2V0VmFsdWVCeUluZGV4KGluZGV4KQ0KICAgICAgICB0aGlzLnNldFRyYW5zZm9ybShwb3MpDQogICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHYsIGlzRHJhZykNCiAgICAgICAgaWYgKHRoaXMuaXNSYW5nZSAmJiAodGhpcy5maXhlZCB8fCB0aGlzLmlzTGVzc1JhbmdlKHBvcywgaW5kZXgpKSkgew0KICAgICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtKHBvcyArICgodGhpcy5maXhlZFZhbHVlICogdGhpcy5nYXApICogKHRoaXMuY3VycmVudFNsaWRlciA9PT0gMCA/IDEgOiAtMSkpLCB0cnVlKQ0KICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKCh2ICogdGhpcy5tdWx0aXBsZSArICh0aGlzLmZpeGVkVmFsdWUgKiB0aGlzLnNwYWNpbmcgKiB0aGlzLm11bHRpcGxlICogKHRoaXMuY3VycmVudFNsaWRlciA9PT0gMCA/IDEgOiAtMSkpKSAvIHRoaXMubXVsdGlwbGUsIGlzRHJhZywgdHJ1ZSkNCiAgICAgICAgfQ0KICAgICAgfSBlbHNlIHsNCiAgICAgICAgY29uc3QgYW5vdGhlclNsaWRlciA9IHBvcyA8IHJhbmdlWzBdID8gMCA6IDENCiAgICAgICAgY29uc3QgY3VycmVudFNsaWRlciA9IGFub3RoZXJTbGlkZXIgPT09IDAgPyAxIDogMA0KICAgICAgICB0aGlzLnNldFRyYW5zZm9ybShyYW5nZVthbm90aGVyU2xpZGVyXSkNCiAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodmFsdWVSYW5nZVthbm90aGVyU2xpZGVyXSkNCiAgICAgICAgaWYgKHRoaXMuaXNSYW5nZSAmJiAodGhpcy5maXhlZCB8fCB0aGlzLmlzTGVzc1JhbmdlKHBvcywgaW5kZXgpKSkgew0KICAgICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtKHRoaXMubGltaXRbdGhpcy5pZGxlU2xpZGVyXVthbm90aGVyU2xpZGVyXSwgdHJ1ZSkNCiAgICAgICAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLnZhbHVlTGltaXRbdGhpcy5pZGxlU2xpZGVyXVthbm90aGVyU2xpZGVyXSwgaXNEcmFnLCB0cnVlKQ0KICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNSYW5nZSAmJiAodGhpcy5lbmFibGVDcm9zcyB8fCB0aGlzLmNyb3NzRmxhZykgJiYgIXRoaXMuaXNGaXhlZCAmJiAhdGhpcy5kaXNhYmxlZEFycmF5W2Fub3RoZXJTbGlkZXJdICYmIHRoaXMuY3VycmVudFNsaWRlciA9PT0gY3VycmVudFNsaWRlcikgew0KICAgICAgICAgIHRoaXMuZm9jdXNTbGlkZXIgPSBhbm90aGVyU2xpZGVyDQogICAgICAgICAgdGhpcy5jdXJyZW50U2xpZGVyID0gYW5vdGhlclNsaWRlcg0KICAgICAgICB9DQogICAgICB9DQogICAgICB0aGlzLmNyb3NzRmxhZyA9IGZhbHNlDQogICAgfSwNCiAgICBpc0xlc3NSYW5nZShwb3MsIGluZGV4KSB7DQogICAgICBpZiAoIXRoaXMuaXNSYW5nZSB8fCAoIXRoaXMubWluUmFuZ2UgJiYgIXRoaXMubWF4UmFuZ2UpKSB7DQogICAgICAgIHJldHVybiBmYWxzZQ0KICAgICAgfQ0KICAgICAgY29uc3QgZGlmZiA9IHRoaXMuY3VycmVudFNsaWRlciA9PT0gMCA/IHRoaXMuY3VycmVudEluZGV4WzFdIC0gaW5kZXggOiBpbmRleCAtIHRoaXMuY3VycmVudEluZGV4WzBdDQogICAgICBpZiAodGhpcy5taW5SYW5nZSAmJiBkaWZmIDw9IHRoaXMubWluUmFuZ2UpIHsNCiAgICAgICAgdGhpcy5maXhlZFZhbHVlID0gdGhpcy5taW5SYW5nZQ0KICAgICAgICByZXR1cm4gdHJ1ZQ0KICAgICAgfQ0KICAgICAgaWYgKHRoaXMubWF4UmFuZ2UgJiYgZGlmZiA+PSB0aGlzLm1heFJhbmdlKSB7DQogICAgICAgIHRoaXMuZml4ZWRWYWx1ZSA9IHRoaXMubWF4UmFuZ2UNCiAgICAgICAgcmV0dXJuIHRydWUNCiAgICAgIH0NCiAgICAgIHRoaXMuY29tcHV0ZWRGaXhlZFZhbHVlKCkNCiAgICAgIHJldHVybiBmYWxzZQ0KICAgIH0sDQogICAgaXNEaWZmKGEsIGIpIHsNCiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSkgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChiKSkgew0KICAgICAgICByZXR1cm4gdHJ1ZQ0KICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGEpICYmIGEubGVuZ3RoID09PSBiLmxlbmd0aCkgew0KICAgICAgICByZXR1cm4gYS5zb21lKCh2LCBpKSA9PiB2ICE9PSBiW2ldKQ0KICAgICAgfQ0KICAgICAgcmV0dXJuIGEgIT09IGINCiAgICB9LA0KICAgIHNldEN1cnJlbnRWYWx1ZSh2YWwsIGlzRHJhZywgaXNJZGxlU2xpZGVyKSB7DQogICAgICBjb25zdCBzbGlkZXIgPSBpc0lkbGVTbGlkZXIgPyB0aGlzLmlkbGVTbGlkZXIgOiB0aGlzLmN1cnJlbnRTbGlkZXINCiAgICAgIGlmICh2YWwgPCB0aGlzLm1pbmltdW0gfHwgdmFsID4gdGhpcy5tYXhpbXVtKSByZXR1cm4gZmFsc2UNCiAgICAgIGlmICh0aGlzLmlzUmFuZ2UpIHsNCiAgICAgICAgaWYgKHRoaXMuaXNEaWZmKHRoaXMuY3VycmVudFZhbHVlW3NsaWRlcl0sIHZhbCkpIHsNCiAgICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZS5zcGxpY2Uoc2xpZGVyLCAxLCB2YWwpDQogICAgICAgICAgaWYgKCF0aGlzLmxhenkgfHwgIXRoaXMuZmxhZykgew0KICAgICAgICAgICAgdGhpcy5zeW5jVmFsdWUoKQ0KICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgICAgfSBlbHNlIGlmICh0aGlzLmlzRGlmZih0aGlzLmN1cnJlbnRWYWx1ZSwgdmFsKSkgew0KICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IHZhbA0KICAgICAgICBpZiAoIXRoaXMubGF6eSB8fCAhdGhpcy5mbGFnKSB7DQogICAgICAgICAgdGhpcy5zeW5jVmFsdWUoKQ0KICAgICAgICB9DQogICAgICB9DQogICAgICBpc0RyYWcgfHwgdGhpcy5zZXRQb3NpdGlvbigpDQogICAgfSwNCiAgICBnZXRWYWx1ZUJ5SW5kZXgoaW5kZXgpIHsNCiAgICAgIHJldHVybiAoKHRoaXMuc3BhY2luZyAqIHRoaXMubXVsdGlwbGUpICogaW5kZXggKyAodGhpcy5taW5pbXVtICogdGhpcy5tdWx0aXBsZSkpIC8gdGhpcy5tdWx0aXBsZQ0KICAgIH0sDQogICAgZ2V0SW5kZXhCeVZhbHVlKHZhbHVlKSB7DQogICAgICByZXR1cm4gTWF0aC5yb3VuZCgodmFsdWUgLSB0aGlzLm1pbmltdW0pICogdGhpcy5tdWx0aXBsZSkgLyAodGhpcy5zcGFjaW5nICogdGhpcy5tdWx0aXBsZSkNCiAgICB9LA0KICAgIHNldEluZGV4KHZhbCkgew0KICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSAmJiB0aGlzLmlzUmFuZ2UpIHsNCiAgICAgICAgbGV0IHZhbHVlDQogICAgICAgIGlmICh0aGlzLmRhdGEpIHsNCiAgICAgICAgICB2YWx1ZSA9IFt0aGlzLmRhdGFbdmFsWzBdXSwgdGhpcy5kYXRhW3ZhbFsxXV1dDQogICAgICAgIH0gZWxzZSB7DQogICAgICAgICAgdmFsdWUgPSBbdGhpcy5nZXRWYWx1ZUJ5SW5kZXgodmFsWzBdKSwgdGhpcy5nZXRWYWx1ZUJ5SW5kZXgodmFsWzFdKV0NCiAgICAgICAgfQ0KICAgICAgICB0aGlzLnNldFZhbHVlKHZhbHVlKQ0KICAgICAgfSBlbHNlIHsNCiAgICAgICAgdmFsID0gdGhpcy5nZXRWYWx1ZUJ5SW5kZXgodmFsKQ0KICAgICAgICBpZiAodGhpcy5pc1JhbmdlKSB7DQogICAgICAgICAgdGhpcy5jdXJyZW50U2xpZGVyID0gdmFsID4gKCh0aGlzLmN1cnJlbnRWYWx1ZVsxXSAtIHRoaXMuY3VycmVudFZhbHVlWzBdKSAvIDIgKyB0aGlzLmN1cnJlbnRWYWx1ZVswXSkgPyAxIDogMA0KICAgICAgICB9DQogICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHZhbCkNCiAgICAgIH0NCiAgICB9LA0KICAgIGluY3JlbWVudChkaXIpIHsNCiAgICAgIGlmICh0aGlzLmJvb2xEaXNhYmxlZCkgcmV0dXJuOw0KICAgICAgY29uc3QgbmV3VmFsID0gdGhpcy5nZXRWYWx1ZSgpICsgZGlyICogdGhpcy5pbnRlcnZhbDsNCiAgICAgIGlmIChuZXdWYWwgPiB0aGlzLm1heCB8fCBuZXdWYWwgPCB0aGlzLm1pbikgcmV0dXJuOw0KICAgICAgdGhpcy5zZXRWYWx1ZShuZXdWYWwpOw0KICAgIH0sDQogICAgc2V0VmFsdWUodmFsLCBub0NiLCBzcGVlZCkgew0KICAgICAgaWYgKHRoaXMuaXNEaWZmKHRoaXMudmFsLCB2YWwpKSB7DQogICAgICAgIGNvbnN0IHJlc2V0VmFsID0gdGhpcy5saW1pdFZhbHVlKHZhbCkNCiAgICAgICAgdGhpcy52YWwgPSB0aGlzLmlzUmFuZ2UgPyByZXNldFZhbC5jb25jYXQoKSA6IHJlc2V0VmFsDQogICAgICAgIHRoaXMuY29tcHV0ZWRGaXhlZFZhbHVlKCkNCiAgICAgICAgdGhpcy5zeW5jVmFsdWUobm9DYikNCiAgICAgIH0NCiAgICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHRoaXMuc2V0UG9zaXRpb24oc3BlZWQpKQ0KICAgIH0sDQogICAgY29tcHV0ZWRGaXhlZFZhbHVlKCkgew0KICAgICAgaWYgKCF0aGlzLmlzRml4ZWQpIHsNCiAgICAgICAgdGhpcy5maXhlZFZhbHVlID0gMA0KICAgICAgICByZXR1cm4gZmFsc2UNCiAgICAgIH0NCiAgICAgIHRoaXMuZml4ZWRWYWx1ZSA9IE1hdGgubWF4KHRoaXMuZml4ZWQgPyB0aGlzLmN1cnJlbnRJbmRleFsxXSAtIHRoaXMuY3VycmVudEluZGV4WzBdIDogMCwgdGhpcy5taW5SYW5nZSB8fCAwKQ0KICAgIH0sDQogICAgc2V0UG9zaXRpb24oc3BlZWQpIHsNCiAgICAgIHRoaXMuZmxhZyB8fCB0aGlzLnNldFRyYW5zaXRpb25UaW1lKHNwZWVkID09PSB1bmRlZmluZWQgPyB0aGlzLnNwZWVkIDogc3BlZWQpDQogICAgICBpZiAodGhpcy5pc1JhbmdlKSB7DQogICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtKHRoaXMucG9zaXRpb25bMF0sIHRoaXMuY3VycmVudFNsaWRlciA9PT0gMSkNCiAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0odGhpcy5wb3NpdGlvblsxXSwgdGhpcy5jdXJyZW50U2xpZGVyID09PSAwKQ0KICAgICAgfSBlbHNlIHsNCiAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0odGhpcy5wb3NpdGlvbikNCiAgICAgIH0NCiAgICAgIHRoaXMuZmxhZyB8fCB0aGlzLnNldFRyYW5zaXRpb25UaW1lKDApDQogICAgfSwNCiAgICBzZXRUcmFuc2Zvcm0odmFsLCBpc0lkbGVTbGlkZXIpIHsNCiAgICAgIGNvbnN0IHNsaWRlciA9IGlzSWRsZVNsaWRlciA/IHRoaXMuaWRsZVNsaWRlciA6IHRoaXMuY3VycmVudFNsaWRlcg0KICAgICAgY29uc3QgdmFsdWUgPSByb3VuZFRvRFBSKCh0aGlzLmRpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJyA/ICgodGhpcy5kb3RBeGlhbFNpemVQeCAvIDIpIC0gdmFsKSA6ICh2YWwgLSAodGhpcy5kb3RBeGlhbFNpemVQeCAvIDIpKSkgKiAodGhpcy5yZXZlcnNlID8gLTEgOiAxKSkNCiAgICAgIGNvbnN0IHRyYW5zbGF0ZVZhbHVlID0gdGhpcy5kaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcgPyBgdHJhbnNsYXRlKC01MCUsICR7dmFsdWV9cHgpYCA6IGB0cmFuc2xhdGUoJHt2YWx1ZX1weCwgLTUwJSlgDQogICAgICBjb25zdCBwcm9jZXNzU2l6ZSA9IHRoaXMuZml4ZWQgPyBgJHt0aGlzLmZpeGVkVmFsdWUgKiB0aGlzLmdhcH1weGAgOiBgJHtzbGlkZXIgPT09IDAgPyB0aGlzLnBvc2l0aW9uWzFdIC0gdmFsIDogdmFsIC0gdGhpcy5wb3NpdGlvblswXX1weGANCiAgICAgIGNvbnN0IHByb2Nlc3NQb3MgPSB0aGlzLmZpeGVkID8gYCR7c2xpZGVyID09PSAwID8gdmFsIDogKHZhbCAtIHRoaXMuZml4ZWRWYWx1ZSAqIHRoaXMuZ2FwKX1weGAgOiBgJHtzbGlkZXIgPT09IDAgPyB2YWwgOiB0aGlzLnBvc2l0aW9uWzBdfXB4YA0KICAgICAgdGhpcy5zbGlkZXJbc2xpZGVyXS5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2xhdGVWYWx1ZQ0KICAgICAgdGhpcy5zbGlkZXJbc2xpZGVyXS5zdHlsZS5XZWJraXRUcmFuc2Zvcm0gPSB0cmFuc2xhdGVWYWx1ZQ0KICAgICAgdGhpcy5zbGlkZXJbc2xpZGVyXS5zdHlsZS5tc1RyYW5zZm9ybSA9IHRyYW5zbGF0ZVZhbHVlDQogICAgICBpZiAodGhpcy5pc1JhbmdlKSB7DQogICAgICAgIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJykgew0KICAgICAgICAgIHRoaXMuJHJlZnMucHJvY2Vzcy5zdHlsZS5oZWlnaHQgPSBwcm9jZXNzU2l6ZQ0KICAgICAgICAgIHRoaXMuJHJlZnMucHJvY2Vzcy5zdHlsZVt0aGlzLnJldmVyc2UgPyAndG9wJyA6ICdib3R0b20nXSA9IHByb2Nlc3NQb3MNCiAgICAgICAgfSBlbHNlIHsNCiAgICAgICAgICB0aGlzLiRyZWZzLnByb2Nlc3Muc3R5bGUud2lkdGggPSBwcm9jZXNzU2l6ZQ0KICAgICAgICAgIHRoaXMuJHJlZnMucHJvY2Vzcy5zdHlsZVt0aGlzLnJldmVyc2UgPyAncmlnaHQnIDogJ2xlZnQnXSA9IHByb2Nlc3NQb3MNCiAgICAgICAgfQ0KICAgICAgfSBlbHNlIHsNCiAgICAgICAgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAndmVydGljYWwnKSB7DQogICAgICAgICAgdGhpcy4kcmVmcy5wcm9jZXNzLnN0eWxlLmhlaWdodCA9IGAke3ZhbH1weGANCiAgICAgICAgICB0aGlzLiRyZWZzLnByb2Nlc3Muc3R5bGVbdGhpcy5yZXZlcnNlID8gJ3RvcCcgOiAnYm90dG9tJ10gPSAwDQogICAgICAgIH0gZWxzZSB7DQogICAgICAgICAgdGhpcy4kcmVmcy5wcm9jZXNzLnN0eWxlLndpZHRoID0gYCR7dmFsfXB4YA0KICAgICAgICAgIHRoaXMuJHJlZnMucHJvY2Vzcy5zdHlsZVt0aGlzLnJldmVyc2UgPyAncmlnaHQnIDogJ2xlZnQnXSA9IDANCiAgICAgICAgfQ0KICAgICAgfQ0KICAgIH0sDQogICAgc2V0VHJhbnNpdGlvblRpbWUodGltZSkgew0KICAgICAgLy8gSW4gb3JkZXIgdG8gYXZvaWQgYnJvd3NlciBtZXJnZSBzdHlsZSBhbmQgbW9kaWZ5IHRvZ2V0aGVyDQogICAgICB0aW1lIHx8IHRoaXMuJHJlZnMucHJvY2Vzcy5vZmZzZXRXaWR0aA0KICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNsaWRlci5sZW5ndGg7IGkrKykgew0KICAgICAgICB0aGlzLnNsaWRlcltpXS5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBgJHt0aW1lfXNgDQogICAgICAgIHRoaXMuc2xpZGVyW2ldLnN0eWxlLldlYmtpdFRyYW5zaXRpb25EdXJhdGlvbiA9IGAke3RpbWV9c2ANCiAgICAgIH0NCiAgICAgIGlmICh0aGlzLmlzUmFuZ2UpIHsNCiAgICAgICAgdGhpcy4kcmVmcy5wcm9jZXNzLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGAke3RpbWV9c2ANCiAgICAgICAgdGhpcy4kcmVmcy5wcm9jZXNzLnN0eWxlLldlYmtpdFRyYW5zaXRpb25EdXJhdGlvbiA9IGAke3RpbWV9c2ANCiAgICAgIH0gZWxzZSB7DQogICAgICAgIHRoaXMuJHJlZnMucHJvY2Vzcy5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBgJHt0aW1lfXNgDQogICAgICAgIHRoaXMuJHJlZnMucHJvY2Vzcy5zdHlsZS5XZWJraXRUcmFuc2l0aW9uRHVyYXRpb24gPSBgJHt0aW1lfXNgDQogICAgICB9DQogICAgfSwNCiAgICBsaW1pdFZhbHVlKHZhbCkgew0KICAgICAgaWYgKHRoaXMuZGF0YSkgew0KICAgICAgICByZXR1cm4gdmFsDQogICAgICB9DQogICAgICBjb25zdCBpblJhbmdlID0gKHYpID0+IHsNCiAgICAgICAgaWYgKHYgPCB0aGlzLm1pbikgew0KICAgICAgICAgIHRoaXMucHJpbnRFcnJvcihgVGhlIHZhbHVlIG9mIHRoZSBzbGlkZXIgaXMgJHt2YWx9LCB0aGUgbWluaW11bSB2YWx1ZSBpcyAke3RoaXMubWlufSwgdGhlIHZhbHVlIG9mIHRoaXMgc2xpZGVyIGNhbiBub3QgYmUgbGVzcyB0aGFuIHRoZSBtaW5pbXVtIHZhbHVlYCkNCiAgICAgICAgICByZXR1cm4gdGhpcy5taW4NCiAgICAgICAgfSBlbHNlIGlmICh2ID4gdGhpcy5tYXgpIHsNCiAgICAgICAgICB0aGlzLnByaW50RXJyb3IoYFRoZSB2YWx1ZSBvZiB0aGUgc2xpZGVyIGlzICR7dmFsfSwgdGhlIG1heGltdW0gdmFsdWUgaXMgJHt0aGlzLm1heH0sIHRoZSB2YWx1ZSBvZiB0aGlzIHNsaWRlciBjYW4gbm90IGJlIGdyZWF0ZXIgdGhhbiB0aGUgbWF4aW11bSB2YWx1ZWApDQogICAgICAgICAgcmV0dXJuIHRoaXMubWF4DQogICAgICAgIH0NCiAgICAgICAgcmV0dXJuIHYNCiAgICAgIH0NCiAgICAgIGlmICh0aGlzLmlzUmFuZ2UpIHsNCiAgICAgICAgcmV0dXJuIHZhbC5tYXAoKHYpID0+IGluUmFuZ2UodikpDQogICAgICB9IGVsc2Ugew0KICAgICAgICByZXR1cm4gaW5SYW5nZSh2YWwpDQogICAgICB9DQogICAgfSwNCiAgICBpc0FjdGl2ZShpbmRleCkgew0KICAgICAgcmV0dXJuIGluZGV4ID49IHRoaXMuaW5kZXhSYW5nZVswXSAmJiBpbmRleCA8PSB0aGlzLmluZGV4UmFuZ2VbMV0NCiAgICB9LA0KICAgIHN5bmNWYWx1ZShub0NiKSB7DQogICAgICBsZXQgdmFsID0gdGhpcy5pc1JhbmdlID8gdGhpcy52YWwuY29uY2F0KCkgOiB0aGlzLnZhbA0KICAgICAgdGhpcy4kZW1pdCgnaW5wdXQnLCB2YWwpDQogICAgICB0aGlzLmtleWRvd25GbGFnICYmIHRoaXMuJGVtaXQoJ29uLWtleXByZXNzJywgdmFsKQ0KICAgICAgbm9DYiB8fCB0aGlzLiRlbWl0KCdjYWxsYmFjaycsIHZhbCkNCiAgICB9LA0KICAgIGdldFZhbHVlKCkgew0KICAgICAgcmV0dXJuIHRoaXMudmFsDQogICAgfSwNCiAgICBnZXRJbmRleCgpIHsNCiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRJbmRleA0KICAgIH0sDQogICAgZ2V0U3RhdGljRGF0YSgpIHsNCiAgICAgIGlmICh0aGlzLiRyZWZzLmVsZW0pIHsNCiAgICAgICAgdGhpcy5zaXplID0gdGhpcy5kaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcgPyB0aGlzLiRyZWZzLmVsZW0ub2Zmc2V0SGVpZ2h0IDogdGhpcy4kcmVmcy5lbGVtLm9mZnNldFdpZHRoDQogICAgICAgIHRoaXMuZG90QXhpYWxTaXplUHggPSB0aGlzLmRpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJyA/IHRoaXMuJHJlZnMuZG90MC5jbGllbnRIZWlnaHQgOiB0aGlzLiRyZWZzLmRvdDAuY2xpZW50V2lkdGg7DQogICAgICB9DQogICAgfSwNCiAgICByZWZyZXNoKCkgew0KICAgICAgaWYgKHRoaXMuJHJlZnMuZWxlbSkgew0KICAgICAgICB0aGlzLmdldFN0YXRpY0RhdGEoKQ0KICAgICAgICB0aGlzLmNvbXB1dGVkRml4ZWRWYWx1ZSgpDQogICAgICAgIHRoaXMuc2V0UG9zaXRpb24oMCkNCiAgICAgIH0NCiAgICB9LA0KICAgIHByaW50RXJyb3IobXNnKSB7DQogICAgICBpZiAodGhpcy5kZWJ1Zykgew0KICAgICAgICBjb25zb2xlLmVycm9yKGBbVnVlU2xpZGVyIGVycm9yXTogJHttc2d9YCkNCiAgICAgIH0NCiAgICB9LA0KICAgIGhhbmRsZU92ZXJsYXBUb29sdGlwKCkgew0KICAgICAgY29uc3QgaXNEaXJlY3Rpb25TYW1lID0gdGhpcy50b29sdGlwRGlyZWN0aW9uWzBdID09PSB0aGlzLnRvb2x0aXBEaXJlY3Rpb25bMV0NCiAgICAgIGlmICh0aGlzLmlzUmFuZ2UgJiYgaXNEaXJlY3Rpb25TYW1lKSB7DQogICAgICAgIGNvbnN0IHRvb2x0aXAwID0gdGhpcy5yZXZlcnNlID8gdGhpcy4kcmVmcy50b29sdGlwMSA6IHRoaXMuJHJlZnMudG9vbHRpcDANCiAgICAgICAgY29uc3QgdG9vbHRpcDEgPSB0aGlzLnJldmVyc2UgPyB0aGlzLiRyZWZzLnRvb2x0aXAwIDogdGhpcy4kcmVmcy50b29sdGlwMQ0KICAgICAgICBjb25zdCB0b29sdGlwMFJlY3QgPSB0b29sdGlwMC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKQ0KICAgICAgICBjb25zdCB0b29sdGlwMVJlY3QgPSB0b29sdGlwMS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKQ0KICAgICAgICBjb25zdCB0b29sdGlwMFJpZ2h0ID0gdG9vbHRpcDBSZWN0LnJpZ2h0DQogICAgICAgIGNvbnN0IHRvb2x0aXAxTGVmdCA9IHRvb2x0aXAxUmVjdC5sZWZ0DQogICAgICAgIGNvbnN0IHRvb2x0aXAwWSA9IHRvb2x0aXAwUmVjdC50b3ANCiAgICAgICAgY29uc3QgdG9vbHRpcDFZID0gdG9vbHRpcDFSZWN0LnRvcCArIHRvb2x0aXAxUmVjdC5oZWlnaHQNCiAgICAgICAgY29uc3QgaG9yaXpvbnRhbE92ZXJsYXAgPSB0aGlzLmRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnICYmIHRvb2x0aXAwUmlnaHQgPiB0b29sdGlwMUxlZnQNCiAgICAgICAgY29uc3QgdmVydGljYWxPdmVybGFwID0gdGhpcy5kaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcgJiYgdG9vbHRpcDFZID4gdG9vbHRpcDBZDQogICAgICAgIGlmIChob3Jpem9udGFsT3ZlcmxhcCB8fCB2ZXJ0aWNhbE92ZXJsYXApIHsNCiAgICAgICAgICB0aGlzLmhhbmRsZURpc3BsYXlNZXJnZWRUb29sdGlwKHRydWUpDQogICAgICAgIH0gZWxzZSB7DQogICAgICAgICAgdGhpcy5oYW5kbGVEaXNwbGF5TWVyZ2VkVG9vbHRpcChmYWxzZSkNCiAgICAgICAgfQ0KICAgICAgfQ0KICAgIH0sDQogICAgaGFuZGxlRGlzcGxheU1lcmdlZFRvb2x0aXAoc2hvdykgew0KICAgICAgY29uc3QgdG9vbHRpcDAgPSB0aGlzLiRyZWZzLnRvb2x0aXAwDQogICAgICBjb25zdCB0b29sdGlwMSA9IHRoaXMuJHJlZnMudG9vbHRpcDENCiAgICAgIGNvbnN0IG1lcmdlZFRvb2x0aXAgPSB0aGlzLiRyZWZzLnByb2Nlc3MuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgndnVlLW1lcmdlZC10b29sdGlwJylbMF0NCiAgICAgIGlmIChzaG93KSB7DQogICAgICAgIHRvb2x0aXAwLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJw0KICAgICAgICB0b29sdGlwMS5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbicNCiAgICAgICAgbWVyZ2VkVG9vbHRpcC5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnDQogICAgICB9IGVsc2Ugew0KICAgICAgICB0b29sdGlwMC5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnDQogICAgICAgIHRvb2x0aXAxLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZScNCiAgICAgICAgbWVyZ2VkVG9vbHRpcC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbicNCiAgICAgIH0NCiAgICB9LA0KICAgIGRvdENvbnRlbnRzKCkgew0KICAgICAgaWYgKE5vdGF0aW9ucy5jdXJyZW50Lm5hbWUgPT09ICJCbGluZCIgfHwgVGhlbWUuY3VycmVudCgpLm5hbWUgPT09ICJTOSIgKSByZXR1cm4gIiI7DQogICAgICAvLyBEb2Vzbid0IHdvcmsgaWYgdGhlIHNsaWRlciBuZWVkcyB0byBzaG93IG1vcmUgcHJlY2lzaW9uIHRoYW4gaW50ZWdlcnMsDQogICAgICAvLyBidXQgSSBkb24ndCB0aGluayB3ZSBoYXZlIGFueSBzdWNoIHNsaWRlcnMuDQogICAgICByZXR1cm4gdGhpcy52YWx1ZUluRG90ID8gTWF0aC5yb3VuZCh0aGlzLmdldFZhbHVlKCkpIDogJyc7DQogICAgfSwNCiAgfSwNCiAgbW91bnRlZCgpIHsNCiAgICB0aGlzLmlzQ29tcG9uZW50RXhpc3RzID0gdHJ1ZQ0KICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7DQogICAgICByZXR1cm4gdGhpcy5wcmludEVycm9yKCd3aW5kb3cgb3IgZG9jdW1lbnQgaXMgdW5kZWZpbmVkLCBjYW4gbm90IGJlIGluaXRpYWxpemF0aW9uLicpDQogICAgfQ0KICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHsNCiAgICAgIGlmICh0aGlzLmlzQ29tcG9uZW50RXhpc3RzKSB7DQogICAgICAgIHRoaXMuZ2V0U3RhdGljRGF0YSgpDQogICAgICAgIHRoaXMuc2V0VmFsdWUodGhpcy5saW1pdFZhbHVlKHRoaXMudmFsdWUpLCB0cnVlLCB0aGlzLnN0YXJ0QW5pbWF0aW9uID8gdGhpcy5zcGVlZCA6IDApDQogICAgICAgIHRoaXMuYmluZEV2ZW50cygpDQogICAgICAgIGlmICh0aGlzLmlzUmFuZ2UgJiYgdGhpcy50b29sdGlwTWVyZ2UgJiYgIXRoaXMuc3RhcnRBbmltYXRpb24pIHsNCiAgICAgICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7DQogICAgICAgICAgICB0aGlzLmhhbmRsZU92ZXJsYXBUb29sdGlwKCkNCiAgICAgICAgICB9KQ0KICAgICAgICB9DQogICAgICB9DQogICAgfSkNCiAgICB0aGlzLmlzTW91bnRlZCA9IHRydWUNCiAgfSwNCiAgYmVmb3JlRGVzdHJveSgpIHsNCiAgICB0aGlzLmlzQ29tcG9uZW50RXhpc3RzID0gZmFsc2UNCiAgICB0aGlzLnVuYmluZEV2ZW50cygpDQogIH0NCn07DQo="},{"version":3,"sources":["SliderComponent.vue"],"names":[],"mappings":";AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"SliderComponent.vue","sourceRoot":"src/components","sourcesContent":["<script>\r\nimport PlusMinusButton from \"@/components/PlusMinusButton\";\r\n\r\n/*\r\n* This is based on vue-slider-component\r\n* downloaded from https://github.com/NightCatSama/vue-slider-component\r\n* It's modified to support showing the slider value in the slider.\r\n*/\r\n/*\r\nThe MIT License (MIT)\r\n\r\nCopyright (c) 2016 NightCatSama.\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n*/\r\n\r\n// Unsharp text [#166](https://github.com/NightCatSama/vue-slider-component/issues/166)\r\nconst roundToDPR = (function () {\r\n  const r = typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1\r\n  return value => Math.round(value * r) / r\r\n})()\r\n\r\nexport default {\r\n  name: \"SliderComponent\",\r\n  components: {\r\n    PlusMinusButton\r\n  },\r\n  props: {\r\n    width: {\r\n      type: String,\r\n      default: 'auto'\r\n    },\r\n    height: {\r\n      type: String,\r\n      default: \"6px\"\r\n    },\r\n    data: {\r\n      type: Array,\r\n      default: null\r\n    },\r\n    dotSize: {\r\n      type: [String, Number],\r\n      default: \"16px\"\r\n    },\r\n    dotWidth: {\r\n      type: String,\r\n      required: false\r\n    },\r\n    dotHeight: {\r\n      type: String,\r\n      required: false\r\n    },\r\n    min: {\r\n      type: Number,\r\n      default: 0\r\n    },\r\n    max: {\r\n      type: Number,\r\n      default: 100\r\n    },\r\n    interval: {\r\n      type: Number,\r\n      default: 1\r\n    },\r\n    show: {\r\n      type: Boolean,\r\n      default: true\r\n    },\r\n    disabled: {\r\n      type: [Boolean, Array],\r\n      default: false\r\n    },\r\n    piecewise: {\r\n      type: Boolean,\r\n      default: false\r\n    },\r\n    tooltip: {\r\n      type: [String, Boolean],\r\n      default: 'always'\r\n    },\r\n    eventType: {\r\n      type: String,\r\n      default: 'auto'\r\n    },\r\n    direction: {\r\n      type: String,\r\n      default: 'horizontal'\r\n    },\r\n    reverse: {\r\n      type: Boolean,\r\n      default: false\r\n    },\r\n    lazy: {\r\n      type: Boolean,\r\n      default: false\r\n    },\r\n    clickable: {\r\n      type: Boolean,\r\n      default: true\r\n    },\r\n    speed: {\r\n      type: Number,\r\n      default: 0.5\r\n    },\r\n    realTime: {\r\n      type: Boolean,\r\n      default: false\r\n    },\r\n    stopPropagation: {\r\n      type: Boolean,\r\n      default: false\r\n    },\r\n    value: {\r\n      type: [String, Number, Array, Object],\r\n      default: 0\r\n    },\r\n    piecewiseLabel: {\r\n      type: Boolean,\r\n      default: false\r\n    },\r\n    debug: {\r\n      type: Boolean,\r\n      default: true\r\n    },\r\n    fixed: {\r\n      type: Boolean,\r\n      default: false\r\n    },\r\n    minRange: {\r\n      type: Number\r\n    },\r\n    maxRange: {\r\n      type: Number\r\n    },\r\n    processDraggable: {\r\n      type: Boolean,\r\n      default: false\r\n    },\r\n    useKeyboard: {\r\n      type: Boolean,\r\n      default: false\r\n    },\r\n    actionsKeyboard: {\r\n      type: Array,\r\n      default() {\r\n        return [(i) => i - 1, (i) => i + 1]\r\n      }\r\n    },\r\n    piecewiseFilter: {\r\n      type: Function\r\n    },\r\n    tooltipMerge: {\r\n      type: Boolean,\r\n      default: true\r\n    },\r\n    startAnimation: {\r\n      type: Boolean,\r\n      default: false\r\n    },\r\n    enableCross: {\r\n      type: Boolean,\r\n      default: true\r\n    },\r\n    valueInDot: {\r\n      type: Boolean,\r\n      default: false\r\n    },\r\n    plusMinusButtons: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n    sliderStyle: [Array, Object, Function],\r\n    focusStyle: [Array, Object, Function],\r\n    tooltipDir: [Array, String],\r\n    xformatter: [String, Function], // Global mixin defines formatter\r\n    mergeFormatter: [String, Function],\r\n    piecewiseStyle: Object,\r\n    disabledStyle: Object,\r\n    piecewiseActiveStyle: Object,\r\n    processStyle: Object,\r\n    processClass: String,\r\n    bgStyle: Object,\r\n    bgClass: String,\r\n    tooltipStyle: [Array, Object, Function],\r\n    disabledDotStyle: [Array, Object, Function],\r\n    labelStyle: Object,\r\n    labelActiveStyle: Object,\r\n    dotClass: [String, Array]\r\n  },\r\n  data() {\r\n    return {\r\n      flag: false,\r\n      dragFlag: false,\r\n      crossFlag: false,\r\n      keydownFlag: null,\r\n      focusFlag: false,\r\n      processFlag: false,\r\n      processSign: null,\r\n      size: 0,\r\n      fixedValue: 0,\r\n      focusSlider: 0,\r\n      currentValue: 0,\r\n      currentSlider: 0,\r\n      isComponentExists: true,\r\n      isMounted: false,\r\n      dotAxialSizePx: 1,\r\n    }\r\n  },\r\n  computed: {\r\n    tooltipFormatHelper() {\r\n      if (this.mergeFormatter) {\r\n        return this.mergeFormatting(this.val[0], this.val[1]);\r\n      }\r\n      if (this.xformatter) {\r\n        if (this.val[0] === this.val[1]) return this.formatting(this.val[0]);\r\n        return this.formatting(this.val[0]) + \"-\" + this.formatting(this.val[1]);\r\n      }\r\n      if (this.val[0] === this.val[1]) return this.val[0];\r\n      return this.val[0] + \"-\" + this.val[1];\r\n    },\r\n    dotWidthVal() {\r\n      return this.dotWidth || this.dotSize;\r\n    },\r\n    dotHeightVal() {\r\n      return this.dotHeight || this.dotSize;\r\n    },\r\n    flowDirection() {\r\n      return `l-ad-slider--${this.direction + (this.reverse ? '-reverse' : '')}`\r\n    },\r\n    tooltipMergedPosition() {\r\n      if (!this.isMounted) return {}\r\n      const tooltipDirection = this.tooltipDirection[0]\r\n      if (this.$refs.dot0) {\r\n        const style = {}\r\n        style[tooltipDirection] = `-${(this.dotAxialSizePx / 2) - (this.size / 2) + 9}px`\r\n        style['left'] = `50%`\r\n        return style\r\n      }\r\n    },\r\n    tooltipDirection() {\r\n      const dir = this.tooltipDir || (this.direction === 'vertical' ? 'left' : 'top')\r\n      if (Array.isArray(dir)) {\r\n        return this.isRange ? dir : dir[1]\r\n      } else {\r\n        return this.isRange ? [dir, dir] : dir\r\n      }\r\n    },\r\n    tooltipStatus() {\r\n      return this.tooltip === 'hover' && this.flag ? 'ad-slider-always' : this.tooltip ? `ad-slider-${this.tooltip}` : ''\r\n    },\r\n    tooltipClass() {\r\n      return [`ad-slider-tooltip-${this.tooltipDirection}`, 'ad-slider-tooltip']\r\n    },\r\n    disabledArray() {\r\n      return Array.isArray(this.disabled) ? this.disabled : [this.disabled, this.disabled]\r\n    },\r\n    boolDisabled() {\r\n      return this.disabledArray.every(b => b === true)\r\n    },\r\n    isDisabled() {\r\n      return this.eventType === 'none' ? true : this.boolDisabled\r\n    },\r\n    disabledClass() {\r\n      return this.boolDisabled ? 'l-ad-slider--disabled' : ''\r\n    },\r\n    stateClass() {\r\n      return {\r\n        'ad-slider-state-process-drag': this.processFlag,\r\n        'ad-slider-state-drag': this.flag && !this.processFlag && !this.keydownFlag,\r\n        'ad-slider-state-focus': this.focusFlag\r\n      }\r\n    },\r\n    isRange() {\r\n      return Array.isArray(this.value)\r\n    },\r\n    slider() {\r\n      return this.isRange ? [this.$refs.dot0, this.$refs.dot1] : [this.$refs.dot0]\r\n    },\r\n    minimum() {\r\n      return this.data ? 0 : this.min\r\n    },\r\n    val: {\r\n      get() {\r\n        return this.data ? (this.isRange ? [this.data[this.currentValue[0]], this.data[this.currentValue[1]]] : this.data[this.currentValue]) : this.currentValue\r\n      },\r\n      set(val) {\r\n        if (this.data) {\r\n          if (this.isRange) {\r\n            const index0 = this.data.indexOf(val[0])\r\n            const index1 = this.data.indexOf(val[1])\r\n            if (index0 > -1 && index1 > -1) {\r\n              this.currentValue = [index0, index1]\r\n            }\r\n          } else {\r\n            const index = this.data.indexOf(val)\r\n            if (index > -1) {\r\n              this.currentValue = index\r\n            }\r\n          }\r\n        } else {\r\n          this.currentValue = val\r\n        }\r\n      }\r\n    },\r\n    currentIndex() {\r\n      if (this.isRange) {\r\n        return this.data ? this.currentValue : [this.getIndexByValue(this.currentValue[0]), this.getIndexByValue(this.currentValue[1])]\r\n      } else {\r\n        return this.getIndexByValue(this.currentValue)\r\n      }\r\n    },\r\n    indexRange() {\r\n      if (this.isRange) {\r\n        return this.currentIndex\r\n      } else {\r\n        return [0, this.currentIndex]\r\n      }\r\n    },\r\n    maximum() {\r\n      return this.data ? (this.data.length - 1) : this.max\r\n    },\r\n    multiple() {\r\n      const decimals = `${this.interval}`.split('.')[1]\r\n      return decimals ? Math.pow(10, decimals.length) : 1\r\n    },\r\n    spacing() {\r\n      return this.data ? 1 : this.interval\r\n    },\r\n    total() {\r\n      if (this.data) {\r\n        return this.data.length - 1\r\n      } else if (Math.floor((this.maximum - this.minimum) * this.multiple) % (this.interval * this.multiple) !== 0) {\r\n        this.printError('Prop[interval] is illegal, Please make sure that the interval can be divisible')\r\n      }\r\n      return (this.maximum - this.minimum) / this.interval\r\n    },\r\n    usableSize() {\r\n      return this.size - this.dotAxialSizePx;\r\n    },\r\n    gap() {\r\n      return this.usableSize / this.total\r\n    },\r\n    position() {\r\n      if (this.isRange) {\r\n        return [(this.currentValue[0] - this.minimum) / this.spacing * this.gap + this.dotAxialSizePx / 2, (this.currentValue[1] - this.minimum) / this.spacing * this.gap + this.dotAxialSizePx / 2]\r\n      } else {\r\n        return ((this.currentValue - this.minimum) / this.spacing * this.gap + this.dotAxialSizePx / 2)\r\n      }\r\n    },\r\n    isFixed() {\r\n      return this.fixed || this.minRange\r\n    },\r\n    limit() {\r\n      if (this.isRange) {\r\n        if (this.isFixed) {\r\n          return [[this.dotAxialSizePx / 2, this.dotAxialSizePx / 2 + (this.total - this.fixedValue) * this.gap], [this.fixedValue * this.gap + this.dotAxialSizePx / 2, this.size - this.dotAxialSizePx / 2]]\r\n        } else {\r\n          return [[this.dotAxialSizePx / 2, this.position[1]], [this.position[0], this.size - this.dotAxialSizePx / 2]];\r\n        }\r\n      } else {\r\n        return [this.dotAxialSizePx / 2, this.size - this.dotAxialSizePx / 2];\r\n      }\r\n    },\r\n    valueLimit() {\r\n      return this.isRange ? this.isFixed ? [[this.minimum, this.maximum - (this.fixedValue * (this.spacing * this.multiple)) / this.multiple], [this.minimum + (this.fixedValue * (this.spacing * this.multiple)) / this.multiple, this.maximum]] : [[this.minimum, this.currentValue[1]], [this.currentValue[0], this.maximum]] : [this.minimum, this.maximum]\r\n    },\r\n    idleSlider() {\r\n      return this.currentSlider === 0 ? 1 : 0\r\n    },\r\n    wrapStyles() {\r\n      let ret = this.direction === 'vertical' ? {\r\n        height: this.height,\r\n      } : {\r\n        width: this.width,\r\n      }\r\n      if (this.plusMinusButtons) {\r\n        ret[this.direction === \"vertical\" ? \"margin-top\" : \"margin-right\"] = \"0.5rem\";\r\n        ret[this.direction === \"vertical\" ? \"margin-bottom\" : \"margin-left\"] = \"0.5rem\";\r\n      }\r\n      return ret;\r\n    },\r\n    sliderStyles() {\r\n      if (Array.isArray(this.sliderStyle)) {\r\n        return this.isRange ? this.sliderStyle : this.sliderStyle[1]\r\n      } else if (typeof this.sliderStyle === 'function') {\r\n        return this.sliderStyle(this.val, this.currentIndex)\r\n      } else {\r\n        return this.isRange ? [this.sliderStyle, this.sliderStyle] : this.sliderStyle\r\n      }\r\n    },\r\n    focusStyles() {\r\n      if (Array.isArray(this.focusStyle)) {\r\n        return this.isRange ? this.focusStyle : this.focusStyle[1]\r\n      } else if (typeof this.focusStyle === 'function') {\r\n        return this.focusStyle(this.val, this.currentIndex)\r\n      } else {\r\n        return this.isRange ? [this.focusStyle, this.focusStyle] : this.focusStyle\r\n      }\r\n    },\r\n    disabledDotStyles() {\r\n      const disabledStyle = this.disabledDotStyle\r\n      if (Array.isArray(disabledStyle)) {\r\n        return disabledStyle\r\n      } else if (typeof disabledStyle === 'function') {\r\n        const style = disabledStyle(this.val, this.currentIndex)\r\n        return Array.isArray(style) ? style : [style, style]\r\n      } else if (disabledStyle) {\r\n        return [disabledStyle, disabledStyle]\r\n      } else {\r\n        return [{\r\n          backgroundColor: '#ccc'\r\n        }, {\r\n          backgroundColor: '#ccc'\r\n        }]\r\n      }\r\n    },\r\n    tooltipStyles() {\r\n      if (Array.isArray(this.tooltipStyle)) {\r\n        return this.isRange ? this.tooltipStyle : this.tooltipStyle[1]\r\n      } else if (typeof this.tooltipStyle === 'function') {\r\n        return this.tooltipStyle(this.val, this.currentIndex)\r\n      } else {\r\n        return this.isRange ? [this.tooltipStyle, this.tooltipStyle] : this.tooltipStyle\r\n      }\r\n    },\r\n    elemStyles() {\r\n      return this.direction === 'vertical' ? {\r\n        width: this.width,\r\n        height: '100%',\r\n        position: \"relative\"\r\n      } : {\r\n        height: this.height,\r\n        position: \"relative\"\r\n      }\r\n    },\r\n    draggableStyle() {\r\n      return {\r\n        cursor: this.boolDisabled ? \"default\" : \"pointer\"\r\n      };\r\n    },\r\n    dotStyles() {\r\n      let ret = {\r\n        width: this.dotWidthVal,\r\n        height: this.dotHeightVal,\r\n        position: \"absolute\",\r\n      }\r\n      if (this.direction === \"vertical\") {\r\n        ret.left = \"50%\";\r\n      } else {\r\n        ret.top = \"50%\";\r\n      }\r\n      return ret;\r\n      /*\r\n      return this.direction === 'vertical' ? {\r\n        width: this.dotWidthVal,\r\n        height: this.dotHeightVal,\r\n        left: `${(-(this.dotWidthVal - this.width) / 2)}px`\r\n      } : {\r\n          width: `${this.dotWidthVal}px`,\r\n          height: `${this.dotHeightVal}px`,\r\n          top: `${(-(this.dotHeightVal - this.height) / 2)}px`\r\n        }*/\r\n    },\r\n    piecewiseDotStyle() {\r\n      return {\r\n        width: this.width,\r\n        height: this.height,\r\n      };\r\n    },\r\n    piecewiseDotWrap() {\r\n      if (!this.piecewise && !this.piecewiseLabel) {\r\n        return false\r\n      }\r\n      let arr = []\r\n      for (let i = 0; i <= this.total; i++) {\r\n        const style = this.direction === 'vertical' ? {\r\n          bottom: `${this.gap * i - this.usableSize / 2 }px`,\r\n          left: 0\r\n        } : {\r\n          left: `${this.gap * i - this.usableSize / 2 }px`,\r\n          top: 0\r\n        }\r\n        const index = this.reverse ? (this.total - i) : i\r\n        const label = this.data ? this.data[index] : (this.spacing * index) + this.min\r\n        if (this.piecewiseFilter && !this.piecewiseFilter({ index, label })) {\r\n          continue\r\n        }\r\n        arr.push({\r\n          style,\r\n          index,\r\n          label: this.xformatter ? this.formatting(label) : label\r\n        })\r\n      }\r\n      return arr\r\n    },\r\n  },\r\n  watch: {\r\n    value(val) {\r\n      this.flag || this.setValue(val, true)\r\n    },\r\n    max(val) {\r\n      if (val < this.min) {\r\n        return this.printError('The maximum value can not be less than the minimum value.')\r\n      }\r\n      const resetVal = this.limitValue(this.val)\r\n      this.setValue(resetVal)\r\n      this.refresh()\r\n    },\r\n    min(val) {\r\n      if (val > this.max) {\r\n        return this.printError('The minimum value can not be greater than the maximum value.')\r\n      }\r\n      const resetVal = this.limitValue(this.val)\r\n      this.setValue(resetVal)\r\n      this.refresh()\r\n    },\r\n    show(bool) {\r\n      if (bool && !this.size) {\r\n        this.$nextTick(() => {\r\n          this.refresh()\r\n        })\r\n      }\r\n    },\r\n    fixed() {\r\n      this.computedFixedValue()\r\n    },\r\n    minRange() {\r\n      this.computedFixedValue()\r\n    },\r\n    reverse() {\r\n      this.$refs.process.style.cssText = ''\r\n      this.refresh()\r\n    },\r\n  },\r\n  methods: {\r\n    bindEvents() {\r\n      document.addEventListener('touchmove', this.moving, { passive: false })\r\n      document.addEventListener('touchend', this.moveEnd, { passive: false })\r\n      document.addEventListener('mousedown', this.blurSlider)\r\n      document.addEventListener('mousemove', this.moving)\r\n      document.addEventListener('mouseup', this.moveEnd)\r\n      document.addEventListener('mouseleave', this.moveEnd)\r\n      document.addEventListener('keydown', this.handleKeydown)\r\n      document.addEventListener('keyup', this.handleKeyup)\r\n      window.addEventListener('resize', this.refresh)\r\n      if (this.isRange && this.tooltipMerge) {\r\n        this.$refs.dot0.addEventListener('transitionend', this.handleOverlapTooltip)\r\n        this.$refs.dot1.addEventListener('transitionend', this.handleOverlapTooltip)\r\n      }\r\n    },\r\n    unbindEvents() {\r\n      document.removeEventListener('touchmove', this.moving)\r\n      document.removeEventListener('touchend', this.moveEnd)\r\n      document.removeEventListener('mousedown', this.blurSlider)\r\n      document.removeEventListener('mousemove', this.moving)\r\n      document.removeEventListener('mouseup', this.moveEnd)\r\n      document.removeEventListener('mouseleave', this.moveEnd)\r\n      document.removeEventListener('keydown', this.handleKeydown)\r\n      document.removeEventListener('keyup', this.handleKeyup)\r\n      window.removeEventListener('resize', this.refresh)\r\n      if (this.isRange && this.tooltipMerge) {\r\n        this.$refs.dot0.removeEventListener('transitionend', this.handleOverlapTooltip)\r\n        this.$refs.dot1.removeEventListener('transitionend', this.handleOverlapTooltip)\r\n      }\r\n    },\r\n    handleKeydown(e) {\r\n      if (!this.useKeyboard || !this.focusFlag) {\r\n        return false\r\n      }\r\n      switch (e.keyCode) {\r\n        case 37:\r\n        case 40:\r\n          e.preventDefault()\r\n          this.keydownFlag = true\r\n          this.flag = true\r\n          this.changeFocusSlider(this.actionsKeyboard[0])\r\n          break\r\n        case 38:\r\n        case 39:\r\n          e.preventDefault()\r\n          this.keydownFlag = true\r\n          this.flag = true\r\n          this.changeFocusSlider(this.actionsKeyboard[1])\r\n          break\r\n      }\r\n    },\r\n    handleKeyup() {\r\n      if (this.keydownFlag) {\r\n        this.keydownFlag = false\r\n        this.flag = false\r\n      }\r\n    },\r\n    changeFocusSlider(fn) {\r\n      if (this.isRange) {\r\n        let arr = this.currentIndex.map((index, i) => {\r\n          if (i === this.focusSlider || this.fixed) {\r\n            const val = fn(index)\r\n            const range = this.fixed ? this.valueLimit[i] : [0, this.total]\r\n            if (val <= range[1] && val >= range[0]) {\r\n              return val\r\n            }\r\n          }\r\n          return index\r\n        })\r\n        if (arr[0] > arr[1]) {\r\n          this.focusSlider = this.focusSlider === 0 ? 1 : 0\r\n          arr = arr.reverse()\r\n        }\r\n        this.setIndex(arr)\r\n      } else {\r\n        this.setIndex(fn(this.currentIndex))\r\n      }\r\n    },\r\n    blurSlider(e) {\r\n      const dot = this.isRange ? this.$refs[`dot${this.focusSlider}`] : this.$refs.dot\r\n      if (!dot || dot === e.target || dot.contains(e.target)) {\r\n        return false\r\n      }\r\n      this.focusFlag = false\r\n    },\r\n    formatting(value) {\r\n      return typeof this.xformatter === 'string' ? this.xformatter.replace(/\\{value\\}/, value) : this.xformatter(value)\r\n    },\r\n    mergeFormatting(value1, value2) {\r\n      return typeof this.mergeFormatter === 'string' ? this.mergeFormatter.replace(/\\{(value1|value2)\\}/g, (_, key) => key === 'value1' ? value1 : value2) : this.mergeFormatter(value1, value2)\r\n    },\r\n    getPos(e) {\r\n      this.realTime && this.getStaticData()\r\n      var rect = this.$refs.elem.getBoundingClientRect();\r\n      return this.direction === 'vertical' ? (this.reverse ? (e.clientY - rect.top) : (this.size - (e.clientY - rect.top))) : (this.reverse ? (this.size - (e.clientX - rect.left)) : (e.clientX - rect.left))\r\n    },\r\n    processClick(e) {\r\n      if (this.fixed) {\r\n        e.stopPropagation()\r\n      }\r\n    },\r\n    wrapClick(e) {\r\n      if (this.isDisabled || !this.clickable || this.processFlag || this.dragFlag) return false\r\n      const pos = this.getPos(e)\r\n      if (this.isRange) {\r\n        if (this.disabledArray.every(b => b === false)) {\r\n          this.currentSlider = pos > ((this.position[1] - this.position[0]) / 2 + this.position[0]) ? 1 : 0\r\n        } else if (this.disabledArray[0]) {\r\n          if (pos < this.position[0]) return false\r\n          this.currentSlider = 1\r\n        } else if (this.disabledArray[1]) {\r\n          if (pos > this.position[1]) return false\r\n          this.currentSlider = 0\r\n        }\r\n      }\r\n      if (this.disabledArray[this.currentSlider]) {\r\n        return false\r\n      }\r\n      this.setValueOnPos(pos)\r\n      if (this.isRange && this.tooltipMerge) {\r\n        const timer = setInterval(() => this.handleOverlapTooltip(), 16.7)\r\n        setTimeout(() => window.clearInterval(timer), this.speed * 1000)\r\n      }\r\n    },\r\n    moveStart(e, index = 0, isProcess) {\r\n      if (this.disabledArray[index]) {\r\n        return false\r\n      }\r\n      if (this.stopPropagation) {\r\n        e.stopPropagation()\r\n      }\r\n      if (this.isRange) {\r\n        this.currentSlider = index\r\n        if (isProcess) {\r\n          if (!this.processDraggable) {\r\n            return false\r\n          }\r\n          this.processFlag = true\r\n          this.processSign = {\r\n            pos: this.position,\r\n            start: this.getPos((e.targetTouches && e.targetTouches[0]) ? e.targetTouches[0] : e)\r\n          }\r\n        }\r\n        if (!this.enableCross && this.val[0] === this.val[1]) {\r\n          this.crossFlag = true\r\n        }\r\n      }\r\n      if (!isProcess && this.useKeyboard) {\r\n        this.focusFlag = true\r\n        this.focusSlider = index\r\n      }\r\n      this.flag = true\r\n      this.$emit('drag-start', this)\r\n    },\r\n    moving(e) {\r\n      if (this.stopPropagation) {\r\n        e.stopPropagation()\r\n      }\r\n      if (!this.flag) return false\r\n      e.preventDefault()\r\n      if (e.targetTouches && e.targetTouches[0]) e = e.targetTouches[0]\r\n      if (this.processFlag) {\r\n        this.currentSlider = 0\r\n        this.setValueOnPos(this.processSign.pos[0] + this.getPos(e) - this.processSign.start, true)\r\n        this.currentSlider = 1\r\n        this.setValueOnPos(this.processSign.pos[1] + this.getPos(e) - this.processSign.start, true)\r\n      } else {\r\n        this.dragFlag = true\r\n        this.setValueOnPos(this.getPos(e), true)\r\n      }\r\n      if (this.isRange && this.tooltipMerge) {\r\n        this.handleOverlapTooltip()\r\n      }\r\n    },\r\n    moveEnd(e) {\r\n      if (this.stopPropagation) {\r\n        e.stopPropagation()\r\n      }\r\n      if (this.flag) {\r\n        this.$emit('drag-end', this)\r\n        if (this.lazy && this.isDiff(this.val, this.value)) {\r\n          this.syncValue()\r\n        }\r\n      } else {\r\n        return false\r\n      }\r\n      this.flag = false\r\n      window.setTimeout(() => {\r\n        this.crossFlag = false\r\n        this.dragFlag = false\r\n        this.processFlag = false\r\n      }, 0)\r\n      this.setPosition()\r\n    },\r\n    setValueOnPos(pos, isDrag) {\r\n      const range = this.isRange ? this.limit[this.currentSlider] : this.limit\r\n      const valueRange = this.isRange ? this.valueLimit[this.currentSlider] : this.valueLimit\r\n      const index = Math.round((pos - this.dotAxialSizePx / 2) / this.gap)\r\n      if (pos >= range[0] && pos <= range[1]) {\r\n        const v = this.getValueByIndex(index)\r\n        this.setTransform(pos)\r\n        this.setCurrentValue(v, isDrag)\r\n        if (this.isRange && (this.fixed || this.isLessRange(pos, index))) {\r\n          this.setTransform(pos + ((this.fixedValue * this.gap) * (this.currentSlider === 0 ? 1 : -1)), true)\r\n          this.setCurrentValue((v * this.multiple + (this.fixedValue * this.spacing * this.multiple * (this.currentSlider === 0 ? 1 : -1))) / this.multiple, isDrag, true)\r\n        }\r\n      } else {\r\n        const anotherSlider = pos < range[0] ? 0 : 1\r\n        const currentSlider = anotherSlider === 0 ? 1 : 0\r\n        this.setTransform(range[anotherSlider])\r\n        this.setCurrentValue(valueRange[anotherSlider])\r\n        if (this.isRange && (this.fixed || this.isLessRange(pos, index))) {\r\n          this.setTransform(this.limit[this.idleSlider][anotherSlider], true)\r\n          this.setCurrentValue(this.valueLimit[this.idleSlider][anotherSlider], isDrag, true)\r\n        } else if (this.isRange && (this.enableCross || this.crossFlag) && !this.isFixed && !this.disabledArray[anotherSlider] && this.currentSlider === currentSlider) {\r\n          this.focusSlider = anotherSlider\r\n          this.currentSlider = anotherSlider\r\n        }\r\n      }\r\n      this.crossFlag = false\r\n    },\r\n    isLessRange(pos, index) {\r\n      if (!this.isRange || (!this.minRange && !this.maxRange)) {\r\n        return false\r\n      }\r\n      const diff = this.currentSlider === 0 ? this.currentIndex[1] - index : index - this.currentIndex[0]\r\n      if (this.minRange && diff <= this.minRange) {\r\n        this.fixedValue = this.minRange\r\n        return true\r\n      }\r\n      if (this.maxRange && diff >= this.maxRange) {\r\n        this.fixedValue = this.maxRange\r\n        return true\r\n      }\r\n      this.computedFixedValue()\r\n      return false\r\n    },\r\n    isDiff(a, b) {\r\n      if (Object.prototype.toString.call(a) !== Object.prototype.toString.call(b)) {\r\n        return true\r\n      } else if (Array.isArray(a) && a.length === b.length) {\r\n        return a.some((v, i) => v !== b[i])\r\n      }\r\n      return a !== b\r\n    },\r\n    setCurrentValue(val, isDrag, isIdleSlider) {\r\n      const slider = isIdleSlider ? this.idleSlider : this.currentSlider\r\n      if (val < this.minimum || val > this.maximum) return false\r\n      if (this.isRange) {\r\n        if (this.isDiff(this.currentValue[slider], val)) {\r\n          this.currentValue.splice(slider, 1, val)\r\n          if (!this.lazy || !this.flag) {\r\n            this.syncValue()\r\n          }\r\n        }\r\n      } else if (this.isDiff(this.currentValue, val)) {\r\n        this.currentValue = val\r\n        if (!this.lazy || !this.flag) {\r\n          this.syncValue()\r\n        }\r\n      }\r\n      isDrag || this.setPosition()\r\n    },\r\n    getValueByIndex(index) {\r\n      return ((this.spacing * this.multiple) * index + (this.minimum * this.multiple)) / this.multiple\r\n    },\r\n    getIndexByValue(value) {\r\n      return Math.round((value - this.minimum) * this.multiple) / (this.spacing * this.multiple)\r\n    },\r\n    setIndex(val) {\r\n      if (Array.isArray(val) && this.isRange) {\r\n        let value\r\n        if (this.data) {\r\n          value = [this.data[val[0]], this.data[val[1]]]\r\n        } else {\r\n          value = [this.getValueByIndex(val[0]), this.getValueByIndex(val[1])]\r\n        }\r\n        this.setValue(value)\r\n      } else {\r\n        val = this.getValueByIndex(val)\r\n        if (this.isRange) {\r\n          this.currentSlider = val > ((this.currentValue[1] - this.currentValue[0]) / 2 + this.currentValue[0]) ? 1 : 0\r\n        }\r\n        this.setCurrentValue(val)\r\n      }\r\n    },\r\n    increment(dir) {\r\n      if (this.boolDisabled) return;\r\n      const newVal = this.getValue() + dir * this.interval;\r\n      if (newVal > this.max || newVal < this.min) return;\r\n      this.setValue(newVal);\r\n    },\r\n    setValue(val, noCb, speed) {\r\n      if (this.isDiff(this.val, val)) {\r\n        const resetVal = this.limitValue(val)\r\n        this.val = this.isRange ? resetVal.concat() : resetVal\r\n        this.computedFixedValue()\r\n        this.syncValue(noCb)\r\n      }\r\n      this.$nextTick(() => this.setPosition(speed))\r\n    },\r\n    computedFixedValue() {\r\n      if (!this.isFixed) {\r\n        this.fixedValue = 0\r\n        return false\r\n      }\r\n      this.fixedValue = Math.max(this.fixed ? this.currentIndex[1] - this.currentIndex[0] : 0, this.minRange || 0)\r\n    },\r\n    setPosition(speed) {\r\n      this.flag || this.setTransitionTime(speed === undefined ? this.speed : speed)\r\n      if (this.isRange) {\r\n        this.setTransform(this.position[0], this.currentSlider === 1)\r\n        this.setTransform(this.position[1], this.currentSlider === 0)\r\n      } else {\r\n        this.setTransform(this.position)\r\n      }\r\n      this.flag || this.setTransitionTime(0)\r\n    },\r\n    setTransform(val, isIdleSlider) {\r\n      const slider = isIdleSlider ? this.idleSlider : this.currentSlider\r\n      const value = roundToDPR((this.direction === 'vertical' ? ((this.dotAxialSizePx / 2) - val) : (val - (this.dotAxialSizePx / 2))) * (this.reverse ? -1 : 1))\r\n      const translateValue = this.direction === 'vertical' ? `translate(-50%, ${value}px)` : `translate(${value}px, -50%)`\r\n      const processSize = this.fixed ? `${this.fixedValue * this.gap}px` : `${slider === 0 ? this.position[1] - val : val - this.position[0]}px`\r\n      const processPos = this.fixed ? `${slider === 0 ? val : (val - this.fixedValue * this.gap)}px` : `${slider === 0 ? val : this.position[0]}px`\r\n      this.slider[slider].style.transform = translateValue\r\n      this.slider[slider].style.WebkitTransform = translateValue\r\n      this.slider[slider].style.msTransform = translateValue\r\n      if (this.isRange) {\r\n        if (this.direction === 'vertical') {\r\n          this.$refs.process.style.height = processSize\r\n          this.$refs.process.style[this.reverse ? 'top' : 'bottom'] = processPos\r\n        } else {\r\n          this.$refs.process.style.width = processSize\r\n          this.$refs.process.style[this.reverse ? 'right' : 'left'] = processPos\r\n        }\r\n      } else {\r\n        if (this.direction === 'vertical') {\r\n          this.$refs.process.style.height = `${val}px`\r\n          this.$refs.process.style[this.reverse ? 'top' : 'bottom'] = 0\r\n        } else {\r\n          this.$refs.process.style.width = `${val}px`\r\n          this.$refs.process.style[this.reverse ? 'right' : 'left'] = 0\r\n        }\r\n      }\r\n    },\r\n    setTransitionTime(time) {\r\n      // In order to avoid browser merge style and modify together\r\n      time || this.$refs.process.offsetWidth\r\n      for (let i = 0; i < this.slider.length; i++) {\r\n        this.slider[i].style.transitionDuration = `${time}s`\r\n        this.slider[i].style.WebkitTransitionDuration = `${time}s`\r\n      }\r\n      if (this.isRange) {\r\n        this.$refs.process.style.transitionDuration = `${time}s`\r\n        this.$refs.process.style.WebkitTransitionDuration = `${time}s`\r\n      } else {\r\n        this.$refs.process.style.transitionDuration = `${time}s`\r\n        this.$refs.process.style.WebkitTransitionDuration = `${time}s`\r\n      }\r\n    },\r\n    limitValue(val) {\r\n      if (this.data) {\r\n        return val\r\n      }\r\n      const inRange = (v) => {\r\n        if (v < this.min) {\r\n          this.printError(`The value of the slider is ${val}, the minimum value is ${this.min}, the value of this slider can not be less than the minimum value`)\r\n          return this.min\r\n        } else if (v > this.max) {\r\n          this.printError(`The value of the slider is ${val}, the maximum value is ${this.max}, the value of this slider can not be greater than the maximum value`)\r\n          return this.max\r\n        }\r\n        return v\r\n      }\r\n      if (this.isRange) {\r\n        return val.map((v) => inRange(v))\r\n      } else {\r\n        return inRange(val)\r\n      }\r\n    },\r\n    isActive(index) {\r\n      return index >= this.indexRange[0] && index <= this.indexRange[1]\r\n    },\r\n    syncValue(noCb) {\r\n      let val = this.isRange ? this.val.concat() : this.val\r\n      this.$emit('input', val)\r\n      this.keydownFlag && this.$emit('on-keypress', val)\r\n      noCb || this.$emit('callback', val)\r\n    },\r\n    getValue() {\r\n      return this.val\r\n    },\r\n    getIndex() {\r\n      return this.currentIndex\r\n    },\r\n    getStaticData() {\r\n      if (this.$refs.elem) {\r\n        this.size = this.direction === 'vertical' ? this.$refs.elem.offsetHeight : this.$refs.elem.offsetWidth\r\n        this.dotAxialSizePx = this.direction === 'vertical' ? this.$refs.dot0.clientHeight : this.$refs.dot0.clientWidth;\r\n      }\r\n    },\r\n    refresh() {\r\n      if (this.$refs.elem) {\r\n        this.getStaticData()\r\n        this.computedFixedValue()\r\n        this.setPosition(0)\r\n      }\r\n    },\r\n    printError(msg) {\r\n      if (this.debug) {\r\n        console.error(`[VueSlider error]: ${msg}`)\r\n      }\r\n    },\r\n    handleOverlapTooltip() {\r\n      const isDirectionSame = this.tooltipDirection[0] === this.tooltipDirection[1]\r\n      if (this.isRange && isDirectionSame) {\r\n        const tooltip0 = this.reverse ? this.$refs.tooltip1 : this.$refs.tooltip0\r\n        const tooltip1 = this.reverse ? this.$refs.tooltip0 : this.$refs.tooltip1\r\n        const tooltip0Rect = tooltip0.getBoundingClientRect()\r\n        const tooltip1Rect = tooltip1.getBoundingClientRect()\r\n        const tooltip0Right = tooltip0Rect.right\r\n        const tooltip1Left = tooltip1Rect.left\r\n        const tooltip0Y = tooltip0Rect.top\r\n        const tooltip1Y = tooltip1Rect.top + tooltip1Rect.height\r\n        const horizontalOverlap = this.direction === 'horizontal' && tooltip0Right > tooltip1Left\r\n        const verticalOverlap = this.direction === 'vertical' && tooltip1Y > tooltip0Y\r\n        if (horizontalOverlap || verticalOverlap) {\r\n          this.handleDisplayMergedTooltip(true)\r\n        } else {\r\n          this.handleDisplayMergedTooltip(false)\r\n        }\r\n      }\r\n    },\r\n    handleDisplayMergedTooltip(show) {\r\n      const tooltip0 = this.$refs.tooltip0\r\n      const tooltip1 = this.$refs.tooltip1\r\n      const mergedTooltip = this.$refs.process.getElementsByClassName('vue-merged-tooltip')[0]\r\n      if (show) {\r\n        tooltip0.style.visibility = 'hidden'\r\n        tooltip1.style.visibility = 'hidden'\r\n        mergedTooltip.style.visibility = 'visible'\r\n      } else {\r\n        tooltip0.style.visibility = 'visible'\r\n        tooltip1.style.visibility = 'visible'\r\n        mergedTooltip.style.visibility = 'hidden'\r\n      }\r\n    },\r\n    dotContents() {\r\n      if (Notations.current.name === \"Blind\" || Theme.current().name === \"S9\" ) return \"\";\r\n      // Doesn't work if the slider needs to show more precision than integers,\r\n      // but I don't think we have any such sliders.\r\n      return this.valueInDot ? Math.round(this.getValue()) : '';\r\n    },\r\n  },\r\n  mounted() {\r\n    this.isComponentExists = true\r\n    if (typeof window === 'undefined' || typeof document === 'undefined') {\r\n      return this.printError('window or document is undefined, can not be initialization.')\r\n    }\r\n    this.$nextTick(() => {\r\n      if (this.isComponentExists) {\r\n        this.getStaticData()\r\n        this.setValue(this.limitValue(this.value), true, this.startAnimation ? this.speed : 0)\r\n        this.bindEvents()\r\n        if (this.isRange && this.tooltipMerge && !this.startAnimation) {\r\n          this.$nextTick(() => {\r\n            this.handleOverlapTooltip()\r\n          })\r\n        }\r\n      }\r\n    })\r\n    this.isMounted = true\r\n  },\r\n  beforeDestroy() {\r\n    this.isComponentExists = false\r\n    this.unbindEvents()\r\n  }\r\n};\r\n</script>\r\n\r\n<template>\r\n  <div :class=\"['l-ad-slider', flowDirection, disabledClass, { 'l-ad-slider--has-label': piecewiseLabel }]\"\r\n       v-show=\"show\">\r\n    <PlusMinusButton v-if=\"plusMinusButtons\" type=\"minus\" @click=\"increment(-1)\"/>\r\n    <div ref=\"wrap\"\r\n         :class=\"['l-ad-slider__wrap', stateClass]\"\r\n         :style=\"[wrapStyles, boolDisabled ? disabledStyle : null]\"\r\n         @click=\"wrapClick\">\r\n      <div ref=\"elem\" aria-hidden=\"true\" :class=\"['l-ad-slider__bg', 'c-ad-slider__bg', bgClass]\"\r\n        :style=\"[elemStyles, bgStyle, draggableStyle]\"\r\n        @mousedown=\"moveStart($event, 0, true)\"\r\n        @touchstart=\"moveStart($event, 0, true)\"\r\n      >\r\n        <template v-if=\"isRange\">\r\n          <div\r\n            ref=\"dot0\"\r\n            key=\"dot0\"\r\n            :class=\"[tooltipStatus, 'l-ad-slider__dot', 'c-ad-slider__dot',\r\n            {\r\n              'l-ad-slider__dot--focus': focusFlag && focusSlider === 0,\r\n              'l-ad-slider__dot--dragging': flag && currentSlider === 0,\r\n              'l-ad-slider__dot--disabled': !boolDisabled && disabledArray[0]\r\n            }\r\n          ]\"\r\n            :style=\"dotStyles\"\r\n            @mousedown=\"moveStart\"\r\n            @touchstart=\"moveStart\"\r\n          >\r\n            <div\r\n              :class=\"['l-ad-slider__dot-handle', 'c-ad-slider__dot-handle', dotClass]\"\r\n              :style=\"[\r\n              (!boolDisabled && disabledArray[0])\r\n              ? disabledDotStyles[0]\r\n              : null,\r\n              sliderStyles[0],\r\n              focusFlag && focusSlider === 0 ? focusStyles[0]: null\r\n            ]\"\r\n            ></div>\r\n            <div ref=\"tooltip0\" :class=\"['ad-slider-tooltip-' + tooltipDirection[0], 'ad-slider-tooltip-wrap']\">\r\n              <span class=\"ad-slider-tooltip\" :style=\"tooltipStyles[0]\">{{ xformatter ? formatting(val[0]) : val[0] }}</span>\r\n            </div>\r\n          </div>\r\n          <div\r\n            ref=\"dot1\"\r\n            key=\"dot1\"\r\n            :class=\"[tooltipStatus, 'l-ad-slider__dot', 'c-ad-slider__dot',\r\n            {\r\n              'l-ad-slider__dot--focus': focusFlag && focusSlider === 1,\r\n              'l-ad-slider__dot--dragging': flag && currentSlider === 1,\r\n              'l-ad-slider__dot--disabled': !boolDisabled && disabledArray[1]\r\n            }\r\n          ]\"\r\n            :style=\"dotStyles\"\r\n            @mousedown=\"moveStart($event, 1)\"\r\n            @touchstart=\"moveStart($event, 1)\"\r\n          >\r\n            <div\r\n              :class=\"['l-ad-slider__dot-handle', 'c-ad-slider__dot-handle', dotClass]\"\r\n              :style=\"[\r\n              (!boolDisabled && disabledArray[1])\r\n              ? disabledDotStyles[1]\r\n              : null,\r\n              sliderStyles[1],\r\n              focusFlag && focusSlider === 1 ? focusStyles[1]: null\r\n            ]\"\r\n            ></div>\r\n            <div ref=\"tooltip1\" :class=\"['ad-slider-tooltip-' + tooltipDirection[1], 'ad-slider-tooltip-wrap']\">\r\n              <span class=\"ad-slider-tooltip\" :style=\"tooltipStyles[1]\">{{ xformatter ? formatting(val[1]) : val[1] }}</span>\r\n            </div>\r\n          </div>\r\n        </template>\r\n        <template v-else>\r\n          <div\r\n            ref=\"dot0\"\r\n            key=\"dot0\"\r\n            :class=\"[tooltipStatus, 'l-ad-slider__dot', 'c-ad-slider__dot',\r\n            {\r\n              'l-ad-slider__dot--focus': focusFlag && focusSlider === 0,\r\n              'l-ad-slider__dot--dragging': flag && currentSlider === 0\r\n            }\r\n          ]\"\r\n            :style=\"dotStyles\"\r\n            @mousedown=\"moveStart\"\r\n            @touchstart=\"moveStart\"\r\n          >\r\n            <div :class=\"['l-ad-slider__dot-handle', 'c-ad-slider__dot-handle', dotClass]\"\r\n                 :style=\"[sliderStyles, focusFlag && focusSlider === 0 ? focusStyles : null]\">\r\n              {{dotContents(0)}}\r\n            </div>\r\n            <div :class=\"['ad-slider-tooltip-' + tooltipDirection, 'ad-slider-tooltip-wrap']\">\r\n              <span class=\"ad-slider-tooltip\" :style=\"tooltipStyles\">{{ xformatter ? formatting(val) : val }}</span>\r\n            </div>\r\n          </div>\r\n        </template>\r\n        <ul class=\"ad-slider-piecewise\">\r\n          <li\r\n            v-for=\"(piecewiseObj, index) in piecewiseDotWrap\"\r\n            class=\"ad-slider-piecewise-item\"\r\n            :style=\"[piecewiseDotStyle, piecewiseObj.style]\"\r\n            :key=\"index\"\r\n          >\r\n            <span\r\n              v-if=\"piecewise\"\r\n              class=\"ad-slider-piecewise-dot\"\r\n              :style=\"[ piecewiseStyle, isActive(piecewiseObj.index) ? piecewiseActiveStyle : null ]\"\r\n            ></span>\r\n\r\n            <span\r\n              v-if=\"piecewiseLabel\"\r\n              class=\"ad-slider-piecewise-label\"\r\n              :style=\"[ labelStyle, isActive(piecewiseObj.index) ? labelActiveStyle : null ]\"\r\n            >\r\n              {{ piecewiseObj.label }}\r\n            </span>\r\n          </li>\r\n        </ul>\r\n        <div\r\n          ref=\"process\"\r\n          :class=\"['l-ad-slider__process', 'c-ad-slider__process', { 'ad-slider-process-draggable': isRange && processDraggable }, processClass]\"\r\n          :style=\"[elemStyles, bgStyle, draggableStyle]\"\r\n          @click=\"processClick\"\r\n        >\r\n          <div\r\n            ref=\"mergedTooltip\"\r\n            :class=\"['vue-merged-tooltip', 'ad-slider-tooltip-' + tooltipDirection[0], 'ad-slider-tooltip-wrap']\"\r\n            :style=\"tooltipMergedPosition\"\r\n          >\r\n            <span class=\"ad-slider-tooltip\" :style=\"tooltipStyles\">\r\n              {{ tooltipFormatHelper }}\r\n            </span>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n    <PlusMinusButton v-if=\"plusMinusButtons\" type=\"plus\" @click=\"increment(1)\"/>\r\n  </div>\r\n</template>\r\n"]}]}