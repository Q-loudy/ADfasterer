{"remainingRequest":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\@vue\\vue-loader-v15\\lib\\index.js??vue-loader-options!C:\\Games\\ADFasterer\\ADfasterer\\src\\components\\GlyphComponent.vue?vue&type=script&lang=js&","dependencies":[{"path":"C:\\Games\\ADFasterer\\ADfasterer\\src\\components\\GlyphComponent.vue","mtime":1745241596773},{"path":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\babel-loader\\lib\\index.js","mtime":1745242219290},{"path":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1745242214069},{"path":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\@vue\\vue-loader-v15\\lib\\index.js","mtime":1745242220175}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:DQppbXBvcnQgeyBHbHlwaEluZm8gfSBmcm9tICIuLi8uLi9zcmMvY29tcG9uZW50cy9tb2RhbHMvb3B0aW9ucy9TZWxlY3RHbHlwaEluZm9Ecm9wZG93biI7DQoNCmltcG9ydCBHbHlwaFRvb2x0aXAgZnJvbSAiQC9jb21wb25lbnRzL0dseXBoVG9vbHRpcCI7DQoNCi8vIFdlIGdlbmVyYXRlIHRoZSBib3JkZXIgZWZmZWN0cyB3aXRoIENTUyBncmFkaWVudHM7IGZvciB0aGUgc2FrZSBvZiBmbGV4aWJpbGl0eSBhbmQgZm9yIGR5bmFtaWNhbGx5IHVzaW5nDQovLyB0aGUgZ2x5cGggY29sb3IgaW5zdGVhZCBvZiB0aGUgZml4ZWQgcmFyaXR5IGNvbG9yLCB0aGUgYm9yZGVyIHBhdHRlcm5zIGFyZSBzdG9yZWQgYmVsb3cgYW5kIHRoZW4gcGFyc2VkDQovLyBpbnRvIHRoZSByZWxldmFudCBDU1Mgb24gYSBwZXItZ2x5cGggYmFzaXMNCmNvbnN0IHJhcml0eUJvcmRlclN0eWxlcyA9IHsNCiAgY29tbW9uOiBbXSwNCiAgdW5jb21tb246IFsNCiAgICB7DQogICAgICBsaW5lVHlwZTogImxpbmVhciIsDQogICAgICBhbmdsZXM6IFs0NV0sDQogICAgICBjb2xvclNwbGl0OiBbMTQsIDE2LCA4NCwgODZdLA0KICAgIH0NCiAgXSwNCiAgcmFyZTogWw0KICAgIHsNCiAgICAgIGxpbmVUeXBlOiAibGluZWFyIiwNCiAgICAgIGFuZ2xlczogWzQ1LCAxMzVdLA0KICAgICAgY29sb3JTcGxpdDogWzE0LCAxNiwgODQsIDg2XSwNCiAgICB9DQogIF0sDQogIGVwaWM6IFsNCiAgICB7DQogICAgICBsaW5lVHlwZTogImxpbmVhciIsDQogICAgICBhbmdsZXM6IFs0NSwgMTM1XSwNCiAgICAgIGNvbG9yU3BsaXQ6IFsxMiwgMTQsIDE2LCAxOCwgODIsIDg0LCA4NiwgODhdLA0KICAgIH0NCiAgXSwNCiAgbGVnZW5kYXJ5OiBbDQogICAgew0KICAgICAgbGluZVR5cGU6ICJidW1wIiwNCiAgICAgIGNvbG9yU3BsaXQ6IFsxNSwgMjVdLA0KICAgIH0NCiAgXSwNCiAgbXl0aGljYWw6IFsNCiAgICB7DQogICAgICBsaW5lVHlwZTogImJ1bXAiLA0KICAgICAgY29sb3JTcGxpdDogWzE1LCAyNV0sDQogICAgfSwNCiAgICB7DQogICAgICBsaW5lVHlwZTogImxpbmVhciIsDQogICAgICBhbmdsZXM6IFs0NSwgMTM1XSwNCiAgICAgIGNvbG9yU3BsaXQ6IFsxMCwgMTMsIDg3LCA5MF0sDQogICAgfQ0KICBdLA0KICB0cmFuc2NlbmRlbnQ6IFsNCiAgICB7DQogICAgICBsaW5lVHlwZTogImJ1bXAiLA0KICAgICAgY29sb3JTcGxpdDogWzE1LCAzNV0sDQogICAgfSwNCiAgICB7DQogICAgICBsaW5lVHlwZTogImxpbmVhciIsDQogICAgICBhbmdsZXM6IFs0NSwgMTM1XSwNCiAgICAgIGNvbG9yU3BsaXQ6IFsxMCwgMTIsIDE0LCAxNiwgODQsIDg2LCA4OCwgOTBdLA0KICAgIH0NCiAgXSwNCiAgY2VsZXN0aWFsOiBbDQogICAgew0KICAgICAgbGluZVR5cGU6ICJidW1wIiwNCiAgICAgIGNvbG9yU3BsaXQ6IFsxNSwgMzVdLA0KICAgIH0sDQogICAgew0KICAgICAgbGluZVR5cGU6ICJyYWRpYWwiLA0KICAgICAgY29sb3JTcGxpdDogWzY1LCA4NV0sDQogICAgfSwNCiAgXSwNCiAgY3Vyc2VkOiBbDQogICAgew0KICAgICAgbGluZVR5cGU6ICJzcGlrZSIsDQogICAgICBjZW50ZXI6IFs0MCwgNDBdLA0KICAgICAgYW5nbGVzOiBbMzA1LCAzMjVdLA0KICAgIH0sDQogICAgew0KICAgICAgbGluZVR5cGU6ICJzcGlrZSIsDQogICAgICBjZW50ZXI6IFs2MCwgNDBdLA0KICAgICAgYW5nbGVzOiBbMzUsIDU1XSwNCiAgICB9LA0KICAgIHsNCiAgICAgIGxpbmVUeXBlOiAic3Bpa2UiLA0KICAgICAgY2VudGVyOiBbNjAsIDYwXSwNCiAgICAgIGFuZ2xlczogWzEyNSwgMTQ1XSwNCiAgICB9LA0KICAgIHsNCiAgICAgIGxpbmVUeXBlOiAic3Bpa2UiLA0KICAgICAgY2VudGVyOiBbNDAsIDYwXSwNCiAgICAgIGFuZ2xlczogWzIxNSwgMjM1XSwNCiAgICB9LA0KICBdLA0KICBjb21wYW5pb246IFsNCiAgICB7DQogICAgICBsaW5lVHlwZTogImNvbXBhbmlvbiIsDQogICAgfSwNCiAgXQ0KfTsNCg0KLy8gVGhpcyBmdW5jdGlvbiBkb2VzIGFsbCB0aGUgcGFyc2luZyBvZiB0aGUgYWJvdmUgZ3JhZGllbnQgc3BlY2lmaWNhdGlvbnMNCi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtcGFyYW1zDQpmdW5jdGlvbiBnZW5lcmF0ZUdyYWRpZW50KGRhdGEsIGNvbG9yLCBnbHlwaCwgaXNDaXJjdWxhcikgew0KICAvLyBUaGUgdW5kZWZpbmVkIGRlY2xhcmF0aW9ucyBoZXJlIGFyZSBtb3N0bHkgdG8gbWFrZSBFU0xpbnQgaGFwcHksIGFuZCBhcmVuJ3QgbmVjZXNzYXJpbHkgdXNlZCBpbiBhbGwgY2FzZXMNCiAgbGV0IGJvcmRlcnMsIHNjYWxlRm4sIGNlbnRlcnMsIHNwZWNpYWxEYXRhLCBpc0NvbG9yID0gZmFsc2U7DQogIGNvbnN0IGVudHJpZXMgPSBbXSwgZWxlbWVudHMgPSBbXTsNCiAgc3dpdGNoIChkYXRhLmxpbmVUeXBlKSB7DQogICAgY2FzZSAibGluZWFyIjoNCiAgICAgIC8vIFByb2R1Y2VzIHN0cmlwZXMgYXQgdGhlIHNwZWNpZmllZCBhbmdsZSwgd2hlcmUgY29sb3Igc2hhcnBseSBzd2l0Y2hlcyBiZXR3ZWVuIHRoZSBzcGVjaWZpZWQgY29sb3IgYW5kDQogICAgICAvLyB0cmFuc3BhcmVudCBhdCBlYWNoIHBlcmNlbnRhZ2UgaW4gbGluZXMNCiAgICAgIGJvcmRlcnMgPSBbMCwgLi4uZGF0YS5jb2xvclNwbGl0LCAxMDBdOw0KICAgICAgc2NhbGVGbiA9IHBlcmMgPT4gKGlzQ2lyY3VsYXIgPyA1MCArIDAuNyAqIChwZXJjIC0gNTApIDogcGVyYyk7DQogICAgICBmb3IgKGNvbnN0IGFuZ2xlIG9mIGRhdGEuYW5nbGVzKSB7DQogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYm9yZGVycy5sZW5ndGggLSAxOyBpKyspIHsNCiAgICAgICAgICBlbnRyaWVzLnB1c2goYCR7aXNDb2xvciA/IGNvbG9yIDogInRyYW5zcGFyZW50In0gJHtzY2FsZUZuKGJvcmRlcnNbaV0pfSUgJHtzY2FsZUZuKGJvcmRlcnNbaSArIDFdKX0lYCk7DQogICAgICAgICAgaXNDb2xvciA9ICFpc0NvbG9yOw0KICAgICAgICB9DQogICAgICAgIGVsZW1lbnRzLnB1c2goYHJlcGVhdGluZy1saW5lYXItZ3JhZGllbnQoJHthbmdsZX1kZWcsICR7ZW50cmllcy5qb2luKCIsIil9KWApOw0KICAgICAgfQ0KICAgICAgcmV0dXJuIGVsZW1lbnRzLmpvaW4oIiwiKTsNCiAgICBjYXNlICJidW1wIjoNCiAgICAgIC8vIFByb2R1Y2VzIGZvdXIgYnVtcHMgb24gdGhlIGNhcmRpbmFsIGRpcmVjdGlvbnMgb2YgdGhlIGdseXBoIGJvcmRlciwgd2l0aCBzcGVjaWZpZWQgY29sb3IgZmFkZSBkaXN0YW5jZXMuDQogICAgICAvLyBUaGVzZSBidW1wcyBvdmVybGFwIHNvbWUgZG90cyBvbiBlZmZhcmlnIGdseXBocywgc28gd2UgY29uZGl0aW9uYWxseSBtYWtlIHRoZW0gbW9yZSB0cmFuc3BhcmVudCAoZWZmZWN0aXZlbHkNCiAgICAgIC8vIHNocmlua2luZyB0aGVtIHNvIHRoZXkgZG9uJ3Qgb3ZlcmxhcCkNCiAgICAgIHNwZWNpYWxEYXRhID0gZ2x5cGgudHlwZSA9PT0gImVmZmFyaWciDQogICAgICAgID8gYCR7Y29sb3J9NjBgDQogICAgICAgIDogY29sb3I7DQogICAgICBjZW50ZXJzID0gWyI1MCUgLTI1JSIsICI1MCUgMTI1JSIsICItMjUlIDUwJSIsICIxMjUlIDUwJSJdOw0KICAgICAgc2NhbGVGbiA9IHBlcmMgPT4gKGlzQ2lyY3VsYXIgPyBwZXJjIDogMC45ICogcGVyYyk7DQogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykgew0KICAgICAgICBlbnRyaWVzLnB1c2goYHJhZGlhbC1ncmFkaWVudChhdCAke2NlbnRlcnNbaV19LCB0cmFuc3BhcmVudCwgJHtzcGVjaWFsRGF0YX0gJHtzY2FsZUZuKGRhdGEuY29sb3JTcGxpdFswXSl9JSwNCiAgICAgICAgICB0cmFuc3BhcmVudCAke3NjYWxlRm4oZGF0YS5jb2xvclNwbGl0WzFdKX0lKWApOw0KICAgICAgfQ0KICAgICAgcmV0dXJuIGVudHJpZXMuam9pbigiLCIpOw0KICAgIGNhc2UgInJhZGlhbCI6DQogICAgICAvLyBQcm9kdWNlcyBhIGNlbnRlcmVkIGNpcmNsZSB0aGF0IG9ubHkgc2hhZGVzIHdpdGhpbiBhIGNlcnRhaW4gcmFkaWFsIGRpc3RhbmNlDQogICAgICBib3JkZXJzID0gWzUwLCAuLi5kYXRhLmNvbG9yU3BsaXQsIDEwMF07DQogICAgICBzY2FsZUZuID0gcGVyYyA9PiAoaXNDaXJjdWxhciA/IDAuOSAqIHBlcmMgOiAxMDAgLSAoMTAwIC0gcGVyYykgLyAyKTsNCiAgICAgIGZvciAoY29uc3QgYm9yZGVyIG9mIGJvcmRlcnMpIHsNCiAgICAgICAgZW50cmllcy5wdXNoKGAke2lzQ29sb3IgPyBjb2xvciA6ICJ0cmFuc3BhcmVudCJ9ICR7c2NhbGVGbihib3JkZXIpfSVgKTsNCiAgICAgICAgaXNDb2xvciA9ICFpc0NvbG9yOw0KICAgICAgfQ0KICAgICAgcmV0dXJuIGByYWRpYWwtZ3JhZGllbnQoJHtlbnRyaWVzLmpvaW4oIiwiKX0pYDsNCiAgICBjYXNlICJzcGlrZSI6DQogICAgICAvLyBQcm9kdWNlcyBhIHNpbmdsZSBzcGlrZSBhdCB0aGUgc3BlY2lmaWVkIGNlbnRlciwgc3Bhbm5pbmcgYmV0d2VlbiB0aGUgc3BlY2lmaWVkIGFuZ2xlcyB3aXRoIDVkZWcgYmx1cg0KICAgICAgZW50cmllcy5wdXNoKGB0cmFuc3BhcmVudCAke2RhdGEuYW5nbGVzWzBdIC0gNX1kZWdgKTsNCiAgICAgIGVudHJpZXMucHVzaChgJHtjb2xvcn1iMCAke2RhdGEuYW5nbGVzWzBdICsgNX1kZWdgKTsNCiAgICAgIGVudHJpZXMucHVzaChgJHtjb2xvcn1iMCAke2RhdGEuYW5nbGVzWzFdIC0gNX1kZWdgKTsNCiAgICAgIGVudHJpZXMucHVzaChgdHJhbnNwYXJlbnQgJHtkYXRhLmFuZ2xlc1sxXSArIDV9ZGVnYCk7DQogICAgICByZXR1cm4gYGNvbmljLWdyYWRpZW50KGZyb20gMGRlZyBhdCAke2RhdGEuY2VudGVyWzBdfSUgJHtkYXRhLmNlbnRlclsxXX0lLCAke2VudHJpZXMuam9pbigiLCIpfSlgOw0KICAgIGNhc2UgImNvbXBhbmlvbiI6DQogICAgICAvLyBTcGVjaWFsIGNhc2UgdG8gbWFrZSB0aGUgY29tcGFuaW9uIGJvcmRlciBsb29rIGxpa2UgYSBoZWFydA0KICAgICAgYm9yZGVycyA9IFswLCAzMCwgMzMwLCAzNjBdOw0KICAgICAgc3BlY2lhbERhdGEgPSBbY29sb3IsICJ0cmFuc3BhcmVudCIsICJ0cmFuc3BhcmVudCIsIGNvbG9yXTsNCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7DQogICAgICAgIGVudHJpZXMucHVzaChgJHtzcGVjaWFsRGF0YVtpXX0gJHtib3JkZXJzW2ldfWRlZ2ApOw0KICAgICAgfQ0KICAgICAgZWxlbWVudHMucHVzaChgY29uaWMtZ3JhZGllbnQoJHtlbnRyaWVzLmpvaW4oIiwiKX0pYCk7DQoNCiAgICAgIGNlbnRlcnMgPSBbIjEyNSUgMTI1JSIsICItMjUlIDEyNSUiXTsNCiAgICAgIHNjYWxlRm4gPSBwZXJjID0+IChpc0NpcmN1bGFyID8gMC45ICogKHBlcmMgKyAxMCkgOiBwZXJjKTsNCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjsgaSsrKSB7DQogICAgICAgIGVsZW1lbnRzLnB1c2goYHJhZGlhbC1ncmFkaWVudChhdCAke2NlbnRlcnNbaV19LCB0cmFuc3BhcmVudCwgJHtjb2xvcn0gJHtzY2FsZUZuKDMwKX0lLA0KICAgICAgICAgIHRyYW5zcGFyZW50ICR7c2NhbGVGbig1MCl9JSlgKTsNCiAgICAgIH0NCiAgICAgIHJldHVybiBlbGVtZW50cy5qb2luKCIsIik7DQogICAgZGVmYXVsdDoNCiAgICAgIHRocm93IG5ldyBFcnJvcigiVW5yZWNvZ25pemVkIGdseXBoIGJvcmRlciBkYXRhIik7DQogIH0NCn0NCg0KZXhwb3J0IGRlZmF1bHQgew0KICBuYW1lOiAiR2x5cGhDb21wb25lbnQiLA0KICBjb21wb25lbnRzOiB7DQogICAgR2x5cGhUb29sdGlwDQogIH0sDQogIHByb3BzOiB7DQogICAgZ2x5cGg6IHsNCiAgICAgIHR5cGU6IE9iamVjdCwNCiAgICAgIHJlcXVpcmVkOiB0cnVlDQogICAgfSwNCiAgICBpc0luTW9kYWw6IHsNCiAgICAgIHR5cGU6IEJvb2xlYW4sDQogICAgICByZXF1aXJlZDogZmFsc2UsDQogICAgICBkZWZhdWx0OiBmYWxzZQ0KICAgIH0sDQogICAgaXNOZXc6IHsNCiAgICAgIHR5cGU6IEJvb2xlYW4sDQogICAgICByZXF1aXJlZDogZmFsc2UsDQogICAgICBkZWZhdWx0OiBmYWxzZQ0KICAgIH0sDQogICAgaXNVbmVxdWlwcGVkOiB7DQogICAgICB0eXBlOiBCb29sZWFuLA0KICAgICAgcmVxdWlyZWQ6IGZhbHNlLA0KICAgICAgZGVmYXVsdDogZmFsc2UNCiAgICB9LA0KICAgIHNob3dTYWNyaWZpY2U6IHsNCiAgICAgIHR5cGU6IEJvb2xlYW4sDQogICAgICByZXF1aXJlZDogZmFsc2UsDQogICAgICBkZWZhdWx0OiBmYWxzZQ0KICAgIH0sDQogICAgaWdub3JlTW9kaWZpZWRMZXZlbDogew0KICAgICAgdHlwZTogQm9vbGVhbiwNCiAgICAgIHJlcXVpcmVkOiBmYWxzZSwNCiAgICAgIGRlZmF1bHQ6IGZhbHNlDQogICAgfSwNCiAgICByZWFsaXR5R2x5cGhCb29zdDogew0KICAgICAgdHlwZTogTnVtYmVyLA0KICAgICAgcmVxdWlyZWQ6IGZhbHNlLA0KICAgICAgZGVmYXVsdDogMA0KICAgIH0sDQogICAgaXNJbnZlbnRvcnlHbHlwaDogew0KICAgICAgdHlwZTogQm9vbGVhbiwNCiAgICAgIHJlcXVpcmVkOiBmYWxzZSwNCiAgICAgIGRlZmF1bHQ6IGZhbHNlDQogICAgfSwNCiAgICBpc0FjdGl2ZUdseXBoOiB7DQogICAgICB0eXBlOiBCb29sZWFuLA0KICAgICAgcmVxdWlyZWQ6IGZhbHNlLA0KICAgICAgZGVmYXVsdDogZmFsc2UNCiAgICB9LA0KICAgIHNpemU6IHsNCiAgICAgIHR5cGU6IFN0cmluZywNCiAgICAgIHJlcXVpcmVkOiBmYWxzZSwNCiAgICAgIGRlZmF1bHQ6ICI1cmVtIiwNCiAgICB9LA0KICAgIGdsb3dCbHVyOiB7DQogICAgICB0eXBlOiBTdHJpbmcsDQogICAgICByZXF1aXJlZDogZmFsc2UsDQogICAgICBkZWZhdWx0OiAiMXJlbSINCiAgICB9LA0KICAgIGdsb3dTcHJlYWQ6IHsNCiAgICAgIHR5cGU6IFN0cmluZywNCiAgICAgIHJlcXVpcmVkOiBmYWxzZSwNCiAgICAgIGRlZmF1bHQ6ICIwLjJyZW0iDQogICAgfSwNCiAgICBib3R0b21QYWRkaW5nOiB7DQogICAgICB0eXBlOiBTdHJpbmcsDQogICAgICByZXF1aXJlZDogZmFsc2UsDQogICAgICBkZWZhdWx0OiAiMC4zcmVtIg0KICAgIH0sDQogICAgdGV4dFByb3BvcnRpb246IHsNCiAgICAgIHR5cGU6IE51bWJlciwNCiAgICAgIHJlcXVpcmVkOiBmYWxzZSwNCiAgICAgIGRlZmF1bHQ6IDAuNQ0KICAgIH0sDQogICAgY2lyY3VsYXI6IHsNCiAgICAgIHR5cGU6IEJvb2xlYW4sDQogICAgICByZXF1aXJlZDogZmFsc2UsDQogICAgICBkZWZhdWx0OiBmYWxzZSwNCiAgICB9LA0KICAgIGRyYWdnYWJsZTogew0KICAgICAgdHlwZTogQm9vbGVhbiwNCiAgICAgIHJlcXVpcmVkOiBmYWxzZSwNCiAgICAgIGRlZmF1bHQ6IGZhbHNlLA0KICAgIH0sDQogICAgZmxpcFRvb2x0aXA6IHsNCiAgICAgIHR5cGU6IEJvb2xlYW4sDQogICAgICByZXF1aXJlZDogZmFsc2UsDQogICAgICBkZWZhdWx0OiBmYWxzZSwNCiAgICB9DQogIH0sDQogIGRhdGEoKSB7DQogICAgcmV0dXJuIHsNCiAgICAgIGNvbXBvbmVudElEOiBVSUlELm5leHQoKSwNCiAgICAgIGlzRHJhZ2dpbmc6IGZhbHNlLA0KICAgICAgLy8gVGhpcyBmbGFnIGlzIHVzZWQgdG8gcHJldmVudCB0aGUgdG9vbHRpcCBmcm9tIGJlaW5nIHNob3duIGluIHNvbWUgdG91Y2ggZXZlbnQgc2VxdWVuY2VzDQogICAgICBzdXBwcmVzc1Rvb2x0aXA6IGZhbHNlLA0KICAgICAgaXNUb3VjaGVkOiBmYWxzZSwNCiAgICAgIHRvb2x0aXBFbmFibGVkOiBmYWxzZSwNCiAgICAgIHNhY3JpZmljZVJld2FyZDogMCwNCiAgICAgIHVuY2FwcGVkUmVmaW5lUmV3YXJkOiAwLA0KICAgICAgcmVmaW5lUmV3YXJkOiAwLA0KICAgICAgZGlzcGxheUxldmVsOiAwLA0KICAgICAgLy8gV2UgdXNlIHRoaXMgdG8gbm90IGNyZWF0ZSBhIHRvbiBvZiB0b29sdGlwIGNvbXBvbmVudHMgYXMgc29vbiBhcyB0aGUgZ2x5cGggdGFiIGxvYWRzLg0KICAgICAgdG9vbHRpcExvYWRlZDogZmFsc2UsDQogICAgICBsb2dUb3RhbFNhY3JpZmljZTogMCwNCiAgICAgIHJlYWxpdHlDb2xvcjogIiIsDQogICAgfTsNCiAgfSwNCiAgY29tcHV0ZWQ6IHsNCiAgICBoYXNUb29sdGlwKCkgew0KICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5nbHlwaC5lZmZlY3RzKTsNCiAgICB9LA0KICAgIHR5cGVDb25maWcoKSB7DQogICAgICByZXR1cm4gR2x5cGhUeXBlc1t0aGlzLmdseXBoLnR5cGVdOw0KICAgIH0sDQogICAgY29zbWV0aWNDb25maWcoKSB7DQogICAgICByZXR1cm4gQ29zbWV0aWNHbHlwaFR5cGVzW3RoaXMuZ2x5cGguY29zbWV0aWMgPz8gdGhpcy5nbHlwaC50eXBlXTsNCiAgICB9LA0KICAgIGlzQmxvYkhlYXJ0KCkgew0KICAgICAgcmV0dXJuIHRoaXMuJHZpZXdNb2RlbC50aGVtZSA9PT0gIlMxMSIgJiYgdGhpcy5nbHlwaC50eXBlID09PSAiY29tcGFuaW9uIjsNCiAgICB9LA0KICAgIHN5bWJvbCgpIHsNCiAgICAgIGNvbnN0IHN5bWJvbCA9IHRoaXMuZ2x5cGguc3ltYm9sOw0KICAgICAgLy8gXHVFMDE5ID0gOmJsb2JoZWFydDoNCiAgICAgIGlmICh0aGlzLmlzQmxvYkhlYXJ0KSByZXR1cm4gIlx1RTAxOSI7DQogICAgICBpZiAoc3ltYm9sKSByZXR1cm4gc3ltYm9sOw0KICAgICAgcmV0dXJuICh0aGlzLiR2aWV3TW9kZWwudGhlbWUgPT09ICJTNCIgJiYgIXRoaXMuZ2x5cGguY29zbWV0aWMpDQogICAgICAgID8gQ0FOQ0VSX0dMWVBIX1NZTUJPTFNbdGhpcy5nbHlwaC50eXBlXQ0KICAgICAgICA6IHRoaXMuY29zbWV0aWNDb25maWcuY3VycmVudFN5bWJvbC5zeW1ib2w7DQogICAgfSwNCiAgICBzeW1ib2xCbHVyKCkgew0KICAgICAgaWYgKHRoaXMuaXNCbG9iSGVhcnQpIHJldHVybiBmYWxzZTsNCiAgICAgIGlmICghdGhpcy5nbHlwaC5zeW1ib2wpIHJldHVybiB0aGlzLmNvc21ldGljQ29uZmlnLmN1cnJlbnRTeW1ib2wuYmx1cjsNCiAgICAgIHJldHVybiAhR2x5cGhBcHBlYXJhbmNlSGFuZGxlci51bmJsdXJyZWRTeW1ib2xzLmluY2x1ZGVzKHRoaXMuc3ltYm9sKTsNCiAgICB9LA0KICAgIHpJbmRleFN0eWxlKCkgew0KICAgICAgcmV0dXJuIHsgInotaW5kZXgiOiB0aGlzLmlzSW5Nb2RhbCA/IDcgOiA2IH07DQogICAgfSwNCiAgICBjb2xvck9iaigpIHsNCiAgICAgIGxldCBvdmVycmlkZUNvbG9yOw0KICAgICAgaWYgKHRoaXMuZ2x5cGguY29sb3IpIG92ZXJyaWRlQ29sb3IgPSBHbHlwaEFwcGVhcmFuY2VIYW5kbGVyLmdldENvbG9yUHJvcHModGhpcy5nbHlwaC5jb2xvcik7DQogICAgICBpZiAodGhpcy5nbHlwaC5jb3NtZXRpYykgew0KICAgICAgICBpZiAodGhpcy5nbHlwaC5jb3NtZXRpYyA9PT0gdGhpcy5nbHlwaC50eXBlKSB7DQogICAgICAgICAgb3ZlcnJpZGVDb2xvciA9IHRoaXMuZ2x5cGgudHlwZSA9PT0gImN1cnNlZCINCiAgICAgICAgICAgID8gR2x5cGhBcHBlYXJhbmNlSGFuZGxlci5nZXRCYXNlQ29sb3IodHJ1ZSkNCiAgICAgICAgICAgIDogdGhpcy5jb3NtZXRpY0NvbmZpZy5jdXJyZW50Q29sb3I7DQogICAgICAgIH0gZWxzZSB7DQogICAgICAgICAgb3ZlcnJpZGVDb2xvciA9IHRoaXMuY29zbWV0aWNDb25maWcuY3VycmVudENvbG9yOw0KICAgICAgICB9DQogICAgICB9DQoNCiAgICAgIGxldCBzeW1ib2xDb2xvcjsNCiAgICAgIGlmICh0aGlzLmlzUmVhbGl0eUdseXBoICYmIHRoaXMucmVhbGl0eUNvbG9yKSBzeW1ib2xDb2xvciA9IHRoaXMucmVhbGl0eUNvbG9yOw0KICAgICAgZWxzZSB7DQogICAgICAgIHN5bWJvbENvbG9yID0gdGhpcy5jb3NtZXRpY0NvbmZpZy5pZ25vcmVSYXJpdHlDb2xvcg0KICAgICAgICAgID8gR2x5cGhBcHBlYXJhbmNlSGFuZGxlci5nZXRCb3JkZXJDb2xvcih0aGlzLmdseXBoLnR5cGUpDQogICAgICAgICAgOiBHbHlwaEFwcGVhcmFuY2VIYW5kbGVyLmdldFJhcml0eUNvbG9yKHRoaXMuZ2x5cGguc3RyZW5ndGgsIHRoaXMuZ2x5cGgudHlwZSk7DQogICAgICB9DQoNCiAgICAgIHJldHVybiB7DQogICAgICAgIGJvcmRlcjogb3ZlcnJpZGVDb2xvcj8uYm9yZGVyID8/IEdseXBoQXBwZWFyYW5jZUhhbmRsZXIuZ2V0Qm9yZGVyQ29sb3IodGhpcy5nbHlwaC50eXBlKSwNCiAgICAgICAgc3ltYm9sOiBvdmVycmlkZUNvbG9yPy5ib3JkZXIgPz8gc3ltYm9sQ29sb3IsDQogICAgICAgIGJnOiBvdmVycmlkZUNvbG9yPy5iZyA/PyB0aGlzLmNvc21ldGljQ29uZmlnLmN1cnJlbnRDb2xvci5iZw0KICAgICAgfTsNCiAgICB9LA0KICAgIHN5bWJvbENvbG9yKCkgew0KICAgICAgcmV0dXJuIHBsYXllci5vcHRpb25zLnN3YXBHbHlwaENvbG9ycyA/IHRoaXMuY29sb3JPYmouYm9yZGVyIDogdGhpcy5jb2xvck9iai5zeW1ib2w7DQogICAgfSwNCiAgICBib3JkZXJDb2xvcigpIHsNCiAgICAgIHJldHVybiBwbGF5ZXIub3B0aW9ucy5zd2FwR2x5cGhDb2xvcnMgPyB0aGlzLmNvbG9yT2JqLnN5bWJvbCA6IHRoaXMuY29sb3JPYmouYm9yZGVyOw0KICAgIH0sDQogICAgYmdDb2xvcigpIHsNCiAgICAgIHJldHVybiB0aGlzLmNvbG9yT2JqLmJnOw0KICAgIH0sDQogICAgb3ZlclN0eWxlKCkgew0KICAgICAgcmV0dXJuIHsNCiAgICAgICAgd2lkdGg6IHRoaXMuc2l6ZSwNCiAgICAgICAgaGVpZ2h0OiB0aGlzLnNpemUsDQogICAgICAgIHBvc2l0aW9uOiAiYWJzb2x1dGUiLA0KICAgICAgICAiYmFja2dyb3VuZC1jb2xvciI6ICJyZ2JhKDAsIDAsIDAsIDApIiwNCiAgICAgICAgImJveC1zaGFkb3ciOiBgMCAwICR7dGhpcy5nbG93Qmx1cn0gY2FsYygke3RoaXMuZ2xvd1NwcmVhZH0gKyAwLjFyZW0pICR7dGhpcy5ib3JkZXJDb2xvcn0gaW5zZXRgLA0KICAgICAgICAiYm9yZGVyLXJhZGl1cyI6IHRoaXMuY2lyY3VsYXIgPyAiNTAlIiA6ICIwIiwNCiAgICAgIH07DQogICAgfSwNCiAgICBvdXRlclN0eWxlKCkgew0KICAgICAgcmV0dXJuIHsNCiAgICAgICAgd2lkdGg6IHRoaXMuc2l6ZSwNCiAgICAgICAgaGVpZ2h0OiB0aGlzLnNpemUsDQogICAgICAgICJiYWNrZ3JvdW5kLWNvbG9yIjogdGhpcy5ib3JkZXJDb2xvciwNCiAgICAgICAgImJveC1zaGFkb3ciOiBgMCAwICR7dGhpcy5nbG93Qmx1cn0gJHt0aGlzLmdsb3dTcHJlYWR9ICR7dGhpcy5ib3JkZXJDb2xvcn1gLA0KICAgICAgICAiYm9yZGVyLXJhZGl1cyI6IHRoaXMuY2lyY3VsYXIgPyAiNTAlIiA6ICIwIiwNCiAgICAgICAgIi13ZWJraXQtdXNlci1kcmFnIjogdGhpcy5kcmFnZ2FibGUgPyAiIiA6ICJub25lIg0KICAgICAgfTsNCiAgICB9LA0KICAgIGlubmVyU3R5bGUoKSB7DQogICAgICBjb25zdCBjb2xvciA9IHRoaXMuc3ltYm9sQ29sb3I7DQogICAgICByZXR1cm4gew0KICAgICAgICB3aWR0aDogYGNhbGMoJHt0aGlzLnNpemV9IC0gMC4ycmVtKWAsDQogICAgICAgIGhlaWdodDogYGNhbGMoJHt0aGlzLnNpemV9IC0gMC4ycmVtKWAsDQogICAgICAgICJmb250LXNpemUiOiBgY2FsYyggJHt0aGlzLnNpemV9ICogJHt0aGlzLnRleHRQcm9wb3J0aW9ufSApYCwNCiAgICAgICAgY29sb3IsDQogICAgICAgICJ0ZXh0LXNoYWRvdyI6IHRoaXMuc3ltYm9sQmx1ciA/IGAtMC4wNGVtIDAuMDRlbSAwLjA4ZW0gJHtjb2xvcn1gIDogdW5kZWZpbmVkLA0KICAgICAgICAiYm9yZGVyLXJhZGl1cyI6IHRoaXMuY2lyY3VsYXIgPyAiNTAlIiA6ICIwIiwNCiAgICAgICAgInBhZGRpbmctYm90dG9tIjogdGhpcy5ib3R0b21QYWRkaW5nLA0KICAgICAgICBiYWNrZ3JvdW5kOiB0aGlzLmJnQ29sb3INCiAgICAgIH07DQogICAgfSwNCiAgICBtb3VzZUV2ZW50SGFuZGxlcnMoKSB7DQogICAgICBjb25zdCBoYW5kbGVycyA9IHRoaXMuaGFzVG9vbHRpcCA/IHsNCiAgICAgICAgbW91c2VlbnRlcjogdGhpcy5tb3VzZUVudGVyLA0KICAgICAgICAiJm1vdXNlbW92ZSI6IHRoaXMubW91c2VNb3ZlLA0KICAgICAgICBtb3VzZWxlYXZlOiB0aGlzLm1vdXNlTGVhdmUsDQogICAgICAgIG1vdXNlZG93bjogdGhpcy5tb3VzZURvd24sDQogICAgICAgIHRvdWNoc3RhcnQ6IHRoaXMudG91Y2hTdGFydCwNCiAgICAgICAgdG91Y2hlbmQ6IHRoaXMudG91Y2hFbmQNCiAgICAgIH0gOiB7fTsNCiAgICAgIGlmICh0aGlzLmhhc1Rvb2x0aXAgfHwgdGhpcy5kcmFnZ2FibGUpIHsNCiAgICAgICAgaGFuZGxlcnMudG91Y2htb3ZlID0gdGhpcy50b3VjaE1vdmU7DQogICAgICB9DQogICAgICByZXR1cm4gaGFuZGxlcnM7DQogICAgfSwNCiAgICBpc0N1cnJlbnRUb29sdGlwKCkgew0KICAgICAgcmV0dXJuIHRoaXMuJHZpZXdNb2RlbC50YWJzLnJlYWxpdHkuY3VycmVudEdseXBoVG9vbHRpcCA9PT0gdGhpcy5jb21wb25lbnRJRDsNCiAgICB9LA0KICAgIHRvb2x0aXBEaXJlY3Rpb25DbGFzcygpIHsNCiAgICAgIGxldCBkaXJlY3Rpb25JRCA9IHRoaXMuJHZpZXdNb2RlbC50YWJzLnJlYWxpdHkuZ2x5cGhUb29sdGlwRGlyZWN0aW9uOw0KICAgICAgaWYgKHRoaXMuZmxpcFRvb2x0aXApIGRpcmVjdGlvbklEICs9IDE7DQogICAgICBzd2l0Y2ggKGRpcmVjdGlvbklEKSB7DQogICAgICAgIGNhc2UgLTE6DQogICAgICAgICAgcmV0dXJuICJsLWdseXBoLXRvb2x0aXAtLWRvd24tbGVmdCI7DQogICAgICAgIGNhc2UgMDoNCiAgICAgICAgICByZXR1cm4gImwtZ2x5cGgtdG9vbHRpcC0tZG93bi1yaWdodCI7DQogICAgICAgIGNhc2UgMToNCiAgICAgICAgICByZXR1cm4gImwtZ2x5cGgtdG9vbHRpcC0tdXAtbGVmdCI7DQogICAgICAgIGNhc2UgMjoNCiAgICAgICAgICByZXR1cm4gImwtZ2x5cGgtdG9vbHRpcC0tdXAtcmlnaHQiOw0KICAgICAgICBkZWZhdWx0Og0KICAgICAgICAgIHJldHVybiAiIjsNCiAgICAgIH0NCiAgICB9LA0KICAgIC8vIFRoaXMgZmluZHMgYWxsIHRoZSBlZmZlY3RzIG9mIGEgZ2x5cGggYW5kIHNoaWZ0cyBhbGwgdGhlaXIgSURzIHNvIHRoYXQgdHlwZSdzIGxvd2VzdC1JRCBlZmZlY3QgaXMgMCBhbmQgYWxsDQogICAgLy8gb3RoZXIgZWZmZWN0cyBjb3VudCB1cCB0byAzIChvciA2IGZvciBlZmZhcmlnKS4gVXNlZCB0byBhZGQgZG90cyBpbiB1bmlxdWUgcG9zaXRpb25zIG9uIGdseXBocyB0byBzaG93IGVmZmVjdHMuDQogICAgZ2x5cGhFZmZlY3RzKCkgew0KICAgICAgbGV0IG1pbkVmZmVjdElEID0gMDsNCiAgICAgIHN3aXRjaCAodGhpcy5nbHlwaC50eXBlKSB7DQogICAgICAgIGNhc2UgInRpbWUiOg0KICAgICAgICBjYXNlICJjdXJzZWQiOg0KICAgICAgICBjYXNlICJjb21wYW5pb24iOg0KICAgICAgICAgIG1pbkVmZmVjdElEID0gMDsNCiAgICAgICAgICBicmVhazsNCiAgICAgICAgY2FzZSAiZGlsYXRpb24iOg0KICAgICAgICBjYXNlICJyZWFsaXR5IjoNCiAgICAgICAgICBtaW5FZmZlY3RJRCA9IDQ7DQogICAgICAgICAgYnJlYWs7DQogICAgICAgIGNhc2UgInJlcGxpY2F0aW9uIjoNCiAgICAgICAgICBtaW5FZmZlY3RJRCA9IDg7DQogICAgICAgICAgYnJlYWs7DQogICAgICAgIGNhc2UgImluZmluaXR5IjoNCiAgICAgICAgICBtaW5FZmZlY3RJRCA9IDEyOw0KICAgICAgICAgIGJyZWFrOw0KICAgICAgICBjYXNlICJwb3dlciI6DQogICAgICAgICAgbWluRWZmZWN0SUQgPSAxNjsNCiAgICAgICAgICBicmVhazsNCiAgICAgICAgY2FzZSAiZWZmYXJpZyI6DQogICAgICAgICAgbWluRWZmZWN0SUQgPSAyMDsNCiAgICAgICAgICBicmVhazsNCiAgICAgICAgZGVmYXVsdDoNCiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBnbHlwaCB0eXBlICIke3RoaXMuZ2x5cGgudHlwZX0iIGluIGdseXBoIGVmZmVjdCBpY29uc2ApOw0KICAgICAgfQ0KICAgICAgY29uc3QgZWZmZWN0SURzID0gW107DQogICAgICBsZXQgcmVtYWluaW5nRWZmZWN0cyA9IHRoaXMuZ2x5cGguZWZmZWN0cyA+PiBtaW5FZmZlY3RJRDsNCiAgICAgIGZvciAobGV0IGlkID0gMDsgcmVtYWluaW5nRWZmZWN0cyA+IDA7IGlkKyspIHsNCiAgICAgICAgaWYgKChyZW1haW5pbmdFZmZlY3RzICYgMSkgPT09IDEpIGVmZmVjdElEcy5wdXNoKGlkKTsNCiAgICAgICAgcmVtYWluaW5nRWZmZWN0cyA+Pj0gMTsNCiAgICAgIH0NCiAgICAgIHJldHVybiBlZmZlY3RJRHM7DQogICAgfSwNCiAgICBpc1JlYWxpdHlHbHlwaCgpIHsNCiAgICAgIHJldHVybiB0aGlzLmdseXBoLnR5cGUgPT09ICJyZWFsaXR5IjsNCiAgICB9LA0KICAgIGlzQ3Vyc2VkR2x5cGgoKSB7DQogICAgICByZXR1cm4gdGhpcy5nbHlwaC50eXBlID09PSAiY3Vyc2VkIjsNCiAgICB9LA0KICAgIGlzQ29tcGFuaW9uR2x5cGgoKSB7DQogICAgICByZXR1cm4gdGhpcy5nbHlwaC50eXBlID09PSAiY29tcGFuaW9uIjsNCiAgICB9LA0KICAgIHNob3dHbHlwaEVmZmVjdERvdHMoKSB7DQogICAgICByZXR1cm4gcGxheWVyLm9wdGlvbnMuc2hvd0hpbnRUZXh0LmdseXBoRWZmZWN0RG90czsNCiAgICB9LA0KICAgIGRpc3BsYXllZEluZm8oKSB7DQogICAgICBjb25zdCBibGFja2xpc3QgPSBbImNvbXBhbmlvbiIsICJjdXJzZWQiXTsNCiAgICAgIGlmICghdGhpcy5pc0ludmVudG9yeUdseXBoIHx8IGJsYWNrbGlzdC5pbmNsdWRlcyh0aGlzLmdseXBoLnR5cGUpKSByZXR1cm4gbnVsbDsNCg0KICAgICAgY29uc3Qgb3B0aW9ucyA9IHBsYXllci5vcHRpb25zLnNob3dIaW50VGV4dDsNCiAgICAgIGlmIChvcHRpb25zLmdseXBoSW5mb1R5cGUgPT09IEdseXBoSW5mby50eXBlcy5OT05FIHx8DQogICAgICAgICghb3B0aW9ucy5zaG93R2x5cGhJbmZvQnlEZWZhdWx0ICYmICF0aGlzLiR2aWV3TW9kZWwuc2hpZnREb3duKSkgew0KICAgICAgICByZXR1cm4gbnVsbDsNCiAgICAgIH0NCg0KICAgICAgY29uc3QgdHlwZUVudW0gPSBHbHlwaEluZm8udHlwZXM7DQogICAgICBzd2l0Y2ggKG9wdGlvbnMuZ2x5cGhJbmZvVHlwZSkgew0KICAgICAgICBjYXNlIHR5cGVFbnVtLkxFVkVMOg0KICAgICAgICAgIHRoaXMudXBkYXRlRGlzcGxheUxldmVsKCk7DQogICAgICAgICAgcmV0dXJuIGZvcm1hdEludCh0aGlzLmRpc3BsYXlMZXZlbCA9PT0gMCA/IHRoaXMuZ2x5cGgubGV2ZWwgOiB0aGlzLmRpc3BsYXlMZXZlbCk7DQogICAgICAgIGNhc2UgdHlwZUVudW0uUkFSSVRZOg0KICAgICAgICAgIHJldHVybiBmb3JtYXRSYXJpdHkoc3RyZW5ndGhUb1Jhcml0eShQZWxsZS5pc0Rvb21lZCA/IFBlbGxlLmdseXBoU3RyZW5ndGggOiB0aGlzLmdseXBoLnN0cmVuZ3RoKSk7DQogICAgICAgIGNhc2UgdHlwZUVudW0uU0FDX1ZBTFVFOg0KICAgICAgICAgIHJldHVybiBmb3JtYXQodGhpcy5zYWNyaWZpY2VSZXdhcmQsIDIsIDIpOw0KICAgICAgICBjYXNlIHR5cGVFbnVtLkZJTFRFUl9TQ09SRToNCiAgICAgICAgICByZXR1cm4gZm9ybWF0KEF1dG9HbHlwaFByb2Nlc3Nvci5maWx0ZXJWYWx1ZSh0aGlzLmdseXBoKSwgMSwgMSk7DQogICAgICAgIGNhc2UgdHlwZUVudW0uQ1VSUkVOVF9SRUZJTkU6DQogICAgICAgICAgcmV0dXJuIGAke2Zvcm1hdCh0aGlzLnJlZmluZVJld2FyZCwgMiwgMil9ICR7dGhpcy5zeW1ib2x9YDsNCiAgICAgICAgY2FzZSB0eXBlRW51bS5NQVhfUkVGSU5FOg0KICAgICAgICAgIHJldHVybiBgJHtmb3JtYXQodGhpcy51bmNhcHBlZFJlZmluZVJld2FyZCwgMiwgMil9ICR7dGhpcy5zeW1ib2x9YDsNCiAgICAgICAgZGVmYXVsdDoNCiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIlVucmVjb2duaXplZCBHbHlwaCBpbmZvIHR5cGUgaW4gaW5mbyB0ZXh0Iik7DQogICAgICB9DQogICAgfSwNCiAgICBzaG93Qm9yZGVycygpIHsNCiAgICAgIHJldHVybiBwbGF5ZXIub3B0aW9ucy5nbHlwaEJvcmRlcnM7DQogICAgfQ0KICB9LA0KICB3YXRjaDogew0KICAgIGxvZ1RvdGFsU2FjcmlmaWNlKCkgew0KICAgICAgdGhpcy50b29sdGlwTG9hZGVkID0gZmFsc2U7DQogICAgICBpZiAodGhpcy5pc0N1cnJlbnRUb29sdGlwKSB0aGlzLnNob3dUb29sdGlwKCk7DQogICAgfQ0KICB9LA0KICBjcmVhdGVkKCkgew0KICAgIHRoaXMub24kKEdBTUVfRVZFTlQuR0xZUEhfVklTVUFMX0NIQU5HRSwgKCkgPT4gew0KICAgICAgdGhpcy4kcmVjb21wdXRlKCJ0eXBlQ29uZmlnIik7DQogICAgICB0aGlzLiRyZWNvbXB1dGUoImNvc21ldGljQ29uZmlnIik7DQogICAgICB0aGlzLiRyZWNvbXB1dGUoImlubmVyU3R5bGUiKTsNCiAgICAgIHRoaXMuJHJlY29tcHV0ZSgib3ZlcnJpZGVDb2xvciIpOw0KICAgICAgdGhpcy4kcmVjb21wdXRlKCJzaG93R2x5cGhFZmZlY3REb3RzIik7DQogICAgICB0aGlzLiRyZWNvbXB1dGUoImRpc3BsYXllZEluZm8iKTsNCiAgICAgIHRoaXMuJHJlY29tcHV0ZSgic2hvd0JvcmRlcnMiKTsNCiAgICB9KTsNCiAgICB0aGlzLm9uJCgidG9vbHRpcC10b3VjaGVkIiwgKCkgPT4gdGhpcy5oaWRlVG9vbHRpcCgpKTsNCiAgICB0aGlzLm9uJChHQU1FX0VWRU5ULlRBQl9DSEFOR0VELCAoKSA9PiB0aGlzLmhpZGVUb29sdGlwKCkpOw0KDQogICAgLy8gVGhlcmUgYXJlIGEgZmV3IHNpdHVhdGlvbnMgd2hlcmUgYSB0b29sdGlwIGNvdWxkIGF0dGVtcHQgdG8gcmVuZGVyIGltbWVkaWF0ZWx5IHVwb24gY29tcG9uZW50IGNyZWF0aW9uLA0KICAgIC8vIHdoaWNoIGNhdXNlcyBpdCB0byBiZSBwbGFjZWQgaW4gYW4gb2RkICJkZWZhdWx0IiBjb3JuZXIgc3BvdCBkdWUgdG8gbW91c2UgcG9zaXRpb24gbm90IGJlaW5nIHNldCBwcm9wZXJseS4NCiAgICAvLyBUaGlzIGlzIGVzc2VudGlhbGx5IGEgaGFjayB0aGF0IGZvcmNlLXN1cHByZXNzZXMgdG9vbHRpcHMgZnJvbSBiZWluZyBzaG93biBpbiBzdHJhbmdlIHNwb3RzIGR1ZSB0byBvbi1sb2FkDQogICAgLy8gZXZlbnRzIGZpcmluZywgYnV0IGhhcyB0aGUgc2lkZSBlZmZlY3QgdGhhdCB0aGUgbW91c2UgbXVzdCBsZWF2ZSBhbmQgZW50ZXIgYW4gZWxlbWVudCB3aGljaCB3YXMgY3JlYXRlZA0KICAgIC8vIHVuZGVybmVhdGggaXQgaW4gb3JkZXIgdG8gbWFrZSB0aGUgdG9vbHRpcCBhcHBlYXINCiAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMudG9vbHRpcEVuYWJsZWQgPSB0cnVlLCAxMCk7DQogIH0sDQogIGJlZm9yZURlc3Ryb3koKSB7DQogICAgaWYgKHRoaXMuaXNDdXJyZW50VG9vbHRpcCkgdGhpcy5oaWRlVG9vbHRpcCgpOw0KICAgIGlmICh0aGlzLiR2aWV3TW9kZWwuZHJhZ2dpbmdVSUlEID09PSB0aGlzLmNvbXBvbmVudElEKSB0aGlzLiR2aWV3TW9kZWwuZHJhZ2dpbmdVSUlEID0gLTE7DQogIH0sDQogIG1ldGhvZHM6IHsNCiAgICB1cGRhdGUoKSB7DQogICAgICB0aGlzLmxvZ1RvdGFsU2FjcmlmaWNlID0gR2FtZUNhY2hlLmxvZ1RvdGFsR2x5cGhTYWNyaWZpY2UudmFsdWU7DQogICAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIHJlYWN0aXZlIGluIG9yZGVyIHRvIGFuaW1hdGUgd2hpbGUgdXNpbmcgb3VyIGxvdy1sYWcgd29ya2Fyb3VuZCwgYnV0IHdlIGFsc28gbmVlZCB0byBtYWtlDQogICAgICAvLyBzdXJlIGl0IG9ubHkgYW5pbWF0ZXMgd2hlbiB0aGF0IGNvbG9yIGlzIGFjdHVhbGx5IGFjdGl2ZQ0KICAgICAgdGhpcy5yZWFsaXR5Q29sb3IgPSBwbGF5ZXIucmVhbGl0eS5nbHlwaHMuY29zbWV0aWNzLmNvbG9yTWFwLnJlYWxpdHkNCiAgICAgICAgPyBudWxsDQogICAgICAgIDogR2x5cGhBcHBlYXJhbmNlSGFuZGxlci5yZWFsaXR5Q29sb3I7DQogICAgICB0aGlzLnNhY3JpZmljZVJld2FyZCA9IEdseXBoU2FjcmlmaWNlSGFuZGxlci5nbHlwaFNhY3JpZmljZUdhaW4odGhpcy5nbHlwaCk7DQogICAgICB0aGlzLnVuY2FwcGVkUmVmaW5lUmV3YXJkID0gQUxDSEVNWV9CQVNJQ19HTFlQSF9UWVBFUy5pbmNsdWRlcyh0aGlzLmdseXBoLnR5cGUpDQogICAgICAgID8gR2x5cGhTYWNyaWZpY2VIYW5kbGVyLmdseXBoUmF3UmVmaW5lbWVudEdhaW4odGhpcy5nbHlwaCkNCiAgICAgICAgOiAwOw0KICAgICAgdGhpcy5yZWZpbmVSZXdhcmQgPSBBTENIRU1ZX0JBU0lDX0dMWVBIX1RZUEVTLmluY2x1ZGVzKHRoaXMuZ2x5cGgudHlwZSkNCiAgICAgICAgPyBHbHlwaFNhY3JpZmljZUhhbmRsZXIuZ2x5cGhSZWZpbmVtZW50R2Fpbih0aGlzLmdseXBoKQ0KICAgICAgICA6IDA7DQogICAgICBpZiAodGhpcy50b29sdGlwTG9hZGVkKSB0aGlzLnVwZGF0ZURpc3BsYXlMZXZlbCgpOw0KICAgIH0sDQogICAgdXBkYXRlRGlzcGxheUxldmVsKCkgew0KICAgICAgaWYgKHRoaXMuaWdub3JlTW9kaWZpZWRMZXZlbCkgew0KICAgICAgICB0aGlzLmRpc3BsYXlMZXZlbCA9IDA7DQogICAgICAgIHJldHVybjsNCiAgICAgIH0NCiAgICAgIC8vIFdlIGhhdmUgdG8gY29uc2lkZXIgc29tZSBvZGQgaW50ZXJhY3Rpb25zIGluIG9yZGVyIHRvIHByb3Blcmx5IHNob3cgbGV2ZWwuIFRoZSBnZXRBZGp1c3RlZEdseXBoTGV2ZWwoKSBmdW5jdGlvbg0KICAgICAgLy8gcmV0dXJucyBhIG1vZGlmaWVkIGxldmVsIHVzaW5nIGNlbGVzdGlhbCBlZmZlY3RzIGFuZCByZWFsaXR5IGdseXBocyBiYXNlZCBvbiB0aGUgQ1VSUkVOVCBnYW1lIHN0YXRlLCBtZWFuaW5nDQogICAgICAvLyB0aGF0IGFwcGx5aW5nIHRoaXMgZ2xvYmFsbHkgd2lsbCBjYXVzZSBsb3RzIG9mIGdseXBocyB0byBzaG93IGFsdGVyZWQgbGV2ZWxzIGV2ZW4gaWYgdGhleSBzaG91bGRuJ3QuIFNvOg0KICAgICAgLy8gLSBBY3RpdmUgZ2x5cGhzIHNob3VsZCBhcHBseSBBTEwgYWRqdXN0ZWQgZWZmZWN0cyBiYXNlZCBvbiB0aGUgY3VycmVudCBnYW1lIHN0YXRlLCBzaW5jZSB0aGV5IGFyZSBndWFyYW50ZWVkDQogICAgICAvLyAgIHRvIGFsd2F5cyBiZSBhZmZlY3RlZCBieSB0aGVtIGFuZCB0aGlzIGlzIGV4YWN0bHkgdGhlIHB1cnBvc2Ugb2YgZ2V0QWRqdXN0ZWRHbHlwaExldmVsKCkgYXMtaXMNCiAgICAgIC8vIC0gSW52ZW50b3J5IGdseXBocyBzaG91bGQgc2hvdyB0aGUgc2FtZSBjdXJyZW50LXN0YXRlIGVmZmVjdHMgYXMgYWN0aXZlLCBidXQgaXQgc2hvdWxkIE5FVkVSIGFwcGx5IHJlYWxpdHkNCiAgICAgIC8vICAgZ2x5cGggYm9vc3RzLiBUaGlzIGFsbG93cyBmb3IgZWFzaWVyIGNvbXBhcmlzb24gd2hlbiBjZWxlc3RpYWwgZWZmZWN0cyBhcmUgY2hhbmdpbmcgYm90aCBhY3RpdmUgYW5kDQogICAgICAvLyAgIGludmVudG9yeSBnbHlwaHMsIGV2ZW4gdGhvdWdoIHN0cmljdGx5IHNwZWFraW5nIHRoZSBpbnZlbnRvcnkgb25lcyBzaG91bGRuJ3QgYmUgYWZmZWN0ZWQgdW50aWwgZXF1aXBwZWQNCiAgICAgIC8vIC0gQWxsIG90aGVyIGdseXBocyBzaG91bGQgbmV2ZXIgYXBwbHkgZWZmZWN0cyBmcm9tIHRoZSBjdXJyZW50IGdhbWUgc3RhdGUsIGFuZCBzaG91bGQgaW4gZmFjdCBvbmx5IGFwcGx5IHRoZQ0KICAgICAgLy8gICByZWFsaXR5IGdseXBoIGJvb3N0IGJhc2VkIG9uIHRoZSByZXN0IG9mIGl0cyBleGlzdGluZyBzZXQgKHdoaWNoIGlzIHBhc3NlZCBpbiB2aWEgcmVhbGl0eUdseXBoQm9vc3QpIGFuZA0KICAgICAgLy8gICBub3RoaW5nIGVsc2UuIFRoaXMgY2FzZSBhcHBsaWVzIHRvIGdseXBocyBhcHBlYXJpbmcgaW4gcHJlc2V0cywgcmVjb3JkcywgYW5kIHByZXZpZXdzLg0KICAgICAgaWYgKHRoaXMuaXNBY3RpdmVHbHlwaCkgdGhpcy5kaXNwbGF5TGV2ZWwgPSBnZXRBZGp1c3RlZEdseXBoTGV2ZWwodGhpcy5nbHlwaCk7DQogICAgICBlbHNlIGlmICh0aGlzLmlzSW52ZW50b3J5R2x5cGgpIHRoaXMuZGlzcGxheUxldmVsID0gZ2V0QWRqdXN0ZWRHbHlwaExldmVsKHRoaXMuZ2x5cGgsIDApOw0KICAgICAgZWxzZSB7DQogICAgICAgIHRoaXMuZGlzcGxheUxldmVsID0gdGhpcy5nbHlwaC5sZXZlbCArDQogICAgICAgICAgKEJBU0lDX0dMWVBIX1RZUEVTLmluY2x1ZGVzKHRoaXMuZ2x5cGgudHlwZSkgPyB0aGlzLnJlYWxpdHlHbHlwaEJvb3N0IDogMCk7DQogICAgICB9DQogICAgfSwNCiAgICBoaWRlVG9vbHRpcCgpIHsNCiAgICAgIHRoaXMudG9vbHRpcExvYWRlZCA9IGZhbHNlOw0KICAgICAgdGhpcy4kdmlld01vZGVsLnRhYnMucmVhbGl0eS5tb3VzZW92ZXJHbHlwaEluZm8udHlwZSA9ICIiOw0KICAgICAgdGhpcy4kdmlld01vZGVsLnRhYnMucmVhbGl0eS5tb3VzZW92ZXJHbHlwaEluZm8uaW5JbnZlbnRvcnkgPSBmYWxzZTsNCiAgICAgIHRoaXMuJHZpZXdNb2RlbC50YWJzLnJlYWxpdHkuY3VycmVudEdseXBoVG9vbHRpcCA9IC0xOw0KICAgIH0sDQogICAgc2hvd1Rvb2x0aXAoKSB7DQogICAgICBpZiAoIXRoaXMudG9vbHRpcEVuYWJsZWQpIHJldHVybjsNCiAgICAgIEdseXBocy5yZW1vdmVWaXN1YWxGbGFnKCJ1bnNlZW4iLCB0aGlzLmdseXBoKTsNCiAgICAgIEdseXBocy5yZW1vdmVWaXN1YWxGbGFnKCJ1bmVxdWlwcGVkIiwgdGhpcy5nbHlwaCk7DQogICAgICB0aGlzLnRvb2x0aXBMb2FkZWQgPSB0cnVlOw0KICAgICAgdGhpcy4kdmlld01vZGVsLnRhYnMucmVhbGl0eS5tb3VzZW92ZXJHbHlwaEluZm8uaW5JbnZlbnRvcnkgPSAhdGhpcy5jaXJjdWxhcjsNCiAgICAgIGNvbnN0IGdseXBoSW5mbyA9IHRoaXMuJHZpZXdNb2RlbC50YWJzLnJlYWxpdHkubW91c2VvdmVyR2x5cGhJbmZvOw0KICAgICAgZ2x5cGhJbmZvLnR5cGUgPSB0aGlzLmdseXBoLnR5cGU7DQogICAgICBnbHlwaEluZm8uc2FjcmlmaWNlVmFsdWUgPSBHbHlwaFNhY3JpZmljZUhhbmRsZXIuZ2x5cGhTYWNyaWZpY2VHYWluKHRoaXMuZ2x5cGgpOw0KICAgICAgZ2x5cGhJbmZvLnJlZmluZVZhbHVlID0gR2x5cGhTYWNyaWZpY2VIYW5kbGVyLmdseXBoUmF3UmVmaW5lbWVudEdhaW4odGhpcy5nbHlwaCk7DQogICAgICB0aGlzLiR2aWV3TW9kZWwudGFicy5yZWFsaXR5LmN1cnJlbnRHbHlwaFRvb2x0aXAgPSB0aGlzLmNvbXBvbmVudElEOw0KICAgICAgaWYgKA0KICAgICAgICBBdXRvR2x5cGhQcm9jZXNzb3Iuc2FjTW9kZSA9PT0gQVVUT19HTFlQSF9SRUpFQ1QuU0FDUklGSUNFIHx8DQogICAgICAgIChBdXRvR2x5cGhQcm9jZXNzb3Iuc2FjTW9kZSA9PT0gQVVUT19HTFlQSF9SRUpFQ1QuUkVGSU5FX1RPX0NBUCAmJiB0aGlzLnJlZmluZVJld2FyZCA9PT0gMCkNCiAgICAgICkgew0KICAgICAgICB0aGlzLmN1cnJlbnRBY3Rpb24gPSAic2FjcmlmaWNlIjsNCiAgICAgIH0gZWxzZSB7DQogICAgICAgIHRoaXMuY3VycmVudEFjdGlvbiA9ICJyZWZpbmUiOw0KICAgICAgfQ0KICAgICAgdGhpcy5zY29yZU1vZGUgPSBBdXRvR2x5cGhQcm9jZXNzb3Iuc2NvcmVNb2RlOw0KICAgIH0sDQogICAgbW92ZVRvb2x0aXBUbyh4LCB5KSB7DQogICAgICAvLyBJZiB3ZSBhcmUganVzdCBjcmVhdGluZyB0aGUgdG9vbHRpcCBub3csIHdlIGNhbid0IG1vdmUgaXQgeWV0Lg0KICAgICAgaWYgKCF0aGlzLiRyZWZzLnRvb2x0aXApIHJldHVybjsNCiAgICAgIGNvbnN0IHRvb2x0aXBFbCA9IHRoaXMuJHJlZnMudG9vbHRpcC4kZWw7DQogICAgICBpZiAodG9vbHRpcEVsKSB7DQogICAgICAgIGNvbnN0IHJlY3QgPSBkb2N1bWVudC5ib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOw0KICAgICAgICB0b29sdGlwRWwuc3R5bGUubGVmdCA9IGAke3ggLSByZWN0LmxlZnR9cHhgOw0KICAgICAgICB0b29sdGlwRWwuc3R5bGUudG9wID0gYCR7eSAtIHJlY3QudG9wfXB4YDsNCiAgICAgICAgaWYgKHRoaXMuJHZpZXdNb2RlbC50YWJzLnJlYWxpdHkuZ2x5cGhUb29sdGlwRGlyZWN0aW9uID09PSAxKSB7DQogICAgICAgICAgLy8gSW4gY2FzZSBvZiBhIHJlYWxseSBzaG9ydCBzY3JlZW4sIGRvbid0IGZsaWNrZXIgYmFjayBhbmQgZm9ydGgNCiAgICAgICAgICBpZiAoeSAtIHRvb2x0aXBFbC5vZmZzZXRIZWlnaHQgPD0gMCAmJiB5ICsgdG9vbHRpcEVsLm9mZnNldEhlaWdodCA8IHJlY3QuaGVpZ2h0KSB7DQogICAgICAgICAgICB0aGlzLiR2aWV3TW9kZWwudGFicy5yZWFsaXR5LmdseXBoVG9vbHRpcERpcmVjdGlvbiA9IC0xOw0KICAgICAgICAgIH0NCiAgICAgICAgfSBlbHNlIGlmICh5ICsgdG9vbHRpcEVsLm9mZnNldEhlaWdodCA+PSByZWN0LmhlaWdodCkgew0KICAgICAgICAgIHRoaXMuJHZpZXdNb2RlbC50YWJzLnJlYWxpdHkuZ2x5cGhUb29sdGlwRGlyZWN0aW9uID0gMTsNCiAgICAgICAgfQ0KICAgICAgfQ0KICAgIH0sDQogICAgbW91c2VFbnRlcihldikgew0KICAgICAgaWYgKHRoaXMuJHZpZXdNb2RlbC5kcmFnZ2luZ1VJSUQgIT09IC0xKSByZXR1cm47DQogICAgICB0aGlzLm1vdmVUb29sdGlwVG8oZXYuY2xpZW50WCwgZXYuY2xpZW50WSk7DQogICAgICB0aGlzLnNob3dUb29sdGlwKCk7DQogICAgfSwNCiAgICBtb3VzZUxlYXZlKCkgew0KICAgICAgaWYgKHRoaXMuaXNDdXJyZW50VG9vbHRpcCkgew0KICAgICAgICB0aGlzLmhpZGVUb29sdGlwKCk7DQogICAgICB9DQogICAgfSwNCiAgICBtb3VzZURvd24oKSB7DQogICAgICBpZiAodGhpcy5pc1RvdWNoZWQpIHJldHVybjsNCiAgICAgIHRoaXMuaGlkZVRvb2x0aXAoKTsNCiAgICB9LA0KICAgIG1vdXNlTW92ZShldikgew0KICAgICAgaWYgKHRoaXMuaXNUb3VjaGVkKSByZXR1cm47DQogICAgICB0aGlzLm1vdmVUb29sdGlwVG8oZXYuY2xpZW50WCwgZXYuY2xpZW50WSk7DQogICAgfSwNCiAgICBkcmFnU3RhcnQoZXYpIHsNCiAgICAgIHRoaXMuaGlkZVRvb2x0aXAoKTsNCiAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7DQogICAgICB0aGlzLnN1cHByZXNzVG9vbHRpcCA9IHRydWU7DQogICAgICBldi5kYXRhVHJhbnNmZXIuc2V0RGF0YShHTFlQSF9NSU1FX1RZUEUsIHRoaXMuZ2x5cGguaWQudG9TdHJpbmcoKSk7DQogICAgICBldi5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9ICJtb3ZlIjsNCiAgICAgIGNvbnN0IHJlY3QgPSB0aGlzLiRyZWZzLm92ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7DQogICAgICBldi5kYXRhVHJhbnNmZXIuc2V0RHJhZ0ltYWdlKHRoaXMuJHJlZnMub3ZlciwgZXYuY2xpZW50WCAtIHJlY3QubGVmdCwgZXYuY2xpZW50WSAtIHJlY3QudG9wKTsNCiAgICAgIHRoaXMuJHZpZXdNb2RlbC5kcmFnZ2luZ1VJSUQgPSB0aGlzLmNvbXBvbmVudElEOw0KICAgICAgY29uc3QgZHJhZ0luZm8gPSB0aGlzLiR2aWV3TW9kZWwudGFicy5yZWFsaXR5LmRyYWdnaW5nR2x5cGhJbmZvOw0KICAgICAgZHJhZ0luZm8uaWQgPSB0aGlzLmdseXBoLmlkOw0KICAgICAgZHJhZ0luZm8udHlwZSA9IHRoaXMuZ2x5cGgudHlwZTsNCiAgICAgIGRyYWdJbmZvLnNhY3JpZmljZVZhbHVlID0gR2x5cGhTYWNyaWZpY2VIYW5kbGVyLmdseXBoU2FjcmlmaWNlR2Fpbih0aGlzLmdseXBoKTsNCiAgICB9LA0KICAgIGRyYWdFbmQoKSB7DQogICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTsNCiAgICAgIHRoaXMuc3VwcHJlc3NUb29sdGlwID0gZmFsc2U7DQogICAgICB0aGlzLiR2aWV3TW9kZWwuc2Nyb2xsV2luZG93ID0gMDsNCiAgICAgIGNvbnN0IGRyYWdJbmZvID0gdGhpcy4kdmlld01vZGVsLnRhYnMucmVhbGl0eS5kcmFnZ2luZ0dseXBoSW5mbzsNCiAgICAgIGRyYWdJbmZvLmlkID0gLTE7DQogICAgICBkcmFnSW5mby50eXBlID0gIiI7DQogICAgICBpZiAodGhpcy4kdmlld01vZGVsLmRyYWdnaW5nVUlJRCA9PT0gdGhpcy5jb21wb25lbnRJRCkgdGhpcy4kdmlld01vZGVsLmRyYWdnaW5nVUlJRCA9IC0xOw0KICAgIH0sDQogICAgZHJhZyhldikgew0KICAgICAgLy8gSXQgbG9va3MgbGlrZSBkcmFnZ2luZyBvZmYgdGhlIGJvdHRvbSBvZiB0aGUgd2luZG93IHNvbWV0aW1lcyBmaXJlcyB0aGVzZQ0KICAgICAgLy8gb2RkIGV2ZW50cw0KICAgICAgaWYgKGV2LnNjcmVlblggPT09IDAgJiYgZXYuc2NyZWVuWSA9PT0gMCkgew0KICAgICAgICB0aGlzLiR2aWV3TW9kZWwuc2Nyb2xsV2luZG93ID0gMDsNCiAgICAgICAgcmV0dXJuOw0KICAgICAgfQ0KICAgICAgY29uc3QgYm91bmRhcnkgPSAxMDA7DQogICAgICBpZiAoZXYuY2xpZW50WSA8IGJvdW5kYXJ5KSB7DQogICAgICAgIHRoaXMuJHZpZXdNb2RlbC5zY3JvbGxXaW5kb3cgPSAtMSArIDAuOSAqIGV2LmNsaWVudFkgLyBib3VuZGFyeTsNCiAgICAgIH0gZWxzZSBpZiAoZXYuY2xpZW50WSA+IHdpbmRvdy5pbm5lckhlaWdodCAtIGJvdW5kYXJ5KSB7DQogICAgICAgIHRoaXMuJHZpZXdNb2RlbC5zY3JvbGxXaW5kb3cgPSAxIC0gMC45ICogKHdpbmRvdy5pbm5lckhlaWdodCAtIGV2LmNsaWVudFkpIC8gYm91bmRhcnk7DQogICAgICB9IGVsc2Ugew0KICAgICAgICB0aGlzLiR2aWV3TW9kZWwuc2Nyb2xsV2luZG93ID0gMDsNCiAgICAgIH0NCiAgICB9LA0KICAgIHRvdWNoU3RhcnQoKSB7DQogICAgICB0aGlzLmlzVG91Y2hlZCA9IHRydWU7DQogICAgfSwNCiAgICB0b3VjaEVuZChlKSB7DQogICAgICBpZiAodGhpcy5pc0N1cnJlbnRUb29sdGlwKSB7DQogICAgICAgIGUucHJldmVudERlZmF1bHQoKTsNCiAgICAgICAgdGhpcy5oaWRlVG9vbHRpcCgpOw0KICAgICAgfSBlbHNlIGlmICghdGhpcy5zdXBwcmVzc1Rvb2x0aXApIHsNCiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOw0KICAgICAgICB0aGlzLnNob3dUb29sdGlwKCk7DQogICAgICAgIHRoaXMubW92ZVRvb2x0aXBUbyhlLmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFgsIGUuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WSk7DQogICAgICB9DQogICAgICB0aGlzLnN1cHByZXNzVG9vbHRpcCA9IGZhbHNlOw0KICAgICAgdGhpcy5pc1RvdWNoZWQgPSBmYWxzZTsNCiAgICB9LA0KICAgIHRvdWNoTW92ZShlKSB7DQogICAgICBjb25zdCB0ID0gZS5jaGFuZ2VkVG91Y2hlc1swXTsNCiAgICAgIGNvbnN0IHIgPSB0aGlzLiRyZWZzLm92ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7DQogICAgICBpZiAodC5jbGllbnRYIDwgci5sZWZ0IHx8IHQuY2xpZW50WSA8IHIudG9wIHx8IHQuY2xpZW50WCA+IHIubGVmdCArIHIud2lkdGggfHwgdC5jbGllbnRZID4gci50b3AgKyByLmhlaWdodCkgew0KICAgICAgICB0aGlzLnN1cHByZXNzVG9vbHRpcCA9IHRydWU7DQogICAgICB9DQogICAgICBpZiAodGhpcy5pc0RyYWdnaW5nKSB7DQogICAgICAgIC8vIERyYWdEcm9wVG91Y2ggZG9lc24ndCBzZWVtIHRvIHNlbmQgZHJhZyBldmVudHMuDQogICAgICAgIHRoaXMuZHJhZyh0KTsNCiAgICAgIH0NCiAgICB9LA0KICAgIC8vIFRyYW5zbGF0ZXMgMC4uLjMgaW50byBlcXVhbGx5LXNwYWNlZCBjb29yZGluYXRlcyBhcm91bmQgYSBjaXJjbGUgOTBkZWcgYXBhcnQgKDAuLi42IGFuZCA0NWRlZyBmb3IgZWZmYXJpZykNCiAgICBlZmZlY3RJY29uUG9zKGlkKSB7DQogICAgICAvLyBQbGFjZSBkb3RzIGNsb2Nrd2lzZSBzdGFydGluZyBmcm9tIHRoZSBib3R0b20gbGVmdA0KICAgICAgY29uc3QgYW5nbGUgPSB0aGlzLmdseXBoLnR5cGUgPT09ICJlZmZhcmlnIg0KICAgICAgICA/IChNYXRoLlBJIC8gNCkgKiAoaWQgKyAxKQ0KICAgICAgICA6IChNYXRoLlBJIC8gMikgKiAoaWQgKyAwLjUpOw0KICAgICAgY29uc3Qgc2NhbGUgPSAwLjI4ICogdGhpcy5zaXplLnJlcGxhY2UoInJlbSIsICIiKTsNCiAgICAgIGNvbnN0IGR4ID0gLXNjYWxlICogTWF0aC5zaW4oYW5nbGUpOw0KICAgICAgY29uc3QgZHkgPSBzY2FsZSAqIChNYXRoLmNvcyhhbmdsZSkgKyAwLjE1KTsNCiAgICAgIHJldHVybiB7IGR4LCBkeSB9Ow0KICAgIH0sDQogICAgZ2x5cGhFZmZlY3REb3RzKGlkKSB7DQogICAgICBpZiAoWyJjb21wYW5pb24iLCAiY3Vyc2VkIl0uaW5jbHVkZXModGhpcy5nbHlwaC50eXBlKSkgcmV0dXJuIHt9Ow0KICAgICAgY29uc3QgcG9zID0gdGhpcy5lZmZlY3RJY29uUG9zKGlkKTsNCg0KICAgICAgcmV0dXJuIHsNCiAgICAgICAgcG9zaXRpb246ICJhYnNvbHV0ZSIsDQogICAgICAgIHdpZHRoOiAiMC4zcmVtIiwNCiAgICAgICAgaGVpZ2h0OiAiMC4zcmVtIiwNCiAgICAgICAgImJvcmRlci1yYWRpdXMiOiAiNTAlIiwNCiAgICAgICAgYmFja2dyb3VuZDogdGhpcy5zeW1ib2xDb2xvciwNCiAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7cG9zLmR4IC0gMC4xNSAqIDAuM31yZW0sICR7cG9zLmR5IC0gMC4xNSAqIDAuM31yZW0pYCwNCiAgICAgICAgb3BhY2l0eTogVGhlbWUuY3VycmVudCgpLm5hbWUgPT09ICJTOSIgPyAwIDogMC44DQogICAgICB9Ow0KICAgIH0sDQogICAgZ2x5cGhCb3JkZXJTdHlsZSgpIHsNCiAgICAgIGlmICghdGhpcy5zaG93Qm9yZGVycykgcmV0dXJuIG51bGw7DQogICAgICBsZXQgYm9yZGVyQXR0cnM7DQogICAgICBpZiAodGhpcy5pc0N1cnNlZEdseXBoKSBib3JkZXJBdHRycyA9IHJhcml0eUJvcmRlclN0eWxlcy5jdXJzZWQ7DQogICAgICBlbHNlIGlmICh0aGlzLmlzQ29tcGFuaW9uR2x5cGgpIGJvcmRlckF0dHJzID0gcmFyaXR5Qm9yZGVyU3R5bGVzLmNvbXBhbmlvbjsNCiAgICAgIGVsc2UgYm9yZGVyQXR0cnMgPSByYXJpdHlCb3JkZXJTdHlsZXNbZ2V0UmFyaXR5KHRoaXMuZ2x5cGguc3RyZW5ndGgpLm5hbWUudG9Mb3dlckNhc2UoKV07DQogICAgICBjb25zdCBsaW5lcyA9IGJvcmRlckF0dHJzLm1hcChhdHRyID0+IGdlbmVyYXRlR3JhZGllbnQoYXR0ciwgdGhpcy5ib3JkZXJDb2xvciwgdGhpcy5nbHlwaCwgdGhpcy5jaXJjdWxhcikpOw0KDQogICAgICByZXR1cm4gew0KICAgICAgICBwb3NpdGlvbjogImFic29sdXRlIiwNCiAgICAgICAgbGVmdDogIjIlIiwNCiAgICAgICAgd2lkdGg6ICI5NiUiLA0KICAgICAgICBoZWlnaHQ6ICI5NiUiLA0KICAgICAgICAiYm9yZGVyLXJhZGl1cyI6IHRoaXMuY2lyY3VsYXIgPyAiNTAlIiA6ICIwIiwNCiAgICAgICAgLy8gU29tZSBjYXNlcyB3aWxsIGhhdmUgdW5kZWZpbmVkIGxpbmVzIHdoaWNoIG5lZWQgdG8gYmUgcmVtb3ZlZCB0byBjb21iaW5lIGV2ZXJ5dGhpbmcgdG9nZXRoZXIgcHJvcGVybHkNCiAgICAgICAgYmFja2dyb3VuZDogbGluZXMuZmlsdGVyKGwgPT4gbCkuam9pbigiLCIpDQogICAgICB9Ow0KICAgIH0NCiAgfQ0KfTsNCg=="},{"version":3,"sources":["GlyphComponent.vue"],"names":[],"mappings":";AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"GlyphComponent.vue","sourceRoot":"src/components","sourcesContent":["<script>\r\nimport { GlyphInfo } from \"../../src/components/modals/options/SelectGlyphInfoDropdown\";\r\n\r\nimport GlyphTooltip from \"@/components/GlyphTooltip\";\r\n\r\n// We generate the border effects with CSS gradients; for the sake of flexibility and for dynamically using\r\n// the glyph color instead of the fixed rarity color, the border patterns are stored below and then parsed\r\n// into the relevant CSS on a per-glyph basis\r\nconst rarityBorderStyles = {\r\n  common: [],\r\n  uncommon: [\r\n    {\r\n      lineType: \"linear\",\r\n      angles: [45],\r\n      colorSplit: [14, 16, 84, 86],\r\n    }\r\n  ],\r\n  rare: [\r\n    {\r\n      lineType: \"linear\",\r\n      angles: [45, 135],\r\n      colorSplit: [14, 16, 84, 86],\r\n    }\r\n  ],\r\n  epic: [\r\n    {\r\n      lineType: \"linear\",\r\n      angles: [45, 135],\r\n      colorSplit: [12, 14, 16, 18, 82, 84, 86, 88],\r\n    }\r\n  ],\r\n  legendary: [\r\n    {\r\n      lineType: \"bump\",\r\n      colorSplit: [15, 25],\r\n    }\r\n  ],\r\n  mythical: [\r\n    {\r\n      lineType: \"bump\",\r\n      colorSplit: [15, 25],\r\n    },\r\n    {\r\n      lineType: \"linear\",\r\n      angles: [45, 135],\r\n      colorSplit: [10, 13, 87, 90],\r\n    }\r\n  ],\r\n  transcendent: [\r\n    {\r\n      lineType: \"bump\",\r\n      colorSplit: [15, 35],\r\n    },\r\n    {\r\n      lineType: \"linear\",\r\n      angles: [45, 135],\r\n      colorSplit: [10, 12, 14, 16, 84, 86, 88, 90],\r\n    }\r\n  ],\r\n  celestial: [\r\n    {\r\n      lineType: \"bump\",\r\n      colorSplit: [15, 35],\r\n    },\r\n    {\r\n      lineType: \"radial\",\r\n      colorSplit: [65, 85],\r\n    },\r\n  ],\r\n  cursed: [\r\n    {\r\n      lineType: \"spike\",\r\n      center: [40, 40],\r\n      angles: [305, 325],\r\n    },\r\n    {\r\n      lineType: \"spike\",\r\n      center: [60, 40],\r\n      angles: [35, 55],\r\n    },\r\n    {\r\n      lineType: \"spike\",\r\n      center: [60, 60],\r\n      angles: [125, 145],\r\n    },\r\n    {\r\n      lineType: \"spike\",\r\n      center: [40, 60],\r\n      angles: [215, 235],\r\n    },\r\n  ],\r\n  companion: [\r\n    {\r\n      lineType: \"companion\",\r\n    },\r\n  ]\r\n};\r\n\r\n// This function does all the parsing of the above gradient specifications\r\n// eslint-disable-next-line max-params\r\nfunction generateGradient(data, color, glyph, isCircular) {\r\n  // The undefined declarations here are mostly to make ESLint happy, and aren't necessarily used in all cases\r\n  let borders, scaleFn, centers, specialData, isColor = false;\r\n  const entries = [], elements = [];\r\n  switch (data.lineType) {\r\n    case \"linear\":\r\n      // Produces stripes at the specified angle, where color sharply switches between the specified color and\r\n      // transparent at each percentage in lines\r\n      borders = [0, ...data.colorSplit, 100];\r\n      scaleFn = perc => (isCircular ? 50 + 0.7 * (perc - 50) : perc);\r\n      for (const angle of data.angles) {\r\n        for (let i = 0; i < borders.length - 1; i++) {\r\n          entries.push(`${isColor ? color : \"transparent\"} ${scaleFn(borders[i])}% ${scaleFn(borders[i + 1])}%`);\r\n          isColor = !isColor;\r\n        }\r\n        elements.push(`repeating-linear-gradient(${angle}deg, ${entries.join(\",\")})`);\r\n      }\r\n      return elements.join(\",\");\r\n    case \"bump\":\r\n      // Produces four bumps on the cardinal directions of the glyph border, with specified color fade distances.\r\n      // These bumps overlap some dots on effarig glyphs, so we conditionally make them more transparent (effectively\r\n      // shrinking them so they don't overlap)\r\n      specialData = glyph.type === \"effarig\"\r\n        ? `${color}60`\r\n        : color;\r\n      centers = [\"50% -25%\", \"50% 125%\", \"-25% 50%\", \"125% 50%\"];\r\n      scaleFn = perc => (isCircular ? perc : 0.9 * perc);\r\n      for (let i = 0; i < 4; i++) {\r\n        entries.push(`radial-gradient(at ${centers[i]}, transparent, ${specialData} ${scaleFn(data.colorSplit[0])}%,\r\n          transparent ${scaleFn(data.colorSplit[1])}%)`);\r\n      }\r\n      return entries.join(\",\");\r\n    case \"radial\":\r\n      // Produces a centered circle that only shades within a certain radial distance\r\n      borders = [50, ...data.colorSplit, 100];\r\n      scaleFn = perc => (isCircular ? 0.9 * perc : 100 - (100 - perc) / 2);\r\n      for (const border of borders) {\r\n        entries.push(`${isColor ? color : \"transparent\"} ${scaleFn(border)}%`);\r\n        isColor = !isColor;\r\n      }\r\n      return `radial-gradient(${entries.join(\",\")})`;\r\n    case \"spike\":\r\n      // Produces a single spike at the specified center, spanning between the specified angles with 5deg blur\r\n      entries.push(`transparent ${data.angles[0] - 5}deg`);\r\n      entries.push(`${color}b0 ${data.angles[0] + 5}deg`);\r\n      entries.push(`${color}b0 ${data.angles[1] - 5}deg`);\r\n      entries.push(`transparent ${data.angles[1] + 5}deg`);\r\n      return `conic-gradient(from 0deg at ${data.center[0]}% ${data.center[1]}%, ${entries.join(\",\")})`;\r\n    case \"companion\":\r\n      // Special case to make the companion border look like a heart\r\n      borders = [0, 30, 330, 360];\r\n      specialData = [color, \"transparent\", \"transparent\", color];\r\n      for (let i = 0; i < 4; i++) {\r\n        entries.push(`${specialData[i]} ${borders[i]}deg`);\r\n      }\r\n      elements.push(`conic-gradient(${entries.join(\",\")})`);\r\n\r\n      centers = [\"125% 125%\", \"-25% 125%\"];\r\n      scaleFn = perc => (isCircular ? 0.9 * (perc + 10) : perc);\r\n      for (let i = 0; i < 2; i++) {\r\n        elements.push(`radial-gradient(at ${centers[i]}, transparent, ${color} ${scaleFn(30)}%,\r\n          transparent ${scaleFn(50)}%)`);\r\n      }\r\n      return elements.join(\",\");\r\n    default:\r\n      throw new Error(\"Unrecognized glyph border data\");\r\n  }\r\n}\r\n\r\nexport default {\r\n  name: \"GlyphComponent\",\r\n  components: {\r\n    GlyphTooltip\r\n  },\r\n  props: {\r\n    glyph: {\r\n      type: Object,\r\n      required: true\r\n    },\r\n    isInModal: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: false\r\n    },\r\n    isNew: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: false\r\n    },\r\n    isUnequipped: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: false\r\n    },\r\n    showSacrifice: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: false\r\n    },\r\n    ignoreModifiedLevel: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: false\r\n    },\r\n    realityGlyphBoost: {\r\n      type: Number,\r\n      required: false,\r\n      default: 0\r\n    },\r\n    isInventoryGlyph: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: false\r\n    },\r\n    isActiveGlyph: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: false\r\n    },\r\n    size: {\r\n      type: String,\r\n      required: false,\r\n      default: \"5rem\",\r\n    },\r\n    glowBlur: {\r\n      type: String,\r\n      required: false,\r\n      default: \"1rem\"\r\n    },\r\n    glowSpread: {\r\n      type: String,\r\n      required: false,\r\n      default: \"0.2rem\"\r\n    },\r\n    bottomPadding: {\r\n      type: String,\r\n      required: false,\r\n      default: \"0.3rem\"\r\n    },\r\n    textProportion: {\r\n      type: Number,\r\n      required: false,\r\n      default: 0.5\r\n    },\r\n    circular: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: false,\r\n    },\r\n    draggable: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: false,\r\n    },\r\n    flipTooltip: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: false,\r\n    }\r\n  },\r\n  data() {\r\n    return {\r\n      componentID: UIID.next(),\r\n      isDragging: false,\r\n      // This flag is used to prevent the tooltip from being shown in some touch event sequences\r\n      suppressTooltip: false,\r\n      isTouched: false,\r\n      tooltipEnabled: false,\r\n      sacrificeReward: 0,\r\n      uncappedRefineReward: 0,\r\n      refineReward: 0,\r\n      displayLevel: 0,\r\n      // We use this to not create a ton of tooltip components as soon as the glyph tab loads.\r\n      tooltipLoaded: false,\r\n      logTotalSacrifice: 0,\r\n      realityColor: \"\",\r\n    };\r\n  },\r\n  computed: {\r\n    hasTooltip() {\r\n      return Boolean(this.glyph.effects);\r\n    },\r\n    typeConfig() {\r\n      return GlyphTypes[this.glyph.type];\r\n    },\r\n    cosmeticConfig() {\r\n      return CosmeticGlyphTypes[this.glyph.cosmetic ?? this.glyph.type];\r\n    },\r\n    isBlobHeart() {\r\n      return this.$viewModel.theme === \"S11\" && this.glyph.type === \"companion\";\r\n    },\r\n    symbol() {\r\n      const symbol = this.glyph.symbol;\r\n      // \\uE019 = :blobheart:\r\n      if (this.isBlobHeart) return \"\\uE019\";\r\n      if (symbol) return symbol;\r\n      return (this.$viewModel.theme === \"S4\" && !this.glyph.cosmetic)\r\n        ? CANCER_GLYPH_SYMBOLS[this.glyph.type]\r\n        : this.cosmeticConfig.currentSymbol.symbol;\r\n    },\r\n    symbolBlur() {\r\n      if (this.isBlobHeart) return false;\r\n      if (!this.glyph.symbol) return this.cosmeticConfig.currentSymbol.blur;\r\n      return !GlyphAppearanceHandler.unblurredSymbols.includes(this.symbol);\r\n    },\r\n    zIndexStyle() {\r\n      return { \"z-index\": this.isInModal ? 7 : 6 };\r\n    },\r\n    colorObj() {\r\n      let overrideColor;\r\n      if (this.glyph.color) overrideColor = GlyphAppearanceHandler.getColorProps(this.glyph.color);\r\n      if (this.glyph.cosmetic) {\r\n        if (this.glyph.cosmetic === this.glyph.type) {\r\n          overrideColor = this.glyph.type === \"cursed\"\r\n            ? GlyphAppearanceHandler.getBaseColor(true)\r\n            : this.cosmeticConfig.currentColor;\r\n        } else {\r\n          overrideColor = this.cosmeticConfig.currentColor;\r\n        }\r\n      }\r\n\r\n      let symbolColor;\r\n      if (this.isRealityGlyph && this.realityColor) symbolColor = this.realityColor;\r\n      else {\r\n        symbolColor = this.cosmeticConfig.ignoreRarityColor\r\n          ? GlyphAppearanceHandler.getBorderColor(this.glyph.type)\r\n          : GlyphAppearanceHandler.getRarityColor(this.glyph.strength, this.glyph.type);\r\n      }\r\n\r\n      return {\r\n        border: overrideColor?.border ?? GlyphAppearanceHandler.getBorderColor(this.glyph.type),\r\n        symbol: overrideColor?.border ?? symbolColor,\r\n        bg: overrideColor?.bg ?? this.cosmeticConfig.currentColor.bg\r\n      };\r\n    },\r\n    symbolColor() {\r\n      return player.options.swapGlyphColors ? this.colorObj.border : this.colorObj.symbol;\r\n    },\r\n    borderColor() {\r\n      return player.options.swapGlyphColors ? this.colorObj.symbol : this.colorObj.border;\r\n    },\r\n    bgColor() {\r\n      return this.colorObj.bg;\r\n    },\r\n    overStyle() {\r\n      return {\r\n        width: this.size,\r\n        height: this.size,\r\n        position: \"absolute\",\r\n        \"background-color\": \"rgba(0, 0, 0, 0)\",\r\n        \"box-shadow\": `0 0 ${this.glowBlur} calc(${this.glowSpread} + 0.1rem) ${this.borderColor} inset`,\r\n        \"border-radius\": this.circular ? \"50%\" : \"0\",\r\n      };\r\n    },\r\n    outerStyle() {\r\n      return {\r\n        width: this.size,\r\n        height: this.size,\r\n        \"background-color\": this.borderColor,\r\n        \"box-shadow\": `0 0 ${this.glowBlur} ${this.glowSpread} ${this.borderColor}`,\r\n        \"border-radius\": this.circular ? \"50%\" : \"0\",\r\n        \"-webkit-user-drag\": this.draggable ? \"\" : \"none\"\r\n      };\r\n    },\r\n    innerStyle() {\r\n      const color = this.symbolColor;\r\n      return {\r\n        width: `calc(${this.size} - 0.2rem)`,\r\n        height: `calc(${this.size} - 0.2rem)`,\r\n        \"font-size\": `calc( ${this.size} * ${this.textProportion} )`,\r\n        color,\r\n        \"text-shadow\": this.symbolBlur ? `-0.04em 0.04em 0.08em ${color}` : undefined,\r\n        \"border-radius\": this.circular ? \"50%\" : \"0\",\r\n        \"padding-bottom\": this.bottomPadding,\r\n        background: this.bgColor\r\n      };\r\n    },\r\n    mouseEventHandlers() {\r\n      const handlers = this.hasTooltip ? {\r\n        mouseenter: this.mouseEnter,\r\n        \"&mousemove\": this.mouseMove,\r\n        mouseleave: this.mouseLeave,\r\n        mousedown: this.mouseDown,\r\n        touchstart: this.touchStart,\r\n        touchend: this.touchEnd\r\n      } : {};\r\n      if (this.hasTooltip || this.draggable) {\r\n        handlers.touchmove = this.touchMove;\r\n      }\r\n      return handlers;\r\n    },\r\n    isCurrentTooltip() {\r\n      return this.$viewModel.tabs.reality.currentGlyphTooltip === this.componentID;\r\n    },\r\n    tooltipDirectionClass() {\r\n      let directionID = this.$viewModel.tabs.reality.glyphTooltipDirection;\r\n      if (this.flipTooltip) directionID += 1;\r\n      switch (directionID) {\r\n        case -1:\r\n          return \"l-glyph-tooltip--down-left\";\r\n        case 0:\r\n          return \"l-glyph-tooltip--down-right\";\r\n        case 1:\r\n          return \"l-glyph-tooltip--up-left\";\r\n        case 2:\r\n          return \"l-glyph-tooltip--up-right\";\r\n        default:\r\n          return \"\";\r\n      }\r\n    },\r\n    // This finds all the effects of a glyph and shifts all their IDs so that type's lowest-ID effect is 0 and all\r\n    // other effects count up to 3 (or 6 for effarig). Used to add dots in unique positions on glyphs to show effects.\r\n    glyphEffects() {\r\n      let minEffectID = 0;\r\n      switch (this.glyph.type) {\r\n        case \"time\":\r\n        case \"cursed\":\r\n        case \"companion\":\r\n          minEffectID = 0;\r\n          break;\r\n        case \"dilation\":\r\n        case \"reality\":\r\n          minEffectID = 4;\r\n          break;\r\n        case \"replication\":\r\n          minEffectID = 8;\r\n          break;\r\n        case \"infinity\":\r\n          minEffectID = 12;\r\n          break;\r\n        case \"power\":\r\n          minEffectID = 16;\r\n          break;\r\n        case \"effarig\":\r\n          minEffectID = 20;\r\n          break;\r\n        default:\r\n          throw new Error(`Unrecognized glyph type \"${this.glyph.type}\" in glyph effect icons`);\r\n      }\r\n      const effectIDs = [];\r\n      let remainingEffects = this.glyph.effects >> minEffectID;\r\n      for (let id = 0; remainingEffects > 0; id++) {\r\n        if ((remainingEffects & 1) === 1) effectIDs.push(id);\r\n        remainingEffects >>= 1;\r\n      }\r\n      return effectIDs;\r\n    },\r\n    isRealityGlyph() {\r\n      return this.glyph.type === \"reality\";\r\n    },\r\n    isCursedGlyph() {\r\n      return this.glyph.type === \"cursed\";\r\n    },\r\n    isCompanionGlyph() {\r\n      return this.glyph.type === \"companion\";\r\n    },\r\n    showGlyphEffectDots() {\r\n      return player.options.showHintText.glyphEffectDots;\r\n    },\r\n    displayedInfo() {\r\n      const blacklist = [\"companion\", \"cursed\"];\r\n      if (!this.isInventoryGlyph || blacklist.includes(this.glyph.type)) return null;\r\n\r\n      const options = player.options.showHintText;\r\n      if (options.glyphInfoType === GlyphInfo.types.NONE ||\r\n        (!options.showGlyphInfoByDefault && !this.$viewModel.shiftDown)) {\r\n        return null;\r\n      }\r\n\r\n      const typeEnum = GlyphInfo.types;\r\n      switch (options.glyphInfoType) {\r\n        case typeEnum.LEVEL:\r\n          this.updateDisplayLevel();\r\n          return formatInt(this.displayLevel === 0 ? this.glyph.level : this.displayLevel);\r\n        case typeEnum.RARITY:\r\n          return formatRarity(strengthToRarity(Pelle.isDoomed ? Pelle.glyphStrength : this.glyph.strength));\r\n        case typeEnum.SAC_VALUE:\r\n          return format(this.sacrificeReward, 2, 2);\r\n        case typeEnum.FILTER_SCORE:\r\n          return format(AutoGlyphProcessor.filterValue(this.glyph), 1, 1);\r\n        case typeEnum.CURRENT_REFINE:\r\n          return `${format(this.refineReward, 2, 2)} ${this.symbol}`;\r\n        case typeEnum.MAX_REFINE:\r\n          return `${format(this.uncappedRefineReward, 2, 2)} ${this.symbol}`;\r\n        default:\r\n          throw new Error(\"Unrecognized Glyph info type in info text\");\r\n      }\r\n    },\r\n    showBorders() {\r\n      return player.options.glyphBorders;\r\n    }\r\n  },\r\n  watch: {\r\n    logTotalSacrifice() {\r\n      this.tooltipLoaded = false;\r\n      if (this.isCurrentTooltip) this.showTooltip();\r\n    }\r\n  },\r\n  created() {\r\n    this.on$(GAME_EVENT.GLYPH_VISUAL_CHANGE, () => {\r\n      this.$recompute(\"typeConfig\");\r\n      this.$recompute(\"cosmeticConfig\");\r\n      this.$recompute(\"innerStyle\");\r\n      this.$recompute(\"overrideColor\");\r\n      this.$recompute(\"showGlyphEffectDots\");\r\n      this.$recompute(\"displayedInfo\");\r\n      this.$recompute(\"showBorders\");\r\n    });\r\n    this.on$(\"tooltip-touched\", () => this.hideTooltip());\r\n    this.on$(GAME_EVENT.TAB_CHANGED, () => this.hideTooltip());\r\n\r\n    // There are a few situations where a tooltip could attempt to render immediately upon component creation,\r\n    // which causes it to be placed in an odd \"default\" corner spot due to mouse position not being set properly.\r\n    // This is essentially a hack that force-suppresses tooltips from being shown in strange spots due to on-load\r\n    // events firing, but has the side effect that the mouse must leave and enter an element which was created\r\n    // underneath it in order to make the tooltip appear\r\n    setTimeout(() => this.tooltipEnabled = true, 10);\r\n  },\r\n  beforeDestroy() {\r\n    if (this.isCurrentTooltip) this.hideTooltip();\r\n    if (this.$viewModel.draggingUIID === this.componentID) this.$viewModel.draggingUIID = -1;\r\n  },\r\n  methods: {\r\n    update() {\r\n      this.logTotalSacrifice = GameCache.logTotalGlyphSacrifice.value;\r\n      // This needs to be reactive in order to animate while using our low-lag workaround, but we also need to make\r\n      // sure it only animates when that color is actually active\r\n      this.realityColor = player.reality.glyphs.cosmetics.colorMap.reality\r\n        ? null\r\n        : GlyphAppearanceHandler.realityColor;\r\n      this.sacrificeReward = GlyphSacrificeHandler.glyphSacrificeGain(this.glyph);\r\n      this.uncappedRefineReward = ALCHEMY_BASIC_GLYPH_TYPES.includes(this.glyph.type)\r\n        ? GlyphSacrificeHandler.glyphRawRefinementGain(this.glyph)\r\n        : 0;\r\n      this.refineReward = ALCHEMY_BASIC_GLYPH_TYPES.includes(this.glyph.type)\r\n        ? GlyphSacrificeHandler.glyphRefinementGain(this.glyph)\r\n        : 0;\r\n      if (this.tooltipLoaded) this.updateDisplayLevel();\r\n    },\r\n    updateDisplayLevel() {\r\n      if (this.ignoreModifiedLevel) {\r\n        this.displayLevel = 0;\r\n        return;\r\n      }\r\n      // We have to consider some odd interactions in order to properly show level. The getAdjustedGlyphLevel() function\r\n      // returns a modified level using celestial effects and reality glyphs based on the CURRENT game state, meaning\r\n      // that applying this globally will cause lots of glyphs to show altered levels even if they shouldn't. So:\r\n      // - Active glyphs should apply ALL adjusted effects based on the current game state, since they are guaranteed\r\n      //   to always be affected by them and this is exactly the purpose of getAdjustedGlyphLevel() as-is\r\n      // - Inventory glyphs should show the same current-state effects as active, but it should NEVER apply reality\r\n      //   glyph boosts. This allows for easier comparison when celestial effects are changing both active and\r\n      //   inventory glyphs, even though strictly speaking the inventory ones shouldn't be affected until equipped\r\n      // - All other glyphs should never apply effects from the current game state, and should in fact only apply the\r\n      //   reality glyph boost based on the rest of its existing set (which is passed in via realityGlyphBoost) and\r\n      //   nothing else. This case applies to glyphs appearing in presets, records, and previews.\r\n      if (this.isActiveGlyph) this.displayLevel = getAdjustedGlyphLevel(this.glyph);\r\n      else if (this.isInventoryGlyph) this.displayLevel = getAdjustedGlyphLevel(this.glyph, 0);\r\n      else {\r\n        this.displayLevel = this.glyph.level +\r\n          (BASIC_GLYPH_TYPES.includes(this.glyph.type) ? this.realityGlyphBoost : 0);\r\n      }\r\n    },\r\n    hideTooltip() {\r\n      this.tooltipLoaded = false;\r\n      this.$viewModel.tabs.reality.mouseoverGlyphInfo.type = \"\";\r\n      this.$viewModel.tabs.reality.mouseoverGlyphInfo.inInventory = false;\r\n      this.$viewModel.tabs.reality.currentGlyphTooltip = -1;\r\n    },\r\n    showTooltip() {\r\n      if (!this.tooltipEnabled) return;\r\n      Glyphs.removeVisualFlag(\"unseen\", this.glyph);\r\n      Glyphs.removeVisualFlag(\"unequipped\", this.glyph);\r\n      this.tooltipLoaded = true;\r\n      this.$viewModel.tabs.reality.mouseoverGlyphInfo.inInventory = !this.circular;\r\n      const glyphInfo = this.$viewModel.tabs.reality.mouseoverGlyphInfo;\r\n      glyphInfo.type = this.glyph.type;\r\n      glyphInfo.sacrificeValue = GlyphSacrificeHandler.glyphSacrificeGain(this.glyph);\r\n      glyphInfo.refineValue = GlyphSacrificeHandler.glyphRawRefinementGain(this.glyph);\r\n      this.$viewModel.tabs.reality.currentGlyphTooltip = this.componentID;\r\n      if (\r\n        AutoGlyphProcessor.sacMode === AUTO_GLYPH_REJECT.SACRIFICE ||\r\n        (AutoGlyphProcessor.sacMode === AUTO_GLYPH_REJECT.REFINE_TO_CAP && this.refineReward === 0)\r\n      ) {\r\n        this.currentAction = \"sacrifice\";\r\n      } else {\r\n        this.currentAction = \"refine\";\r\n      }\r\n      this.scoreMode = AutoGlyphProcessor.scoreMode;\r\n    },\r\n    moveTooltipTo(x, y) {\r\n      // If we are just creating the tooltip now, we can't move it yet.\r\n      if (!this.$refs.tooltip) return;\r\n      const tooltipEl = this.$refs.tooltip.$el;\r\n      if (tooltipEl) {\r\n        const rect = document.body.getBoundingClientRect();\r\n        tooltipEl.style.left = `${x - rect.left}px`;\r\n        tooltipEl.style.top = `${y - rect.top}px`;\r\n        if (this.$viewModel.tabs.reality.glyphTooltipDirection === 1) {\r\n          // In case of a really short screen, don't flicker back and forth\r\n          if (y - tooltipEl.offsetHeight <= 0 && y + tooltipEl.offsetHeight < rect.height) {\r\n            this.$viewModel.tabs.reality.glyphTooltipDirection = -1;\r\n          }\r\n        } else if (y + tooltipEl.offsetHeight >= rect.height) {\r\n          this.$viewModel.tabs.reality.glyphTooltipDirection = 1;\r\n        }\r\n      }\r\n    },\r\n    mouseEnter(ev) {\r\n      if (this.$viewModel.draggingUIID !== -1) return;\r\n      this.moveTooltipTo(ev.clientX, ev.clientY);\r\n      this.showTooltip();\r\n    },\r\n    mouseLeave() {\r\n      if (this.isCurrentTooltip) {\r\n        this.hideTooltip();\r\n      }\r\n    },\r\n    mouseDown() {\r\n      if (this.isTouched) return;\r\n      this.hideTooltip();\r\n    },\r\n    mouseMove(ev) {\r\n      if (this.isTouched) return;\r\n      this.moveTooltipTo(ev.clientX, ev.clientY);\r\n    },\r\n    dragStart(ev) {\r\n      this.hideTooltip();\r\n      this.isDragging = true;\r\n      this.suppressTooltip = true;\r\n      ev.dataTransfer.setData(GLYPH_MIME_TYPE, this.glyph.id.toString());\r\n      ev.dataTransfer.dropEffect = \"move\";\r\n      const rect = this.$refs.over.getBoundingClientRect();\r\n      ev.dataTransfer.setDragImage(this.$refs.over, ev.clientX - rect.left, ev.clientY - rect.top);\r\n      this.$viewModel.draggingUIID = this.componentID;\r\n      const dragInfo = this.$viewModel.tabs.reality.draggingGlyphInfo;\r\n      dragInfo.id = this.glyph.id;\r\n      dragInfo.type = this.glyph.type;\r\n      dragInfo.sacrificeValue = GlyphSacrificeHandler.glyphSacrificeGain(this.glyph);\r\n    },\r\n    dragEnd() {\r\n      this.isDragging = false;\r\n      this.suppressTooltip = false;\r\n      this.$viewModel.scrollWindow = 0;\r\n      const dragInfo = this.$viewModel.tabs.reality.draggingGlyphInfo;\r\n      dragInfo.id = -1;\r\n      dragInfo.type = \"\";\r\n      if (this.$viewModel.draggingUIID === this.componentID) this.$viewModel.draggingUIID = -1;\r\n    },\r\n    drag(ev) {\r\n      // It looks like dragging off the bottom of the window sometimes fires these\r\n      // odd events\r\n      if (ev.screenX === 0 && ev.screenY === 0) {\r\n        this.$viewModel.scrollWindow = 0;\r\n        return;\r\n      }\r\n      const boundary = 100;\r\n      if (ev.clientY < boundary) {\r\n        this.$viewModel.scrollWindow = -1 + 0.9 * ev.clientY / boundary;\r\n      } else if (ev.clientY > window.innerHeight - boundary) {\r\n        this.$viewModel.scrollWindow = 1 - 0.9 * (window.innerHeight - ev.clientY) / boundary;\r\n      } else {\r\n        this.$viewModel.scrollWindow = 0;\r\n      }\r\n    },\r\n    touchStart() {\r\n      this.isTouched = true;\r\n    },\r\n    touchEnd(e) {\r\n      if (this.isCurrentTooltip) {\r\n        e.preventDefault();\r\n        this.hideTooltip();\r\n      } else if (!this.suppressTooltip) {\r\n        e.preventDefault();\r\n        this.showTooltip();\r\n        this.moveTooltipTo(e.changedTouches[0].clientX, e.changedTouches[0].clientY);\r\n      }\r\n      this.suppressTooltip = false;\r\n      this.isTouched = false;\r\n    },\r\n    touchMove(e) {\r\n      const t = e.changedTouches[0];\r\n      const r = this.$refs.over.getBoundingClientRect();\r\n      if (t.clientX < r.left || t.clientY < r.top || t.clientX > r.left + r.width || t.clientY > r.top + r.height) {\r\n        this.suppressTooltip = true;\r\n      }\r\n      if (this.isDragging) {\r\n        // DragDropTouch doesn't seem to send drag events.\r\n        this.drag(t);\r\n      }\r\n    },\r\n    // Translates 0...3 into equally-spaced coordinates around a circle 90deg apart (0...6 and 45deg for effarig)\r\n    effectIconPos(id) {\r\n      // Place dots clockwise starting from the bottom left\r\n      const angle = this.glyph.type === \"effarig\"\r\n        ? (Math.PI / 4) * (id + 1)\r\n        : (Math.PI / 2) * (id + 0.5);\r\n      const scale = 0.28 * this.size.replace(\"rem\", \"\");\r\n      const dx = -scale * Math.sin(angle);\r\n      const dy = scale * (Math.cos(angle) + 0.15);\r\n      return { dx, dy };\r\n    },\r\n    glyphEffectDots(id) {\r\n      if ([\"companion\", \"cursed\"].includes(this.glyph.type)) return {};\r\n      const pos = this.effectIconPos(id);\r\n\r\n      return {\r\n        position: \"absolute\",\r\n        width: \"0.3rem\",\r\n        height: \"0.3rem\",\r\n        \"border-radius\": \"50%\",\r\n        background: this.symbolColor,\r\n        transform: `translate(${pos.dx - 0.15 * 0.3}rem, ${pos.dy - 0.15 * 0.3}rem)`,\r\n        opacity: Theme.current().name === \"S9\" ? 0 : 0.8\r\n      };\r\n    },\r\n    glyphBorderStyle() {\r\n      if (!this.showBorders) return null;\r\n      let borderAttrs;\r\n      if (this.isCursedGlyph) borderAttrs = rarityBorderStyles.cursed;\r\n      else if (this.isCompanionGlyph) borderAttrs = rarityBorderStyles.companion;\r\n      else borderAttrs = rarityBorderStyles[getRarity(this.glyph.strength).name.toLowerCase()];\r\n      const lines = borderAttrs.map(attr => generateGradient(attr, this.borderColor, this.glyph, this.circular));\r\n\r\n      return {\r\n        position: \"absolute\",\r\n        left: \"2%\",\r\n        width: \"96%\",\r\n        height: \"96%\",\r\n        \"border-radius\": this.circular ? \"50%\" : \"0\",\r\n        // Some cases will have undefined lines which need to be removed to combine everything together properly\r\n        background: lines.filter(l => l).join(\",\")\r\n      };\r\n    }\r\n  }\r\n};\r\n</script>\r\n\r\n<template>\r\n  <!--\r\n    The naive approach with a border and box-shadow seems to have problems with\r\n    weird seams/artifacts at the edges. This makes for a rather complex workaround\r\n  -->\r\n  <div\r\n    :style=\"outerStyle\"\r\n    :class=\"['l-glyph-component', {'c-glyph-component--dragging': isDragging}]\"\r\n    :draggable=\"draggable\"\r\n    v-on=\"draggable ? { dragstart: dragStart, dragend: dragEnd, drag: drag } : {}\"\r\n  >\r\n    <div\r\n      ref=\"glyph\"\r\n      :style=\"innerStyle\"\r\n      :class=\"['l-glyph-component', 'c-glyph-component']\"\r\n    >\r\n      {{ symbol }}\r\n      <template v-if=\"$viewModel.shiftDown || showGlyphEffectDots\">\r\n        <div\r\n          v-for=\"x in glyphEffects\"\r\n          :key=\"x\"\r\n          :style=\"glyphEffectDots(x)\"\r\n        />\r\n      </template>\r\n    </div>\r\n    <div :style=\"glyphBorderStyle()\" />\r\n    <GlyphTooltip\r\n      v-if=\"hasTooltip && tooltipLoaded\"\r\n      v-show=\"isCurrentTooltip\"\r\n      ref=\"tooltip\"\r\n      v-bind=\"glyph\"\r\n      :class=\"tooltipDirectionClass\"\r\n      :style=\"zIndexStyle\"\r\n      :sacrifice-reward=\"sacrificeReward\"\r\n      :refine-reward=\"refineReward\"\r\n      :uncapped-refine-reward=\"uncappedRefineReward\"\r\n      :current-action=\"currentAction\"\r\n      :score-mode=\"scoreMode\"\r\n      :show-deletion-text=\"showSacrifice\"\r\n      :display-level=\"displayLevel\"\r\n      :component=\"componentID\"\r\n      :change-watcher=\"logTotalSacrifice\"\r\n    />\r\n    <div\r\n      v-if=\"isNew\"\r\n      class=\"l-corner-icon l-new-glyph\"\r\n    >\r\n      New!\r\n    </div>\r\n    <div\r\n      v-else-if=\"isUnequipped\"\r\n      class=\"l-corner-icon l-unequipped-glyph fas fa-arrow-up-from-bracket\"\r\n    />\r\n    <div\r\n      v-if=\"displayedInfo\"\r\n      class=\"l-glyph-info\"\r\n    >\r\n      {{ displayedInfo }}\r\n    </div>\r\n    <div\r\n      ref=\"over\"\r\n      :style=\"overStyle\"\r\n      v-on=\"mouseEventHandlers\"\r\n      @click.shift.exact=\"$emit('shiftClicked', glyph.id)\"\r\n      @click.ctrl.shift.exact=\"$emit('ctrlShiftClicked', glyph.id)\"\r\n      @click.meta.shift.exact=\"$emit('ctrlShiftClicked', glyph.id)\"\r\n      @click.exact=\"$emit('clicked', glyph.id)\"\r\n    />\r\n  </div>\r\n</template>\r\n\r\n<style scoped>\r\n.l-corner-icon {\r\n  position: absolute;\r\n  z-index: 5;\r\n  color: black;\r\n  border-radius: var(--var-border-radius, 0.2rem);\r\n  padding: 0.2rem;\r\n}\r\n\r\n.l-new-glyph {\r\n  top: -0.7rem;\r\n  left: -0.7rem;\r\n  font-size: 1rem;\r\n  background-color: yellow;\r\n}\r\n\r\n.l-unequipped-glyph {\r\n  top: -0.5rem;\r\n  left: -0.5rem;\r\n  font-size: 1.2rem;\r\n  background-color: orange;\r\n}\r\n</style>\r\n"]}]}