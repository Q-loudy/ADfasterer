{"remainingRequest":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\@vue\\vue-loader-v15\\lib\\index.js??vue-loader-options!C:\\Games\\ADFasterer\\ADfasterer\\src\\components\\GlyphSetName.vue?vue&type=script&lang=js&","dependencies":[{"path":"C:\\Games\\ADFasterer\\ADfasterer\\src\\components\\GlyphSetName.vue","mtime":1745241596774},{"path":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\babel-loader\\lib\\index.js","mtime":1745242219290},{"path":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1745242214069},{"path":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\@vue\\vue-loader-v15\\lib\\index.js","mtime":1745242220175}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:DQpjb25zdCBHTFlQSF9OQU1FUyA9IHsNCiAgY29tcGFuaW9uOiB7DQogICAgYWRqZWN0aXZlOiAiSHVnZ2FibGUiLA0KICAgIG5vdW46ICJDb21wYW5pb24iDQogIH0sDQogIHJlYWxpdHk6IHsNCiAgICBhZGplY3RpdmU6ICJSZWFsIiwNCiAgICBub3VuOiAiUmVhbGl0eSINCiAgfSwNCiAgbXVzaWM6IHsNCiAgICBhZGplY3RpdmU6IHsgaGlnaDogIk1lbG9kaWMiLCBtaWQ6ICJDaG9yZGFsIiwgbG93OiAiVHVuZWQiIH0sDQogICAgLy8gVGhpcyBub3VuIGlzIG9ubHkgdXNlZCBpbiB0aGUgY2FzZSBvZiBhIHNpbmdsZSBjb21wYW5pb24gcmVza2lubmVkIGFzIG11c2ljIChyZXN1bHRpbmcgaW4gIkh1Z2dhYmxlIE11c2ljIik7DQogICAgLy8gb3RoZXJ3aXNlIHRoZSBzZXQncyBub3VuIHdpbGwgYWx3YXlzIGNvbWUgZnJvbSBhbiBhY3R1YWwgZ2x5cGggdHlwZSBpbnN0ZWFkIG9mIG11c2ljDQogICAgbm91bjogIk11c2ljIg0KICB9LA0KICBlZmZhcmlnOiB7DQogICAgYWRqZWN0aXZlOiB7IGJvdGg6ICJNZXRhIiwgZ2x5cGg6ICJTdGFibGUiLCBybTogIk1lY2hhbmljYWwiLCBub25lOiAiRnJhZ21lbnRlZCIgfSwNCiAgICBub3VuOiB7IGJvdGg6ICJFZmZhcmlnIiwgZ2x5cGg6ICJTdGFiaWxpdHkiLCBybTogIk1lY2hhbmlzbSIsIG5vbmU6ICJGcmFnbWVudGF0aW9uIiB9DQogIH0sDQogIGN1cnNlZDogew0KICAgIGFkamVjdGl2ZTogeyBoaWdoOiAiQ3Vyc2VkIiwgbWlkOiAiSGV4ZWQiLCBsb3c6ICJKaW54ZWQiIH0sDQogICAgbm91bjogIkN1cnNlIg0KICB9LA0KICBwb3dlcjogew0KICAgIGFkamVjdGl2ZTogeyBoaWdoOiAiUG93ZXJmdWwiLCBtaWQ6ICJNYXN0ZXJlZCIsIGxvdzogIlBvdGVudGlhbCIgfSwNCiAgICBub3VuOiAiUG93ZXIiDQogIH0sDQogIGluZmluaXR5OiB7DQogICAgYWRqZWN0aXZlOiB7IGhpZ2g6ICJJbmZpbml0ZSIsIG1pZDogIkJvdW5kbGVzcyIsIGxvdzogIkltbWVuc2UiIH0sDQogICAgbm91bjogIkluZmluaXR5Ig0KICB9LA0KICByZXBsaWNhdGlvbjogew0KICAgIGFkamVjdGl2ZTogeyBoaWdoOiAiUmVwbGljYXRlZCIsIG1pZDogIlNpbXVsYXRlZCIsIGxvdzogIkR1cGxpY2F0ZWQiIH0sDQogICAgbm91bjogIlJlcGxpY2F0aW9uIg0KICB9LA0KICB0aW1lOiB7DQogICAgYWRqZWN0aXZlOiB7IGhpZ2g6ICJUZW1wb3JhbCIsIG1pZDogIkNocm9uYWwiLCBsb3c6ICJUcmFuc2llbnQiIH0sDQogICAgbm91bjogIlRpbWUiDQogIH0sDQogIGRpbGF0aW9uOiB7DQogICAgYWRqZWN0aXZlOiB7IGhpZ2g6ICJEaWxhdGVkIiwgbWlkOiAiQXR0ZW51YXRlZCIsIGxvdzogIkRpbHV0ZWQiIH0sDQogICAgbm91bjogIkRpbGF0aW9uIg0KICB9LA0KfTsNCg0KZXhwb3J0IGRlZmF1bHQgew0KICBuYW1lOiAiR2x5cGhTZXROYW1lIiwNCiAgcHJvcHM6IHsNCiAgICBnbHlwaFNldDogew0KICAgICAgdHlwZTogQXJyYXksDQogICAgICByZXF1aXJlZDogdHJ1ZQ0KICAgIH0sDQogICAgZm9yY2VDb2xvcjogew0KICAgICAgdHlwZTogQm9vbGVhbiwNCiAgICAgIHJlcXVpcmVkOiBmYWxzZSwNCiAgICAgIGRlZmF1bHQ6IGZhbHNlDQogICAgfQ0KICB9LA0KICBkYXRhKCkgew0KICAgIHJldHVybiB7DQogICAgICBpc0NvbG9yZWQ6IHRydWUsDQogICAgICAvLyBBZGplY3RpdmVzIGFyZSBhZGRlZCBpbiBkZXNjZW5kaW5nIG9yZGVyIG9mIGFkak9yZGVyIChiYXNpYyBnbHlwaHMgYXJlIGhhbmRsZWQgdG9nZXRoZXIpDQogICAgICBnbHlwaFR5cGVMaXN0OiBbDQogICAgICAgIHsgdHlwZTogInBvd2VyIiwgcGVyYzogMCwgYWRqT3JkZXI6IDEgfSwNCiAgICAgICAgeyB0eXBlOiAiaW5maW5pdHkiLCBwZXJjOiAwLCBhZGpPcmRlcjogMSB9LA0KICAgICAgICB7IHR5cGU6ICJyZXBsaWNhdGlvbiIsIHBlcmM6IDAsIGFkak9yZGVyOiAxIH0sDQogICAgICAgIHsgdHlwZTogInRpbWUiLCBwZXJjOiAwLCBhZGpPcmRlcjogMSB9LA0KICAgICAgICB7IHR5cGU6ICJkaWxhdGlvbiIsIHBlcmM6IDAsIGFkak9yZGVyOiAxIH0sDQogICAgICAgIHsgdHlwZTogImVmZmFyaWciLCBwZXJjOiAwLCBhZGpPcmRlcjogMiB9LA0KICAgICAgICB7IHR5cGU6ICJtdXNpYyIsIHBlcmM6IDAsIGFkak9yZGVyOiAzIH0sDQogICAgICAgIHsgdHlwZTogInJlYWxpdHkiLCBwZXJjOiAwLCBhZGpPcmRlcjogNCB9LA0KICAgICAgICB7IHR5cGU6ICJjb21wYW5pb24iLCBwZXJjOiAwLCBhZGpPcmRlcjogNSB9LA0KICAgICAgICB7IHR5cGU6ICJjdXJzZWQiLCBwZXJjOiAwLCBhZGpPcmRlcjogNiB9LA0KICAgICAgXSwNCiAgICAgIHNvcnRlZEdseXBoczogW10sDQogICAgICBzbG90Q291bnQ6IDANCiAgICB9Ow0KICB9LA0KICBjb21wdXRlZDogew0KICAgIGlzRG9vbWVkOiAoKSA9PiBQZWxsZS5pc0Rvb21lZCwNCiAgICBzZXROYW1lKCkgew0KICAgICAgdGhpcy5zb3J0R2x5cGhMaXN0KCk7DQogICAgICBpZiAodGhpcy5zb3J0ZWRHbHlwaHMubGVuZ3RoID09PSAwKSByZXR1cm4gIlZvaWQiOw0KICAgICAgaWYgKHRoaXMuc29ydGVkR2x5cGhzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRoaXMuc2luZ2xldG9uTmFtZTsNCg0KICAgICAgLy8gRmlndXJlIG91dCB0aGUgbm91biBwYXJ0IG9mIHRoZSBuYW1lIGZpcnN0LiBJZiB3ZSBoYXZlIGJhc2ljIGdseXBocywgdGhpcyBpcyBnZW5lcmF0ZWQgdGhyb3VnaCBleGFtaW5pbmcgdGhvc2UNCiAgICAgIC8vIHNwZWNpZmljYWxseS4gT3RoZXJ3aXNlLCB3ZSB0YWtlIHRoZSBsb3dlc3QtcHJpb3JpdHkgc3BlY2lhbCBnbHlwaCBhbmQgdHVybiBpdCBpbnRvIGl0cyBub3VuIGZvcm0NCiAgICAgIGxldCBhZGpMaXN0LCBub3VuUGhyYXNlOw0KICAgICAgaWYgKHRoaXMuc29ydGVkR2x5cGhzLnNvbWUodCA9PiB0LmFkak9yZGVyID09PSAxKSkgew0KICAgICAgICBhZGpMaXN0ID0gdGhpcy5zb3J0ZWRHbHlwaHMuZmlsdGVyKHQgPT4gdC5hZGpPcmRlciAhPT0gMSk7DQogICAgICAgIG5vdW5QaHJhc2UgPSB0aGlzLmJhc2ljVHlwZVBocmFzZTsNCiAgICAgIH0gZWxzZSB7DQogICAgICAgIGFkakxpc3QgPSBbLi4udGhpcy5zb3J0ZWRHbHlwaHNdOw0KICAgICAgICBub3VuUGhyYXNlID0gdGhpcy5nZXROb3VuKGFkakxpc3QucG9wKCkpOw0KICAgICAgfQ0KDQogICAgICBjb25zdCBhZGplY3RpdmVzID0gW107DQogICAgICBmb3IgKGNvbnN0IGxpc3RFbnRyeSBvZiBhZGpMaXN0KSBhZGplY3RpdmVzLnB1c2godGhpcy5nZXRBZGplY3RpdmUobGlzdEVudHJ5KSk7DQogICAgICByZXR1cm4gYCR7YWRqZWN0aXZlcy5qb2luKCIgIil9ICR7bm91blBocmFzZX1gOw0KICAgIH0sDQogICAgYmFzaWNUeXBlUGhyYXNlKCkgew0KICAgICAgY29uc3QgYmFzaWNHbHlwaExpc3QgPSB0aGlzLnNvcnRlZEdseXBocy5maWx0ZXIodCA9PiBCQVNJQ19HTFlQSF9UWVBFUy5pbmNsdWRlcyh0LnR5cGUpICYmIHQucGVyYyAhPT0gMCk7DQogICAgICBzd2l0Y2ggKGJhc2ljR2x5cGhMaXN0Lmxlbmd0aCkgew0KICAgICAgICBjYXNlIDE6DQogICAgICAgICAgcmV0dXJuIEdMWVBIX05BTUVTW2Jhc2ljR2x5cGhMaXN0WzBdLnR5cGVdLm5vdW47DQogICAgICAgIGNhc2UgMjoNCiAgICAgICAgICAvLyBDYWxsIGl0IGEgbWl4dHVyZSBpZiB0aGV5J3JlIGVxdWFsIGFuZCBhcHBseSBhZGplY3RpdmVzIG9mIGFwcHJvcHJpYXRlIG1hZ25pdHVkZQ0KICAgICAgICAgIGlmIChiYXNpY0dseXBoTGlzdFswXS5wZXJjID09PSBiYXNpY0dseXBoTGlzdFsxXS5wZXJjKSB7DQogICAgICAgICAgICByZXR1cm4gW3RoaXMuZ2V0QWRqZWN0aXZlKGJhc2ljR2x5cGhMaXN0WzBdKSwNCiAgICAgICAgICAgICAgdGhpcy5nZXRBZGplY3RpdmUoYmFzaWNHbHlwaExpc3RbMV0pLA0KICAgICAgICAgICAgICAiTWl4dHVyZSINCiAgICAgICAgICAgIF0uam9pbigiICIpOw0KICAgICAgICAgIH0NCiAgICAgICAgICAvLyBPdGhlcndpc2UsIGdpdmUgaXQgYSBub3VuIGZyb20gdGhlIGxhcmdlc3QgY29tcG9uZW50DQogICAgICAgICAgcmV0dXJuIGAke3RoaXMuZ2V0QWRqZWN0aXZlKGJhc2ljR2x5cGhMaXN0WzFdKX0gJHt0aGlzLmdldE5vdW4oYmFzaWNHbHlwaExpc3RbMF0pfWA7DQogICAgICAgIGNhc2UgMzoNCiAgICAgICAgICAvLyBHaXZlIGl0IGEgbm91biBpZiB0aGVyZSdzIGEgY2xlYXIgbWFqb3JpdHkNCiAgICAgICAgICBpZiAoYmFzaWNHbHlwaExpc3RbMF0ucGVyYyA+IGJhc2ljR2x5cGhMaXN0WzFdLnBlcmMpIHsNCiAgICAgICAgICAgIHJldHVybiBbdGhpcy5nZXRBZGplY3RpdmUoYmFzaWNHbHlwaExpc3RbMV0pLA0KICAgICAgICAgICAgICB0aGlzLmdldEFkamVjdGl2ZShiYXNpY0dseXBoTGlzdFsyXSksDQogICAgICAgICAgICAgIHRoaXMuZ2V0Tm91bihiYXNpY0dseXBoTGlzdFswXSksDQogICAgICAgICAgICBdLmpvaW4oIiAiKTsNCiAgICAgICAgICB9DQogICAgICAgICAgLy8gVGhpcyBpcyByZWxhdGl2ZWx5IHJhcmU7IHdlIGhhdmUgMS8xLzEsIHdoaWNoIG1lYW5zIHRoYXQgd2UgbWF5IGFsc28gYWxyZWFkeSBoYXZlIDMgb3RoZXIgYWRqZWN0aXZlcy4NCiAgICAgICAgICAvLyBJbiB0aGlzIGNhc2Ugd2UgbWFrZSBhbiBleGNlcHRpb24gYW5kIHNob3J0ZW4gdGhlIG5hbWUgaW5zdGVhZCBvZiBwcm92aWRpbmcgYW5vdGhlciA0IHdvcmRzDQogICAgICAgICAgaWYgKGJhc2ljR2x5cGhMaXN0WzBdLnBlcmMgPT09IGJhc2ljR2x5cGhMaXN0WzJdLnBlcmMpIHJldHVybiAiTWl4ZWQgSXJyZWd1bGFyaXR5IjsNCiAgICAgICAgICAvLyBUaGUgb25seSBjYXNlIGxlZnQgaXMgMi8yLzEsIHdoZXJlIHdlIGhhdmUgcGxlbnR5IG9mIHJvb20gZm9yIHdvcmRzDQogICAgICAgICAgcmV0dXJuIFt0aGlzLmdldEFkamVjdGl2ZShiYXNpY0dseXBoTGlzdFswXSksDQogICAgICAgICAgICB0aGlzLmdldEFkamVjdGl2ZShiYXNpY0dseXBoTGlzdFsxXSksDQogICAgICAgICAgICB0aGlzLmdldEFkamVjdGl2ZShiYXNpY0dseXBoTGlzdFsyXSksDQogICAgICAgICAgICAiSXJyZWd1bGFyaXR5Ig0KICAgICAgICAgIF0uam9pbigiICIpOw0KICAgICAgICBjYXNlIDQ6DQogICAgICAgICAgLy8gRG9uJ3QgYm90aGVyIGZpbGxpbmcgdGhlIG5hbWUgd2l0aCBleGNlc3NpdmUgYWRqZWN0aXZlcyBpZiB3ZSBoYXZlIGFuIGVxdWFsIHByb3BvcnRpb24gKDEvMS8xLzEpLA0KICAgICAgICAgIC8vIG90aGVyd2lzZSB3ZSB0YWtlIHRoZSBsYXJnZXN0IGNvbXBvbmVudCBhbmQgaWdub3JlIGFsbCB0aGUgb3RoZXJzICgyLzEvMS8xKQ0KICAgICAgICAgIGlmIChiYXNpY0dseXBoTGlzdFswXS5wZXJjID09PSBiYXNpY0dseXBoTGlzdFsxXS5wZXJjKSByZXR1cm4gIklycmVndWxhciBKdW1ibGUiOw0KICAgICAgICAgIHJldHVybiBgJHt0aGlzLmdldEFkamVjdGl2ZShiYXNpY0dseXBoTGlzdFswXSl9IEp1bWJsZWA7DQogICAgICAgIGNhc2UgNToNCiAgICAgICAgICAvLyBUaGlzIGlzIGluIHJlZmVyZW5jZSB0byB0aGUgYWNoaWV2ZW1lbnQgbmFtZSwgYW5kIGNhbiBvbmx5IG9jY3VyIHdpdGggZXhhY3RseSBvbmUgb2YgZXZlcnkgYmFzaWMgZ2x5cGguDQogICAgICAgICAgLy8gRHVlIHRvIG11c2ljIGdseXBocyBkb3VibGluZy11cCBjb250cmlidXRpb25zLCB0aGlzIG1heSByZXN1bHQgaW4gYSAiTWVsb2RpYyBSb3lhbCBGbHVzaCIgb3Igc2ltaWxhcg0KICAgICAgICAgIHJldHVybiAiUm95YWwgRmx1c2giOw0KICAgICAgICBkZWZhdWx0Og0KICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiVW5leHBlY3RlZCBnbHlwaCBzZXQgY29uZmlndXJhdGlvbiBpbiBHbHlwaFNldE5hbWUiKTsNCiAgICAgIH0NCiAgICB9LA0KICAgIC8vIENoZWNrIGZvciBzaW5nbGUtdHlwZSBzZXRzIGFuZCBnaXZlIHRoZW0gYSBzcGVjaWFsIG5hbWUgYmFzZWQgb24gaG93IG11Y2ggb2YgdGhlIGZ1bGwgZXF1aXBwZWQgc2xvdHMgdGhleSB0YWtlIHVwDQogICAgc2luZ2xldG9uTmFtZSgpIHsNCiAgICAgIGlmICh0aGlzLnNvcnRlZEdseXBoc1swXS50eXBlID09PSAiZWZmYXJpZyIpIHJldHVybiBHTFlQSF9OQU1FUy5lZmZhcmlnLm5vdW5bdGhpcy5nZXRFZmZhcmlnUHJvcCgpXTsNCiAgICAgIGNvbnN0IHNpbmdsZUdseXBoVHlwZXMgPSBbInJlYWxpdHkiLCAiY29tcGFuaW9uIl07DQogICAgICBmb3IgKGNvbnN0IGtleSBvZiBzaW5nbGVHbHlwaFR5cGVzKSB7DQogICAgICAgIGlmICh0aGlzLnNvcnRlZEdseXBoc1swXS50eXBlID09PSBrZXkpIHJldHVybiBHTFlQSF9OQU1FU1trZXldLm5vdW47DQogICAgICB9DQoNCiAgICAgIC8vIFdlIHdhbnQgYSBiaXQgb2YgYWRkaXRpb25hbCBmbGF2b3IgZm9yIHBhcnRpYWxseS1maWxsZWQgc2V0cw0KICAgICAgY29uc3Qgd29yZCA9IEdMWVBIX05BTUVTW3RoaXMuc29ydGVkR2x5cGhzWzBdLnR5cGVdLm5vdW47DQogICAgICBjb25zdCBwZXJjID0gdGhpcy5zb3J0ZWRHbHlwaHNbMF0ucGVyYzsNCiAgICAgIGlmICh0aGlzLmlzRG9vbWVkKSByZXR1cm4gYERvb21lZCAke3dvcmR9YDsNCiAgICAgIGlmIChwZXJjID09PSAxMDApIHJldHVybiBgRnVsbCAke3dvcmR9YDsNCiAgICAgIGlmIChwZXJjID49IDc1KSByZXR1cm4gYFN0cmVuZ3RoZW5lZCAke3dvcmR9YDsNCiAgICAgIGlmIChwZXJjID49IDQwKSByZXR1cm4gYFBhcnRpYWwgJHt3b3JkfWA7DQogICAgICByZXR1cm4gYFdlYWsgJHt3b3JkfWA7DQogICAgfSwNCiAgICBtYWluR2x5cGhOYW1lKCkgew0KICAgICAgLy8gVGhpcyByZXR1cm5zIHRoZSB0eXBlIG9mIEdseXBoIHRoYXQgd2Ugd2FudCBmb3IgY29sb3IgZGV0ZXJtaW5hdGlvbnMuDQogICAgICAvLyBUaGUgcHJpb3JpdHkgaXMgRW1wdHkgPiBDdXJzZWQgPiBDb21wYW5pb24gPiBSZWFsaXR5ID4gNTAlIG9yIG1vcmUgbm9ybWFsIEdseXBocyA+IEVmZmFyaWcgPiBhbnkgbm9ybWFsIEdseXBoDQogICAgICBpZiAodGhpcy5zb3J0ZWRHbHlwaHMubGVuZ3RoID09PSAwKSByZXR1cm4geyBpZDogIm5vbmUiLCBjdXJyZW50Q29sb3I6IHsgYm9yZGVyOiAiIzg4ODg4OCIgfSB9Ow0KICAgICAgaWYgKHRoaXMuY2FsY3VsYXRlR2x5cGhQZXJjZW50KCJjdXJzZWQiKSkgcmV0dXJuIENvc21ldGljR2x5cGhUeXBlcy5jdXJzZWQ7DQogICAgICBpZiAodGhpcy5jYWxjdWxhdGVHbHlwaFBlcmNlbnQoImNvbXBhbmlvbiIpKSByZXR1cm4gQ29zbWV0aWNHbHlwaFR5cGVzLmNvbXBhbmlvbjsNCiAgICAgIGlmICh0aGlzLmNhbGN1bGF0ZUdseXBoUGVyY2VudCgicmVhbGl0eSIpKSByZXR1cm4gQ29zbWV0aWNHbHlwaFR5cGVzLnJlYWxpdHk7DQogICAgICBpZiAodGhpcy5jYWxjdWxhdGVHbHlwaFBlcmNlbnQoIm11c2ljIikgPj0gNTApIHJldHVybiBDb3NtZXRpY0dseXBoVHlwZXMubXVzaWM7DQogICAgICBjb25zdCBwcmltYXJ5VHlwZSA9IHRoaXMuc29ydGVkR2x5cGhzLmZpbHRlcih0ID0+IHQuYWRqT3JkZXIgPT09IDEpWzBdOw0KICAgICAgaWYgKHByaW1hcnlUeXBlPy5wZXJjID49IDUwKSByZXR1cm4gQ29zbWV0aWNHbHlwaFR5cGVzW3ByaW1hcnlUeXBlLnR5cGVdOw0KICAgICAgaWYgKHRoaXMuY2FsY3VsYXRlR2x5cGhQZXJjZW50KCJlZmZhcmlnIikpIHJldHVybiBDb3NtZXRpY0dseXBoVHlwZXMuZWZmYXJpZzsNCiAgICAgIHJldHVybiBDb3NtZXRpY0dseXBoVHlwZXNbcHJpbWFyeVR5cGUudHlwZV07DQogICAgfSwNCiAgICB0ZXh0Q29sb3IoKSB7DQogICAgICAvLyBJZiBpdCdzIHRoZSBzaW5ndWxhciBlcXVpcHBlZCBnbHlwaCBpbiBEb29tZWQsIHdlIGNvbG9yIGl0IGNyaW1zb24NCiAgICAgIC8vIElmIGl0cyBjdXJzZWQsIHdlIGdpdmUgaXQgdGhlIGNlbGVzdGlhbCBjb2xvciBiZWNhdXNlIHRoZSBkZWZhdWx0ICh3aXRob3V0IGNvc21ldGljcykgYmxhY2sgaXMgb2Z0ZW4gdW5yZWFkYWJsZQ0KICAgICAgLy8gSWYgd2UgaGF2ZSAzIHR5cGVzIG9mIEdseXBocywgYW5kIG5vbmUgb2YgdGhlbSBoYXZlIG1vcmUgdGhhbiAzMCUgdG90YWwsIGxldHMgZ2V0IGEgY29wcGVyIGNvbG9yLg0KICAgICAgLy8gQW5kIGlmIHdlIGhhdmUgbm9uZSBvZiB0aGUgYWJvdmUgKHdoaWNoIGlzIG1vc3QgY29tbW9uKSwgbGV0cyBnZXQgdGhlIGNvbG9yIG9mIHRoZSBtYWluIEdseXBoLg0KICAgICAgaWYgKHRoaXMuaXNEb29tZWQgJiYgdGhpcy5nbHlwaFNldC5sZW5ndGggPT09IDEpIHJldHVybiAidmFyKC0tY29sb3ItcGVsbGUtLWJhc2UpIjsNCiAgICAgIGlmICh0aGlzLm1haW5HbHlwaE5hbWUuaWQgPT09ICJjdXJzZWQiKSByZXR1cm4gInZhcigtLWNvbG9yLWNlbGVzdGlhbHMpIjsNCiAgICAgIGlmICh0aGlzLm1haW5HbHlwaE5hbWUuaWQgPT09ICJtdXNpYyIpIHJldHVybiBDb3NtZXRpY0dseXBoVHlwZXMubXVzaWMuY3VycmVudENvbG9yLmJvcmRlcjsNCiAgICAgIGlmICh0aGlzLnNvcnRlZEdseXBocy5sZW5ndGggPj0gMyAmJiB0aGlzLnNvcnRlZEdseXBoc1swXS5wZXJjIDw9IDMwKSByZXR1cm4gIiNDNDYyMDAiOw0KICAgICAgcmV0dXJuIHRoaXMubWFpbkdseXBoTmFtZS5jdXJyZW50Q29sb3IuYm9yZGVyOw0KICAgIH0sDQogICAgdGV4dFN0eWxlKCkgew0KICAgICAgdGhpcy4kcmVjb21wdXRlKCJtYWluR2x5cGhOYW1lIik7DQogICAgICAvLyBJZiB5b3UgaGF2ZSB0aGUgcGxheWVyIG9wdGlvbiB0byBub3Qgc2hvdyBjb2xvciBlbmFibGVkLCBhbmQgdGhpcyBpc24ndCBhIHNwZWNpYWwgY2FzZSBmb3JjaW5nIGNvbG9yLCByZXR1cm4ge30NCiAgICAgIGlmICghdGhpcy5pc0NvbG9yZWQgJiYgIXRoaXMuZm9yY2VDb2xvcikgcmV0dXJuIHt9Ow0KICAgICAgLy8gT3RoZXJ3aXNlLCBsZXRzIHNldCB0aGUgc2hhZG93IHRvIGJlIDQsIGVhY2ggb2Zmc2V0IHRvIGEgZGlmZmVyZW50IGNvcm5lciwgYW5kIGJsdXJpbmcgYnkgMXB4LA0KICAgICAgLy8gdGhlbiBibHVyaW5nIGJ5IDNweCB3aXRoIG5vIG9mZnNldCB3aXRoIHRoZSBzYW1lIGNvbG9yIGFzIHRoZSB0ZXh0Lg0KICAgICAgLy8gSWYgaXRzIGEgUmVhbGl0eSBHbHlwaCwgYXNzaWduIGl0IFJlYWxpdHkgR2x5cGgncyBhbmltYXRpb24uDQogICAgICByZXR1cm4gew0KICAgICAgICBjb2xvcjogdGhpcy50ZXh0Q29sb3IsDQogICAgICAgICJ0ZXh0LXNoYWRvdyI6IGAtMXB4IDFweCAxcHggdmFyKC0tY29sb3ItdGV4dC1iYXNlKSwgMXB4IDFweCAxcHggdmFyKC0tY29sb3ItdGV4dC1iYXNlKSwNCiAgICAgICAgICAgICAgICAgICAgICAgIC0xcHggLTFweCAxcHggdmFyKC0tY29sb3ItdGV4dC1iYXNlKSwgMXB4IC0xcHggMXB4IHZhcigtLWNvbG9yLXRleHQtYmFzZSksDQogICAgICAgICAgICAgICAgICAgICAgICAwIDAgM3B4ICR7dGhpcy50ZXh0Q29sb3J9YCwNCiAgICAgICAgYW5pbWF0aW9uOiB0aGlzLm1haW5HbHlwaE5hbWUuaWQgPT09ICJyZWFsaXR5IiA/ICJhLXJlYWxpdHktZ2x5cGgtZGVzY3JpcHRpb24tY3ljbGUgMTBzIGluZmluaXRlIiA6IHVuZGVmaW5lZCwNCiAgICAgIH07DQogICAgfQ0KICB9LA0KICBjcmVhdGVkKCkgew0KICAgIHRoaXMub24kKEdBTUVfRVZFTlQuR0xZUEhTX0NIQU5HRUQsIHRoaXMuc29ydEdseXBoTGlzdCk7DQogICAgdGhpcy5zb3J0R2x5cGhMaXN0KCk7DQogIH0sDQogIG1ldGhvZHM6IHsNCiAgICB1cGRhdGUoKSB7DQogICAgICB0aGlzLmlzQ29sb3JlZCA9IHBsYXllci5vcHRpb25zLmdseXBoVGV4dENvbG9yczsNCiAgICAgIC8vIFdpdGhvdXQgbWF4LCBEb29tZWQgbWF5IHJldHJvYWN0aXZlbHkgemVybyB0aGUgc2xvdCBjb3VudCBvZiBvbGRlciBzZXRzIGluIHJlY29yZHMgYW5kIG1lc3MgdXAgdGhlaXIgbmFtZXMNCiAgICAgIC8vIFRoaXMgY2FuIHJldHJvYWN0aXZlbHkgY2hhbmdlIG5hbWVzIG9uIG9sZCBzZXRzIHdoZW4gZ2FpbmluZyBuZXcgc2xvdHMgaW4gcmVhbGl0eSB1cGdyYWRlcywgYnV0IHRoaXMgaXMNCiAgICAgIC8vIHByb2JhYmx5IGFjY2VwdGFibGUgc2luY2UgdGhlIG9sZCBuYW1lcyBtYXkgaGF2ZSBiZWNvbWUgdW5hdHRhaW5hYmxlIHdpdGggdGhlIG5ldyBzbG90IGNvdW50IGFueXdheQ0KICAgICAgdGhpcy5zbG90Q291bnQgPSBNYXRoLm1heChHbHlwaHMuYWN0aXZlU2xvdENvdW50LCB0aGlzLmdseXBoU2V0Lmxlbmd0aCk7DQogICAgfSwNCiAgICBnZXRFZmZhcmlnUHJvcCgpIHsNCiAgICAgIGNvbnN0IGVmZmFyaWdSTSA9IHRoaXMuZ2x5cGhTZXQuc29tZShpID0+IGdldFNpbmdsZUdseXBoRWZmZWN0RnJvbUJpdG1hc2soImVmZmFyaWdybSIsIGkpKTsNCiAgICAgIGNvbnN0IGVmZmFyaWdHbHlwaCA9IHRoaXMuZ2x5cGhTZXQuc29tZShpID0+IGdldFNpbmdsZUdseXBoRWZmZWN0RnJvbUJpdG1hc2soImVmZmFyaWdnbHlwaCIsIGkpKTsNCiAgICAgIGlmIChlZmZhcmlnUk0gJiYgZWZmYXJpZ0dseXBoKSByZXR1cm4gImJvdGgiOw0KICAgICAgaWYgKGVmZmFyaWdSTSkgcmV0dXJuICJybSI7DQogICAgICBpZiAoZWZmYXJpZ0dseXBoKSByZXR1cm4gImdseXBoIjsNCiAgICAgIHJldHVybiAibm9uZSI7DQogICAgfSwNCiAgICBjYWxjdWxhdGVHbHlwaFBlcmNlbnQobmFtZSkgew0KICAgICAgY29uc3QgcGVyY2VudFBlckdseXBoID0gdGhpcy5zbG90Q291bnQgPyAxMDAgLyB0aGlzLnNsb3RDb3VudCA6IDA7DQogICAgICBpZiAobmFtZSA9PT0gIm11c2ljIikgcmV0dXJuIHRoaXMuZ2x5cGhTZXQuZmlsdGVyKGkgPT4gR2x5cGhzLmlzTXVzaWNHbHlwaChpKSkubGVuZ3RoICogcGVyY2VudFBlckdseXBoOw0KICAgICAgLy8gVGFrZSB0aGUgYW1vdW50IG9mIGEgdHlwZSBvZiBnbHlwaCBpbiB0aGUgc2V0LCBkaXZpZGUgYnkgdGhlIG1heGltdW0gbnVtYmVyIG9mIGdseXBocywgdGhlbiAqIDEwMCB0byBnZXQgJQ0KICAgICAgcmV0dXJuIHRoaXMuZ2x5cGhTZXQuZmlsdGVyKGkgPT4gaS50eXBlID09PSBuYW1lKS5sZW5ndGggKiBwZXJjZW50UGVyR2x5cGg7DQogICAgfSwNCiAgICBzb3J0R2x5cGhMaXN0KCkgew0KICAgICAgdGhpcy4kcmVjb21wdXRlKCJ0ZXh0Q29sb3IiKTsNCiAgICAgIHRoaXMuZ2x5cGhUeXBlTGlzdC5mb3JFYWNoKHQgPT4gdC5wZXJjID0gdGhpcy5jYWxjdWxhdGVHbHlwaFBlcmNlbnQodC50eXBlKSk7DQogICAgICB0aGlzLnNvcnRlZEdseXBocyA9IHRoaXMuZ2x5cGhUeXBlTGlzdC5maWx0ZXIodCA9PiB0LnBlcmMgIT09IDApOw0KICAgICAgLy8gVGhpcyBjb21wb3NpdGUgZnVuY3Rpb24gaXMgcmVxdWlyZWQgaW4gb3JkZXIgdG8gZW5zdXJlIGNvbnNpc3RlbnQgbmFtZXMgd2l0aCBlcXVhbCBwZXJjZW50YWdlcywgYXMgSlMgZG9lc24ndA0KICAgICAgLy8gZ3VhcmFudGVlIC5zb3J0KCkgb3BlcmF0aW9ucyBhcmUgc3RhYmxlIHNvcnRzLiBTb3J0cyBieSBhZGpPcmRlciwgZm9sbG93ZWQgYnkgcGVyYywgZm9sbG93ZWQgYnkgYWxwaGFiZXRpY2FsLg0KICAgICAgY29uc3Qgc29ydEZuID0gdCA9PiAxMDAgKiB0LmFkak9yZGVyICsgdC5wZXJjICsgdC50eXBlLmNoYXJDb2RlQXQoMCkgLyAxMDAwOw0KICAgICAgdGhpcy5zb3J0ZWRHbHlwaHMuc29ydCgoYSwgYikgPT4gc29ydEZuKGIpIC0gc29ydEZuKGEpKTsNCiAgICB9LA0KICAgIGdldEFkamVjdGl2ZShsaXN0RW50cnkpIHsNCiAgICAgIGlmIChsaXN0RW50cnkudHlwZSA9PT0gImVmZmFyaWciKSByZXR1cm4gR0xZUEhfTkFNRVMuZWZmYXJpZy5hZGplY3RpdmVbdGhpcy5nZXRFZmZhcmlnUHJvcCgpXTsNCiAgICAgIGNvbnN0IGFkakZuID0gdmFsID0+IHsNCiAgICAgICAgaWYgKHZhbCA+PSA2MCkgcmV0dXJuICJoaWdoIjsNCiAgICAgICAgaWYgKHZhbCA+PSA0MCkgcmV0dXJuICJtaWQiOw0KICAgICAgICByZXR1cm4gImxvdyI7DQogICAgICB9Ow0KICAgICAgY29uc3QgYWRqID0gR0xZUEhfTkFNRVNbbGlzdEVudHJ5LnR5cGVdLmFkamVjdGl2ZTsNCiAgICAgIHJldHVybiB0eXBlb2YgYWRqID09PSAic3RyaW5nIiA/IGFkaiA6IGFkalthZGpGbihsaXN0RW50cnkucGVyYyldOw0KICAgIH0sDQogICAgZ2V0Tm91bihsaXN0RW50cnkpIHsNCiAgICAgIGlmIChsaXN0RW50cnkudHlwZSA9PT0gImVmZmFyaWciKSByZXR1cm4gR0xZUEhfTkFNRVMuZWZmYXJpZy5ub3VuW3RoaXMuZ2V0RWZmYXJpZ1Byb3AoKV07DQogICAgICByZXR1cm4gR0xZUEhfTkFNRVNbbGlzdEVudHJ5LnR5cGVdLm5vdW47DQogICAgfSwNCiAgfQ0KfTsNCg=="},{"version":3,"sources":["GlyphSetName.vue"],"names":[],"mappings":";AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"GlyphSetName.vue","sourceRoot":"src/components","sourcesContent":["<script>\r\nconst GLYPH_NAMES = {\r\n  companion: {\r\n    adjective: \"Huggable\",\r\n    noun: \"Companion\"\r\n  },\r\n  reality: {\r\n    adjective: \"Real\",\r\n    noun: \"Reality\"\r\n  },\r\n  music: {\r\n    adjective: { high: \"Melodic\", mid: \"Chordal\", low: \"Tuned\" },\r\n    // This noun is only used in the case of a single companion reskinned as music (resulting in \"Huggable Music\");\r\n    // otherwise the set's noun will always come from an actual glyph type instead of music\r\n    noun: \"Music\"\r\n  },\r\n  effarig: {\r\n    adjective: { both: \"Meta\", glyph: \"Stable\", rm: \"Mechanical\", none: \"Fragmented\" },\r\n    noun: { both: \"Effarig\", glyph: \"Stability\", rm: \"Mechanism\", none: \"Fragmentation\" }\r\n  },\r\n  cursed: {\r\n    adjective: { high: \"Cursed\", mid: \"Hexed\", low: \"Jinxed\" },\r\n    noun: \"Curse\"\r\n  },\r\n  power: {\r\n    adjective: { high: \"Powerful\", mid: \"Mastered\", low: \"Potential\" },\r\n    noun: \"Power\"\r\n  },\r\n  infinity: {\r\n    adjective: { high: \"Infinite\", mid: \"Boundless\", low: \"Immense\" },\r\n    noun: \"Infinity\"\r\n  },\r\n  replication: {\r\n    adjective: { high: \"Replicated\", mid: \"Simulated\", low: \"Duplicated\" },\r\n    noun: \"Replication\"\r\n  },\r\n  time: {\r\n    adjective: { high: \"Temporal\", mid: \"Chronal\", low: \"Transient\" },\r\n    noun: \"Time\"\r\n  },\r\n  dilation: {\r\n    adjective: { high: \"Dilated\", mid: \"Attenuated\", low: \"Diluted\" },\r\n    noun: \"Dilation\"\r\n  },\r\n};\r\n\r\nexport default {\r\n  name: \"GlyphSetName\",\r\n  props: {\r\n    glyphSet: {\r\n      type: Array,\r\n      required: true\r\n    },\r\n    forceColor: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: false\r\n    }\r\n  },\r\n  data() {\r\n    return {\r\n      isColored: true,\r\n      // Adjectives are added in descending order of adjOrder (basic glyphs are handled together)\r\n      glyphTypeList: [\r\n        { type: \"power\", perc: 0, adjOrder: 1 },\r\n        { type: \"infinity\", perc: 0, adjOrder: 1 },\r\n        { type: \"replication\", perc: 0, adjOrder: 1 },\r\n        { type: \"time\", perc: 0, adjOrder: 1 },\r\n        { type: \"dilation\", perc: 0, adjOrder: 1 },\r\n        { type: \"effarig\", perc: 0, adjOrder: 2 },\r\n        { type: \"music\", perc: 0, adjOrder: 3 },\r\n        { type: \"reality\", perc: 0, adjOrder: 4 },\r\n        { type: \"companion\", perc: 0, adjOrder: 5 },\r\n        { type: \"cursed\", perc: 0, adjOrder: 6 },\r\n      ],\r\n      sortedGlyphs: [],\r\n      slotCount: 0\r\n    };\r\n  },\r\n  computed: {\r\n    isDoomed: () => Pelle.isDoomed,\r\n    setName() {\r\n      this.sortGlyphList();\r\n      if (this.sortedGlyphs.length === 0) return \"Void\";\r\n      if (this.sortedGlyphs.length === 1) return this.singletonName;\r\n\r\n      // Figure out the noun part of the name first. If we have basic glyphs, this is generated through examining those\r\n      // specifically. Otherwise, we take the lowest-priority special glyph and turn it into its noun form\r\n      let adjList, nounPhrase;\r\n      if (this.sortedGlyphs.some(t => t.adjOrder === 1)) {\r\n        adjList = this.sortedGlyphs.filter(t => t.adjOrder !== 1);\r\n        nounPhrase = this.basicTypePhrase;\r\n      } else {\r\n        adjList = [...this.sortedGlyphs];\r\n        nounPhrase = this.getNoun(adjList.pop());\r\n      }\r\n\r\n      const adjectives = [];\r\n      for (const listEntry of adjList) adjectives.push(this.getAdjective(listEntry));\r\n      return `${adjectives.join(\" \")} ${nounPhrase}`;\r\n    },\r\n    basicTypePhrase() {\r\n      const basicGlyphList = this.sortedGlyphs.filter(t => BASIC_GLYPH_TYPES.includes(t.type) && t.perc !== 0);\r\n      switch (basicGlyphList.length) {\r\n        case 1:\r\n          return GLYPH_NAMES[basicGlyphList[0].type].noun;\r\n        case 2:\r\n          // Call it a mixture if they're equal and apply adjectives of appropriate magnitude\r\n          if (basicGlyphList[0].perc === basicGlyphList[1].perc) {\r\n            return [this.getAdjective(basicGlyphList[0]),\r\n              this.getAdjective(basicGlyphList[1]),\r\n              \"Mixture\"\r\n            ].join(\" \");\r\n          }\r\n          // Otherwise, give it a noun from the largest component\r\n          return `${this.getAdjective(basicGlyphList[1])} ${this.getNoun(basicGlyphList[0])}`;\r\n        case 3:\r\n          // Give it a noun if there's a clear majority\r\n          if (basicGlyphList[0].perc > basicGlyphList[1].perc) {\r\n            return [this.getAdjective(basicGlyphList[1]),\r\n              this.getAdjective(basicGlyphList[2]),\r\n              this.getNoun(basicGlyphList[0]),\r\n            ].join(\" \");\r\n          }\r\n          // This is relatively rare; we have 1/1/1, which means that we may also already have 3 other adjectives.\r\n          // In this case we make an exception and shorten the name instead of providing another 4 words\r\n          if (basicGlyphList[0].perc === basicGlyphList[2].perc) return \"Mixed Irregularity\";\r\n          // The only case left is 2/2/1, where we have plenty of room for words\r\n          return [this.getAdjective(basicGlyphList[0]),\r\n            this.getAdjective(basicGlyphList[1]),\r\n            this.getAdjective(basicGlyphList[2]),\r\n            \"Irregularity\"\r\n          ].join(\" \");\r\n        case 4:\r\n          // Don't bother filling the name with excessive adjectives if we have an equal proportion (1/1/1/1),\r\n          // otherwise we take the largest component and ignore all the others (2/1/1/1)\r\n          if (basicGlyphList[0].perc === basicGlyphList[1].perc) return \"Irregular Jumble\";\r\n          return `${this.getAdjective(basicGlyphList[0])} Jumble`;\r\n        case 5:\r\n          // This is in reference to the achievement name, and can only occur with exactly one of every basic glyph.\r\n          // Due to music glyphs doubling-up contributions, this may result in a \"Melodic Royal Flush\" or similar\r\n          return \"Royal Flush\";\r\n        default:\r\n          throw new Error(\"Unexpected glyph set configuration in GlyphSetName\");\r\n      }\r\n    },\r\n    // Check for single-type sets and give them a special name based on how much of the full equipped slots they take up\r\n    singletonName() {\r\n      if (this.sortedGlyphs[0].type === \"effarig\") return GLYPH_NAMES.effarig.noun[this.getEffarigProp()];\r\n      const singleGlyphTypes = [\"reality\", \"companion\"];\r\n      for (const key of singleGlyphTypes) {\r\n        if (this.sortedGlyphs[0].type === key) return GLYPH_NAMES[key].noun;\r\n      }\r\n\r\n      // We want a bit of additional flavor for partially-filled sets\r\n      const word = GLYPH_NAMES[this.sortedGlyphs[0].type].noun;\r\n      const perc = this.sortedGlyphs[0].perc;\r\n      if (this.isDoomed) return `Doomed ${word}`;\r\n      if (perc === 100) return `Full ${word}`;\r\n      if (perc >= 75) return `Strengthened ${word}`;\r\n      if (perc >= 40) return `Partial ${word}`;\r\n      return `Weak ${word}`;\r\n    },\r\n    mainGlyphName() {\r\n      // This returns the type of Glyph that we want for color determinations.\r\n      // The priority is Empty > Cursed > Companion > Reality > 50% or more normal Glyphs > Effarig > any normal Glyph\r\n      if (this.sortedGlyphs.length === 0) return { id: \"none\", currentColor: { border: \"#888888\" } };\r\n      if (this.calculateGlyphPercent(\"cursed\")) return CosmeticGlyphTypes.cursed;\r\n      if (this.calculateGlyphPercent(\"companion\")) return CosmeticGlyphTypes.companion;\r\n      if (this.calculateGlyphPercent(\"reality\")) return CosmeticGlyphTypes.reality;\r\n      if (this.calculateGlyphPercent(\"music\") >= 50) return CosmeticGlyphTypes.music;\r\n      const primaryType = this.sortedGlyphs.filter(t => t.adjOrder === 1)[0];\r\n      if (primaryType?.perc >= 50) return CosmeticGlyphTypes[primaryType.type];\r\n      if (this.calculateGlyphPercent(\"effarig\")) return CosmeticGlyphTypes.effarig;\r\n      return CosmeticGlyphTypes[primaryType.type];\r\n    },\r\n    textColor() {\r\n      // If it's the singular equipped glyph in Doomed, we color it crimson\r\n      // If its cursed, we give it the celestial color because the default (without cosmetics) black is often unreadable\r\n      // If we have 3 types of Glyphs, and none of them have more than 30% total, lets get a copper color.\r\n      // And if we have none of the above (which is most common), lets get the color of the main Glyph.\r\n      if (this.isDoomed && this.glyphSet.length === 1) return \"var(--color-pelle--base)\";\r\n      if (this.mainGlyphName.id === \"cursed\") return \"var(--color-celestials)\";\r\n      if (this.mainGlyphName.id === \"music\") return CosmeticGlyphTypes.music.currentColor.border;\r\n      if (this.sortedGlyphs.length >= 3 && this.sortedGlyphs[0].perc <= 30) return \"#C46200\";\r\n      return this.mainGlyphName.currentColor.border;\r\n    },\r\n    textStyle() {\r\n      this.$recompute(\"mainGlyphName\");\r\n      // If you have the player option to not show color enabled, and this isn't a special case forcing color, return {}\r\n      if (!this.isColored && !this.forceColor) return {};\r\n      // Otherwise, lets set the shadow to be 4, each offset to a different corner, and bluring by 1px,\r\n      // then bluring by 3px with no offset with the same color as the text.\r\n      // If its a Reality Glyph, assign it Reality Glyph's animation.\r\n      return {\r\n        color: this.textColor,\r\n        \"text-shadow\": `-1px 1px 1px var(--color-text-base), 1px 1px 1px var(--color-text-base),\r\n                        -1px -1px 1px var(--color-text-base), 1px -1px 1px var(--color-text-base),\r\n                        0 0 3px ${this.textColor}`,\r\n        animation: this.mainGlyphName.id === \"reality\" ? \"a-reality-glyph-description-cycle 10s infinite\" : undefined,\r\n      };\r\n    }\r\n  },\r\n  created() {\r\n    this.on$(GAME_EVENT.GLYPHS_CHANGED, this.sortGlyphList);\r\n    this.sortGlyphList();\r\n  },\r\n  methods: {\r\n    update() {\r\n      this.isColored = player.options.glyphTextColors;\r\n      // Without max, Doomed may retroactively zero the slot count of older sets in records and mess up their names\r\n      // This can retroactively change names on old sets when gaining new slots in reality upgrades, but this is\r\n      // probably acceptable since the old names may have become unattainable with the new slot count anyway\r\n      this.slotCount = Math.max(Glyphs.activeSlotCount, this.glyphSet.length);\r\n    },\r\n    getEffarigProp() {\r\n      const effarigRM = this.glyphSet.some(i => getSingleGlyphEffectFromBitmask(\"effarigrm\", i));\r\n      const effarigGlyph = this.glyphSet.some(i => getSingleGlyphEffectFromBitmask(\"effarigglyph\", i));\r\n      if (effarigRM && effarigGlyph) return \"both\";\r\n      if (effarigRM) return \"rm\";\r\n      if (effarigGlyph) return \"glyph\";\r\n      return \"none\";\r\n    },\r\n    calculateGlyphPercent(name) {\r\n      const percentPerGlyph = this.slotCount ? 100 / this.slotCount : 0;\r\n      if (name === \"music\") return this.glyphSet.filter(i => Glyphs.isMusicGlyph(i)).length * percentPerGlyph;\r\n      // Take the amount of a type of glyph in the set, divide by the maximum number of glyphs, then * 100 to get %\r\n      return this.glyphSet.filter(i => i.type === name).length * percentPerGlyph;\r\n    },\r\n    sortGlyphList() {\r\n      this.$recompute(\"textColor\");\r\n      this.glyphTypeList.forEach(t => t.perc = this.calculateGlyphPercent(t.type));\r\n      this.sortedGlyphs = this.glyphTypeList.filter(t => t.perc !== 0);\r\n      // This composite function is required in order to ensure consistent names with equal percentages, as JS doesn't\r\n      // guarantee .sort() operations are stable sorts. Sorts by adjOrder, followed by perc, followed by alphabetical.\r\n      const sortFn = t => 100 * t.adjOrder + t.perc + t.type.charCodeAt(0) / 1000;\r\n      this.sortedGlyphs.sort((a, b) => sortFn(b) - sortFn(a));\r\n    },\r\n    getAdjective(listEntry) {\r\n      if (listEntry.type === \"effarig\") return GLYPH_NAMES.effarig.adjective[this.getEffarigProp()];\r\n      const adjFn = val => {\r\n        if (val >= 60) return \"high\";\r\n        if (val >= 40) return \"mid\";\r\n        return \"low\";\r\n      };\r\n      const adj = GLYPH_NAMES[listEntry.type].adjective;\r\n      return typeof adj === \"string\" ? adj : adj[adjFn(listEntry.perc)];\r\n    },\r\n    getNoun(listEntry) {\r\n      if (listEntry.type === \"effarig\") return GLYPH_NAMES.effarig.noun[this.getEffarigProp()];\r\n      return GLYPH_NAMES[listEntry.type].noun;\r\n    },\r\n  }\r\n};\r\n</script>\r\n\r\n<template>\r\n  <div>\r\n    <span\r\n      :style=\"textStyle\"\r\n      class=\"c-current-glyph-effects__header\"\r\n    >\r\n      {{ setName }}\r\n    </span>\r\n  </div>\r\n</template>\r\n"]}]}