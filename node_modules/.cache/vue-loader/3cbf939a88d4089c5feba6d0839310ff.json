{"remainingRequest":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\@vue\\vue-loader-v15\\lib\\index.js??vue-loader-options!C:\\Games\\ADFasterer\\ADfasterer\\src\\components\\GlyphComponent.vue?vue&type=style&index=0&id=628e0a3e&scoped=true&lang=css&","dependencies":[{"path":"C:\\Games\\ADFasterer\\ADfasterer\\src\\components\\GlyphComponent.vue","mtime":1745241596773},{"path":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\css-loader\\dist\\cjs.js","mtime":1745242216572},{"path":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\@vue\\vue-loader-v15\\lib\\loaders\\stylePostLoader.js","mtime":1745242222796},{"path":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\postcss-loader\\dist\\cjs.js","mtime":1745242214022},{"path":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1745242214069},{"path":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\@vue\\vue-loader-v15\\lib\\index.js","mtime":1745242220175}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCg0KLmwtY29ybmVyLWljb24gew0KICBwb3NpdGlvbjogYWJzb2x1dGU7DQogIHotaW5kZXg6IDU7DQogIGNvbG9yOiBibGFjazsNCiAgYm9yZGVyLXJhZGl1czogdmFyKC0tdmFyLWJvcmRlci1yYWRpdXMsIDAuMnJlbSk7DQogIHBhZGRpbmc6IDAuMnJlbTsNCn0NCg0KLmwtbmV3LWdseXBoIHsNCiAgdG9wOiAtMC43cmVtOw0KICBsZWZ0OiAtMC43cmVtOw0KICBmb250LXNpemU6IDFyZW07DQogIGJhY2tncm91bmQtY29sb3I6IHllbGxvdzsNCn0NCg0KLmwtdW5lcXVpcHBlZC1nbHlwaCB7DQogIHRvcDogLTAuNXJlbTsNCiAgbGVmdDogLTAuNXJlbTsNCiAgZm9udC1zaXplOiAxLjJyZW07DQogIGJhY2tncm91bmQtY29sb3I6IG9yYW5nZTsNCn0NCg=="},{"version":3,"sources":["GlyphComponent.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyyBA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA","file":"GlyphComponent.vue","sourceRoot":"src/components","sourcesContent":["<script>\r\nimport { GlyphInfo } from \"../../src/components/modals/options/SelectGlyphInfoDropdown\";\r\n\r\nimport GlyphTooltip from \"@/components/GlyphTooltip\";\r\n\r\n// We generate the border effects with CSS gradients; for the sake of flexibility and for dynamically using\r\n// the glyph color instead of the fixed rarity color, the border patterns are stored below and then parsed\r\n// into the relevant CSS on a per-glyph basis\r\nconst rarityBorderStyles = {\r\n  common: [],\r\n  uncommon: [\r\n    {\r\n      lineType: \"linear\",\r\n      angles: [45],\r\n      colorSplit: [14, 16, 84, 86],\r\n    }\r\n  ],\r\n  rare: [\r\n    {\r\n      lineType: \"linear\",\r\n      angles: [45, 135],\r\n      colorSplit: [14, 16, 84, 86],\r\n    }\r\n  ],\r\n  epic: [\r\n    {\r\n      lineType: \"linear\",\r\n      angles: [45, 135],\r\n      colorSplit: [12, 14, 16, 18, 82, 84, 86, 88],\r\n    }\r\n  ],\r\n  legendary: [\r\n    {\r\n      lineType: \"bump\",\r\n      colorSplit: [15, 25],\r\n    }\r\n  ],\r\n  mythical: [\r\n    {\r\n      lineType: \"bump\",\r\n      colorSplit: [15, 25],\r\n    },\r\n    {\r\n      lineType: \"linear\",\r\n      angles: [45, 135],\r\n      colorSplit: [10, 13, 87, 90],\r\n    }\r\n  ],\r\n  transcendent: [\r\n    {\r\n      lineType: \"bump\",\r\n      colorSplit: [15, 35],\r\n    },\r\n    {\r\n      lineType: \"linear\",\r\n      angles: [45, 135],\r\n      colorSplit: [10, 12, 14, 16, 84, 86, 88, 90],\r\n    }\r\n  ],\r\n  celestial: [\r\n    {\r\n      lineType: \"bump\",\r\n      colorSplit: [15, 35],\r\n    },\r\n    {\r\n      lineType: \"radial\",\r\n      colorSplit: [65, 85],\r\n    },\r\n  ],\r\n  cursed: [\r\n    {\r\n      lineType: \"spike\",\r\n      center: [40, 40],\r\n      angles: [305, 325],\r\n    },\r\n    {\r\n      lineType: \"spike\",\r\n      center: [60, 40],\r\n      angles: [35, 55],\r\n    },\r\n    {\r\n      lineType: \"spike\",\r\n      center: [60, 60],\r\n      angles: [125, 145],\r\n    },\r\n    {\r\n      lineType: \"spike\",\r\n      center: [40, 60],\r\n      angles: [215, 235],\r\n    },\r\n  ],\r\n  companion: [\r\n    {\r\n      lineType: \"companion\",\r\n    },\r\n  ]\r\n};\r\n\r\n// This function does all the parsing of the above gradient specifications\r\n// eslint-disable-next-line max-params\r\nfunction generateGradient(data, color, glyph, isCircular) {\r\n  // The undefined declarations here are mostly to make ESLint happy, and aren't necessarily used in all cases\r\n  let borders, scaleFn, centers, specialData, isColor = false;\r\n  const entries = [], elements = [];\r\n  switch (data.lineType) {\r\n    case \"linear\":\r\n      // Produces stripes at the specified angle, where color sharply switches between the specified color and\r\n      // transparent at each percentage in lines\r\n      borders = [0, ...data.colorSplit, 100];\r\n      scaleFn = perc => (isCircular ? 50 + 0.7 * (perc - 50) : perc);\r\n      for (const angle of data.angles) {\r\n        for (let i = 0; i < borders.length - 1; i++) {\r\n          entries.push(`${isColor ? color : \"transparent\"} ${scaleFn(borders[i])}% ${scaleFn(borders[i + 1])}%`);\r\n          isColor = !isColor;\r\n        }\r\n        elements.push(`repeating-linear-gradient(${angle}deg, ${entries.join(\",\")})`);\r\n      }\r\n      return elements.join(\",\");\r\n    case \"bump\":\r\n      // Produces four bumps on the cardinal directions of the glyph border, with specified color fade distances.\r\n      // These bumps overlap some dots on effarig glyphs, so we conditionally make them more transparent (effectively\r\n      // shrinking them so they don't overlap)\r\n      specialData = glyph.type === \"effarig\"\r\n        ? `${color}60`\r\n        : color;\r\n      centers = [\"50% -25%\", \"50% 125%\", \"-25% 50%\", \"125% 50%\"];\r\n      scaleFn = perc => (isCircular ? perc : 0.9 * perc);\r\n      for (let i = 0; i < 4; i++) {\r\n        entries.push(`radial-gradient(at ${centers[i]}, transparent, ${specialData} ${scaleFn(data.colorSplit[0])}%,\r\n          transparent ${scaleFn(data.colorSplit[1])}%)`);\r\n      }\r\n      return entries.join(\",\");\r\n    case \"radial\":\r\n      // Produces a centered circle that only shades within a certain radial distance\r\n      borders = [50, ...data.colorSplit, 100];\r\n      scaleFn = perc => (isCircular ? 0.9 * perc : 100 - (100 - perc) / 2);\r\n      for (const border of borders) {\r\n        entries.push(`${isColor ? color : \"transparent\"} ${scaleFn(border)}%`);\r\n        isColor = !isColor;\r\n      }\r\n      return `radial-gradient(${entries.join(\",\")})`;\r\n    case \"spike\":\r\n      // Produces a single spike at the specified center, spanning between the specified angles with 5deg blur\r\n      entries.push(`transparent ${data.angles[0] - 5}deg`);\r\n      entries.push(`${color}b0 ${data.angles[0] + 5}deg`);\r\n      entries.push(`${color}b0 ${data.angles[1] - 5}deg`);\r\n      entries.push(`transparent ${data.angles[1] + 5}deg`);\r\n      return `conic-gradient(from 0deg at ${data.center[0]}% ${data.center[1]}%, ${entries.join(\",\")})`;\r\n    case \"companion\":\r\n      // Special case to make the companion border look like a heart\r\n      borders = [0, 30, 330, 360];\r\n      specialData = [color, \"transparent\", \"transparent\", color];\r\n      for (let i = 0; i < 4; i++) {\r\n        entries.push(`${specialData[i]} ${borders[i]}deg`);\r\n      }\r\n      elements.push(`conic-gradient(${entries.join(\",\")})`);\r\n\r\n      centers = [\"125% 125%\", \"-25% 125%\"];\r\n      scaleFn = perc => (isCircular ? 0.9 * (perc + 10) : perc);\r\n      for (let i = 0; i < 2; i++) {\r\n        elements.push(`radial-gradient(at ${centers[i]}, transparent, ${color} ${scaleFn(30)}%,\r\n          transparent ${scaleFn(50)}%)`);\r\n      }\r\n      return elements.join(\",\");\r\n    default:\r\n      throw new Error(\"Unrecognized glyph border data\");\r\n  }\r\n}\r\n\r\nexport default {\r\n  name: \"GlyphComponent\",\r\n  components: {\r\n    GlyphTooltip\r\n  },\r\n  props: {\r\n    glyph: {\r\n      type: Object,\r\n      required: true\r\n    },\r\n    isInModal: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: false\r\n    },\r\n    isNew: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: false\r\n    },\r\n    isUnequipped: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: false\r\n    },\r\n    showSacrifice: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: false\r\n    },\r\n    ignoreModifiedLevel: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: false\r\n    },\r\n    realityGlyphBoost: {\r\n      type: Number,\r\n      required: false,\r\n      default: 0\r\n    },\r\n    isInventoryGlyph: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: false\r\n    },\r\n    isActiveGlyph: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: false\r\n    },\r\n    size: {\r\n      type: String,\r\n      required: false,\r\n      default: \"5rem\",\r\n    },\r\n    glowBlur: {\r\n      type: String,\r\n      required: false,\r\n      default: \"1rem\"\r\n    },\r\n    glowSpread: {\r\n      type: String,\r\n      required: false,\r\n      default: \"0.2rem\"\r\n    },\r\n    bottomPadding: {\r\n      type: String,\r\n      required: false,\r\n      default: \"0.3rem\"\r\n    },\r\n    textProportion: {\r\n      type: Number,\r\n      required: false,\r\n      default: 0.5\r\n    },\r\n    circular: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: false,\r\n    },\r\n    draggable: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: false,\r\n    },\r\n    flipTooltip: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: false,\r\n    }\r\n  },\r\n  data() {\r\n    return {\r\n      componentID: UIID.next(),\r\n      isDragging: false,\r\n      // This flag is used to prevent the tooltip from being shown in some touch event sequences\r\n      suppressTooltip: false,\r\n      isTouched: false,\r\n      tooltipEnabled: false,\r\n      sacrificeReward: 0,\r\n      uncappedRefineReward: 0,\r\n      refineReward: 0,\r\n      displayLevel: 0,\r\n      // We use this to not create a ton of tooltip components as soon as the glyph tab loads.\r\n      tooltipLoaded: false,\r\n      logTotalSacrifice: 0,\r\n      realityColor: \"\",\r\n    };\r\n  },\r\n  computed: {\r\n    hasTooltip() {\r\n      return Boolean(this.glyph.effects);\r\n    },\r\n    typeConfig() {\r\n      return GlyphTypes[this.glyph.type];\r\n    },\r\n    cosmeticConfig() {\r\n      return CosmeticGlyphTypes[this.glyph.cosmetic ?? this.glyph.type];\r\n    },\r\n    isBlobHeart() {\r\n      return this.$viewModel.theme === \"S11\" && this.glyph.type === \"companion\";\r\n    },\r\n    symbol() {\r\n      const symbol = this.glyph.symbol;\r\n      // \\uE019 = :blobheart:\r\n      if (this.isBlobHeart) return \"\\uE019\";\r\n      if (symbol) return symbol;\r\n      return (this.$viewModel.theme === \"S4\" && !this.glyph.cosmetic)\r\n        ? CANCER_GLYPH_SYMBOLS[this.glyph.type]\r\n        : this.cosmeticConfig.currentSymbol.symbol;\r\n    },\r\n    symbolBlur() {\r\n      if (this.isBlobHeart) return false;\r\n      if (!this.glyph.symbol) return this.cosmeticConfig.currentSymbol.blur;\r\n      return !GlyphAppearanceHandler.unblurredSymbols.includes(this.symbol);\r\n    },\r\n    zIndexStyle() {\r\n      return { \"z-index\": this.isInModal ? 7 : 6 };\r\n    },\r\n    colorObj() {\r\n      let overrideColor;\r\n      if (this.glyph.color) overrideColor = GlyphAppearanceHandler.getColorProps(this.glyph.color);\r\n      if (this.glyph.cosmetic) {\r\n        if (this.glyph.cosmetic === this.glyph.type) {\r\n          overrideColor = this.glyph.type === \"cursed\"\r\n            ? GlyphAppearanceHandler.getBaseColor(true)\r\n            : this.cosmeticConfig.currentColor;\r\n        } else {\r\n          overrideColor = this.cosmeticConfig.currentColor;\r\n        }\r\n      }\r\n\r\n      let symbolColor;\r\n      if (this.isRealityGlyph && this.realityColor) symbolColor = this.realityColor;\r\n      else {\r\n        symbolColor = this.cosmeticConfig.ignoreRarityColor\r\n          ? GlyphAppearanceHandler.getBorderColor(this.glyph.type)\r\n          : GlyphAppearanceHandler.getRarityColor(this.glyph.strength, this.glyph.type);\r\n      }\r\n\r\n      return {\r\n        border: overrideColor?.border ?? GlyphAppearanceHandler.getBorderColor(this.glyph.type),\r\n        symbol: overrideColor?.border ?? symbolColor,\r\n        bg: overrideColor?.bg ?? this.cosmeticConfig.currentColor.bg\r\n      };\r\n    },\r\n    symbolColor() {\r\n      return player.options.swapGlyphColors ? this.colorObj.border : this.colorObj.symbol;\r\n    },\r\n    borderColor() {\r\n      return player.options.swapGlyphColors ? this.colorObj.symbol : this.colorObj.border;\r\n    },\r\n    bgColor() {\r\n      return this.colorObj.bg;\r\n    },\r\n    overStyle() {\r\n      return {\r\n        width: this.size,\r\n        height: this.size,\r\n        position: \"absolute\",\r\n        \"background-color\": \"rgba(0, 0, 0, 0)\",\r\n        \"box-shadow\": `0 0 ${this.glowBlur} calc(${this.glowSpread} + 0.1rem) ${this.borderColor} inset`,\r\n        \"border-radius\": this.circular ? \"50%\" : \"0\",\r\n      };\r\n    },\r\n    outerStyle() {\r\n      return {\r\n        width: this.size,\r\n        height: this.size,\r\n        \"background-color\": this.borderColor,\r\n        \"box-shadow\": `0 0 ${this.glowBlur} ${this.glowSpread} ${this.borderColor}`,\r\n        \"border-radius\": this.circular ? \"50%\" : \"0\",\r\n        \"-webkit-user-drag\": this.draggable ? \"\" : \"none\"\r\n      };\r\n    },\r\n    innerStyle() {\r\n      const color = this.symbolColor;\r\n      return {\r\n        width: `calc(${this.size} - 0.2rem)`,\r\n        height: `calc(${this.size} - 0.2rem)`,\r\n        \"font-size\": `calc( ${this.size} * ${this.textProportion} )`,\r\n        color,\r\n        \"text-shadow\": this.symbolBlur ? `-0.04em 0.04em 0.08em ${color}` : undefined,\r\n        \"border-radius\": this.circular ? \"50%\" : \"0\",\r\n        \"padding-bottom\": this.bottomPadding,\r\n        background: this.bgColor\r\n      };\r\n    },\r\n    mouseEventHandlers() {\r\n      const handlers = this.hasTooltip ? {\r\n        mouseenter: this.mouseEnter,\r\n        \"&mousemove\": this.mouseMove,\r\n        mouseleave: this.mouseLeave,\r\n        mousedown: this.mouseDown,\r\n        touchstart: this.touchStart,\r\n        touchend: this.touchEnd\r\n      } : {};\r\n      if (this.hasTooltip || this.draggable) {\r\n        handlers.touchmove = this.touchMove;\r\n      }\r\n      return handlers;\r\n    },\r\n    isCurrentTooltip() {\r\n      return this.$viewModel.tabs.reality.currentGlyphTooltip === this.componentID;\r\n    },\r\n    tooltipDirectionClass() {\r\n      let directionID = this.$viewModel.tabs.reality.glyphTooltipDirection;\r\n      if (this.flipTooltip) directionID += 1;\r\n      switch (directionID) {\r\n        case -1:\r\n          return \"l-glyph-tooltip--down-left\";\r\n        case 0:\r\n          return \"l-glyph-tooltip--down-right\";\r\n        case 1:\r\n          return \"l-glyph-tooltip--up-left\";\r\n        case 2:\r\n          return \"l-glyph-tooltip--up-right\";\r\n        default:\r\n          return \"\";\r\n      }\r\n    },\r\n    // This finds all the effects of a glyph and shifts all their IDs so that type's lowest-ID effect is 0 and all\r\n    // other effects count up to 3 (or 6 for effarig). Used to add dots in unique positions on glyphs to show effects.\r\n    glyphEffects() {\r\n      let minEffectID = 0;\r\n      switch (this.glyph.type) {\r\n        case \"time\":\r\n        case \"cursed\":\r\n        case \"companion\":\r\n          minEffectID = 0;\r\n          break;\r\n        case \"dilation\":\r\n        case \"reality\":\r\n          minEffectID = 4;\r\n          break;\r\n        case \"replication\":\r\n          minEffectID = 8;\r\n          break;\r\n        case \"infinity\":\r\n          minEffectID = 12;\r\n          break;\r\n        case \"power\":\r\n          minEffectID = 16;\r\n          break;\r\n        case \"effarig\":\r\n          minEffectID = 20;\r\n          break;\r\n        default:\r\n          throw new Error(`Unrecognized glyph type \"${this.glyph.type}\" in glyph effect icons`);\r\n      }\r\n      const effectIDs = [];\r\n      let remainingEffects = this.glyph.effects >> minEffectID;\r\n      for (let id = 0; remainingEffects > 0; id++) {\r\n        if ((remainingEffects & 1) === 1) effectIDs.push(id);\r\n        remainingEffects >>= 1;\r\n      }\r\n      return effectIDs;\r\n    },\r\n    isRealityGlyph() {\r\n      return this.glyph.type === \"reality\";\r\n    },\r\n    isCursedGlyph() {\r\n      return this.glyph.type === \"cursed\";\r\n    },\r\n    isCompanionGlyph() {\r\n      return this.glyph.type === \"companion\";\r\n    },\r\n    showGlyphEffectDots() {\r\n      return player.options.showHintText.glyphEffectDots;\r\n    },\r\n    displayedInfo() {\r\n      const blacklist = [\"companion\", \"cursed\"];\r\n      if (!this.isInventoryGlyph || blacklist.includes(this.glyph.type)) return null;\r\n\r\n      const options = player.options.showHintText;\r\n      if (options.glyphInfoType === GlyphInfo.types.NONE ||\r\n        (!options.showGlyphInfoByDefault && !this.$viewModel.shiftDown)) {\r\n        return null;\r\n      }\r\n\r\n      const typeEnum = GlyphInfo.types;\r\n      switch (options.glyphInfoType) {\r\n        case typeEnum.LEVEL:\r\n          this.updateDisplayLevel();\r\n          return formatInt(this.displayLevel === 0 ? this.glyph.level : this.displayLevel);\r\n        case typeEnum.RARITY:\r\n          return formatRarity(strengthToRarity(Pelle.isDoomed ? Pelle.glyphStrength : this.glyph.strength));\r\n        case typeEnum.SAC_VALUE:\r\n          return format(this.sacrificeReward, 2, 2);\r\n        case typeEnum.FILTER_SCORE:\r\n          return format(AutoGlyphProcessor.filterValue(this.glyph), 1, 1);\r\n        case typeEnum.CURRENT_REFINE:\r\n          return `${format(this.refineReward, 2, 2)} ${this.symbol}`;\r\n        case typeEnum.MAX_REFINE:\r\n          return `${format(this.uncappedRefineReward, 2, 2)} ${this.symbol}`;\r\n        default:\r\n          throw new Error(\"Unrecognized Glyph info type in info text\");\r\n      }\r\n    },\r\n    showBorders() {\r\n      return player.options.glyphBorders;\r\n    }\r\n  },\r\n  watch: {\r\n    logTotalSacrifice() {\r\n      this.tooltipLoaded = false;\r\n      if (this.isCurrentTooltip) this.showTooltip();\r\n    }\r\n  },\r\n  created() {\r\n    this.on$(GAME_EVENT.GLYPH_VISUAL_CHANGE, () => {\r\n      this.$recompute(\"typeConfig\");\r\n      this.$recompute(\"cosmeticConfig\");\r\n      this.$recompute(\"innerStyle\");\r\n      this.$recompute(\"overrideColor\");\r\n      this.$recompute(\"showGlyphEffectDots\");\r\n      this.$recompute(\"displayedInfo\");\r\n      this.$recompute(\"showBorders\");\r\n    });\r\n    this.on$(\"tooltip-touched\", () => this.hideTooltip());\r\n    this.on$(GAME_EVENT.TAB_CHANGED, () => this.hideTooltip());\r\n\r\n    // There are a few situations where a tooltip could attempt to render immediately upon component creation,\r\n    // which causes it to be placed in an odd \"default\" corner spot due to mouse position not being set properly.\r\n    // This is essentially a hack that force-suppresses tooltips from being shown in strange spots due to on-load\r\n    // events firing, but has the side effect that the mouse must leave and enter an element which was created\r\n    // underneath it in order to make the tooltip appear\r\n    setTimeout(() => this.tooltipEnabled = true, 10);\r\n  },\r\n  beforeDestroy() {\r\n    if (this.isCurrentTooltip) this.hideTooltip();\r\n    if (this.$viewModel.draggingUIID === this.componentID) this.$viewModel.draggingUIID = -1;\r\n  },\r\n  methods: {\r\n    update() {\r\n      this.logTotalSacrifice = GameCache.logTotalGlyphSacrifice.value;\r\n      // This needs to be reactive in order to animate while using our low-lag workaround, but we also need to make\r\n      // sure it only animates when that color is actually active\r\n      this.realityColor = player.reality.glyphs.cosmetics.colorMap.reality\r\n        ? null\r\n        : GlyphAppearanceHandler.realityColor;\r\n      this.sacrificeReward = GlyphSacrificeHandler.glyphSacrificeGain(this.glyph);\r\n      this.uncappedRefineReward = ALCHEMY_BASIC_GLYPH_TYPES.includes(this.glyph.type)\r\n        ? GlyphSacrificeHandler.glyphRawRefinementGain(this.glyph)\r\n        : 0;\r\n      this.refineReward = ALCHEMY_BASIC_GLYPH_TYPES.includes(this.glyph.type)\r\n        ? GlyphSacrificeHandler.glyphRefinementGain(this.glyph)\r\n        : 0;\r\n      if (this.tooltipLoaded) this.updateDisplayLevel();\r\n    },\r\n    updateDisplayLevel() {\r\n      if (this.ignoreModifiedLevel) {\r\n        this.displayLevel = 0;\r\n        return;\r\n      }\r\n      // We have to consider some odd interactions in order to properly show level. The getAdjustedGlyphLevel() function\r\n      // returns a modified level using celestial effects and reality glyphs based on the CURRENT game state, meaning\r\n      // that applying this globally will cause lots of glyphs to show altered levels even if they shouldn't. So:\r\n      // - Active glyphs should apply ALL adjusted effects based on the current game state, since they are guaranteed\r\n      //   to always be affected by them and this is exactly the purpose of getAdjustedGlyphLevel() as-is\r\n      // - Inventory glyphs should show the same current-state effects as active, but it should NEVER apply reality\r\n      //   glyph boosts. This allows for easier comparison when celestial effects are changing both active and\r\n      //   inventory glyphs, even though strictly speaking the inventory ones shouldn't be affected until equipped\r\n      // - All other glyphs should never apply effects from the current game state, and should in fact only apply the\r\n      //   reality glyph boost based on the rest of its existing set (which is passed in via realityGlyphBoost) and\r\n      //   nothing else. This case applies to glyphs appearing in presets, records, and previews.\r\n      if (this.isActiveGlyph) this.displayLevel = getAdjustedGlyphLevel(this.glyph);\r\n      else if (this.isInventoryGlyph) this.displayLevel = getAdjustedGlyphLevel(this.glyph, 0);\r\n      else {\r\n        this.displayLevel = this.glyph.level +\r\n          (BASIC_GLYPH_TYPES.includes(this.glyph.type) ? this.realityGlyphBoost : 0);\r\n      }\r\n    },\r\n    hideTooltip() {\r\n      this.tooltipLoaded = false;\r\n      this.$viewModel.tabs.reality.mouseoverGlyphInfo.type = \"\";\r\n      this.$viewModel.tabs.reality.mouseoverGlyphInfo.inInventory = false;\r\n      this.$viewModel.tabs.reality.currentGlyphTooltip = -1;\r\n    },\r\n    showTooltip() {\r\n      if (!this.tooltipEnabled) return;\r\n      Glyphs.removeVisualFlag(\"unseen\", this.glyph);\r\n      Glyphs.removeVisualFlag(\"unequipped\", this.glyph);\r\n      this.tooltipLoaded = true;\r\n      this.$viewModel.tabs.reality.mouseoverGlyphInfo.inInventory = !this.circular;\r\n      const glyphInfo = this.$viewModel.tabs.reality.mouseoverGlyphInfo;\r\n      glyphInfo.type = this.glyph.type;\r\n      glyphInfo.sacrificeValue = GlyphSacrificeHandler.glyphSacrificeGain(this.glyph);\r\n      glyphInfo.refineValue = GlyphSacrificeHandler.glyphRawRefinementGain(this.glyph);\r\n      this.$viewModel.tabs.reality.currentGlyphTooltip = this.componentID;\r\n      if (\r\n        AutoGlyphProcessor.sacMode === AUTO_GLYPH_REJECT.SACRIFICE ||\r\n        (AutoGlyphProcessor.sacMode === AUTO_GLYPH_REJECT.REFINE_TO_CAP && this.refineReward === 0)\r\n      ) {\r\n        this.currentAction = \"sacrifice\";\r\n      } else {\r\n        this.currentAction = \"refine\";\r\n      }\r\n      this.scoreMode = AutoGlyphProcessor.scoreMode;\r\n    },\r\n    moveTooltipTo(x, y) {\r\n      // If we are just creating the tooltip now, we can't move it yet.\r\n      if (!this.$refs.tooltip) return;\r\n      const tooltipEl = this.$refs.tooltip.$el;\r\n      if (tooltipEl) {\r\n        const rect = document.body.getBoundingClientRect();\r\n        tooltipEl.style.left = `${x - rect.left}px`;\r\n        tooltipEl.style.top = `${y - rect.top}px`;\r\n        if (this.$viewModel.tabs.reality.glyphTooltipDirection === 1) {\r\n          // In case of a really short screen, don't flicker back and forth\r\n          if (y - tooltipEl.offsetHeight <= 0 && y + tooltipEl.offsetHeight < rect.height) {\r\n            this.$viewModel.tabs.reality.glyphTooltipDirection = -1;\r\n          }\r\n        } else if (y + tooltipEl.offsetHeight >= rect.height) {\r\n          this.$viewModel.tabs.reality.glyphTooltipDirection = 1;\r\n        }\r\n      }\r\n    },\r\n    mouseEnter(ev) {\r\n      if (this.$viewModel.draggingUIID !== -1) return;\r\n      this.moveTooltipTo(ev.clientX, ev.clientY);\r\n      this.showTooltip();\r\n    },\r\n    mouseLeave() {\r\n      if (this.isCurrentTooltip) {\r\n        this.hideTooltip();\r\n      }\r\n    },\r\n    mouseDown() {\r\n      if (this.isTouched) return;\r\n      this.hideTooltip();\r\n    },\r\n    mouseMove(ev) {\r\n      if (this.isTouched) return;\r\n      this.moveTooltipTo(ev.clientX, ev.clientY);\r\n    },\r\n    dragStart(ev) {\r\n      this.hideTooltip();\r\n      this.isDragging = true;\r\n      this.suppressTooltip = true;\r\n      ev.dataTransfer.setData(GLYPH_MIME_TYPE, this.glyph.id.toString());\r\n      ev.dataTransfer.dropEffect = \"move\";\r\n      const rect = this.$refs.over.getBoundingClientRect();\r\n      ev.dataTransfer.setDragImage(this.$refs.over, ev.clientX - rect.left, ev.clientY - rect.top);\r\n      this.$viewModel.draggingUIID = this.componentID;\r\n      const dragInfo = this.$viewModel.tabs.reality.draggingGlyphInfo;\r\n      dragInfo.id = this.glyph.id;\r\n      dragInfo.type = this.glyph.type;\r\n      dragInfo.sacrificeValue = GlyphSacrificeHandler.glyphSacrificeGain(this.glyph);\r\n    },\r\n    dragEnd() {\r\n      this.isDragging = false;\r\n      this.suppressTooltip = false;\r\n      this.$viewModel.scrollWindow = 0;\r\n      const dragInfo = this.$viewModel.tabs.reality.draggingGlyphInfo;\r\n      dragInfo.id = -1;\r\n      dragInfo.type = \"\";\r\n      if (this.$viewModel.draggingUIID === this.componentID) this.$viewModel.draggingUIID = -1;\r\n    },\r\n    drag(ev) {\r\n      // It looks like dragging off the bottom of the window sometimes fires these\r\n      // odd events\r\n      if (ev.screenX === 0 && ev.screenY === 0) {\r\n        this.$viewModel.scrollWindow = 0;\r\n        return;\r\n      }\r\n      const boundary = 100;\r\n      if (ev.clientY < boundary) {\r\n        this.$viewModel.scrollWindow = -1 + 0.9 * ev.clientY / boundary;\r\n      } else if (ev.clientY > window.innerHeight - boundary) {\r\n        this.$viewModel.scrollWindow = 1 - 0.9 * (window.innerHeight - ev.clientY) / boundary;\r\n      } else {\r\n        this.$viewModel.scrollWindow = 0;\r\n      }\r\n    },\r\n    touchStart() {\r\n      this.isTouched = true;\r\n    },\r\n    touchEnd(e) {\r\n      if (this.isCurrentTooltip) {\r\n        e.preventDefault();\r\n        this.hideTooltip();\r\n      } else if (!this.suppressTooltip) {\r\n        e.preventDefault();\r\n        this.showTooltip();\r\n        this.moveTooltipTo(e.changedTouches[0].clientX, e.changedTouches[0].clientY);\r\n      }\r\n      this.suppressTooltip = false;\r\n      this.isTouched = false;\r\n    },\r\n    touchMove(e) {\r\n      const t = e.changedTouches[0];\r\n      const r = this.$refs.over.getBoundingClientRect();\r\n      if (t.clientX < r.left || t.clientY < r.top || t.clientX > r.left + r.width || t.clientY > r.top + r.height) {\r\n        this.suppressTooltip = true;\r\n      }\r\n      if (this.isDragging) {\r\n        // DragDropTouch doesn't seem to send drag events.\r\n        this.drag(t);\r\n      }\r\n    },\r\n    // Translates 0...3 into equally-spaced coordinates around a circle 90deg apart (0...6 and 45deg for effarig)\r\n    effectIconPos(id) {\r\n      // Place dots clockwise starting from the bottom left\r\n      const angle = this.glyph.type === \"effarig\"\r\n        ? (Math.PI / 4) * (id + 1)\r\n        : (Math.PI / 2) * (id + 0.5);\r\n      const scale = 0.28 * this.size.replace(\"rem\", \"\");\r\n      const dx = -scale * Math.sin(angle);\r\n      const dy = scale * (Math.cos(angle) + 0.15);\r\n      return { dx, dy };\r\n    },\r\n    glyphEffectDots(id) {\r\n      if ([\"companion\", \"cursed\"].includes(this.glyph.type)) return {};\r\n      const pos = this.effectIconPos(id);\r\n\r\n      return {\r\n        position: \"absolute\",\r\n        width: \"0.3rem\",\r\n        height: \"0.3rem\",\r\n        \"border-radius\": \"50%\",\r\n        background: this.symbolColor,\r\n        transform: `translate(${pos.dx - 0.15 * 0.3}rem, ${pos.dy - 0.15 * 0.3}rem)`,\r\n        opacity: Theme.current().name === \"S9\" ? 0 : 0.8\r\n      };\r\n    },\r\n    glyphBorderStyle() {\r\n      if (!this.showBorders) return null;\r\n      let borderAttrs;\r\n      if (this.isCursedGlyph) borderAttrs = rarityBorderStyles.cursed;\r\n      else if (this.isCompanionGlyph) borderAttrs = rarityBorderStyles.companion;\r\n      else borderAttrs = rarityBorderStyles[getRarity(this.glyph.strength).name.toLowerCase()];\r\n      const lines = borderAttrs.map(attr => generateGradient(attr, this.borderColor, this.glyph, this.circular));\r\n\r\n      return {\r\n        position: \"absolute\",\r\n        left: \"2%\",\r\n        width: \"96%\",\r\n        height: \"96%\",\r\n        \"border-radius\": this.circular ? \"50%\" : \"0\",\r\n        // Some cases will have undefined lines which need to be removed to combine everything together properly\r\n        background: lines.filter(l => l).join(\",\")\r\n      };\r\n    }\r\n  }\r\n};\r\n</script>\r\n\r\n<template>\r\n  <!--\r\n    The naive approach with a border and box-shadow seems to have problems with\r\n    weird seams/artifacts at the edges. This makes for a rather complex workaround\r\n  -->\r\n  <div\r\n    :style=\"outerStyle\"\r\n    :class=\"['l-glyph-component', {'c-glyph-component--dragging': isDragging}]\"\r\n    :draggable=\"draggable\"\r\n    v-on=\"draggable ? { dragstart: dragStart, dragend: dragEnd, drag: drag } : {}\"\r\n  >\r\n    <div\r\n      ref=\"glyph\"\r\n      :style=\"innerStyle\"\r\n      :class=\"['l-glyph-component', 'c-glyph-component']\"\r\n    >\r\n      {{ symbol }}\r\n      <template v-if=\"$viewModel.shiftDown || showGlyphEffectDots\">\r\n        <div\r\n          v-for=\"x in glyphEffects\"\r\n          :key=\"x\"\r\n          :style=\"glyphEffectDots(x)\"\r\n        />\r\n      </template>\r\n    </div>\r\n    <div :style=\"glyphBorderStyle()\" />\r\n    <GlyphTooltip\r\n      v-if=\"hasTooltip && tooltipLoaded\"\r\n      v-show=\"isCurrentTooltip\"\r\n      ref=\"tooltip\"\r\n      v-bind=\"glyph\"\r\n      :class=\"tooltipDirectionClass\"\r\n      :style=\"zIndexStyle\"\r\n      :sacrifice-reward=\"sacrificeReward\"\r\n      :refine-reward=\"refineReward\"\r\n      :uncapped-refine-reward=\"uncappedRefineReward\"\r\n      :current-action=\"currentAction\"\r\n      :score-mode=\"scoreMode\"\r\n      :show-deletion-text=\"showSacrifice\"\r\n      :display-level=\"displayLevel\"\r\n      :component=\"componentID\"\r\n      :change-watcher=\"logTotalSacrifice\"\r\n    />\r\n    <div\r\n      v-if=\"isNew\"\r\n      class=\"l-corner-icon l-new-glyph\"\r\n    >\r\n      New!\r\n    </div>\r\n    <div\r\n      v-else-if=\"isUnequipped\"\r\n      class=\"l-corner-icon l-unequipped-glyph fas fa-arrow-up-from-bracket\"\r\n    />\r\n    <div\r\n      v-if=\"displayedInfo\"\r\n      class=\"l-glyph-info\"\r\n    >\r\n      {{ displayedInfo }}\r\n    </div>\r\n    <div\r\n      ref=\"over\"\r\n      :style=\"overStyle\"\r\n      v-on=\"mouseEventHandlers\"\r\n      @click.shift.exact=\"$emit('shiftClicked', glyph.id)\"\r\n      @click.ctrl.shift.exact=\"$emit('ctrlShiftClicked', glyph.id)\"\r\n      @click.meta.shift.exact=\"$emit('ctrlShiftClicked', glyph.id)\"\r\n      @click.exact=\"$emit('clicked', glyph.id)\"\r\n    />\r\n  </div>\r\n</template>\r\n\r\n<style scoped>\r\n.l-corner-icon {\r\n  position: absolute;\r\n  z-index: 5;\r\n  color: black;\r\n  border-radius: var(--var-border-radius, 0.2rem);\r\n  padding: 0.2rem;\r\n}\r\n\r\n.l-new-glyph {\r\n  top: -0.7rem;\r\n  left: -0.7rem;\r\n  font-size: 1rem;\r\n  background-color: yellow;\r\n}\r\n\r\n.l-unequipped-glyph {\r\n  top: -0.5rem;\r\n  left: -0.5rem;\r\n  font-size: 1.2rem;\r\n  background-color: orange;\r\n}\r\n</style>\r\n"]}]}