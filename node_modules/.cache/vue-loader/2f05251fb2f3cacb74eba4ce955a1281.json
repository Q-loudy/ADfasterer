{"remainingRequest":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\@vue\\vue-loader-v15\\lib\\index.js??vue-loader-options!C:\\Games\\ADFasterer\\ADfasterer\\src\\components\\tabs\\alchemy\\AlchemyTab.vue?vue&type=style&index=0&id=720700da&scoped=true&lang=css&","dependencies":[{"path":"C:\\Games\\ADFasterer\\ADfasterer\\src\\components\\tabs\\alchemy\\AlchemyTab.vue","mtime":1745241597016},{"path":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\css-loader\\dist\\cjs.js","mtime":1745242216572},{"path":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\@vue\\vue-loader-v15\\lib\\loaders\\stylePostLoader.js","mtime":1745242222796},{"path":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\postcss-loader\\dist\\cjs.js","mtime":1745242214022},{"path":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1745242214069},{"path":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\@vue\\vue-loader-v15\\lib\\index.js","mtime":1745242220175}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoNCi5vLWNsaWNrYWJsZSB7DQogIGN1cnNvcjogcG9pbnRlcjsNCn0NCg0KLmMtcGVsbGUtc3ltYm9sLW92ZXJsYXkgew0KICBkaXNwbGF5OiBmbGV4Ow0KICB3aWR0aDogMTAwJTsNCiAgaGVpZ2h0OiAxMDAlOw0KICBwb3NpdGlvbjogYWJzb2x1dGU7DQogIHRvcDogLTEuNXJlbTsNCiAgbGVmdDogMDsNCiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7DQogIGFsaWduLWl0ZW1zOiBjZW50ZXI7DQogIGZvbnQtc2l6ZTogNjByZW07DQogIGNvbG9yOiB2YXIoLS1jb2xvci1wZWxsZS0tYmFzZSk7DQogIHRleHQtc2hhZG93OiAwIDAgM3JlbTsNCiAgcG9pbnRlci1ldmVudHM6IG5vbmU7DQogIHVzZXItc2VsZWN0OiBub25lOw0KICBvcGFjaXR5OiAwLjg7DQogIHotaW5kZXg6IDI7DQp9DQo="},{"version":3,"sources":["AlchemyTab.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuRA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"AlchemyTab.vue","sourceRoot":"src/components/tabs/alchemy","sourcesContent":["<script>\r\nimport { AlchemyCircleLayout } from \"./alchemy-circle-layout\";\r\nimport AlchemyCircleNode from \"./AlchemyCircleNode\";\r\nimport AlchemyResourceInfo from \"./AlchemyResourceInfo\";\r\nimport PrimaryButton from \"@/components/PrimaryButton\";\r\n\r\nexport default {\r\n  name: \"AlchemyTab\",\r\n  components: {\r\n    PrimaryButton,\r\n    AlchemyCircleNode,\r\n    AlchemyResourceInfo\r\n  },\r\n  data() {\r\n    return {\r\n      infoResourceId: 0,\r\n      focusedResourceId: -1,\r\n      reactionsAvailable: false,\r\n      realityCreationVisible: false,\r\n      animationTimer: 0,\r\n      alchemyCap: 0,\r\n      capFactor: 0,\r\n      createdRealityGlyph: false,\r\n      allReactionsDisabled: false,\r\n      // Used to force a re-render of reaction lines when reality glyphs are created\r\n      realityAmount: 0,\r\n    };\r\n  },\r\n  computed: {\r\n    resources: () => AlchemyResources.all,\r\n    layout: () => new AlchemyCircleLayout(),\r\n    sizeMultiplier: () => 5,\r\n    infoResource() {\r\n      return this.resources[this.infoResourceId];\r\n    },\r\n    circleStyle() {\r\n      const size = this.layout.size * this.sizeMultiplier;\r\n      return {\r\n        width: `${size}rem`,\r\n        height: `${size}rem`,\r\n        opacity: this.isDoomed ? 0.8 : 1\r\n      };\r\n    },\r\n    orbitClass() {\r\n      return (this.focusedResourceId === -1 || this.isDoomed) ? undefined : \"o-alchemy-orbit--unfocused\";\r\n    },\r\n    realityGlyphCreationClass() {\r\n      return {\r\n        \"o-primary-btn--subtab-option\": true,\r\n        \"tutorial--glow\": !this.createdRealityGlyph\r\n      };\r\n    },\r\n    reactions() {\r\n      return AlchemyReactions.all.compact().filter(r => r.product.isUnlocked);\r\n    },\r\n    isDoomed() {\r\n      return Pelle.isDoomed;\r\n    },\r\n    pelleSymbol() {\r\n      return Pelle.symbol;\r\n    }\r\n  },\r\n  methods: {\r\n    update() {\r\n      this.reactionsAvailable = AlchemyResources.all.filter(res => !res.isBaseResource && res.isUnlocked).length !== 0;\r\n      this.realityCreationVisible = Ra.pets.effarig.level === 25;\r\n      this.animationTimer += 35;\r\n      this.alchemyCap = Ra.alchemyResourceCap;\r\n      this.capFactor = 1 / GlyphSacrificeHandler.glyphRefinementEfficiency;\r\n      this.createdRealityGlyph = player.reality.glyphs.createdRealityGlyph;\r\n      this.allReactionsDisabled = this.reactions.every(reaction => !reaction.isActive);\r\n      this.realityAmount = AlchemyResource.reality.amount;\r\n    },\r\n    orbitSize(orbit) {\r\n      const maxRadius = this.layout.orbits.map(o => o.radius).max();\r\n      return `${(orbit.radius / maxRadius * 50)}%`;\r\n    },\r\n    handleMouseEnter(node) {\r\n      this.infoResourceId = node.resource.id;\r\n      if (node.resource.isUnlocked) {\r\n        this.focusedResourceId = node.resource.id;\r\n      }\r\n    },\r\n    handleMouseLeave() {\r\n      this.focusedResourceId = -1;\r\n    },\r\n    handleClick(node) {\r\n      const resource = node.resource;\r\n      if (!resource.isUnlocked) return;\r\n      if (this.infoResourceId !== resource.id) {\r\n        this.infoResourceId = resource.id;\r\n        this.focusedResourceId = resource.id;\r\n        return;\r\n      }\r\n      if (resource.isBaseResource) return;\r\n      resource.reaction.isActive = !resource.reaction.isActive;\r\n      GameUI.update();\r\n    },\r\n    isUnlocked(reactionArrow) {\r\n      return reactionArrow.product.resource.isUnlocked && reactionArrow.reagent.resource.isUnlocked;\r\n    },\r\n    isCapped(reactionArrow) {\r\n      const inRes = reactionArrow.reagent.resource;\r\n      const outRes = reactionArrow.product.resource;\r\n      // We render the reaction as capped if it won't trigger; this can happen under two conditions - either the\r\n      // output is higher than this particular input amount, or it's at its cap due to a different input\r\n      return (outRes.amount > 0 && outRes.amount >= inRes.amount) || outRes.amount >= outRes.cap;\r\n    },\r\n    isLessThanRequired(reactionArrow) {\r\n      return reactionArrow.product.resource.amount > 0 &&\r\n        reactionArrow.reagent.cost < reactionArrow.reagent.resource.cap;\r\n    },\r\n    isActiveReaction(reactionArrow) {\r\n      return reactionArrow.reaction.isActive && !this.isDoomed;\r\n    },\r\n    isFocusedReaction(reactionArrow) {\r\n      if (this.isDoomed) return false;\r\n      return this.isUnlocked(reactionArrow) && (reactionArrow.product.resource.id === this.focusedResourceId ||\r\n        reactionArrow.reagent.resource.id === this.focusedResourceId);\r\n    },\r\n    isDisplayed(reactionArrow) {\r\n      return this.isUnlocked(reactionArrow) &&\r\n        (this.isActiveReaction(reactionArrow) || this.isFocusedReaction(reactionArrow));\r\n    },\r\n    isFocusedNode(node) {\r\n      if (this.focusedResourceId === -1 || this.isDoomed) return true;\r\n      const focusedResource = this.resources[this.focusedResourceId];\r\n      if (focusedResource === node.resource) return true;\r\n      return focusedResource.reaction?.reagents.some(r => r.resource === node.resource) ||\r\n        node.resource.reaction?.reagents.some(r => r.resource === focusedResource);\r\n    },\r\n    reactionArrowPositions(reactionArrow) {\r\n      if (!this.isDisplayed(reactionArrow) || this.isCapped(reactionArrow)) return undefined;\r\n      const xStart = reactionArrow.reagent.x;\r\n      const yStart = reactionArrow.reagent.y;\r\n      const xEnd = reactionArrow.product.x;\r\n      const yEnd = reactionArrow.product.y;\r\n      const pathLength = Math.sqrt(Math.pow(xEnd - xStart, 2) + Math.pow(yEnd - yStart, 2));\r\n      const animationTime = pathLength * 40;\r\n      const reactionProgress = (this.animationTimer % animationTime) / animationTime;\r\n      const leadPoint = Math.max(0, reactionProgress + 2 / pathLength);\r\n      const trailPoint = Math.min(1, reactionProgress - 2 / pathLength);\r\n      return {\r\n        x1: `${xStart * (1 - leadPoint) + xEnd * leadPoint}%`,\r\n        y1: `${yStart * (1 - leadPoint) + yEnd * leadPoint}%`,\r\n        x2: `${xStart * (1 - trailPoint) + xEnd * trailPoint}%`,\r\n        y2: `${yStart * (1 - trailPoint) + yEnd * trailPoint}%`,\r\n      };\r\n    },\r\n    reactionArrowPaths(reactionArrow) {\r\n      return {\r\n        x1: `${reactionArrow.reagent.x}%`,\r\n        y1: `${reactionArrow.reagent.y}%`,\r\n        x2: `${reactionArrow.product.x}%`,\r\n        y2: `${reactionArrow.product.y}%`,\r\n      };\r\n    },\r\n    reactionPathClass(reactionArrow) {\r\n      return {\r\n        \"o-alchemy-reaction-path\": this.isUnlocked(reactionArrow),\r\n        \"o-alchemy-reaction-path--capped\": this.isCapped(reactionArrow) && this.isDisplayed(reactionArrow),\r\n        \"o-alchemy-reaction-path--less-than-required\": this.isLessThanRequired(reactionArrow) &&\r\n          this.isDisplayed(reactionArrow),\r\n        \"o-alchemy-reaction-path--focused\": !this.isCapped(reactionArrow) && this.isFocusedReaction(reactionArrow),\r\n        \"o-alchemy-reaction-path--not-focused\": !this.isFocusedReaction(reactionArrow) && this.focusedResourceId !== -1,\r\n        \"o-alchemy-reaction-path--doomed\": this.isDoomed\r\n      };\r\n    },\r\n    reactionArrowClass(reactionArrow) {\r\n      return {\r\n        \"o-alchemy-reaction-arrow\": !this.isCapped(reactionArrow) && this.isDisplayed(reactionArrow),\r\n        \"o-alchemy-reaction-arrow--focused\": this.isFocusedReaction(reactionArrow),\r\n      };\r\n    },\r\n    showAlchemyHowTo() {\r\n      ui.view.h2pForcedTab = GameDatabase.h2p.tabs.filter(tab => tab.name === \"Glyph Alchemy\")[0];\r\n      Modal.h2p.show();\r\n    },\r\n    toggleAllReactions() {\r\n      const setIsActive = this.allReactionsDisabled;\r\n      for (const reaction of this.reactions) {\r\n        reaction.isActive = setIsActive;\r\n      }\r\n    },\r\n    nodeClass(node) {\r\n      const resource = node.resource;\r\n      return {\r\n        \"o-clickable\": resource.isUnlocked && !resource.isBaseResource && !this.isDoomed\r\n      };\r\n    },\r\n  }\r\n};\r\n</script>\r\n\r\n<template>\r\n  <div class=\"l-ra-alchemy-tab\">\r\n    <div class=\"c-subtab-option-container\">\r\n      <PrimaryButton\r\n        class=\"o-primary-btn--subtab-option\"\r\n        @click=\"showAlchemyHowTo\"\r\n      >\r\n        Click for alchemy info\r\n      </PrimaryButton>\r\n      <PrimaryButton\r\n        v-if=\"!isDoomed\"\r\n        class=\"o-primary-btn--subtab-option\"\r\n        @click=\"toggleAllReactions\"\r\n      >\r\n        {{ allReactionsDisabled ? \"Enable\" : \"Disable\" }} all reactions\r\n      </PrimaryButton>\r\n      <PrimaryButton\r\n        v-if=\"realityCreationVisible\"\r\n        :class=\"realityGlyphCreationClass\"\r\n        onclick=\"Modal.realityGlyph.show()\"\r\n      >\r\n        View Reality Glyph creation\r\n      </PrimaryButton>\r\n    </div>\r\n    <AlchemyResourceInfo\r\n      :key=\"infoResourceId\"\r\n      :resource=\"infoResource\"\r\n    />\r\n    <br>\r\n    Glyphs can now be refined using your Glyph filter in the Glyphs tab.\r\n    <br>\r\n    When refining a Glyph, it will only give you resources up to a cap\r\n    of {{ formatX(capFactor) }} its highest refinement value.\r\n    <span v-if=\"reactionsAvailable\">\r\n      Reactions trigger once every time you Reality, unaffected by amplification from stored real time.\r\n    </span>\r\n    <div\r\n      class=\"l-alchemy-circle\"\r\n      :style=\"circleStyle\"\r\n    >\r\n      <span\r\n        v-if=\"isDoomed\"\r\n        class=\"c-pelle-symbol-overlay\"\r\n        v-html=\"pelleSymbol\"\r\n      />\r\n      <svg class=\"l-alchemy-orbit-canvas\">\r\n        <circle\r\n          v-for=\"(orbit, i) in layout.orbits\"\r\n          :key=\"i\"\r\n          cx=\"50%\"\r\n          cy=\"50%\"\r\n          class=\"o-alchemy-orbit\"\r\n          :r=\"orbitSize(orbit)\"\r\n          :class=\"orbitClass\"\r\n        />\r\n      </svg>\r\n      <AlchemyCircleNode\r\n        v-for=\"(node, i) in layout.nodes\"\r\n        :key=\"i\"\r\n        :node=\"node\"\r\n        :is-focused=\"isFocusedNode(node)\"\r\n        :class=\"nodeClass(node)\"\r\n        @mouseenter=\"handleMouseEnter(node)\"\r\n        @mouseleave=\"handleMouseLeave\"\r\n        @click=\"handleClick(node)\"\r\n      />\r\n      <svg class=\"l-alchemy-arrow-canvas\">\r\n        <line\r\n          v-for=\"(reactionArrow, idx) in layout.reactionArrows\"\r\n          :key=\"'arrow-' + idx + realityAmount\"\r\n          v-bind=\"reactionArrowPaths(reactionArrow)\"\r\n          :class=\"reactionPathClass(reactionArrow)\"\r\n        />\r\n        <line\r\n          v-for=\"(reactionArrow, idx) in layout.reactionArrows\"\r\n          :key=\"'arrow2-' + idx + realityAmount\"\r\n          v-bind=\"reactionArrowPositions(reactionArrow)\"\r\n          :class=\"reactionArrowClass(reactionArrow)\"\r\n        />\r\n      </svg>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<style scoped>\r\n.o-clickable {\r\n  cursor: pointer;\r\n}\r\n\r\n.c-pelle-symbol-overlay {\r\n  display: flex;\r\n  width: 100%;\r\n  height: 100%;\r\n  position: absolute;\r\n  top: -1.5rem;\r\n  left: 0;\r\n  justify-content: center;\r\n  align-items: center;\r\n  font-size: 60rem;\r\n  color: var(--color-pelle--base);\r\n  text-shadow: 0 0 3rem;\r\n  pointer-events: none;\r\n  user-select: none;\r\n  opacity: 0.8;\r\n  z-index: 2;\r\n}\r\n</style>\r\n"]}]}