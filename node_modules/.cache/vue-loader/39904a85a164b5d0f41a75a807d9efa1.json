{"remainingRequest":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\@vue\\vue-loader-v15\\lib\\index.js??vue-loader-options!C:\\Games\\ADFasterer\\ADfasterer\\src\\components\\tabs\\automator\\AutomatorBlockSingleInput.vue?vue&type=style&index=0&id=2e1b60ad&scoped=true&lang=css&","dependencies":[{"path":"C:\\Games\\ADFasterer\\ADfasterer\\src\\components\\tabs\\automator\\AutomatorBlockSingleInput.vue","mtime":1745241597061},{"path":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\css-loader\\dist\\cjs.js","mtime":1745242216572},{"path":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\@vue\\vue-loader-v15\\lib\\loaders\\stylePostLoader.js","mtime":1745242222796},{"path":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\postcss-loader\\dist\\cjs.js","mtime":1745242214022},{"path":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1745242214069},{"path":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\@vue\\vue-loader-v15\\lib\\index.js","mtime":1745242220175}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKDQouYy1hdXRvbWF0b3Itc2luZ2xlLWJsb2NrIHsNCiAgZGlzcGxheTogZmxleDsNCiAgZmxleC1kaXJlY3Rpb246IHJvdzsNCiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7DQogIGFsaWduLWl0ZW1zOiBjZW50ZXI7DQogIGhlaWdodDogMi44cmVtOw0KICB3aGl0ZS1zcGFjZTogbm93cmFwOw0KfQ0KDQouYy1hdXRvbWF0b3ItY29uc3RhbnQtYmxvY2sgew0KICBiYWNrZ3JvdW5kOiB2YXIoLS1jb2xvci1ibG9ja21hdG9yLWJsb2NrLWNvbW1hbmQpOw0KICBjb2xvcjogdmFyKC0tY29sb3ItYmxvY2ttYXRvci1lZGl0b3ItYmFja2dyb3VuZCk7DQp9DQoNCi5jLWF1dG9tYXRvci10ZXh0LWlucHV0LWNvbnRhaW5lciB7DQogIHBvc2l0aW9uOiByZWxhdGl2ZTsNCn0NCg0KLm8tbG9uZy10ZXh0LWlucHV0IHsNCiAgd2lkdGg6IDMwcmVtOw0KfQ0KDQouYy1hdXRvbWF0b3ItY2xvc2UtdGV4dC1pbnB1dCB7DQogIHBvc2l0aW9uOiBhYnNvbHV0ZTsNCiAgY29sb3I6IHZhcigtLWNvbG9yLWF1dG9tYXRvci1lcnJvci1vdXRsaW5lKTsNCiAgZm9udC1zaXplOiAxLjVyZW07DQogIHotaW5kZXg6IDE7DQogIHJpZ2h0OiAwLjhyZW07DQogIHRvcDogMC42cmVtOw0KfQ0KDQoubC1lcnJvci10ZXh0Ym94IHsNCiAgYmFja2dyb3VuZDogdmFyKC0tY29sb3ItYXV0b21hdG9yLWVycm9yLWJhY2tncm91bmQpOw0KICBjb2xvcjogeWVsbG93Ow0KfQ0KDQoubC1ibG9iIHsNCiAgZm9udC1zaXplOiAxLjhyZW07DQogIGJhY2tncm91bmQ6IGJsYWNrOw0KICBjb2xvcjogI2ZjMjsNCn0NCg=="},{"version":3,"sources":["AutomatorBlockSingleInput.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+WA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA","file":"AutomatorBlockSingleInput.vue","sourceRoot":"src/components/tabs/automator","sourcesContent":["<script>\r\nimport { validateLine } from \"@/core/automator\";\r\n\r\nexport default {\r\n  name: \"AutomatorBlockSingleInput\",\r\n  props: {\r\n    constant: {\r\n      type: String,\r\n      required: false,\r\n      default: \"\"\r\n    },\r\n    block: {\r\n      type: Object,\r\n      required: true\r\n    },\r\n    blockTarget: {\r\n      type: String,\r\n      required: false,\r\n      default: \"\"\r\n    },\r\n    updateFunction: {\r\n      type: Function,\r\n      required: true\r\n    },\r\n    initialSelection: {\r\n      type: String,\r\n      required: false,\r\n      default: \"\"\r\n    },\r\n    patterns: {\r\n      type: Array,\r\n      required: false,\r\n      default: () => []\r\n    },\r\n    recursive: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: false\r\n    },\r\n    currentPath: {\r\n      type: String,\r\n      required: false,\r\n      default: \"\"\r\n    }\r\n  },\r\n  data() {\r\n    return {\r\n      b: {},\r\n      suppressTooltip: false,\r\n      errors: [],\r\n      hasError: false,\r\n\r\n      isTextInput: false,\r\n      dropdownOptions: [],\r\n      dropdownSelection: \"\",\r\n      textContents: \"\",\r\n      pathRef: {},\r\n      currentNodeOnPath: \"\",\r\n      unknownNext: false,\r\n      nextNodeCount: 0,\r\n      lineNumber: 0,\r\n      // This is tracked here because switching scripts causes events to be fired in a weird order, often seemingly\r\n      // starting the creation of the new component before the UI's visible script ID is properly updated\r\n      scriptID: 0,\r\n    };\r\n  },\r\n  computed: {\r\n    displayedConstant() {\r\n      if (this.constant) {\r\n        // \\uE010 is :blob:\r\n        return this.constant === \"BLOB\" ? \"\\uE010\" : this.constant;\r\n      }\r\n      return (this.dropdownOptions.length === 1 && !this.isBoolTarget && !this.isTextInput)\r\n        ? this.dropdownOptions[0]\r\n        : \"\";\r\n    },\r\n    isBoolTarget() {\r\n      return this.blockTarget === \"nowait\" || this.blockTarget === \"respec\";\r\n    },\r\n    nextInputKey() {\r\n      return this.block.targets[this.currentPath.length + 1];\r\n    },\r\n    nextInputValue() {\r\n      const targetList = this.block.targets;\r\n      const value = targetList ? this.block[this.nextInputKey] : \"\";\r\n      // Sometimes the target might be a Number or undefined but the prop type-checks for it to be a String\r\n      return value ? `${value}` : \"\";\r\n    },\r\n    // Most of the time the input is just a number or constant but these ones will typically lead to longer\r\n    // phrases in String format, so we want to give some extra room\r\n    hasLongTextInput() {\r\n      return this.block.cmd === \"NOTIFY\" || this.block.cmd === \"COMMENT\";\r\n    }\r\n  },\r\n  created() {\r\n    this.scriptID = player.reality.automator.state.editorScript;\r\n    this.b = this.block;\r\n    this.lineNumber = BlockAutomator.lineNumber(BlockAutomator._idArray.indexOf(this.block.id) + 1);\r\n    BlockAutomator.updateIdArray();\r\n    if (this.constant) return;\r\n    if (this.isBoolTarget) {\r\n      this.dropdownOptions = [this.blockTarget.toUpperCase()];\r\n      this.dropdownSelection = this.block[this.blockTarget] ? this.blockTarget.toUpperCase() : \"\";\r\n      return;\r\n    }\r\n\r\n    // This is used for sequences of inputs, which are traversed by recursion\r\n    if (this.recursive) {\r\n      const availableOptions = this.patterns\r\n        .filter(s => s.startsWith(this.currentPath) && s.length > this.currentPath.length)\r\n        .map(s => s.charAt(this.currentPath.length));\r\n      for (const node of availableOptions) {\r\n        if (this.pathRef[node]) continue;\r\n        const entries = this.block[node];\r\n        this.pathRef[node] = entries;\r\n        this.dropdownOptions.push(...entries);\r\n      }\r\n      this.calculatePath();\r\n    }\r\n\r\n    // Set the initial display state properly\r\n    if (this.dropdownOptions.includes(this.initialSelection)) {\r\n      this.dropdownSelection = this.initialSelection;\r\n    } else if (this.initialSelection) {\r\n      this.isTextInput = true;\r\n      this.textContents = this.initialSelection;\r\n    }\r\n\r\n    // Special handling for text-input-only fields, which will have single-element array specifications\r\n    if (this.dropdownOptions.length === 1 && this.dropdownOptions[0].startsWith(\"*\")) {\r\n      this.isTextInput = true;\r\n      this.textContents = this.initialSelection;\r\n    }\r\n\r\n    // This forces errors to show up immediately when the block is created instead of requiring user interaction, but\r\n    // we also want to hide tooltips because this causes poor UI if there are a lot of nearby errors upon conversion\r\n    this.recalculateErrorCount();\r\n    this.suppressTooltip = true;\r\n\r\n    // Force the editor to parse the script again after all the values have been filled in above, or else it'll create\r\n    // blocks which always have errors due to undefined props\r\n    BlockAutomator.parseTextFromBlocks();\r\n  },\r\n  // Destroying single inputs need to be handled carefully because there are three situations under which they will\r\n  // be removed, and they all require different behavior:\r\n  // * The player changes to the text editor or switches tabs/scripts, wiping the entire script (we do nothing here)\r\n  // * Blocks are dragged and reordered, causing a parent component to key-swap and force a rerender on this\r\n  //   component - in that case we need to remove the errors corresponding to the old line number\r\n  // * An earlier input in the command chain makes this input unnecessary (eg. changing \"unlock ec 8\" to\r\n  //   \"unlock dilation\" makes the 8 unnecessary) - this case is handled when the parent block calls changeBlock(),\r\n  //   but we still need to verify error count and parse the script again since we avoid doing that within\r\n  //   changeBlock() for performance reasons\r\n  destroyed() {\r\n    if (player.reality.automator.type === AUTOMATOR_TYPE.TEXT || Tabs.current._currentSubtab.key !== \"automator\" ||\r\n      this.scriptID !== player.reality.automator.state.editorScript) {\r\n      return;\r\n    }\r\n\r\n    this.recalculateErrorCount();\r\n    const newLineNum = BlockAutomator.lineNumber(BlockAutomator._idArray.indexOf(this.block.id) + 1);\r\n    if (this.lineNumber !== newLineNum) {\r\n      const newErrors = [];\r\n      for (const error of AutomatorData.cachedErrors) {\r\n        if (error.startLine !== this.lineNumber) newErrors.push(error);\r\n      }\r\n      newErrors.sort((a, b) => a.startLine - b.startLine);\r\n      AutomatorData.cachedErrors = newErrors;\r\n      return;\r\n    }\r\n\r\n    this.recalculateErrorCount();\r\n    BlockAutomator.parseTextFromBlocks();\r\n  },\r\n  methods: {\r\n    update() {\r\n      this.errors = AutomatorData.cachedErrors;\r\n      this.hasError = this.errors.some(e => e.startLine === this.lineNumber);\r\n      if (this.dropdownSelection.startsWith(\"*\")) this.isTextInput = true;\r\n      this.calculatePath();\r\n    },\r\n    calculatePath() {\r\n      this.currentNodeOnPath = \" \";\r\n      for (const node of Object.keys(this.pathRef)) {\r\n        const isValidText = this.pathRef[node].some(o => o.startsWith(\"*\")) && this.isTextInput;\r\n        if (this.pathRef[node].includes(this.dropdownSelection) || isValidText) {\r\n          this.currentNodeOnPath = node;\r\n        }\r\n      }\r\n      const fullPath = this.currentPath + this.currentNodeOnPath;\r\n      this.nextNodeCount = this.patterns.filter(p => p.length > fullPath.length && p.startsWith(fullPath)).length;\r\n      this.unknownNext = this.nextNodeCount > 1 || (this.dropdownSelection === \"\" && !this.isTextInput);\r\n    },\r\n    validateInput() {\r\n      let validator, lines;\r\n      if (this.b.nest) {\r\n        const clone = Object.assign({}, this.b);\r\n        clone.nest = [];\r\n        lines = BlockAutomator.parseLines([clone]);\r\n        validator = validateLine(lines.join(\"\\n\"));\r\n      } else {\r\n        lines = BlockAutomator.parseLines([this.b]);\r\n        validator = validateLine(lines[0]);\r\n      }\r\n\r\n      // Yes, the odd structure of this check is intentional. Something odd happens within parseLines under certain\r\n      // conditions which seem hard to pin down, which causes this evaluate to an array with the string \"undefined\"\r\n      // being its only element. These cases all seem to be false positives\r\n      if (lines[0] === \"undefined\") return;\r\n\r\n      // We're actually validating only this single line, so we reconstruct the error list by removing everything on\r\n      // this line and adding anything new that was found. We only take the first error from this line (if there are\r\n      // any) because multiple errors on the same line are generally redundant, and sometimes the parser hiccups and\r\n      // duplicates errors onto the last line of the script (which we explicitly ignore)\r\n      const newErrors = [];\r\n      const lastLine = BlockAutomator._idArray.filter(id => id).length;\r\n      for (const error of AutomatorData.cachedErrors) {\r\n        if (error.startLine !== this.lineNumber && error.startLine < lastLine) {\r\n          newErrors.push(error);\r\n        }\r\n      }\r\n      if (validator.errors.length > 0) {\r\n        const error = validator.errors[0];\r\n        error.startLine = this.lineNumber;\r\n        newErrors.push(error);\r\n      }\r\n      newErrors.sort((a, b) => a.startLine - b.startLine);\r\n      AutomatorData.cachedErrors = newErrors;\r\n    },\r\n    handleFocus(focusState) {\r\n      this.suppressTooltip = !focusState;\r\n      this.changeBlock();\r\n    },\r\n    changeBlock() {\r\n      this.updateFunction(this.block, this.block.id);\r\n      if (this.blockTarget) {\r\n        let newValue;\r\n        if (this.isBoolTarget) newValue = this.dropdownSelection !== \"\";\r\n        else if (this.isTextInput) newValue = this.textContents;\r\n        else newValue = this.dropdownSelection;\r\n\r\n        // eslint-disable-next-line vue/no-mutating-props\r\n        this.block[this.blockTarget] = newValue;\r\n\r\n        // Sometimes changing a block value causes later blocks on the line to no longer exist due to a different\r\n        // command structure; we wipe the props related to those blocks here so that they don't cause parsing errors\r\n        this.calculatePath();\r\n        if (this.nextNodeCount === 0 && !this.isBoolTarget) {\r\n          const currIndex = this.block.targets.indexOf(this.blockTarget);\r\n          for (let toClear = currIndex + 1; toClear < this.block.targets.length; toClear++) {\r\n            // eslint-disable-next-line vue/no-mutating-props\r\n            this.block[this.block.targets[toClear]] = undefined;\r\n          }\r\n        }\r\n      }\r\n      this.recalculateErrorCount();\r\n    },\r\n    // This gets called whenever blocks are changed, but we also need to halt execution if the currently visible script\r\n    // is also the one being run\r\n    recalculateErrorCount() {\r\n      BlockAutomator.parseTextFromBlocks(this.scriptID);\r\n      this.validateInput();\r\n      if (AutomatorBackend.currentEditingScript.id === AutomatorBackend.currentRunningScript.id) {\r\n        AutomatorBackend.stop();\r\n      }\r\n    },\r\n    errorTooltip() {\r\n      if (!this.hasError || this.suppressTooltip) return undefined;\r\n\r\n      // We want to keep the verbose error info for the error panel, but we need to shorten it for the tooltips here\r\n      // The problematic errors all seem to have the same format, which we can explicitly modify\r\n      let errorInfo = this.errors.find(e => e.startLine === this.lineNumber).info;\r\n      errorInfo = errorInfo\r\n        .replaceAll(\"\\n\", \"\")\r\n        .replace(/Expecting: one of these possible Token sequences:.*but found: (.*)/ui, \"Unexpected input format: $1\");\r\n      return {\r\n        content:\r\n          `<div class=\"c-block-automator-error\">\r\n          <div>${errorInfo}</div>\r\n        </div>`,\r\n        html: true,\r\n        trigger: \"manual\",\r\n        show: true,\r\n        classes: [\"c-block-automator-error-container\", \"general-tooltip\"]\r\n      };\r\n    },\r\n    textInputClassObject() {\r\n      return {\r\n        \"o-automator-block-input\": true,\r\n        \"o-long-text-input\": this.hasLongTextInput,\r\n        \"l-error-textbox\": this.hasError,\r\n        \"c-automator-input-required\": !this.hasError,\r\n      };\r\n    },\r\n    dropdownClassObject() {\r\n      return {\r\n        \"o-automator-block-input\": true,\r\n        \"c-automator-input-required\": !this.isBoolTarget,\r\n        \"c-automator-input-optional\": this.isBoolTarget,\r\n        \"l-error-textbox\": this.hasError && !this.isBoolTarget && this.dropdownSelection === \"\",\r\n      };\r\n    },\r\n    revertToDropdown() {\r\n      this.isTextInput = false;\r\n      this.dropdownSelection = \"\";\r\n      this.textContents = \"\";\r\n    }\r\n  }\r\n};\r\n</script>\r\n\r\n<template>\r\n  <div class=\"c-automator-single-block\">\r\n    <div\r\n      v-if=\"displayedConstant\"\r\n      class=\"c-automator-single-block o-automator-command c-automator-constant-block\"\r\n      :class=\"{ 'l-blob' : constant === 'BLOB' }\"\r\n    >\r\n      {{ displayedConstant }}\r\n    </div>\r\n    <div\r\n      v-else-if=\"isTextInput\"\r\n      class=\"c-automator-text-input-container\"\r\n    >\r\n      <input\r\n        v-model=\"textContents\"\r\n        v-tooltip=\"errorTooltip()\"\r\n        :class=\"textInputClassObject()\"\r\n        @keyup=\"changeBlock()\"\r\n        @focusin=\"handleFocus(true)\"\r\n        @focusout=\"handleFocus(false)\"\r\n      >\r\n      <div\r\n        v-if=\"dropdownOptions.length > 1\"\r\n        class=\"c-automator-close-text-input fa-solid fa-circle-xmark\"\r\n        @click=\"revertToDropdown\"\r\n      />\r\n    </div>\r\n    <select\r\n      v-else\r\n      v-model=\"dropdownSelection\"\r\n      :class=\"dropdownClassObject()\"\r\n      @change=\"changeBlock()\"\r\n    >\r\n      <option\r\n        v-for=\"target in ['', ...dropdownOptions]\"\r\n        :key=\"target\"\r\n        :value=\"target\"\r\n      >\r\n        {{ target }}\r\n      </option>\r\n    </select>\r\n    <AutomatorBlockSingleInput\r\n      v-if=\"recursive && nextNodeCount > 0\"\r\n      :key=\"currentNodeOnPath\"\r\n      :constant=\"unknownNext ? '...' : ''\"\r\n      :block=\"block\"\r\n      :block-target=\"nextInputKey\"\r\n      :patterns=\"patterns\"\r\n      :initial-selection=\"nextInputValue\"\r\n      :update-function=\"updateFunction\"\r\n      :recursive=\"true\"\r\n      :current-path=\"currentPath + currentNodeOnPath\"\r\n    />\r\n  </div>\r\n</template>\r\n\r\n<style scoped>\r\n.c-automator-single-block {\r\n  display: flex;\r\n  flex-direction: row;\r\n  justify-content: center;\r\n  align-items: center;\r\n  height: 2.8rem;\r\n  white-space: nowrap;\r\n}\r\n\r\n.c-automator-constant-block {\r\n  background: var(--color-blockmator-block-command);\r\n  color: var(--color-blockmator-editor-background);\r\n}\r\n\r\n.c-automator-text-input-container {\r\n  position: relative;\r\n}\r\n\r\n.o-long-text-input {\r\n  width: 30rem;\r\n}\r\n\r\n.c-automator-close-text-input {\r\n  position: absolute;\r\n  color: var(--color-automator-error-outline);\r\n  font-size: 1.5rem;\r\n  z-index: 1;\r\n  right: 0.8rem;\r\n  top: 0.6rem;\r\n}\r\n\r\n.l-error-textbox {\r\n  background: var(--color-automator-error-background);\r\n  color: yellow;\r\n}\r\n\r\n.l-blob {\r\n  font-size: 1.8rem;\r\n  background: black;\r\n  color: #fc2;\r\n}\r\n</style>\r\n"]}]}