{"remainingRequest":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\@vue\\vue-loader-v15\\lib\\index.js??vue-loader-options!C:\\Games\\ADFasterer\\ADfasterer\\src\\components\\tabs\\automator\\AutomatorBlockSingleInput.vue?vue&type=script&lang=js&","dependencies":[{"path":"C:\\Games\\ADFasterer\\ADfasterer\\src\\components\\tabs\\automator\\AutomatorBlockSingleInput.vue","mtime":1745241597061},{"path":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\babel-loader\\lib\\index.js","mtime":1745242219290},{"path":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1745242214069},{"path":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\@vue\\vue-loader-v15\\lib\\index.js","mtime":1745242220175}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:DQppbXBvcnQgeyB2YWxpZGF0ZUxpbmUgfSBmcm9tICJAL2NvcmUvYXV0b21hdG9yIjsNCg0KZXhwb3J0IGRlZmF1bHQgew0KICBuYW1lOiAiQXV0b21hdG9yQmxvY2tTaW5nbGVJbnB1dCIsDQogIHByb3BzOiB7DQogICAgY29uc3RhbnQ6IHsNCiAgICAgIHR5cGU6IFN0cmluZywNCiAgICAgIHJlcXVpcmVkOiBmYWxzZSwNCiAgICAgIGRlZmF1bHQ6ICIiDQogICAgfSwNCiAgICBibG9jazogew0KICAgICAgdHlwZTogT2JqZWN0LA0KICAgICAgcmVxdWlyZWQ6IHRydWUNCiAgICB9LA0KICAgIGJsb2NrVGFyZ2V0OiB7DQogICAgICB0eXBlOiBTdHJpbmcsDQogICAgICByZXF1aXJlZDogZmFsc2UsDQogICAgICBkZWZhdWx0OiAiIg0KICAgIH0sDQogICAgdXBkYXRlRnVuY3Rpb246IHsNCiAgICAgIHR5cGU6IEZ1bmN0aW9uLA0KICAgICAgcmVxdWlyZWQ6IHRydWUNCiAgICB9LA0KICAgIGluaXRpYWxTZWxlY3Rpb246IHsNCiAgICAgIHR5cGU6IFN0cmluZywNCiAgICAgIHJlcXVpcmVkOiBmYWxzZSwNCiAgICAgIGRlZmF1bHQ6ICIiDQogICAgfSwNCiAgICBwYXR0ZXJuczogew0KICAgICAgdHlwZTogQXJyYXksDQogICAgICByZXF1aXJlZDogZmFsc2UsDQogICAgICBkZWZhdWx0OiAoKSA9PiBbXQ0KICAgIH0sDQogICAgcmVjdXJzaXZlOiB7DQogICAgICB0eXBlOiBCb29sZWFuLA0KICAgICAgcmVxdWlyZWQ6IGZhbHNlLA0KICAgICAgZGVmYXVsdDogZmFsc2UNCiAgICB9LA0KICAgIGN1cnJlbnRQYXRoOiB7DQogICAgICB0eXBlOiBTdHJpbmcsDQogICAgICByZXF1aXJlZDogZmFsc2UsDQogICAgICBkZWZhdWx0OiAiIg0KICAgIH0NCiAgfSwNCiAgZGF0YSgpIHsNCiAgICByZXR1cm4gew0KICAgICAgYjoge30sDQogICAgICBzdXBwcmVzc1Rvb2x0aXA6IGZhbHNlLA0KICAgICAgZXJyb3JzOiBbXSwNCiAgICAgIGhhc0Vycm9yOiBmYWxzZSwNCg0KICAgICAgaXNUZXh0SW5wdXQ6IGZhbHNlLA0KICAgICAgZHJvcGRvd25PcHRpb25zOiBbXSwNCiAgICAgIGRyb3Bkb3duU2VsZWN0aW9uOiAiIiwNCiAgICAgIHRleHRDb250ZW50czogIiIsDQogICAgICBwYXRoUmVmOiB7fSwNCiAgICAgIGN1cnJlbnROb2RlT25QYXRoOiAiIiwNCiAgICAgIHVua25vd25OZXh0OiBmYWxzZSwNCiAgICAgIG5leHROb2RlQ291bnQ6IDAsDQogICAgICBsaW5lTnVtYmVyOiAwLA0KICAgICAgLy8gVGhpcyBpcyB0cmFja2VkIGhlcmUgYmVjYXVzZSBzd2l0Y2hpbmcgc2NyaXB0cyBjYXVzZXMgZXZlbnRzIHRvIGJlIGZpcmVkIGluIGEgd2VpcmQgb3JkZXIsIG9mdGVuIHNlZW1pbmdseQ0KICAgICAgLy8gc3RhcnRpbmcgdGhlIGNyZWF0aW9uIG9mIHRoZSBuZXcgY29tcG9uZW50IGJlZm9yZSB0aGUgVUkncyB2aXNpYmxlIHNjcmlwdCBJRCBpcyBwcm9wZXJseSB1cGRhdGVkDQogICAgICBzY3JpcHRJRDogMCwNCiAgICB9Ow0KICB9LA0KICBjb21wdXRlZDogew0KICAgIGRpc3BsYXllZENvbnN0YW50KCkgew0KICAgICAgaWYgKHRoaXMuY29uc3RhbnQpIHsNCiAgICAgICAgLy8gXHVFMDEwIGlzIDpibG9iOg0KICAgICAgICByZXR1cm4gdGhpcy5jb25zdGFudCA9PT0gIkJMT0IiID8gIlx1RTAxMCIgOiB0aGlzLmNvbnN0YW50Ow0KICAgICAgfQ0KICAgICAgcmV0dXJuICh0aGlzLmRyb3Bkb3duT3B0aW9ucy5sZW5ndGggPT09IDEgJiYgIXRoaXMuaXNCb29sVGFyZ2V0ICYmICF0aGlzLmlzVGV4dElucHV0KQ0KICAgICAgICA/IHRoaXMuZHJvcGRvd25PcHRpb25zWzBdDQogICAgICAgIDogIiI7DQogICAgfSwNCiAgICBpc0Jvb2xUYXJnZXQoKSB7DQogICAgICByZXR1cm4gdGhpcy5ibG9ja1RhcmdldCA9PT0gIm5vd2FpdCIgfHwgdGhpcy5ibG9ja1RhcmdldCA9PT0gInJlc3BlYyI7DQogICAgfSwNCiAgICBuZXh0SW5wdXRLZXkoKSB7DQogICAgICByZXR1cm4gdGhpcy5ibG9jay50YXJnZXRzW3RoaXMuY3VycmVudFBhdGgubGVuZ3RoICsgMV07DQogICAgfSwNCiAgICBuZXh0SW5wdXRWYWx1ZSgpIHsNCiAgICAgIGNvbnN0IHRhcmdldExpc3QgPSB0aGlzLmJsb2NrLnRhcmdldHM7DQogICAgICBjb25zdCB2YWx1ZSA9IHRhcmdldExpc3QgPyB0aGlzLmJsb2NrW3RoaXMubmV4dElucHV0S2V5XSA6ICIiOw0KICAgICAgLy8gU29tZXRpbWVzIHRoZSB0YXJnZXQgbWlnaHQgYmUgYSBOdW1iZXIgb3IgdW5kZWZpbmVkIGJ1dCB0aGUgcHJvcCB0eXBlLWNoZWNrcyBmb3IgaXQgdG8gYmUgYSBTdHJpbmcNCiAgICAgIHJldHVybiB2YWx1ZSA/IGAke3ZhbHVlfWAgOiAiIjsNCiAgICB9LA0KICAgIC8vIE1vc3Qgb2YgdGhlIHRpbWUgdGhlIGlucHV0IGlzIGp1c3QgYSBudW1iZXIgb3IgY29uc3RhbnQgYnV0IHRoZXNlIG9uZXMgd2lsbCB0eXBpY2FsbHkgbGVhZCB0byBsb25nZXINCiAgICAvLyBwaHJhc2VzIGluIFN0cmluZyBmb3JtYXQsIHNvIHdlIHdhbnQgdG8gZ2l2ZSBzb21lIGV4dHJhIHJvb20NCiAgICBoYXNMb25nVGV4dElucHV0KCkgew0KICAgICAgcmV0dXJuIHRoaXMuYmxvY2suY21kID09PSAiTk9USUZZIiB8fCB0aGlzLmJsb2NrLmNtZCA9PT0gIkNPTU1FTlQiOw0KICAgIH0NCiAgfSwNCiAgY3JlYXRlZCgpIHsNCiAgICB0aGlzLnNjcmlwdElEID0gcGxheWVyLnJlYWxpdHkuYXV0b21hdG9yLnN0YXRlLmVkaXRvclNjcmlwdDsNCiAgICB0aGlzLmIgPSB0aGlzLmJsb2NrOw0KICAgIHRoaXMubGluZU51bWJlciA9IEJsb2NrQXV0b21hdG9yLmxpbmVOdW1iZXIoQmxvY2tBdXRvbWF0b3IuX2lkQXJyYXkuaW5kZXhPZih0aGlzLmJsb2NrLmlkKSArIDEpOw0KICAgIEJsb2NrQXV0b21hdG9yLnVwZGF0ZUlkQXJyYXkoKTsNCiAgICBpZiAodGhpcy5jb25zdGFudCkgcmV0dXJuOw0KICAgIGlmICh0aGlzLmlzQm9vbFRhcmdldCkgew0KICAgICAgdGhpcy5kcm9wZG93bk9wdGlvbnMgPSBbdGhpcy5ibG9ja1RhcmdldC50b1VwcGVyQ2FzZSgpXTsNCiAgICAgIHRoaXMuZHJvcGRvd25TZWxlY3Rpb24gPSB0aGlzLmJsb2NrW3RoaXMuYmxvY2tUYXJnZXRdID8gdGhpcy5ibG9ja1RhcmdldC50b1VwcGVyQ2FzZSgpIDogIiI7DQogICAgICByZXR1cm47DQogICAgfQ0KDQogICAgLy8gVGhpcyBpcyB1c2VkIGZvciBzZXF1ZW5jZXMgb2YgaW5wdXRzLCB3aGljaCBhcmUgdHJhdmVyc2VkIGJ5IHJlY3Vyc2lvbg0KICAgIGlmICh0aGlzLnJlY3Vyc2l2ZSkgew0KICAgICAgY29uc3QgYXZhaWxhYmxlT3B0aW9ucyA9IHRoaXMucGF0dGVybnMNCiAgICAgICAgLmZpbHRlcihzID0+IHMuc3RhcnRzV2l0aCh0aGlzLmN1cnJlbnRQYXRoKSAmJiBzLmxlbmd0aCA+IHRoaXMuY3VycmVudFBhdGgubGVuZ3RoKQ0KICAgICAgICAubWFwKHMgPT4gcy5jaGFyQXQodGhpcy5jdXJyZW50UGF0aC5sZW5ndGgpKTsNCiAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBhdmFpbGFibGVPcHRpb25zKSB7DQogICAgICAgIGlmICh0aGlzLnBhdGhSZWZbbm9kZV0pIGNvbnRpbnVlOw0KICAgICAgICBjb25zdCBlbnRyaWVzID0gdGhpcy5ibG9ja1tub2RlXTsNCiAgICAgICAgdGhpcy5wYXRoUmVmW25vZGVdID0gZW50cmllczsNCiAgICAgICAgdGhpcy5kcm9wZG93bk9wdGlvbnMucHVzaCguLi5lbnRyaWVzKTsNCiAgICAgIH0NCiAgICAgIHRoaXMuY2FsY3VsYXRlUGF0aCgpOw0KICAgIH0NCg0KICAgIC8vIFNldCB0aGUgaW5pdGlhbCBkaXNwbGF5IHN0YXRlIHByb3Blcmx5DQogICAgaWYgKHRoaXMuZHJvcGRvd25PcHRpb25zLmluY2x1ZGVzKHRoaXMuaW5pdGlhbFNlbGVjdGlvbikpIHsNCiAgICAgIHRoaXMuZHJvcGRvd25TZWxlY3Rpb24gPSB0aGlzLmluaXRpYWxTZWxlY3Rpb247DQogICAgfSBlbHNlIGlmICh0aGlzLmluaXRpYWxTZWxlY3Rpb24pIHsNCiAgICAgIHRoaXMuaXNUZXh0SW5wdXQgPSB0cnVlOw0KICAgICAgdGhpcy50ZXh0Q29udGVudHMgPSB0aGlzLmluaXRpYWxTZWxlY3Rpb247DQogICAgfQ0KDQogICAgLy8gU3BlY2lhbCBoYW5kbGluZyBmb3IgdGV4dC1pbnB1dC1vbmx5IGZpZWxkcywgd2hpY2ggd2lsbCBoYXZlIHNpbmdsZS1lbGVtZW50IGFycmF5IHNwZWNpZmljYXRpb25zDQogICAgaWYgKHRoaXMuZHJvcGRvd25PcHRpb25zLmxlbmd0aCA9PT0gMSAmJiB0aGlzLmRyb3Bkb3duT3B0aW9uc1swXS5zdGFydHNXaXRoKCIqIikpIHsNCiAgICAgIHRoaXMuaXNUZXh0SW5wdXQgPSB0cnVlOw0KICAgICAgdGhpcy50ZXh0Q29udGVudHMgPSB0aGlzLmluaXRpYWxTZWxlY3Rpb247DQogICAgfQ0KDQogICAgLy8gVGhpcyBmb3JjZXMgZXJyb3JzIHRvIHNob3cgdXAgaW1tZWRpYXRlbHkgd2hlbiB0aGUgYmxvY2sgaXMgY3JlYXRlZCBpbnN0ZWFkIG9mIHJlcXVpcmluZyB1c2VyIGludGVyYWN0aW9uLCBidXQNCiAgICAvLyB3ZSBhbHNvIHdhbnQgdG8gaGlkZSB0b29sdGlwcyBiZWNhdXNlIHRoaXMgY2F1c2VzIHBvb3IgVUkgaWYgdGhlcmUgYXJlIGEgbG90IG9mIG5lYXJieSBlcnJvcnMgdXBvbiBjb252ZXJzaW9uDQogICAgdGhpcy5yZWNhbGN1bGF0ZUVycm9yQ291bnQoKTsNCiAgICB0aGlzLnN1cHByZXNzVG9vbHRpcCA9IHRydWU7DQoNCiAgICAvLyBGb3JjZSB0aGUgZWRpdG9yIHRvIHBhcnNlIHRoZSBzY3JpcHQgYWdhaW4gYWZ0ZXIgYWxsIHRoZSB2YWx1ZXMgaGF2ZSBiZWVuIGZpbGxlZCBpbiBhYm92ZSwgb3IgZWxzZSBpdCdsbCBjcmVhdGUNCiAgICAvLyBibG9ja3Mgd2hpY2ggYWx3YXlzIGhhdmUgZXJyb3JzIGR1ZSB0byB1bmRlZmluZWQgcHJvcHMNCiAgICBCbG9ja0F1dG9tYXRvci5wYXJzZVRleHRGcm9tQmxvY2tzKCk7DQogIH0sDQogIC8vIERlc3Ryb3lpbmcgc2luZ2xlIGlucHV0cyBuZWVkIHRvIGJlIGhhbmRsZWQgY2FyZWZ1bGx5IGJlY2F1c2UgdGhlcmUgYXJlIHRocmVlIHNpdHVhdGlvbnMgdW5kZXIgd2hpY2ggdGhleSB3aWxsDQogIC8vIGJlIHJlbW92ZWQsIGFuZCB0aGV5IGFsbCByZXF1aXJlIGRpZmZlcmVudCBiZWhhdmlvcjoNCiAgLy8gKiBUaGUgcGxheWVyIGNoYW5nZXMgdG8gdGhlIHRleHQgZWRpdG9yIG9yIHN3aXRjaGVzIHRhYnMvc2NyaXB0cywgd2lwaW5nIHRoZSBlbnRpcmUgc2NyaXB0ICh3ZSBkbyBub3RoaW5nIGhlcmUpDQogIC8vICogQmxvY2tzIGFyZSBkcmFnZ2VkIGFuZCByZW9yZGVyZWQsIGNhdXNpbmcgYSBwYXJlbnQgY29tcG9uZW50IHRvIGtleS1zd2FwIGFuZCBmb3JjZSBhIHJlcmVuZGVyIG9uIHRoaXMNCiAgLy8gICBjb21wb25lbnQgLSBpbiB0aGF0IGNhc2Ugd2UgbmVlZCB0byByZW1vdmUgdGhlIGVycm9ycyBjb3JyZXNwb25kaW5nIHRvIHRoZSBvbGQgbGluZSBudW1iZXINCiAgLy8gKiBBbiBlYXJsaWVyIGlucHV0IGluIHRoZSBjb21tYW5kIGNoYWluIG1ha2VzIHRoaXMgaW5wdXQgdW5uZWNlc3NhcnkgKGVnLiBjaGFuZ2luZyAidW5sb2NrIGVjIDgiIHRvDQogIC8vICAgInVubG9jayBkaWxhdGlvbiIgbWFrZXMgdGhlIDggdW5uZWNlc3NhcnkpIC0gdGhpcyBjYXNlIGlzIGhhbmRsZWQgd2hlbiB0aGUgcGFyZW50IGJsb2NrIGNhbGxzIGNoYW5nZUJsb2NrKCksDQogIC8vICAgYnV0IHdlIHN0aWxsIG5lZWQgdG8gdmVyaWZ5IGVycm9yIGNvdW50IGFuZCBwYXJzZSB0aGUgc2NyaXB0IGFnYWluIHNpbmNlIHdlIGF2b2lkIGRvaW5nIHRoYXQgd2l0aGluDQogIC8vICAgY2hhbmdlQmxvY2soKSBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucw0KICBkZXN0cm95ZWQoKSB7DQogICAgaWYgKHBsYXllci5yZWFsaXR5LmF1dG9tYXRvci50eXBlID09PSBBVVRPTUFUT1JfVFlQRS5URVhUIHx8IFRhYnMuY3VycmVudC5fY3VycmVudFN1YnRhYi5rZXkgIT09ICJhdXRvbWF0b3IiIHx8DQogICAgICB0aGlzLnNjcmlwdElEICE9PSBwbGF5ZXIucmVhbGl0eS5hdXRvbWF0b3Iuc3RhdGUuZWRpdG9yU2NyaXB0KSB7DQogICAgICByZXR1cm47DQogICAgfQ0KDQogICAgdGhpcy5yZWNhbGN1bGF0ZUVycm9yQ291bnQoKTsNCiAgICBjb25zdCBuZXdMaW5lTnVtID0gQmxvY2tBdXRvbWF0b3IubGluZU51bWJlcihCbG9ja0F1dG9tYXRvci5faWRBcnJheS5pbmRleE9mKHRoaXMuYmxvY2suaWQpICsgMSk7DQogICAgaWYgKHRoaXMubGluZU51bWJlciAhPT0gbmV3TGluZU51bSkgew0KICAgICAgY29uc3QgbmV3RXJyb3JzID0gW107DQogICAgICBmb3IgKGNvbnN0IGVycm9yIG9mIEF1dG9tYXRvckRhdGEuY2FjaGVkRXJyb3JzKSB7DQogICAgICAgIGlmIChlcnJvci5zdGFydExpbmUgIT09IHRoaXMubGluZU51bWJlcikgbmV3RXJyb3JzLnB1c2goZXJyb3IpOw0KICAgICAgfQ0KICAgICAgbmV3RXJyb3JzLnNvcnQoKGEsIGIpID0+IGEuc3RhcnRMaW5lIC0gYi5zdGFydExpbmUpOw0KICAgICAgQXV0b21hdG9yRGF0YS5jYWNoZWRFcnJvcnMgPSBuZXdFcnJvcnM7DQogICAgICByZXR1cm47DQogICAgfQ0KDQogICAgdGhpcy5yZWNhbGN1bGF0ZUVycm9yQ291bnQoKTsNCiAgICBCbG9ja0F1dG9tYXRvci5wYXJzZVRleHRGcm9tQmxvY2tzKCk7DQogIH0sDQogIG1ldGhvZHM6IHsNCiAgICB1cGRhdGUoKSB7DQogICAgICB0aGlzLmVycm9ycyA9IEF1dG9tYXRvckRhdGEuY2FjaGVkRXJyb3JzOw0KICAgICAgdGhpcy5oYXNFcnJvciA9IHRoaXMuZXJyb3JzLnNvbWUoZSA9PiBlLnN0YXJ0TGluZSA9PT0gdGhpcy5saW5lTnVtYmVyKTsNCiAgICAgIGlmICh0aGlzLmRyb3Bkb3duU2VsZWN0aW9uLnN0YXJ0c1dpdGgoIioiKSkgdGhpcy5pc1RleHRJbnB1dCA9IHRydWU7DQogICAgICB0aGlzLmNhbGN1bGF0ZVBhdGgoKTsNCiAgICB9LA0KICAgIGNhbGN1bGF0ZVBhdGgoKSB7DQogICAgICB0aGlzLmN1cnJlbnROb2RlT25QYXRoID0gIiAiOw0KICAgICAgZm9yIChjb25zdCBub2RlIG9mIE9iamVjdC5rZXlzKHRoaXMucGF0aFJlZikpIHsNCiAgICAgICAgY29uc3QgaXNWYWxpZFRleHQgPSB0aGlzLnBhdGhSZWZbbm9kZV0uc29tZShvID0+IG8uc3RhcnRzV2l0aCgiKiIpKSAmJiB0aGlzLmlzVGV4dElucHV0Ow0KICAgICAgICBpZiAodGhpcy5wYXRoUmVmW25vZGVdLmluY2x1ZGVzKHRoaXMuZHJvcGRvd25TZWxlY3Rpb24pIHx8IGlzVmFsaWRUZXh0KSB7DQogICAgICAgICAgdGhpcy5jdXJyZW50Tm9kZU9uUGF0aCA9IG5vZGU7DQogICAgICAgIH0NCiAgICAgIH0NCiAgICAgIGNvbnN0IGZ1bGxQYXRoID0gdGhpcy5jdXJyZW50UGF0aCArIHRoaXMuY3VycmVudE5vZGVPblBhdGg7DQogICAgICB0aGlzLm5leHROb2RlQ291bnQgPSB0aGlzLnBhdHRlcm5zLmZpbHRlcihwID0+IHAubGVuZ3RoID4gZnVsbFBhdGgubGVuZ3RoICYmIHAuc3RhcnRzV2l0aChmdWxsUGF0aCkpLmxlbmd0aDsNCiAgICAgIHRoaXMudW5rbm93bk5leHQgPSB0aGlzLm5leHROb2RlQ291bnQgPiAxIHx8ICh0aGlzLmRyb3Bkb3duU2VsZWN0aW9uID09PSAiIiAmJiAhdGhpcy5pc1RleHRJbnB1dCk7DQogICAgfSwNCiAgICB2YWxpZGF0ZUlucHV0KCkgew0KICAgICAgbGV0IHZhbGlkYXRvciwgbGluZXM7DQogICAgICBpZiAodGhpcy5iLm5lc3QpIHsNCiAgICAgICAgY29uc3QgY2xvbmUgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmIpOw0KICAgICAgICBjbG9uZS5uZXN0ID0gW107DQogICAgICAgIGxpbmVzID0gQmxvY2tBdXRvbWF0b3IucGFyc2VMaW5lcyhbY2xvbmVdKTsNCiAgICAgICAgdmFsaWRhdG9yID0gdmFsaWRhdGVMaW5lKGxpbmVzLmpvaW4oIlxuIikpOw0KICAgICAgfSBlbHNlIHsNCiAgICAgICAgbGluZXMgPSBCbG9ja0F1dG9tYXRvci5wYXJzZUxpbmVzKFt0aGlzLmJdKTsNCiAgICAgICAgdmFsaWRhdG9yID0gdmFsaWRhdGVMaW5lKGxpbmVzWzBdKTsNCiAgICAgIH0NCg0KICAgICAgLy8gWWVzLCB0aGUgb2RkIHN0cnVjdHVyZSBvZiB0aGlzIGNoZWNrIGlzIGludGVudGlvbmFsLiBTb21ldGhpbmcgb2RkIGhhcHBlbnMgd2l0aGluIHBhcnNlTGluZXMgdW5kZXIgY2VydGFpbg0KICAgICAgLy8gY29uZGl0aW9ucyB3aGljaCBzZWVtIGhhcmQgdG8gcGluIGRvd24sIHdoaWNoIGNhdXNlcyB0aGlzIGV2YWx1YXRlIHRvIGFuIGFycmF5IHdpdGggdGhlIHN0cmluZyAidW5kZWZpbmVkIg0KICAgICAgLy8gYmVpbmcgaXRzIG9ubHkgZWxlbWVudC4gVGhlc2UgY2FzZXMgYWxsIHNlZW0gdG8gYmUgZmFsc2UgcG9zaXRpdmVzDQogICAgICBpZiAobGluZXNbMF0gPT09ICJ1bmRlZmluZWQiKSByZXR1cm47DQoNCiAgICAgIC8vIFdlJ3JlIGFjdHVhbGx5IHZhbGlkYXRpbmcgb25seSB0aGlzIHNpbmdsZSBsaW5lLCBzbyB3ZSByZWNvbnN0cnVjdCB0aGUgZXJyb3IgbGlzdCBieSByZW1vdmluZyBldmVyeXRoaW5nIG9uDQogICAgICAvLyB0aGlzIGxpbmUgYW5kIGFkZGluZyBhbnl0aGluZyBuZXcgdGhhdCB3YXMgZm91bmQuIFdlIG9ubHkgdGFrZSB0aGUgZmlyc3QgZXJyb3IgZnJvbSB0aGlzIGxpbmUgKGlmIHRoZXJlIGFyZQ0KICAgICAgLy8gYW55KSBiZWNhdXNlIG11bHRpcGxlIGVycm9ycyBvbiB0aGUgc2FtZSBsaW5lIGFyZSBnZW5lcmFsbHkgcmVkdW5kYW50LCBhbmQgc29tZXRpbWVzIHRoZSBwYXJzZXIgaGljY3VwcyBhbmQNCiAgICAgIC8vIGR1cGxpY2F0ZXMgZXJyb3JzIG9udG8gdGhlIGxhc3QgbGluZSBvZiB0aGUgc2NyaXB0ICh3aGljaCB3ZSBleHBsaWNpdGx5IGlnbm9yZSkNCiAgICAgIGNvbnN0IG5ld0Vycm9ycyA9IFtdOw0KICAgICAgY29uc3QgbGFzdExpbmUgPSBCbG9ja0F1dG9tYXRvci5faWRBcnJheS5maWx0ZXIoaWQgPT4gaWQpLmxlbmd0aDsNCiAgICAgIGZvciAoY29uc3QgZXJyb3Igb2YgQXV0b21hdG9yRGF0YS5jYWNoZWRFcnJvcnMpIHsNCiAgICAgICAgaWYgKGVycm9yLnN0YXJ0TGluZSAhPT0gdGhpcy5saW5lTnVtYmVyICYmIGVycm9yLnN0YXJ0TGluZSA8IGxhc3RMaW5lKSB7DQogICAgICAgICAgbmV3RXJyb3JzLnB1c2goZXJyb3IpOw0KICAgICAgICB9DQogICAgICB9DQogICAgICBpZiAodmFsaWRhdG9yLmVycm9ycy5sZW5ndGggPiAwKSB7DQogICAgICAgIGNvbnN0IGVycm9yID0gdmFsaWRhdG9yLmVycm9yc1swXTsNCiAgICAgICAgZXJyb3Iuc3RhcnRMaW5lID0gdGhpcy5saW5lTnVtYmVyOw0KICAgICAgICBuZXdFcnJvcnMucHVzaChlcnJvcik7DQogICAgICB9DQogICAgICBuZXdFcnJvcnMuc29ydCgoYSwgYikgPT4gYS5zdGFydExpbmUgLSBiLnN0YXJ0TGluZSk7DQogICAgICBBdXRvbWF0b3JEYXRhLmNhY2hlZEVycm9ycyA9IG5ld0Vycm9yczsNCiAgICB9LA0KICAgIGhhbmRsZUZvY3VzKGZvY3VzU3RhdGUpIHsNCiAgICAgIHRoaXMuc3VwcHJlc3NUb29sdGlwID0gIWZvY3VzU3RhdGU7DQogICAgICB0aGlzLmNoYW5nZUJsb2NrKCk7DQogICAgfSwNCiAgICBjaGFuZ2VCbG9jaygpIHsNCiAgICAgIHRoaXMudXBkYXRlRnVuY3Rpb24odGhpcy5ibG9jaywgdGhpcy5ibG9jay5pZCk7DQogICAgICBpZiAodGhpcy5ibG9ja1RhcmdldCkgew0KICAgICAgICBsZXQgbmV3VmFsdWU7DQogICAgICAgIGlmICh0aGlzLmlzQm9vbFRhcmdldCkgbmV3VmFsdWUgPSB0aGlzLmRyb3Bkb3duU2VsZWN0aW9uICE9PSAiIjsNCiAgICAgICAgZWxzZSBpZiAodGhpcy5pc1RleHRJbnB1dCkgbmV3VmFsdWUgPSB0aGlzLnRleHRDb250ZW50czsNCiAgICAgICAgZWxzZSBuZXdWYWx1ZSA9IHRoaXMuZHJvcGRvd25TZWxlY3Rpb247DQoNCiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHZ1ZS9uby1tdXRhdGluZy1wcm9wcw0KICAgICAgICB0aGlzLmJsb2NrW3RoaXMuYmxvY2tUYXJnZXRdID0gbmV3VmFsdWU7DQoNCiAgICAgICAgLy8gU29tZXRpbWVzIGNoYW5naW5nIGEgYmxvY2sgdmFsdWUgY2F1c2VzIGxhdGVyIGJsb2NrcyBvbiB0aGUgbGluZSB0byBubyBsb25nZXIgZXhpc3QgZHVlIHRvIGEgZGlmZmVyZW50DQogICAgICAgIC8vIGNvbW1hbmQgc3RydWN0dXJlOyB3ZSB3aXBlIHRoZSBwcm9wcyByZWxhdGVkIHRvIHRob3NlIGJsb2NrcyBoZXJlIHNvIHRoYXQgdGhleSBkb24ndCBjYXVzZSBwYXJzaW5nIGVycm9ycw0KICAgICAgICB0aGlzLmNhbGN1bGF0ZVBhdGgoKTsNCiAgICAgICAgaWYgKHRoaXMubmV4dE5vZGVDb3VudCA9PT0gMCAmJiAhdGhpcy5pc0Jvb2xUYXJnZXQpIHsNCiAgICAgICAgICBjb25zdCBjdXJySW5kZXggPSB0aGlzLmJsb2NrLnRhcmdldHMuaW5kZXhPZih0aGlzLmJsb2NrVGFyZ2V0KTsNCiAgICAgICAgICBmb3IgKGxldCB0b0NsZWFyID0gY3VyckluZGV4ICsgMTsgdG9DbGVhciA8IHRoaXMuYmxvY2sudGFyZ2V0cy5sZW5ndGg7IHRvQ2xlYXIrKykgew0KICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHZ1ZS9uby1tdXRhdGluZy1wcm9wcw0KICAgICAgICAgICAgdGhpcy5ibG9ja1t0aGlzLmJsb2NrLnRhcmdldHNbdG9DbGVhcl1dID0gdW5kZWZpbmVkOw0KICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgICAgfQ0KICAgICAgdGhpcy5yZWNhbGN1bGF0ZUVycm9yQ291bnQoKTsNCiAgICB9LA0KICAgIC8vIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbmV2ZXIgYmxvY2tzIGFyZSBjaGFuZ2VkLCBidXQgd2UgYWxzbyBuZWVkIHRvIGhhbHQgZXhlY3V0aW9uIGlmIHRoZSBjdXJyZW50bHkgdmlzaWJsZSBzY3JpcHQNCiAgICAvLyBpcyBhbHNvIHRoZSBvbmUgYmVpbmcgcnVuDQogICAgcmVjYWxjdWxhdGVFcnJvckNvdW50KCkgew0KICAgICAgQmxvY2tBdXRvbWF0b3IucGFyc2VUZXh0RnJvbUJsb2Nrcyh0aGlzLnNjcmlwdElEKTsNCiAgICAgIHRoaXMudmFsaWRhdGVJbnB1dCgpOw0KICAgICAgaWYgKEF1dG9tYXRvckJhY2tlbmQuY3VycmVudEVkaXRpbmdTY3JpcHQuaWQgPT09IEF1dG9tYXRvckJhY2tlbmQuY3VycmVudFJ1bm5pbmdTY3JpcHQuaWQpIHsNCiAgICAgICAgQXV0b21hdG9yQmFja2VuZC5zdG9wKCk7DQogICAgICB9DQogICAgfSwNCiAgICBlcnJvclRvb2x0aXAoKSB7DQogICAgICBpZiAoIXRoaXMuaGFzRXJyb3IgfHwgdGhpcy5zdXBwcmVzc1Rvb2x0aXApIHJldHVybiB1bmRlZmluZWQ7DQoNCiAgICAgIC8vIFdlIHdhbnQgdG8ga2VlcCB0aGUgdmVyYm9zZSBlcnJvciBpbmZvIGZvciB0aGUgZXJyb3IgcGFuZWwsIGJ1dCB3ZSBuZWVkIHRvIHNob3J0ZW4gaXQgZm9yIHRoZSB0b29sdGlwcyBoZXJlDQogICAgICAvLyBUaGUgcHJvYmxlbWF0aWMgZXJyb3JzIGFsbCBzZWVtIHRvIGhhdmUgdGhlIHNhbWUgZm9ybWF0LCB3aGljaCB3ZSBjYW4gZXhwbGljaXRseSBtb2RpZnkNCiAgICAgIGxldCBlcnJvckluZm8gPSB0aGlzLmVycm9ycy5maW5kKGUgPT4gZS5zdGFydExpbmUgPT09IHRoaXMubGluZU51bWJlcikuaW5mbzsNCiAgICAgIGVycm9ySW5mbyA9IGVycm9ySW5mbw0KICAgICAgICAucmVwbGFjZUFsbCgiXG4iLCAiIikNCiAgICAgICAgLnJlcGxhY2UoL0V4cGVjdGluZzogb25lIG9mIHRoZXNlIHBvc3NpYmxlIFRva2VuIHNlcXVlbmNlczouKmJ1dCBmb3VuZDogKC4qKS91aSwgIlVuZXhwZWN0ZWQgaW5wdXQgZm9ybWF0OiAkMSIpOw0KICAgICAgcmV0dXJuIHsNCiAgICAgICAgY29udGVudDoNCiAgICAgICAgICBgPGRpdiBjbGFzcz0iYy1ibG9jay1hdXRvbWF0b3ItZXJyb3IiPg0KICAgICAgICAgIDxkaXY+JHtlcnJvckluZm99PC9kaXY+DQogICAgICAgIDwvZGl2PmAsDQogICAgICAgIGh0bWw6IHRydWUsDQogICAgICAgIHRyaWdnZXI6ICJtYW51YWwiLA0KICAgICAgICBzaG93OiB0cnVlLA0KICAgICAgICBjbGFzc2VzOiBbImMtYmxvY2stYXV0b21hdG9yLWVycm9yLWNvbnRhaW5lciIsICJnZW5lcmFsLXRvb2x0aXAiXQ0KICAgICAgfTsNCiAgICB9LA0KICAgIHRleHRJbnB1dENsYXNzT2JqZWN0KCkgew0KICAgICAgcmV0dXJuIHsNCiAgICAgICAgIm8tYXV0b21hdG9yLWJsb2NrLWlucHV0IjogdHJ1ZSwNCiAgICAgICAgIm8tbG9uZy10ZXh0LWlucHV0IjogdGhpcy5oYXNMb25nVGV4dElucHV0LA0KICAgICAgICAibC1lcnJvci10ZXh0Ym94IjogdGhpcy5oYXNFcnJvciwNCiAgICAgICAgImMtYXV0b21hdG9yLWlucHV0LXJlcXVpcmVkIjogIXRoaXMuaGFzRXJyb3IsDQogICAgICB9Ow0KICAgIH0sDQogICAgZHJvcGRvd25DbGFzc09iamVjdCgpIHsNCiAgICAgIHJldHVybiB7DQogICAgICAgICJvLWF1dG9tYXRvci1ibG9jay1pbnB1dCI6IHRydWUsDQogICAgICAgICJjLWF1dG9tYXRvci1pbnB1dC1yZXF1aXJlZCI6ICF0aGlzLmlzQm9vbFRhcmdldCwNCiAgICAgICAgImMtYXV0b21hdG9yLWlucHV0LW9wdGlvbmFsIjogdGhpcy5pc0Jvb2xUYXJnZXQsDQogICAgICAgICJsLWVycm9yLXRleHRib3giOiB0aGlzLmhhc0Vycm9yICYmICF0aGlzLmlzQm9vbFRhcmdldCAmJiB0aGlzLmRyb3Bkb3duU2VsZWN0aW9uID09PSAiIiwNCiAgICAgIH07DQogICAgfSwNCiAgICByZXZlcnRUb0Ryb3Bkb3duKCkgew0KICAgICAgdGhpcy5pc1RleHRJbnB1dCA9IGZhbHNlOw0KICAgICAgdGhpcy5kcm9wZG93blNlbGVjdGlvbiA9ICIiOw0KICAgICAgdGhpcy50ZXh0Q29udGVudHMgPSAiIjsNCiAgICB9DQogIH0NCn07DQo="},{"version":3,"sources":["AutomatorBlockSingleInput.vue"],"names":[],"mappings":";AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"AutomatorBlockSingleInput.vue","sourceRoot":"src/components/tabs/automator","sourcesContent":["<script>\r\nimport { validateLine } from \"@/core/automator\";\r\n\r\nexport default {\r\n  name: \"AutomatorBlockSingleInput\",\r\n  props: {\r\n    constant: {\r\n      type: String,\r\n      required: false,\r\n      default: \"\"\r\n    },\r\n    block: {\r\n      type: Object,\r\n      required: true\r\n    },\r\n    blockTarget: {\r\n      type: String,\r\n      required: false,\r\n      default: \"\"\r\n    },\r\n    updateFunction: {\r\n      type: Function,\r\n      required: true\r\n    },\r\n    initialSelection: {\r\n      type: String,\r\n      required: false,\r\n      default: \"\"\r\n    },\r\n    patterns: {\r\n      type: Array,\r\n      required: false,\r\n      default: () => []\r\n    },\r\n    recursive: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: false\r\n    },\r\n    currentPath: {\r\n      type: String,\r\n      required: false,\r\n      default: \"\"\r\n    }\r\n  },\r\n  data() {\r\n    return {\r\n      b: {},\r\n      suppressTooltip: false,\r\n      errors: [],\r\n      hasError: false,\r\n\r\n      isTextInput: false,\r\n      dropdownOptions: [],\r\n      dropdownSelection: \"\",\r\n      textContents: \"\",\r\n      pathRef: {},\r\n      currentNodeOnPath: \"\",\r\n      unknownNext: false,\r\n      nextNodeCount: 0,\r\n      lineNumber: 0,\r\n      // This is tracked here because switching scripts causes events to be fired in a weird order, often seemingly\r\n      // starting the creation of the new component before the UI's visible script ID is properly updated\r\n      scriptID: 0,\r\n    };\r\n  },\r\n  computed: {\r\n    displayedConstant() {\r\n      if (this.constant) {\r\n        // \\uE010 is :blob:\r\n        return this.constant === \"BLOB\" ? \"\\uE010\" : this.constant;\r\n      }\r\n      return (this.dropdownOptions.length === 1 && !this.isBoolTarget && !this.isTextInput)\r\n        ? this.dropdownOptions[0]\r\n        : \"\";\r\n    },\r\n    isBoolTarget() {\r\n      return this.blockTarget === \"nowait\" || this.blockTarget === \"respec\";\r\n    },\r\n    nextInputKey() {\r\n      return this.block.targets[this.currentPath.length + 1];\r\n    },\r\n    nextInputValue() {\r\n      const targetList = this.block.targets;\r\n      const value = targetList ? this.block[this.nextInputKey] : \"\";\r\n      // Sometimes the target might be a Number or undefined but the prop type-checks for it to be a String\r\n      return value ? `${value}` : \"\";\r\n    },\r\n    // Most of the time the input is just a number or constant but these ones will typically lead to longer\r\n    // phrases in String format, so we want to give some extra room\r\n    hasLongTextInput() {\r\n      return this.block.cmd === \"NOTIFY\" || this.block.cmd === \"COMMENT\";\r\n    }\r\n  },\r\n  created() {\r\n    this.scriptID = player.reality.automator.state.editorScript;\r\n    this.b = this.block;\r\n    this.lineNumber = BlockAutomator.lineNumber(BlockAutomator._idArray.indexOf(this.block.id) + 1);\r\n    BlockAutomator.updateIdArray();\r\n    if (this.constant) return;\r\n    if (this.isBoolTarget) {\r\n      this.dropdownOptions = [this.blockTarget.toUpperCase()];\r\n      this.dropdownSelection = this.block[this.blockTarget] ? this.blockTarget.toUpperCase() : \"\";\r\n      return;\r\n    }\r\n\r\n    // This is used for sequences of inputs, which are traversed by recursion\r\n    if (this.recursive) {\r\n      const availableOptions = this.patterns\r\n        .filter(s => s.startsWith(this.currentPath) && s.length > this.currentPath.length)\r\n        .map(s => s.charAt(this.currentPath.length));\r\n      for (const node of availableOptions) {\r\n        if (this.pathRef[node]) continue;\r\n        const entries = this.block[node];\r\n        this.pathRef[node] = entries;\r\n        this.dropdownOptions.push(...entries);\r\n      }\r\n      this.calculatePath();\r\n    }\r\n\r\n    // Set the initial display state properly\r\n    if (this.dropdownOptions.includes(this.initialSelection)) {\r\n      this.dropdownSelection = this.initialSelection;\r\n    } else if (this.initialSelection) {\r\n      this.isTextInput = true;\r\n      this.textContents = this.initialSelection;\r\n    }\r\n\r\n    // Special handling for text-input-only fields, which will have single-element array specifications\r\n    if (this.dropdownOptions.length === 1 && this.dropdownOptions[0].startsWith(\"*\")) {\r\n      this.isTextInput = true;\r\n      this.textContents = this.initialSelection;\r\n    }\r\n\r\n    // This forces errors to show up immediately when the block is created instead of requiring user interaction, but\r\n    // we also want to hide tooltips because this causes poor UI if there are a lot of nearby errors upon conversion\r\n    this.recalculateErrorCount();\r\n    this.suppressTooltip = true;\r\n\r\n    // Force the editor to parse the script again after all the values have been filled in above, or else it'll create\r\n    // blocks which always have errors due to undefined props\r\n    BlockAutomator.parseTextFromBlocks();\r\n  },\r\n  // Destroying single inputs need to be handled carefully because there are three situations under which they will\r\n  // be removed, and they all require different behavior:\r\n  // * The player changes to the text editor or switches tabs/scripts, wiping the entire script (we do nothing here)\r\n  // * Blocks are dragged and reordered, causing a parent component to key-swap and force a rerender on this\r\n  //   component - in that case we need to remove the errors corresponding to the old line number\r\n  // * An earlier input in the command chain makes this input unnecessary (eg. changing \"unlock ec 8\" to\r\n  //   \"unlock dilation\" makes the 8 unnecessary) - this case is handled when the parent block calls changeBlock(),\r\n  //   but we still need to verify error count and parse the script again since we avoid doing that within\r\n  //   changeBlock() for performance reasons\r\n  destroyed() {\r\n    if (player.reality.automator.type === AUTOMATOR_TYPE.TEXT || Tabs.current._currentSubtab.key !== \"automator\" ||\r\n      this.scriptID !== player.reality.automator.state.editorScript) {\r\n      return;\r\n    }\r\n\r\n    this.recalculateErrorCount();\r\n    const newLineNum = BlockAutomator.lineNumber(BlockAutomator._idArray.indexOf(this.block.id) + 1);\r\n    if (this.lineNumber !== newLineNum) {\r\n      const newErrors = [];\r\n      for (const error of AutomatorData.cachedErrors) {\r\n        if (error.startLine !== this.lineNumber) newErrors.push(error);\r\n      }\r\n      newErrors.sort((a, b) => a.startLine - b.startLine);\r\n      AutomatorData.cachedErrors = newErrors;\r\n      return;\r\n    }\r\n\r\n    this.recalculateErrorCount();\r\n    BlockAutomator.parseTextFromBlocks();\r\n  },\r\n  methods: {\r\n    update() {\r\n      this.errors = AutomatorData.cachedErrors;\r\n      this.hasError = this.errors.some(e => e.startLine === this.lineNumber);\r\n      if (this.dropdownSelection.startsWith(\"*\")) this.isTextInput = true;\r\n      this.calculatePath();\r\n    },\r\n    calculatePath() {\r\n      this.currentNodeOnPath = \" \";\r\n      for (const node of Object.keys(this.pathRef)) {\r\n        const isValidText = this.pathRef[node].some(o => o.startsWith(\"*\")) && this.isTextInput;\r\n        if (this.pathRef[node].includes(this.dropdownSelection) || isValidText) {\r\n          this.currentNodeOnPath = node;\r\n        }\r\n      }\r\n      const fullPath = this.currentPath + this.currentNodeOnPath;\r\n      this.nextNodeCount = this.patterns.filter(p => p.length > fullPath.length && p.startsWith(fullPath)).length;\r\n      this.unknownNext = this.nextNodeCount > 1 || (this.dropdownSelection === \"\" && !this.isTextInput);\r\n    },\r\n    validateInput() {\r\n      let validator, lines;\r\n      if (this.b.nest) {\r\n        const clone = Object.assign({}, this.b);\r\n        clone.nest = [];\r\n        lines = BlockAutomator.parseLines([clone]);\r\n        validator = validateLine(lines.join(\"\\n\"));\r\n      } else {\r\n        lines = BlockAutomator.parseLines([this.b]);\r\n        validator = validateLine(lines[0]);\r\n      }\r\n\r\n      // Yes, the odd structure of this check is intentional. Something odd happens within parseLines under certain\r\n      // conditions which seem hard to pin down, which causes this evaluate to an array with the string \"undefined\"\r\n      // being its only element. These cases all seem to be false positives\r\n      if (lines[0] === \"undefined\") return;\r\n\r\n      // We're actually validating only this single line, so we reconstruct the error list by removing everything on\r\n      // this line and adding anything new that was found. We only take the first error from this line (if there are\r\n      // any) because multiple errors on the same line are generally redundant, and sometimes the parser hiccups and\r\n      // duplicates errors onto the last line of the script (which we explicitly ignore)\r\n      const newErrors = [];\r\n      const lastLine = BlockAutomator._idArray.filter(id => id).length;\r\n      for (const error of AutomatorData.cachedErrors) {\r\n        if (error.startLine !== this.lineNumber && error.startLine < lastLine) {\r\n          newErrors.push(error);\r\n        }\r\n      }\r\n      if (validator.errors.length > 0) {\r\n        const error = validator.errors[0];\r\n        error.startLine = this.lineNumber;\r\n        newErrors.push(error);\r\n      }\r\n      newErrors.sort((a, b) => a.startLine - b.startLine);\r\n      AutomatorData.cachedErrors = newErrors;\r\n    },\r\n    handleFocus(focusState) {\r\n      this.suppressTooltip = !focusState;\r\n      this.changeBlock();\r\n    },\r\n    changeBlock() {\r\n      this.updateFunction(this.block, this.block.id);\r\n      if (this.blockTarget) {\r\n        let newValue;\r\n        if (this.isBoolTarget) newValue = this.dropdownSelection !== \"\";\r\n        else if (this.isTextInput) newValue = this.textContents;\r\n        else newValue = this.dropdownSelection;\r\n\r\n        // eslint-disable-next-line vue/no-mutating-props\r\n        this.block[this.blockTarget] = newValue;\r\n\r\n        // Sometimes changing a block value causes later blocks on the line to no longer exist due to a different\r\n        // command structure; we wipe the props related to those blocks here so that they don't cause parsing errors\r\n        this.calculatePath();\r\n        if (this.nextNodeCount === 0 && !this.isBoolTarget) {\r\n          const currIndex = this.block.targets.indexOf(this.blockTarget);\r\n          for (let toClear = currIndex + 1; toClear < this.block.targets.length; toClear++) {\r\n            // eslint-disable-next-line vue/no-mutating-props\r\n            this.block[this.block.targets[toClear]] = undefined;\r\n          }\r\n        }\r\n      }\r\n      this.recalculateErrorCount();\r\n    },\r\n    // This gets called whenever blocks are changed, but we also need to halt execution if the currently visible script\r\n    // is also the one being run\r\n    recalculateErrorCount() {\r\n      BlockAutomator.parseTextFromBlocks(this.scriptID);\r\n      this.validateInput();\r\n      if (AutomatorBackend.currentEditingScript.id === AutomatorBackend.currentRunningScript.id) {\r\n        AutomatorBackend.stop();\r\n      }\r\n    },\r\n    errorTooltip() {\r\n      if (!this.hasError || this.suppressTooltip) return undefined;\r\n\r\n      // We want to keep the verbose error info for the error panel, but we need to shorten it for the tooltips here\r\n      // The problematic errors all seem to have the same format, which we can explicitly modify\r\n      let errorInfo = this.errors.find(e => e.startLine === this.lineNumber).info;\r\n      errorInfo = errorInfo\r\n        .replaceAll(\"\\n\", \"\")\r\n        .replace(/Expecting: one of these possible Token sequences:.*but found: (.*)/ui, \"Unexpected input format: $1\");\r\n      return {\r\n        content:\r\n          `<div class=\"c-block-automator-error\">\r\n          <div>${errorInfo}</div>\r\n        </div>`,\r\n        html: true,\r\n        trigger: \"manual\",\r\n        show: true,\r\n        classes: [\"c-block-automator-error-container\", \"general-tooltip\"]\r\n      };\r\n    },\r\n    textInputClassObject() {\r\n      return {\r\n        \"o-automator-block-input\": true,\r\n        \"o-long-text-input\": this.hasLongTextInput,\r\n        \"l-error-textbox\": this.hasError,\r\n        \"c-automator-input-required\": !this.hasError,\r\n      };\r\n    },\r\n    dropdownClassObject() {\r\n      return {\r\n        \"o-automator-block-input\": true,\r\n        \"c-automator-input-required\": !this.isBoolTarget,\r\n        \"c-automator-input-optional\": this.isBoolTarget,\r\n        \"l-error-textbox\": this.hasError && !this.isBoolTarget && this.dropdownSelection === \"\",\r\n      };\r\n    },\r\n    revertToDropdown() {\r\n      this.isTextInput = false;\r\n      this.dropdownSelection = \"\";\r\n      this.textContents = \"\";\r\n    }\r\n  }\r\n};\r\n</script>\r\n\r\n<template>\r\n  <div class=\"c-automator-single-block\">\r\n    <div\r\n      v-if=\"displayedConstant\"\r\n      class=\"c-automator-single-block o-automator-command c-automator-constant-block\"\r\n      :class=\"{ 'l-blob' : constant === 'BLOB' }\"\r\n    >\r\n      {{ displayedConstant }}\r\n    </div>\r\n    <div\r\n      v-else-if=\"isTextInput\"\r\n      class=\"c-automator-text-input-container\"\r\n    >\r\n      <input\r\n        v-model=\"textContents\"\r\n        v-tooltip=\"errorTooltip()\"\r\n        :class=\"textInputClassObject()\"\r\n        @keyup=\"changeBlock()\"\r\n        @focusin=\"handleFocus(true)\"\r\n        @focusout=\"handleFocus(false)\"\r\n      >\r\n      <div\r\n        v-if=\"dropdownOptions.length > 1\"\r\n        class=\"c-automator-close-text-input fa-solid fa-circle-xmark\"\r\n        @click=\"revertToDropdown\"\r\n      />\r\n    </div>\r\n    <select\r\n      v-else\r\n      v-model=\"dropdownSelection\"\r\n      :class=\"dropdownClassObject()\"\r\n      @change=\"changeBlock()\"\r\n    >\r\n      <option\r\n        v-for=\"target in ['', ...dropdownOptions]\"\r\n        :key=\"target\"\r\n        :value=\"target\"\r\n      >\r\n        {{ target }}\r\n      </option>\r\n    </select>\r\n    <AutomatorBlockSingleInput\r\n      v-if=\"recursive && nextNodeCount > 0\"\r\n      :key=\"currentNodeOnPath\"\r\n      :constant=\"unknownNext ? '...' : ''\"\r\n      :block=\"block\"\r\n      :block-target=\"nextInputKey\"\r\n      :patterns=\"patterns\"\r\n      :initial-selection=\"nextInputValue\"\r\n      :update-function=\"updateFunction\"\r\n      :recursive=\"true\"\r\n      :current-path=\"currentPath + currentNodeOnPath\"\r\n    />\r\n  </div>\r\n</template>\r\n\r\n<style scoped>\r\n.c-automator-single-block {\r\n  display: flex;\r\n  flex-direction: row;\r\n  justify-content: center;\r\n  align-items: center;\r\n  height: 2.8rem;\r\n  white-space: nowrap;\r\n}\r\n\r\n.c-automator-constant-block {\r\n  background: var(--color-blockmator-block-command);\r\n  color: var(--color-blockmator-editor-background);\r\n}\r\n\r\n.c-automator-text-input-container {\r\n  position: relative;\r\n}\r\n\r\n.o-long-text-input {\r\n  width: 30rem;\r\n}\r\n\r\n.c-automator-close-text-input {\r\n  position: absolute;\r\n  color: var(--color-automator-error-outline);\r\n  font-size: 1.5rem;\r\n  z-index: 1;\r\n  right: 0.8rem;\r\n  top: 0.6rem;\r\n}\r\n\r\n.l-error-textbox {\r\n  background: var(--color-automator-error-background);\r\n  color: yellow;\r\n}\r\n\r\n.l-blob {\r\n  font-size: 1.8rem;\r\n  background: black;\r\n  color: #fc2;\r\n}\r\n</style>\r\n"]}]}