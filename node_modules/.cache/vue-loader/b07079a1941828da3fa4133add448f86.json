{"remainingRequest":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\@vue\\vue-loader-v15\\lib\\index.js??vue-loader-options!C:\\Games\\ADFasterer\\ADfasterer\\src\\components\\tabs\\autobuyers\\AutobuyerInput.vue?vue&type=style&index=0&id=90abc8b6&scoped=true&lang=css&","dependencies":[{"path":"C:\\Games\\ADFasterer\\ADfasterer\\src\\components\\tabs\\autobuyers\\AutobuyerInput.vue","mtime":1745241597029},{"path":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\css-loader\\dist\\cjs.js","mtime":1745242216572},{"path":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\@vue\\vue-loader-v15\\lib\\loaders\\stylePostLoader.js","mtime":1745242222796},{"path":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\postcss-loader\\dist\\cjs.js","mtime":1745242214022},{"path":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1745242214069},{"path":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\@vue\\vue-loader-v15\\lib\\index.js","mtime":1745242220175}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoNCi5vLWF1dG9idXllci1pbnB1dC0taW52YWxpZCB7DQogIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWJhZCk7DQp9DQoNCi5zLWJhc2UtLWRhcmsgLm8tYXV0b2J1eWVyLWlucHV0LS1pbnZhbGlkLA0KLnQtczEgLm8tYXV0b2J1eWVyLWlucHV0LS1pbnZhbGlkIHsNCiAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3ItYmFkKTsNCn0NCg=="},{"version":3,"sources":["AutobuyerInput.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+JA;AACA;AACA;;AAEA;AACA;AACA;AACA","file":"AutobuyerInput.vue","sourceRoot":"src/components/tabs/autobuyers","sourcesContent":["<script>\r\nexport default {\r\n  name: \"AutobuyerInput\",\r\n  props: {\r\n    autobuyer: {\r\n      type: Object,\r\n      required: true\r\n    },\r\n    property: {\r\n      type: String,\r\n      required: true\r\n    },\r\n    type: {\r\n      type: String,\r\n      required: true\r\n    }\r\n  },\r\n  data() {\r\n    return {\r\n      isValid: true,\r\n      isFocused: false,\r\n      displayValue: \"0\"\r\n    };\r\n  },\r\n  computed: {\r\n    inputType() {\r\n      return this.type === \"int\" ? \"number\" : \"text\";\r\n    },\r\n    typeFunctions() {\r\n      const functions = AutobuyerInputFunctions[this.type];\r\n      if (functions === undefined) {\r\n        throw new Error(\"Unknown autobuyer input type\");\r\n      }\r\n      return functions;\r\n    },\r\n    validityClass() {\r\n      return this.isValid ? undefined : \"o-autobuyer-input--invalid\";\r\n    }\r\n  },\r\n  methods: {\r\n    update() {\r\n      if (this.isFocused) return;\r\n      this.updateActualValue();\r\n    },\r\n    updateActualValue() {\r\n      const actualValue = this.autobuyer[this.property];\r\n      if (this.areEqual(this.actualValue, actualValue)) return;\r\n      this.actualValue = this.typeFunctions.copyValue(actualValue);\r\n      this.updateDisplayValue();\r\n    },\r\n    areEqual(value, other) {\r\n      if (other === undefined || value === undefined) return false;\r\n      return this.typeFunctions.areEqual(value, other);\r\n    },\r\n    updateDisplayValue() {\r\n      this.displayValue = this.typeFunctions.formatValue(this.actualValue);\r\n    },\r\n    handleInput(event) {\r\n      const input = event.target.value;\r\n      this.displayValue = input;\r\n      if (input.length === 0) {\r\n        this.isValid = false;\r\n        return;\r\n      }\r\n      const parsedValue = this.typeFunctions.tryParse(input);\r\n      this.isValid = parsedValue !== undefined;\r\n      this.actualValue = this.typeFunctions.copyValue(parsedValue);\r\n    },\r\n    handleFocus() {\r\n      this.isFocused = true;\r\n    },\r\n    handleChange(event) {\r\n      if (this.displayValue === \"69\") {\r\n        SecretAchievement(28).unlock();\r\n      }\r\n      if (this.isValid) {\r\n        this.autobuyer[this.property] = this.typeFunctions.copyValue(this.actualValue);\r\n      } else {\r\n        this.updateActualValue();\r\n      }\r\n      this.updateDisplayValue();\r\n      this.isValid = true;\r\n\r\n      this.isFocused = false;\r\n      event.target.blur();\r\n    },\r\n  }\r\n};\r\n\r\nexport const AutobuyerInputFunctions = {\r\n  decimal: {\r\n    areEqual: (value, other) => Decimal.eq(value, other),\r\n    formatValue: value => Notation.scientific.format(value, 2, 2),\r\n    copyValue: value => new Decimal(value),\r\n    tryParse: input => {\r\n      if (!input) return undefined;\r\n      try {\r\n        let decimal;\r\n        if (/^e\\d*[.]?\\d+$/u.test(input.replaceAll(\",\", \"\"))) {\r\n          // Logarithm Notation\r\n          decimal = Decimal.pow10(parseFloat(input.replaceAll(\",\", \"\").slice(1)));\r\n        } else if (/^\\d*[.]?\\d+(e\\d+)?$/u.test(input.replaceAll(\",\", \"\"))) {\r\n          // Scientific notation; internals of break-infinity will gladly strip extraneous letters before parsing, but\r\n          // since this is largely uncommunicated to the user, we instead explicitly check for formatting and reject\r\n          // anything that doesn't fit as invalid\r\n          decimal = Decimal.fromString(input.replaceAll(\",\", \"\"));\r\n        } else if (/^\\d*[.]?\\d+(e\\d*[.]?\\d+)?$/u.test(input.replaceAll(\",\", \"\"))) {\r\n          // \"Mixed scientific notation\" - inputs such as \"2.33e41.2\" cause buggy behavior when fed directly into\r\n          // Decimal.fromString, so we parse out the mantissa and exponent separately before combining them\r\n          const regex = /(?<mantissa>\\d*[.]?\\d+)e(?<exponent>\\d*[.]?\\d+)/u;\r\n          const match = input.replaceAll(\",\", \"\").match(regex);\r\n          decimal = Decimal.pow10(Math.log10(Number(match.groups.mantissa)) + Number(match.groups.exponent));\r\n        } else {\r\n          return undefined;\r\n        }\r\n        return isNaN(decimal.mantissa) || isNaN(decimal.exponent) ? undefined : decimal;\r\n      } catch (e) {\r\n        return undefined;\r\n      }\r\n    }\r\n  },\r\n  float: {\r\n    areEqual: (value, other) => value === other,\r\n    formatValue: value => value.toString(),\r\n    copyValue: value => value,\r\n    tryParse: input => {\r\n      const float = parseFloat(input);\r\n      return isNaN(float) ? undefined : float;\r\n    }\r\n  },\r\n  int: {\r\n    areEqual: (value, other) => value === other,\r\n    formatValue: value => value.toString(),\r\n    copyValue: value => value,\r\n    tryParse: input => {\r\n      if (!input) return undefined;\r\n      // We explicitly check formatting here instead of letting parseInt handle the whole thing because otherwise the\r\n      // fact that parseInt removes extraneous letters means junk like \"361ebqv3\" registers as valid and parses as 361\r\n      if (!/^\\d+$/u.test(input.replaceAll(\",\", \"\"))) return undefined;\r\n      const int = parseInt(input, 10);\r\n      return isNaN(int) || !Number.isInteger(int) ? undefined : int;\r\n    }\r\n  }\r\n};\r\n</script>\r\n\r\n<template>\r\n  <input\r\n    :value=\"displayValue\"\r\n    :class=\"validityClass\"\r\n    :type=\"inputType\"\r\n    class=\"o-autobuyer-input\"\r\n    @change=\"handleChange\"\r\n    @focus=\"handleFocus\"\r\n    @input=\"handleInput\"\r\n  >\r\n</template>\r\n\r\n<style scoped>\r\n.o-autobuyer-input--invalid {\r\n  background-color: var(--color-bad);\r\n}\r\n\r\n.s-base--dark .o-autobuyer-input--invalid,\r\n.t-s1 .o-autobuyer-input--invalid {\r\n  background-color: var(--color-bad);\r\n}\r\n</style>\r\n"]}]}