{"remainingRequest":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\@vue\\vue-loader-v15\\lib\\index.js??vue-loader-options!C:\\Games\\ADFasterer\\ADfasterer\\src\\components\\ui-modes\\HeaderChallengeDisplay.vue?vue&type=style&index=0&id=2a5a9e24&scoped=true&lang=css&","dependencies":[{"path":"C:\\Games\\ADFasterer\\ADfasterer\\src\\components\\ui-modes\\HeaderChallengeDisplay.vue","mtime":1745241597517},{"path":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\css-loader\\dist\\cjs.js","mtime":1745242216572},{"path":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\@vue\\vue-loader-v15\\lib\\loaders\\stylePostLoader.js","mtime":1745242222796},{"path":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\postcss-loader\\dist\\cjs.js","mtime":1745242214022},{"path":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1745242214069},{"path":"C:\\Games\\ADFasterer\\ADfasterer\\node_modules\\@vue\\vue-loader-v15\\lib\\index.js","mtime":1745242220175}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKDQoubC1nYW1lLWhlYWRlcl9fY2hhbGxlbmdlLXRleHQgew0KICBkaXNwbGF5OiBmbGV4Ow0KICBoZWlnaHQ6IDJyZW07DQogIHRvcDogNTAlOw0KICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjsNCiAgYWxpZ24taXRlbXM6IGNlbnRlcjsNCiAgZm9udC1zaXplOiAxLjJyZW07DQogIGZvbnQtd2VpZ2h0OiBib2xkOw0KICBjb2xvcjogdmFyKC0tY29sb3ItdGV4dCk7DQogIG1hcmdpbjogMC41cmVtOw0KfQ0KDQoubC1jaGFsbGVuZ2UtZGlzcGxheSB7DQogIHBhZGRpbmc6IDAuNXJlbTsNCiAgY3Vyc29yOiBkZWZhdWx0Ow0KfQ0KDQoubC1jaGFsbGVuZ2UtZGlzcGxheS0tY2xpY2thYmxlIHsNCiAgY3Vyc29yOiBwb2ludGVyOw0KICB1c2VyLXNlbGVjdDogbm9uZTsNCn0NCg0KLmwtY2hhbGxlbmdlLWRpc3BsYXktLWNsaWNrYWJsZTpob3ZlciB7DQogIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lOw0KfQ0KDQoubC1wYWRkaW5nLWxpbmUgew0KICBwYWRkaW5nOiAwLjNyZW07DQp9DQo="},{"version":3,"sources":["HeaderChallengeDisplay.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA","file":"HeaderChallengeDisplay.vue","sourceRoot":"src/components/ui-modes","sourcesContent":["<script>\r\nimport FailableEcText from \"./FailableEcText\";\r\nimport PrimaryButton from \"@/components/PrimaryButton\";\r\n\r\nexport default {\r\n  name: \"HeaderChallengeDisplay\",\r\n  components: {\r\n    FailableEcText,\r\n    PrimaryButton\r\n  },\r\n  data() {\r\n    return {\r\n      activityTokens: [],\r\n      infinityUnlocked: false,\r\n      showExit: false,\r\n      exitText: \"\",\r\n      resetCelestial: false,\r\n      inPelle: false,\r\n    };\r\n  },\r\n  computed: {\r\n    parts() {\r\n      // We need activityToken for NC/IC/EC because plain check of WhateverChallenge.isRunning\r\n      // won't trigger display update if we, say, switch from one challenge to another\r\n      function celestialReality(celestial, name, tab) {\r\n        return {\r\n          name: () => `${name} Reality`,\r\n          isActive: token => token,\r\n          activityToken: () => celestial.isRunning,\r\n          tabName: () => tab,\r\n        };\r\n      }\r\n      return [\r\n        celestialReality(Teresa, \"Teresa's\", \"teresa\"),\r\n        celestialReality(Effarig, \"Effarig's\", \"effarig\"),\r\n        celestialReality(Enslaved, \"The Nameless Ones'\", \"enslaved\"),\r\n        celestialReality(V, \"V's\", \"v\"),\r\n        celestialReality(Ra, \"Ra's\", \"ra\"),\r\n        celestialReality(Laitela, \"Lai'tela's\", \"laitela\"),\r\n        {\r\n          name: () => \"Time Dilation\",\r\n          isActive: token => token,\r\n          activityToken: () => player.dilation.active\r\n        },\r\n        {\r\n          name: token => `Eternity Challenge ${token}`,\r\n          isActive: token => token > 0,\r\n          activityToken: () => player.challenge.eternity.current\r\n        },\r\n        {\r\n          name: token => `Infinity Challenge ${token}`,\r\n          isActive: token => token > 0,\r\n          activityToken: () => player.challenge.infinity.current\r\n        },\r\n        {\r\n          name: token => `${NormalChallenge(token).config.name} Challenge`,\r\n          isActive: token => token > 0,\r\n          activityToken: () => player.challenge.normal.current\r\n        },\r\n      ];\r\n    },\r\n    activeChallengeNames() {\r\n      const names = [];\r\n      for (let i = 0; i < this.activityTokens.length; i++) {\r\n        const token = this.activityTokens[i];\r\n        const part = this.parts[i];\r\n        if (!part.isActive(token)) continue;\r\n        if (part.name(token).includes(\"Eternity Challenge\")) {\r\n          const currEC = player.challenge.eternity.current;\r\n          const nextCompletion = EternityChallenge(currEC).completions + 1;\r\n          let completionText = \"\";\r\n          if (Enslaved.isRunning && currEC === 1) {\r\n            completionText = `(${formatInt(nextCompletion)}/???)`;\r\n          } else if (nextCompletion === 6) {\r\n            completionText = `(already completed)`;\r\n          } else {\r\n            completionText = `(${formatInt(nextCompletion)}/${formatInt(5)})`;\r\n          }\r\n          names.push(`${part.name(token)} ${completionText}`);\r\n        } else {\r\n          names.push(part.name(token));\r\n        }\r\n      }\r\n      return names;\r\n    },\r\n    isVisible() {\r\n      return this.infinityUnlocked || this.activeChallengeNames.length > 0;\r\n    },\r\n    isInFailableEC() {\r\n      return this.activeChallengeNames.some(str => str.match(/Eternity Challenge (4|12)/gu));\r\n    },\r\n    challengeDisplay() {\r\n      if (this.inPelle && this.activeChallengeNames.length > 0) {\r\n        return `${this.activeChallengeNames.join(\" + \")} in a Doomed Reality. Good luck.`;\r\n      }\r\n      if (this.inPelle) return \"a Doomed Reality. Good luck.\";\r\n      if (this.activeChallengeNames.length === 0) {\r\n        return \"the Antimatter Universe (no active challenges)\";\r\n      }\r\n      return this.activeChallengeNames.join(\" + \");\r\n    },\r\n  },\r\n  methods: {\r\n    update() {\r\n      this.infinityUnlocked = PlayerProgress.infinityUnlocked();\r\n      this.activityTokens = this.parts.map(part => part.activityToken());\r\n      // Dilation in Pelle can't be left once entered, but we still want to allow leaving more nested challenges\r\n      this.showExit = this.inPelle && player.dilation.active\r\n        ? this.activeChallengeNames.length > 1\r\n        : this.activeChallengeNames.length !== 0;\r\n      this.exitText = this.exitDisplay();\r\n      this.resetCelestial = player.options.retryCelestial;\r\n      this.inPelle = Pelle.isDoomed;\r\n    },\r\n    // Process exit requests from the inside out; Challenges first, then dilation, then Celestial Reality. If the\r\n    // relevant option is toggled, we pass a bunch of information over to a modal - otherwise we immediately exit\r\n    exitButtonClicked() {\r\n      let names, clickFn;\r\n      const isEC = Player.anyChallenge instanceof EternityChallengeState;\r\n\r\n      // Dilation and ECs can't be exited independently and we have a special dilation-exit modal, so we have\r\n      // to treat that particular case differently. The dilation modal itself will account for EC state\r\n      if (player.dilation.active && (!Player.isInAnyChallenge || isEC)) {\r\n        if (player.options.confirmations.dilation) Modal.exitDilation.show();\r\n        else startDilatedEternityRequest();\r\n        return;\r\n      }\r\n\r\n      if (Player.isInAnyChallenge) {\r\n        // Regex replacement is used to remove the \"(X/Y)\" which appears after ECs. The ternary statement is there\r\n        // because this path gets called for NCs, ICs, and ECs\r\n        const toExit = this.activeChallengeNames[this.activeChallengeNames.length - 1].replace(/\\W+\\(.*\\)/u, \"\");\r\n        names = { chall: toExit, normal: isEC ? \"Eternity\" : \"Infinity\" };\r\n        clickFn = () => {\r\n          const oldChall = Player.anyChallenge;\r\n          Player.anyChallenge.exit(false);\r\n          if (player.options.retryChallenge) oldChall.requestStart();\r\n        };\r\n      } else {\r\n        names = { chall: this.activeChallengeNames[0], normal: \"Reality\" };\r\n        clickFn = () => beginProcessReality(getRealityProps(true));\r\n      }\r\n\r\n      if (player.options.confirmations.exitChallenge) {\r\n        Modal.exitChallenge.show(\r\n          {\r\n            challengeName: names.chall,\r\n            normalName: names.normal,\r\n            hasHigherLayers: this.inPelle || this.activeChallengeNames.length > 1,\r\n            exitFn: clickFn\r\n          }\r\n        );\r\n      } else {\r\n        clickFn();\r\n      }\r\n    },\r\n    // Bring the player to the tab related to the innermost challenge\r\n    textClicked() {\r\n      if (this.activeChallengeNames.length === 0) return;\r\n\r\n      // Iterating back-to-front and breaking ensures we get the innermost restriction\r\n      let fullName = \"\", celestial = \"\";\r\n      for (let i = this.activityTokens.length - 1; i >= 0; i--) {\r\n        const token = this.activityTokens[i];\r\n        const part = this.parts[i];\r\n        if (!part.isActive(token)) continue;\r\n        fullName = part.name(token);\r\n        celestial = part.tabName?.();\r\n        break;\r\n      }\r\n\r\n      // Normal challenges are matched with an end-of-string metacharacter\r\n      if (fullName.match(\" Challenge$\")) Tab.challenges.normal.show(true);\r\n      else if (fullName.match(\"Infinity Challenge\")) Tab.challenges.infinity.show(true);\r\n      else if (fullName.match(\"Eternity Challenge\")) Tab.challenges.eternity.show(true);\r\n      else if (player.dilation.active) Tab.eternity.dilation.show(true);\r\n      else Tab.celestials[celestial].show(true);\r\n    },\r\n    exitDisplay() {\r\n      if (Player.isInAnyChallenge) return player.options.retryChallenge ? \"Retry Challenge\" : \"Exit Challenge\";\r\n      if (player.dilation.active) return \"Exit Dilation\";\r\n      if (this.resetCelestial) return \"Restart Reality\";\r\n      return \"Exit Reality\";\r\n    },\r\n    textClassObject() {\r\n      return {\r\n        \"l-challenge-display\": true,\r\n        \"l-challenge-display--clickable\": this.activeChallengeNames.length !== 0,\r\n      };\r\n    }\r\n  },\r\n};\r\n</script>\r\n\r\n<template>\r\n  <div\r\n    v-if=\"isVisible\"\r\n    class=\"l-game-header__challenge-text\"\r\n  >\r\n    <span\r\n      :class=\"textClassObject()\"\r\n      @click=\"textClicked\"\r\n    >\r\n      You are currently in {{ challengeDisplay }}\r\n    </span>\r\n    <FailableEcText v-if=\"isInFailableEC\" />\r\n    <span class=\"l-padding-line\" />\r\n    <PrimaryButton\r\n      v-if=\"showExit\"\r\n      @click=\"exitButtonClicked\"\r\n    >\r\n      {{ exitText }}\r\n    </PrimaryButton>\r\n  </div>\r\n</template>\r\n\r\n<style scoped>\r\n.l-game-header__challenge-text {\r\n  display: flex;\r\n  height: 2rem;\r\n  top: 50%;\r\n  justify-content: center;\r\n  align-items: center;\r\n  font-size: 1.2rem;\r\n  font-weight: bold;\r\n  color: var(--color-text);\r\n  margin: 0.5rem;\r\n}\r\n\r\n.l-challenge-display {\r\n  padding: 0.5rem;\r\n  cursor: default;\r\n}\r\n\r\n.l-challenge-display--clickable {\r\n  cursor: pointer;\r\n  user-select: none;\r\n}\r\n\r\n.l-challenge-display--clickable:hover {\r\n  text-decoration: underline;\r\n}\r\n\r\n.l-padding-line {\r\n  padding: 0.3rem;\r\n}\r\n</style>\r\n"]}]}