{"ast":null,"code":"import \"core-js/modules/web.dom-collections.iterator.js\";\nimport { Pelle } from \"../globals\";\nimport { GlyphCombiner } from \"@/core/secret-formula\";\n\nclass GlyphEffectState {\n  constructor(id, props) {\n    this._id = id;\n    this._adjustApply = props.adjustApply;\n  }\n\n  applyEffect(applyFn) {\n    let effectValue = getAdjustedGlyphEffect(this._id);\n\n    if (this._adjustApply !== undefined) {\n      effectValue = this._adjustApply(effectValue);\n    }\n\n    applyFn(effectValue);\n  }\n\n}\n\nexport const GlyphEffect = {\n  dimBoostPower: new GlyphEffectState(\"powerdimboost\", {\n    adjustApply: value => Math.max(1, value)\n  }),\n  ipMult: new GlyphEffectState(\"infinityIP\", {\n    adjustApply: value => Decimal.max(1, value)\n  }),\n  epMult: new GlyphEffectState(\"timeEP\", {\n    adjustApply: value => Decimal.max(1, value)\n  })\n};\n/**\r\n * This returns just the value, unlike getTotalEffect(), which outputs the softcap status as well\r\n * This variant is used by GameCache\r\n * @param {string} effectKey\r\n * @return {number | Decimal}\r\n */\n\nexport function getAdjustedGlyphEffectUncached(effectKey) {\n  return getTotalEffect(effectKey).value;\n}\n/**\r\n * This returns just the value, unlike getTotalEffect(), which outputs the softcap status as well\r\n * @param {string} effectKey\r\n * @return {number | Decimal}\r\n */\n\nexport function getAdjustedGlyphEffect(effectKey) {\n  return GameCache.glyphEffects.value[effectKey];\n}\n/**\r\n * Takes the glyph effect value and feeds it through the conversion function that gives the value of the secondary\r\n * effect from glyph alteration.\r\n * @param {string} effectKey\r\n * @return {number | Decimal}\r\n */\n\nexport function getSecondaryGlyphEffect(effectKey) {\n  return GlyphEffects[effectKey].conversion(getAdjustedGlyphEffect(effectKey));\n}\n/**\r\n * Finds all equipped glyphs with the specified effect and returns an array of effect values.\r\n * @param {string} effectKey\r\n * @returns {number[]}\r\n */\n\nexport function getGlyphEffectValues(effectKey) {\n  if (!orderedEffectList.includes(effectKey)) {\n    throw new Error(`Unknown Glyph effect requested \"${effectKey}\"'`);\n  }\n\n  return player.reality.glyphs.active.filter(glyph => (1 << GlyphEffects[effectKey].bitmaskIndex & glyph.effects) !== 0).filter(glyph => generatedTypes.includes(glyph.type) === GlyphEffects[effectKey].isGenerated).map(glyph => getSingleGlyphEffectFromBitmask(effectKey, glyph));\n} // Combines all specified glyph effects, reduces some boilerplate\n\nfunction getTotalEffect(effectKey) {\n  return GlyphEffects[effectKey].combine(getGlyphEffectValues(effectKey));\n}\n/**\r\n * Key is type+effect\r\n */\n\n\nexport function separateEffectKey(effectKey) {\n  let type = \"\";\n  let effect = \"\";\n\n  for (let i = 0; i < GLYPH_TYPES.length; i++) {\n    if (effectKey.substring(0, GLYPH_TYPES[i].length) === GLYPH_TYPES[i]) {\n      type = GLYPH_TYPES[i];\n      effect = effectKey.substring(GLYPH_TYPES[i].length);\n      break;\n    }\n  }\n\n  return [type, effect];\n} // Turns a glyph effect bitmask into an effect list and corresponding values. This also picks up non-generated effects,\n// since there is some id overlap. Those should be filtered out as needed after calling this function.\n// eslint-disable-next-line max-params\n\nexport function getGlyphEffectValuesFromBitmask(bitmask, level, baseStrength, type) {\n  // If we don't specifically exclude companion glyphs, the first-reality EP record is wrong within Doomed since its\n  // value is encoded in the rarity field\n  const strength = Pelle.isDoomed && type !== \"companion\" ? Pelle.glyphStrength : baseStrength;\n  return getGlyphEffectsFromBitmask(bitmask).map(effect => ({\n    id: effect.id,\n    value: effect.effect(level, strength)\n  }));\n} // Pulls out a single effect value from a glyph's bitmask, returning just the value (nothing for missing effects)\n\nexport function getSingleGlyphEffectFromBitmask(effectName, glyph) {\n  const glyphEffect = GlyphEffects[effectName];\n\n  if ((glyph.effects & 1 << glyphEffect.bitmaskIndex) === 0) {\n    return undefined;\n  }\n\n  return glyphEffect.effect(getAdjustedGlyphLevel(glyph), Pelle.isDoomed ? Pelle.glyphStrength : glyph.strength);\n} // Note this function is used for glyph bitmasks, news ticker bitmasks, and offline achievements\n\nexport function countValuesFromBitmask(bitmask) {\n  let numEffects = 0;\n  let bits = bitmask;\n\n  while (bits !== 0) {\n    numEffects += bits & 1;\n    bits >>= 1;\n  }\n\n  return numEffects;\n} // Returns both effect value and softcap status\n\nexport function getActiveGlyphEffects() {\n  let effectValues = orderedEffectList.map(effect => ({\n    effect,\n    values: getGlyphEffectValues(effect)\n  })).filter(ev => ev.values.length > 0).map(ev => ({\n    id: ev.effect,\n    value: GlyphEffects[ev.effect].combine(ev.values)\n  }));\n  const effectNames = effectValues.map(e => e.id); // Numerically combine cursed effects with other glyph effects which directly conflict with them\n\n  const cursedEffects = [\"cursedgalaxies\", \"curseddimensions\", \"cursedEP\"];\n  const conflictingEffects = [\"realitygalaxies\", \"effarigdimensions\", \"timeEP\"];\n  const combineFunction = [GlyphCombiner.multiply, GlyphCombiner.multiply, GlyphCombiner.multiplyDecimal];\n\n  for (let i = 0; i < cursedEffects.length; i++) {\n    if (effectNames.includes(cursedEffects[i]) && effectNames.includes(conflictingEffects[i])) {\n      const combined = combineFunction[i]([getAdjustedGlyphEffect(cursedEffects[i]), getAdjustedGlyphEffect(conflictingEffects[i])]);\n\n      if (Decimal.lt(combined, 1)) {\n        effectValues = effectValues.filter(e => e.id !== conflictingEffects[i]);\n        effectValues.filter(e => e.id === cursedEffects[i])[0].value.value = combined;\n      } else {\n        effectValues = effectValues.filter(e => e.id !== cursedEffects[i]);\n        effectValues.filter(e => e.id === conflictingEffects[i])[0].value.value = combined;\n      }\n    }\n  }\n\n  return effectValues;\n}","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/glyphs/glyph-effects.js"],"names":["Pelle","GlyphCombiner","GlyphEffectState","constructor","id","props","_id","_adjustApply","adjustApply","applyEffect","applyFn","effectValue","getAdjustedGlyphEffect","undefined","GlyphEffect","dimBoostPower","value","Math","max","ipMult","Decimal","epMult","getAdjustedGlyphEffectUncached","effectKey","getTotalEffect","GameCache","glyphEffects","getSecondaryGlyphEffect","GlyphEffects","conversion","getGlyphEffectValues","orderedEffectList","includes","Error","player","reality","glyphs","active","filter","glyph","bitmaskIndex","effects","generatedTypes","type","isGenerated","map","getSingleGlyphEffectFromBitmask","combine","separateEffectKey","effect","i","GLYPH_TYPES","length","substring","getGlyphEffectValuesFromBitmask","bitmask","level","baseStrength","strength","isDoomed","glyphStrength","getGlyphEffectsFromBitmask","effectName","glyphEffect","getAdjustedGlyphLevel","countValuesFromBitmask","numEffects","bits","getActiveGlyphEffects","effectValues","values","ev","effectNames","e","cursedEffects","conflictingEffects","combineFunction","multiply","multiplyDecimal","combined","lt"],"mappings":"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","sourcesContent":["import { Pelle } from \"../globals\";\r\n\r\nimport { GlyphCombiner } from \"@/core/secret-formula\";\r\n\r\nclass GlyphEffectState {\r\n  constructor(id, props) {\r\n    this._id = id;\r\n    this._adjustApply = props.adjustApply;\r\n  }\r\n\r\n  applyEffect(applyFn) {\r\n    let effectValue = getAdjustedGlyphEffect(this._id);\r\n    if (this._adjustApply !== undefined) {\r\n      effectValue = this._adjustApply(effectValue);\r\n    }\r\n    applyFn(effectValue);\r\n  }\r\n}\r\n\r\nexport const GlyphEffect = {\r\n  dimBoostPower: new GlyphEffectState(\"powerdimboost\", {\r\n    adjustApply: value => Math.max(1, value)\r\n  }),\r\n  ipMult: new GlyphEffectState(\"infinityIP\", {\r\n    adjustApply: value => Decimal.max(1, value)\r\n  }),\r\n  epMult: new GlyphEffectState(\"timeEP\", {\r\n    adjustApply: value => Decimal.max(1, value)\r\n  })\r\n};\r\n\r\n/**\r\n * This returns just the value, unlike getTotalEffect(), which outputs the softcap status as well\r\n * This variant is used by GameCache\r\n * @param {string} effectKey\r\n * @return {number | Decimal}\r\n */\r\nexport function getAdjustedGlyphEffectUncached(effectKey) {\r\n  return getTotalEffect(effectKey).value;\r\n}\r\n\r\n/**\r\n * This returns just the value, unlike getTotalEffect(), which outputs the softcap status as well\r\n * @param {string} effectKey\r\n * @return {number | Decimal}\r\n */\r\nexport function getAdjustedGlyphEffect(effectKey) {\r\n  return GameCache.glyphEffects.value[effectKey];\r\n}\r\n\r\n/**\r\n * Takes the glyph effect value and feeds it through the conversion function that gives the value of the secondary\r\n * effect from glyph alteration.\r\n * @param {string} effectKey\r\n * @return {number | Decimal}\r\n */\r\nexport function getSecondaryGlyphEffect(effectKey) {\r\n  return GlyphEffects[effectKey].conversion(getAdjustedGlyphEffect(effectKey));\r\n}\r\n\r\n/**\r\n * Finds all equipped glyphs with the specified effect and returns an array of effect values.\r\n * @param {string} effectKey\r\n * @returns {number[]}\r\n */\r\nexport function getGlyphEffectValues(effectKey) {\r\n  if (!orderedEffectList.includes(effectKey)) {\r\n    throw new Error(`Unknown Glyph effect requested \"${effectKey}\"'`);\r\n  }\r\n  return player.reality.glyphs.active\r\n    .filter(glyph => ((1 << GlyphEffects[effectKey].bitmaskIndex) & glyph.effects) !== 0)\r\n    .filter(glyph => generatedTypes.includes(glyph.type) === GlyphEffects[effectKey].isGenerated)\r\n    .map(glyph => getSingleGlyphEffectFromBitmask(effectKey, glyph));\r\n}\r\n\r\n// Combines all specified glyph effects, reduces some boilerplate\r\nfunction getTotalEffect(effectKey) {\r\n  return GlyphEffects[effectKey].combine(getGlyphEffectValues(effectKey));\r\n}\r\n\r\n/**\r\n * Key is type+effect\r\n */\r\nexport function separateEffectKey(effectKey) {\r\n  let type = \"\";\r\n  let effect = \"\";\r\n  for (let i = 0; i < GLYPH_TYPES.length; i++) {\r\n    if (effectKey.substring(0, GLYPH_TYPES[i].length) === GLYPH_TYPES[i]) {\r\n      type = GLYPH_TYPES[i];\r\n      effect = effectKey.substring(GLYPH_TYPES[i].length);\r\n      break;\r\n    }\r\n  }\r\n  return [type, effect];\r\n}\r\n\r\n// Turns a glyph effect bitmask into an effect list and corresponding values. This also picks up non-generated effects,\r\n// since there is some id overlap. Those should be filtered out as needed after calling this function.\r\n// eslint-disable-next-line max-params\r\nexport function getGlyphEffectValuesFromBitmask(bitmask, level, baseStrength, type) {\r\n  // If we don't specifically exclude companion glyphs, the first-reality EP record is wrong within Doomed since its\r\n  // value is encoded in the rarity field\r\n  const strength = (Pelle.isDoomed && type !== \"companion\") ? Pelle.glyphStrength : baseStrength;\r\n  return getGlyphEffectsFromBitmask(bitmask)\r\n    .map(effect => ({\r\n      id: effect.id,\r\n      value: effect.effect(level, strength)\r\n    }));\r\n}\r\n\r\n// Pulls out a single effect value from a glyph's bitmask, returning just the value (nothing for missing effects)\r\nexport function getSingleGlyphEffectFromBitmask(effectName, glyph) {\r\n  const glyphEffect = GlyphEffects[effectName];\r\n  if ((glyph.effects & (1 << glyphEffect.bitmaskIndex)) === 0) {\r\n    return undefined;\r\n  }\r\n  return glyphEffect.effect(getAdjustedGlyphLevel(glyph), Pelle.isDoomed ? Pelle.glyphStrength : glyph.strength);\r\n}\r\n\r\n// Note this function is used for glyph bitmasks, news ticker bitmasks, and offline achievements\r\nexport function countValuesFromBitmask(bitmask) {\r\n  let numEffects = 0;\r\n  let bits = bitmask;\r\n  while (bits !== 0) {\r\n    numEffects += bits & 1;\r\n    bits >>= 1;\r\n  }\r\n  return numEffects;\r\n}\r\n\r\n// Returns both effect value and softcap status\r\nexport function getActiveGlyphEffects() {\r\n  let effectValues = orderedEffectList\r\n    .map(effect => ({ effect, values: getGlyphEffectValues(effect) }))\r\n    .filter(ev => ev.values.length > 0)\r\n    .map(ev => ({\r\n      id: ev.effect,\r\n      value: GlyphEffects[ev.effect].combine(ev.values),\r\n    }));\r\n  const effectNames = effectValues.map(e => e.id);\r\n\r\n  // Numerically combine cursed effects with other glyph effects which directly conflict with them\r\n  const cursedEffects = [\"cursedgalaxies\", \"curseddimensions\", \"cursedEP\"];\r\n  const conflictingEffects = [\"realitygalaxies\", \"effarigdimensions\", \"timeEP\"];\r\n  const combineFunction = [GlyphCombiner.multiply, GlyphCombiner.multiply, GlyphCombiner.multiplyDecimal];\r\n  for (let i = 0; i < cursedEffects.length; i++) {\r\n    if (effectNames.includes(cursedEffects[i]) && effectNames.includes(conflictingEffects[i])) {\r\n      const combined = combineFunction[i]([getAdjustedGlyphEffect(cursedEffects[i]),\r\n        getAdjustedGlyphEffect(conflictingEffects[i])]);\r\n      if (Decimal.lt(combined, 1)) {\r\n        effectValues = effectValues.filter(e => e.id !== conflictingEffects[i]);\r\n        effectValues.filter(e => e.id === cursedEffects[i])[0].value.value = combined;\r\n      } else {\r\n        effectValues = effectValues.filter(e => e.id !== cursedEffects[i]);\r\n        effectValues.filter(e => e.id === conflictingEffects[i])[0].value.value = combined;\r\n      }\r\n    }\r\n  }\r\n\r\n  return effectValues;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}