{"ast":null,"code":"import \"core-js/modules/web.dom-collections.iterator.js\";\nimport { DC } from \"./constants\";\nexport function effectiveBaseGalaxies() {\n  // Note that this already includes the \"50% more\" active path effect\n  let replicantiGalaxies = Replicanti.galaxies.bought;\n  replicantiGalaxies *= 1 + Effects.sum(TimeStudy(132), TimeStudy(133)); // \"extra\" galaxies unaffected by the passive/idle boosts come from studies 225/226 and Effarig Infinity\n\n  replicantiGalaxies += Replicanti.galaxies.extra;\n  const nonActivePathReplicantiGalaxies = Math.min(Replicanti.galaxies.bought, ReplicantiUpgrade.galaxies.value); // Effects.sum is intentional here - if EC8 is not completed,\n  // this value should not be contributed to total replicanti galaxies\n\n  replicantiGalaxies += nonActivePathReplicantiGalaxies * Effects.sum(EternityChallenge(8).reward);\n  let freeGalaxies = player.dilation.totalTachyonGalaxies;\n  freeGalaxies *= 1 + Math.max(0, Replicanti.amount.log10() / 1e6) * AlchemyResource.alternation.effectValue;\n  return Math.max(player.galaxies + GalaxyGenerator.galaxies + replicantiGalaxies + freeGalaxies, 0);\n}\nexport function getTickSpeedMultiplier() {\n  if (InfinityChallenge(3).isRunning) return DC.D1;\n  if (Ra.isRunning) return DC.C1D1_1245;\n  let galaxies = effectiveBaseGalaxies();\n  const effects = Effects.product(InfinityUpgrade.galaxyBoost, InfinityUpgrade.galaxyBoost.chargedEffect, BreakInfinityUpgrade.galaxyBoost, TimeStudy(212), TimeStudy(232), Achievement(86), Achievement(178), InfinityChallenge(5).reward, PelleUpgrade.galaxyPower, PelleRifts.decay.milestones[1]);\n\n  if (galaxies < 3) {\n    // Magic numbers are to retain balancing from before while displaying\n    // them now as positive multipliers rather than negative percentages\n    let _baseMultiplier = 1 / 1.1245;\n\n    if (player.galaxies === 1) _baseMultiplier = 1 / 1.11888888;\n    if (player.galaxies === 2) _baseMultiplier = 1 / 1.11267177;\n\n    if (NormalChallenge(5).isRunning) {\n      _baseMultiplier = 1 / 1.08;\n      if (player.galaxies === 1) _baseMultiplier = 1 / 1.07632;\n      if (player.galaxies === 2) _baseMultiplier = 1 / 1.072;\n    }\n\n    const _perGalaxy = 0.02 * effects;\n\n    if (Pelle.isDoomed) galaxies *= 0.5;\n    galaxies *= Pelle.specialGlyphEffect.power;\n    return DC.D0_01.clampMin(_baseMultiplier - galaxies * _perGalaxy);\n  }\n\n  let baseMultiplier = 0.8;\n  if (NormalChallenge(5).isRunning) baseMultiplier = 0.83;\n  galaxies -= 2;\n  galaxies *= effects;\n  galaxies *= getAdjustedGlyphEffect(\"cursedgalaxies\");\n  galaxies *= getAdjustedGlyphEffect(\"realitygalaxies\");\n  galaxies *= 1 + ImaginaryUpgrade(9).effectOrDefault(0);\n  if (Pelle.isDoomed) galaxies *= 0.5;\n  galaxies *= Pelle.specialGlyphEffect.power;\n  const perGalaxy = DC.D0_965;\n  return perGalaxy.pow(galaxies - 2).times(baseMultiplier);\n}\nexport function buyTickSpeed() {\n  if (!Tickspeed.isAvailableForPurchase || !Tickspeed.isAffordable) return false;\n\n  if (NormalChallenge(9).isRunning) {\n    Tickspeed.multiplySameCosts();\n  }\n\n  Tutorial.turnOffEffect(TUTORIAL_STATE.TICKSPEED);\n  Currency.antimatter.subtract(Tickspeed.cost);\n  player.totalTickBought++;\n  player.records.thisInfinity.lastBuyTime = player.records.thisInfinity.time;\n  player.requirementChecks.permanent.singleTickspeed++;\n  if (NormalChallenge(2).isRunning) player.chall2Pow = 0;\n  GameUI.update();\n  return true;\n}\nexport function buyMaxTickSpeed() {\n  if (!Tickspeed.isAvailableForPurchase || !Tickspeed.isAffordable) return;\n  let boughtTickspeed = false;\n  Tutorial.turnOffEffect(TUTORIAL_STATE.TICKSPEED);\n\n  if (NormalChallenge(9).isRunning) {\n    const goal = Player.infinityGoal;\n    let cost = Tickspeed.cost;\n\n    while (Currency.antimatter.gt(cost) && cost.lt(goal)) {\n      Tickspeed.multiplySameCosts();\n      Currency.antimatter.subtract(cost);\n      player.totalTickBought++;\n      boughtTickspeed = true;\n      cost = Tickspeed.cost;\n    }\n  } else {\n    const purchases = Tickspeed.costScale.getMaxBought(player.totalTickBought, Currency.antimatter.value, 1);\n\n    if (purchases === null) {\n      return;\n    }\n\n    Currency.antimatter.subtract(Decimal.pow10(purchases.logPrice));\n    player.totalTickBought += purchases.quantity;\n    boughtTickspeed = true;\n  }\n\n  if (boughtTickspeed) {\n    player.records.thisInfinity.lastBuyTime = player.records.thisInfinity.time;\n    if (NormalChallenge(2).isRunning) player.chall2Pow = 0;\n  }\n}\nexport function resetTickspeed() {\n  player.totalTickBought = 0;\n  player.chall9TickspeedCostBumps = 0;\n}\nexport const Tickspeed = {\n  get isUnlocked() {\n    return AntimatterDimension(2).bought > 0 || EternityMilestone.unlockAllND.isReached || PlayerProgress.realityUnlocked();\n  },\n\n  get isAvailableForPurchase() {\n    return this.isUnlocked && !EternityChallenge(9).isRunning && !Laitela.continuumActive && (player.break || this.cost.lt(Decimal.NUMBER_MAX_VALUE));\n  },\n\n  get isAffordable() {\n    return Currency.antimatter.gte(this.cost);\n  },\n\n  get multiplier() {\n    return getTickSpeedMultiplier();\n  },\n\n  get current() {\n    const tickspeed = Effarig.isRunning ? Effarig.tickspeed : this.baseValue.powEffectOf(DilationUpgrade.tickspeedPower);\n    return player.dilation.active || PelleStrikes.dilation.hasStrike ? dilatedValueOf(tickspeed) : tickspeed;\n  },\n\n  get cost() {\n    return this.costScale.calculateCost(player.totalTickBought + player.chall9TickspeedCostBumps);\n  },\n\n  get costScale() {\n    return new ExponentialCostScaling({\n      baseCost: 1000,\n      baseIncrease: 10,\n      costScale: Player.tickSpeedMultDecrease,\n      scalingCostThreshold: Number.MAX_VALUE\n    });\n  },\n\n  get continuumValue() {\n    if (!this.isUnlocked) return 0;\n    return this.costScale.getContinuumValue(Currency.antimatter.value, 1) * Laitela.matterExtraPurchaseFactor;\n  },\n\n  get baseValue() {\n    return DC.E3.timesEffectsOf(Achievement(36), Achievement(45), Achievement(66), Achievement(83)).times(getTickSpeedMultiplier().pow(this.totalUpgrades));\n  },\n\n  get totalUpgrades() {\n    let boughtTickspeed;\n    if (Laitela.continuumActive) boughtTickspeed = this.continuumValue;else boughtTickspeed = player.totalTickBought;\n    return boughtTickspeed + player.totalTickGained;\n  },\n\n  get perSecond() {\n    return Decimal.divide(1000, this.current);\n  },\n\n  multiplySameCosts() {\n    for (const dimension of AntimatterDimensions.all) {\n      if (dimension.cost.e === this.cost.e) dimension.costBumps++;\n    }\n  }\n\n};\nexport const FreeTickspeed = {\n  BASE_SOFTCAP: 300000,\n  GROWTH_RATE: 6e-6,\n  GROWTH_EXP: 2,\n  multToNext: 1.33,\n\n  get amount() {\n    return player.totalTickGained;\n  },\n\n  get softcap() {\n    let softcap = FreeTickspeed.BASE_SOFTCAP;\n\n    if (Enslaved.has(ENSLAVED_UNLOCKS.FREE_TICKSPEED_SOFTCAP)) {\n      softcap += 100000;\n    }\n\n    return softcap;\n  },\n\n  fromShards(shards) {\n    const tickmult = 1 + (Effects.min(1.33, TimeStudy(171)) - 1) * Math.max(getAdjustedGlyphEffect(\"cursedtickspeed\"), 1);\n    const logTickmult = Math.log(tickmult);\n    const logShards = shards.ln();\n    const uncapped = Math.max(0, logShards / logTickmult);\n\n    if (uncapped <= FreeTickspeed.softcap) {\n      this.multToNext = tickmult;\n      return {\n        newAmount: Math.ceil(uncapped),\n        nextShards: Decimal.pow(tickmult, Math.ceil(uncapped))\n      };\n    } // Log of (cost - cost up to softcap)\n\n\n    const priceToCap = FreeTickspeed.softcap * logTickmult; // In the following we're implicitly applying the function (ln(x) - priceToCap) / logTickmult to all costs,\n    // so, for example, if the cost is 1 that means it's actually exp(priceToCap) * tickmult.\n\n    const desiredCost = (logShards - priceToCap) / logTickmult;\n    const costFormulaCoefficient = FreeTickspeed.GROWTH_RATE / FreeTickspeed.GROWTH_EXP / logTickmult; // In the following we're implicitly subtracting softcap from bought,\n    // so, for example, if bought is 1 that means it's actually softcap + 1.\n    // The first term (the big one) is the asymptotically more important term (since FreeTickspeed.GROWTH_EXP > 1),\n    // but is small initially. The second term allows us to continue the pre-cap free tickspeed upgrade scaling\n    // of tickmult per upgrade.\n\n    const boughtToCost = bought => costFormulaCoefficient * Math.pow(Math.max(bought, 0), FreeTickspeed.GROWTH_EXP) + bought;\n\n    const derivativeOfBoughtToCost = x => FreeTickspeed.GROWTH_EXP * costFormulaCoefficient * Math.pow(Math.max(x, 0), FreeTickspeed.GROWTH_EXP - 1) + 1;\n\n    const newtonsMethod = bought => bought - (boughtToCost(bought) - desiredCost) / derivativeOfBoughtToCost(bought);\n\n    let oldApproximation;\n    let approximation = Math.min(desiredCost, Math.pow(desiredCost / costFormulaCoefficient, 1 / FreeTickspeed.GROWTH_EXP));\n    let counter = 0; // The bought formula is concave upwards. We start with an over-estimate; when using newton's method,\n    // this means that successive iterations are also over-etimates. Thus, we can just check for continued\n    // progress with the approximation < oldApproximation check. The counter is a fallback.\n\n    do {\n      oldApproximation = approximation;\n      approximation = newtonsMethod(approximation);\n    } while (approximation < oldApproximation && ++counter < 100);\n\n    const purchases = Math.floor(approximation); // This undoes the function we're implicitly applying to costs (the \"+ 1\") is because we want\n    // the cost of the next upgrade.\n\n    const next = Decimal.exp(priceToCap + boughtToCost(purchases + 1) * logTickmult);\n    this.multToNext = Decimal.exp((boughtToCost(purchases + 1) - boughtToCost(purchases)) * logTickmult);\n    return {\n      newAmount: purchases + FreeTickspeed.softcap,\n      nextShards: next\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/tickspeed.js"],"names":["DC","effectiveBaseGalaxies","replicantiGalaxies","Replicanti","galaxies","bought","Effects","sum","TimeStudy","extra","nonActivePathReplicantiGalaxies","Math","min","ReplicantiUpgrade","value","EternityChallenge","reward","freeGalaxies","player","dilation","totalTachyonGalaxies","max","amount","log10","AlchemyResource","alternation","effectValue","GalaxyGenerator","getTickSpeedMultiplier","InfinityChallenge","isRunning","D1","Ra","C1D1_1245","effects","product","InfinityUpgrade","galaxyBoost","chargedEffect","BreakInfinityUpgrade","Achievement","PelleUpgrade","galaxyPower","PelleRifts","decay","milestones","baseMultiplier","NormalChallenge","perGalaxy","Pelle","isDoomed","specialGlyphEffect","power","D0_01","clampMin","getAdjustedGlyphEffect","ImaginaryUpgrade","effectOrDefault","D0_965","pow","times","buyTickSpeed","Tickspeed","isAvailableForPurchase","isAffordable","multiplySameCosts","Tutorial","turnOffEffect","TUTORIAL_STATE","TICKSPEED","Currency","antimatter","subtract","cost","totalTickBought","records","thisInfinity","lastBuyTime","time","requirementChecks","permanent","singleTickspeed","chall2Pow","GameUI","update","buyMaxTickSpeed","boughtTickspeed","goal","Player","infinityGoal","gt","lt","purchases","costScale","getMaxBought","Decimal","pow10","logPrice","quantity","resetTickspeed","chall9TickspeedCostBumps","isUnlocked","AntimatterDimension","EternityMilestone","unlockAllND","isReached","PlayerProgress","realityUnlocked","Laitela","continuumActive","break","NUMBER_MAX_VALUE","gte","multiplier","current","tickspeed","Effarig","baseValue","powEffectOf","DilationUpgrade","tickspeedPower","active","PelleStrikes","hasStrike","dilatedValueOf","calculateCost","ExponentialCostScaling","baseCost","baseIncrease","tickSpeedMultDecrease","scalingCostThreshold","Number","MAX_VALUE","continuumValue","getContinuumValue","matterExtraPurchaseFactor","E3","timesEffectsOf","totalUpgrades","totalTickGained","perSecond","divide","dimension","AntimatterDimensions","all","e","costBumps","FreeTickspeed","BASE_SOFTCAP","GROWTH_RATE","GROWTH_EXP","multToNext","softcap","Enslaved","has","ENSLAVED_UNLOCKS","FREE_TICKSPEED_SOFTCAP","fromShards","shards","tickmult","logTickmult","log","logShards","ln","uncapped","newAmount","ceil","nextShards","priceToCap","desiredCost","costFormulaCoefficient","boughtToCost","derivativeOfBoughtToCost","x","newtonsMethod","oldApproximation","approximation","counter","floor","next","exp"],"mappings":"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","sourcesContent":["import { DC } from \"./constants\";\r\n\r\nexport function effectiveBaseGalaxies() {\r\n  // Note that this already includes the \"50% more\" active path effect\r\n  let replicantiGalaxies = Replicanti.galaxies.bought;\r\n  replicantiGalaxies *= (1 + Effects.sum(\r\n    TimeStudy(132),\r\n    TimeStudy(133)\r\n  ));\r\n  // \"extra\" galaxies unaffected by the passive/idle boosts come from studies 225/226 and Effarig Infinity\r\n  replicantiGalaxies += Replicanti.galaxies.extra;\r\n  const nonActivePathReplicantiGalaxies = Math.min(Replicanti.galaxies.bought,\r\n    ReplicantiUpgrade.galaxies.value);\r\n  // Effects.sum is intentional here - if EC8 is not completed,\r\n  // this value should not be contributed to total replicanti galaxies\r\n  replicantiGalaxies += nonActivePathReplicantiGalaxies * Effects.sum(EternityChallenge(8).reward);\r\n  let freeGalaxies = player.dilation.totalTachyonGalaxies;\r\n  freeGalaxies *= 1 + Math.max(0, Replicanti.amount.log10() / 1e6) * AlchemyResource.alternation.effectValue;\r\n  return Math.max(player.galaxies + GalaxyGenerator.galaxies + replicantiGalaxies + freeGalaxies, 0);\r\n}\r\n\r\nexport function getTickSpeedMultiplier() {\r\n  if (InfinityChallenge(3).isRunning) return DC.D1;\r\n  if (Ra.isRunning) return DC.C1D1_1245;\r\n  let galaxies = effectiveBaseGalaxies();\r\n  const effects = Effects.product(\r\n    InfinityUpgrade.galaxyBoost,\r\n    InfinityUpgrade.galaxyBoost.chargedEffect,\r\n    BreakInfinityUpgrade.galaxyBoost,\r\n    TimeStudy(212),\r\n    TimeStudy(232),\r\n    Achievement(86),\r\n    Achievement(178),\r\n    InfinityChallenge(5).reward,\r\n    PelleUpgrade.galaxyPower,\r\n    PelleRifts.decay.milestones[1]\r\n  );\r\n  if (galaxies < 3) {\r\n    // Magic numbers are to retain balancing from before while displaying\r\n    // them now as positive multipliers rather than negative percentages\r\n    let baseMultiplier = 1 / 1.1245;\r\n    if (player.galaxies === 1) baseMultiplier = 1 / 1.11888888;\r\n    if (player.galaxies === 2) baseMultiplier = 1 / 1.11267177;\r\n    if (NormalChallenge(5).isRunning) {\r\n      baseMultiplier = 1 / 1.08;\r\n      if (player.galaxies === 1) baseMultiplier = 1 / 1.07632;\r\n      if (player.galaxies === 2) baseMultiplier = 1 / 1.072;\r\n    }\r\n    const perGalaxy = 0.02 * effects;\r\n    if (Pelle.isDoomed) galaxies *= 0.5;\r\n\r\n    galaxies *= Pelle.specialGlyphEffect.power;\r\n    return DC.D0_01.clampMin(baseMultiplier - (galaxies * perGalaxy));\r\n  }\r\n  let baseMultiplier = 0.8;\r\n  if (NormalChallenge(5).isRunning) baseMultiplier = 0.83;\r\n  galaxies -= 2;\r\n  galaxies *= effects;\r\n  galaxies *= getAdjustedGlyphEffect(\"cursedgalaxies\");\r\n  galaxies *= getAdjustedGlyphEffect(\"realitygalaxies\");\r\n  galaxies *= 1 + ImaginaryUpgrade(9).effectOrDefault(0);\r\n  if (Pelle.isDoomed) galaxies *= 0.5;\r\n\r\n  galaxies *= Pelle.specialGlyphEffect.power;\r\n  const perGalaxy = DC.D0_965;\r\n  return perGalaxy.pow(galaxies - 2).times(baseMultiplier);\r\n}\r\n\r\nexport function buyTickSpeed() {\r\n  if (!Tickspeed.isAvailableForPurchase || !Tickspeed.isAffordable) return false;\r\n\r\n  if (NormalChallenge(9).isRunning) {\r\n    Tickspeed.multiplySameCosts();\r\n  }\r\n  Tutorial.turnOffEffect(TUTORIAL_STATE.TICKSPEED);\r\n  Currency.antimatter.subtract(Tickspeed.cost);\r\n  player.totalTickBought++;\r\n  player.records.thisInfinity.lastBuyTime = player.records.thisInfinity.time;\r\n  player.requirementChecks.permanent.singleTickspeed++;\r\n  if (NormalChallenge(2).isRunning) player.chall2Pow = 0;\r\n  GameUI.update();\r\n  return true;\r\n}\r\n\r\nexport function buyMaxTickSpeed() {\r\n  if (!Tickspeed.isAvailableForPurchase || !Tickspeed.isAffordable) return;\r\n  let boughtTickspeed = false;\r\n\r\n  Tutorial.turnOffEffect(TUTORIAL_STATE.TICKSPEED);\r\n  if (NormalChallenge(9).isRunning) {\r\n    const goal = Player.infinityGoal;\r\n    let cost = Tickspeed.cost;\r\n    while (Currency.antimatter.gt(cost) && cost.lt(goal)) {\r\n      Tickspeed.multiplySameCosts();\r\n      Currency.antimatter.subtract(cost);\r\n      player.totalTickBought++;\r\n      boughtTickspeed = true;\r\n      cost = Tickspeed.cost;\r\n    }\r\n  } else {\r\n    const purchases = Tickspeed.costScale.getMaxBought(player.totalTickBought, Currency.antimatter.value, 1);\r\n    if (purchases === null) {\r\n      return;\r\n    }\r\n    Currency.antimatter.subtract(Decimal.pow10(purchases.logPrice));\r\n    player.totalTickBought += purchases.quantity;\r\n    boughtTickspeed = true;\r\n  }\r\n\r\n  if (boughtTickspeed) {\r\n    player.records.thisInfinity.lastBuyTime = player.records.thisInfinity.time;\r\n    if (NormalChallenge(2).isRunning) player.chall2Pow = 0;\r\n  }\r\n}\r\n\r\nexport function resetTickspeed() {\r\n  player.totalTickBought = 0;\r\n  player.chall9TickspeedCostBumps = 0;\r\n}\r\n\r\nexport const Tickspeed = {\r\n\r\n  get isUnlocked() {\r\n    return AntimatterDimension(2).bought > 0 || EternityMilestone.unlockAllND.isReached ||\r\n      PlayerProgress.realityUnlocked();\r\n  },\r\n\r\n  get isAvailableForPurchase() {\r\n    return this.isUnlocked &&\r\n      !EternityChallenge(9).isRunning &&\r\n      !Laitela.continuumActive &&\r\n      (player.break || this.cost.lt(Decimal.NUMBER_MAX_VALUE));\r\n  },\r\n\r\n  get isAffordable() {\r\n    return Currency.antimatter.gte(this.cost);\r\n  },\r\n\r\n  get multiplier() {\r\n    return getTickSpeedMultiplier();\r\n  },\r\n\r\n  get current() {\r\n    const tickspeed = Effarig.isRunning\r\n      ? Effarig.tickspeed\r\n      : this.baseValue.powEffectOf(DilationUpgrade.tickspeedPower);\r\n    return player.dilation.active || PelleStrikes.dilation.hasStrike ? dilatedValueOf(tickspeed) : tickspeed;\r\n  },\r\n\r\n  get cost() {\r\n    return this.costScale.calculateCost(player.totalTickBought + player.chall9TickspeedCostBumps);\r\n  },\r\n\r\n  get costScale() {\r\n    return new ExponentialCostScaling({\r\n      baseCost: 1000,\r\n      baseIncrease: 10,\r\n      costScale: Player.tickSpeedMultDecrease,\r\n      scalingCostThreshold: Number.MAX_VALUE\r\n    });\r\n  },\r\n\r\n  get continuumValue() {\r\n    if (!this.isUnlocked) return 0;\r\n    return this.costScale.getContinuumValue(Currency.antimatter.value, 1) * Laitela.matterExtraPurchaseFactor;\r\n  },\r\n\r\n  get baseValue() {\r\n    return DC.E3.timesEffectsOf(\r\n      Achievement(36),\r\n      Achievement(45),\r\n      Achievement(66),\r\n      Achievement(83)\r\n    )\r\n      .times(getTickSpeedMultiplier().pow(this.totalUpgrades));\r\n  },\r\n\r\n  get totalUpgrades() {\r\n    let boughtTickspeed;\r\n    if (Laitela.continuumActive) boughtTickspeed = this.continuumValue;\r\n    else boughtTickspeed = player.totalTickBought;\r\n    return boughtTickspeed + player.totalTickGained;\r\n  },\r\n\r\n  get perSecond() {\r\n    return Decimal.divide(1000, this.current);\r\n  },\r\n\r\n  multiplySameCosts() {\r\n    for (const dimension of AntimatterDimensions.all) {\r\n      if (dimension.cost.e === this.cost.e) dimension.costBumps++;\r\n    }\r\n  }\r\n};\r\n\r\n\r\nexport const FreeTickspeed = {\r\n  BASE_SOFTCAP: 300000,\r\n  GROWTH_RATE: 6e-6,\r\n  GROWTH_EXP: 2,\r\n  multToNext: 1.33,\r\n\r\n  get amount() {\r\n    return player.totalTickGained;\r\n  },\r\n\r\n  get softcap() {\r\n    let softcap = FreeTickspeed.BASE_SOFTCAP;\r\n    if (Enslaved.has(ENSLAVED_UNLOCKS.FREE_TICKSPEED_SOFTCAP)) {\r\n      softcap += 100000;\r\n    }\r\n    return softcap;\r\n  },\r\n\r\n  fromShards(shards) {\r\n    const tickmult = (1 + (Effects.min(1.33, TimeStudy(171)) - 1) *\r\n      Math.max(getAdjustedGlyphEffect(\"cursedtickspeed\"), 1));\r\n    const logTickmult = Math.log(tickmult);\r\n    const logShards = shards.ln();\r\n    const uncapped = Math.max(0, logShards / logTickmult);\r\n    if (uncapped <= FreeTickspeed.softcap) {\r\n      this.multToNext = tickmult;\r\n      return {\r\n        newAmount: Math.ceil(uncapped),\r\n        nextShards: Decimal.pow(tickmult, Math.ceil(uncapped))\r\n      };\r\n    }\r\n    // Log of (cost - cost up to softcap)\r\n    const priceToCap = FreeTickspeed.softcap * logTickmult;\r\n    // In the following we're implicitly applying the function (ln(x) - priceToCap) / logTickmult to all costs,\r\n    // so, for example, if the cost is 1 that means it's actually exp(priceToCap) * tickmult.\r\n    const desiredCost = (logShards - priceToCap) / logTickmult;\r\n    const costFormulaCoefficient = FreeTickspeed.GROWTH_RATE / FreeTickspeed.GROWTH_EXP / logTickmult;\r\n    // In the following we're implicitly subtracting softcap from bought,\r\n    // so, for example, if bought is 1 that means it's actually softcap + 1.\r\n    // The first term (the big one) is the asymptotically more important term (since FreeTickspeed.GROWTH_EXP > 1),\r\n    // but is small initially. The second term allows us to continue the pre-cap free tickspeed upgrade scaling\r\n    // of tickmult per upgrade.\r\n    const boughtToCost = bought => costFormulaCoefficient * Math.pow(\r\n      Math.max(bought, 0), FreeTickspeed.GROWTH_EXP) + bought;\r\n    const derivativeOfBoughtToCost = x => FreeTickspeed.GROWTH_EXP * costFormulaCoefficient * Math.pow(\r\n      Math.max(x, 0), FreeTickspeed.GROWTH_EXP - 1) + 1;\r\n    const newtonsMethod = bought => bought - (boughtToCost(bought) - desiredCost) / derivativeOfBoughtToCost(bought);\r\n    let oldApproximation;\r\n    let approximation = Math.min(\r\n      desiredCost,\r\n      Math.pow(desiredCost / costFormulaCoefficient, 1 / FreeTickspeed.GROWTH_EXP)\r\n    );\r\n    let counter = 0;\r\n    // The bought formula is concave upwards. We start with an over-estimate; when using newton's method,\r\n    // this means that successive iterations are also over-etimates. Thus, we can just check for continued\r\n    // progress with the approximation < oldApproximation check. The counter is a fallback.\r\n    do {\r\n      oldApproximation = approximation;\r\n      approximation = newtonsMethod(approximation);\r\n    } while (approximation < oldApproximation && ++counter < 100);\r\n    const purchases = Math.floor(approximation);\r\n    // This undoes the function we're implicitly applying to costs (the \"+ 1\") is because we want\r\n    // the cost of the next upgrade.\r\n    const next = Decimal.exp(priceToCap + boughtToCost(purchases + 1) * logTickmult);\r\n    this.multToNext = Decimal.exp((boughtToCost(purchases + 1) - boughtToCost(purchases)) * logTickmult);\r\n    return {\r\n      newAmount: purchases + FreeTickspeed.softcap,\r\n      nextShards: next,\r\n    };\r\n  }\r\n\r\n};\r\n"]},"metadata":{},"sourceType":"module"}