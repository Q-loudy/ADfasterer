{"ast":null,"code":"import \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport { MAC } from \"@/env\";\nimport { openExternalLink } from \"@/utility/open-external-link\";\nimport * as PlayFab from \"./bindings/playfab\";\nexport async function loginPlayFabWithSteam(ticket, screenName) {\n  await PlayFab.LoginWithSteam(ticket);\n  PlayFab.UpdateUserTitleDisplayName(screenName);\n  validatePurchases();\n  syncIAP();\n}\nexport async function purchaseIAP(std) {\n  const itemId = `${std}STD`;\n  const quantity = 1;\n  const annotation = \"Purchased via in-game store\";\n  const order = await PlayFab.StartPurchase(itemId, quantity, annotation);\n  const orderId = order.OrderId;\n  const currency = \"RM\";\n  const providerName = \"Steam\";\n  const result = await PlayFab.PayForPurchase(orderId, currency, providerName);\n  pendingValidations.push(result.OrderId);\n\n  if (MAC) {\n    const txnId = result.ProviderData;\n    openExternalLink(`https://store.steampowered.com/checkout/approvetxn/${txnId}/?returnurl=steam`);\n  }\n}\nlet validateTimeout = 0;\nlet pendingValidations = [];\nlet isValidating = false;\nlet retryValidation = false;\nexport async function validatePurchases() {\n  if (isValidating) {\n    retryValidation = true;\n    return;\n  }\n\n  clearTimeout(validateTimeout);\n  isValidating = true; // Copy pendingValidations, because it will be modified in validatePurchase\n\n  const orders = [...pendingValidations];\n\n  for (const order of orders) {\n    try {\n      await validatePurchase(order);\n    } catch (_unused) {// Do nothing, will be retried.\n    }\n  }\n\n  isValidating = false;\n  const timeout = retryValidation ? 0 : 2000;\n  validateTimeout = setTimeout(validatePurchases, timeout);\n  retryValidation = false;\n}\n\nasync function validatePurchase(orderId) {\n  const confirm = await PlayFab.ConfirmPurchase(orderId);\n  const purchaseName = confirm.Items[0].ItemId;\n  const purchaseInstance = confirm.Items[0].ItemInstanceId;\n  await PlayFab.ConsumeItem(purchaseInstance, 1);\n  const stdsBought = Number(purchaseName.replace(\"STD\", \"\"));\n  pendingValidations = pendingValidations.filter(item => item !== orderId);\n  await PlayFab.AddUserVirtualCurrency(stdsBought, \"ST\");\n  GameUI.notify.info(`${stdsBought} STDs Obtained!`);\n  syncIAP();\n}\n\nexport function hasPendingPurchaseConfirmations() {\n  return MAC && pendingValidations.length > 0;\n}\n\nasync function syncIAP() {\n  var _userInventory$Virtua, _userInventory$Virtua2, _userData$Data$Cosmet, _userData$Data$Cosmet2, _userData$Data$Cosmet3;\n\n  const userInventory = await PlayFab.GetUserInventory();\n  ShopPurchaseData.totalSTD = (_userInventory$Virtua = (_userInventory$Virtua2 = userInventory.VirtualCurrency) === null || _userInventory$Virtua2 === void 0 ? void 0 : _userInventory$Virtua2.ST) !== null && _userInventory$Virtua !== void 0 ? _userInventory$Virtua : 0;\n\n  for (const key of Object.keys(GameDatabase.shopPurchases)) {\n    var _item$RemainingUses;\n\n    const item = userInventory.Inventory.find(x => x.ItemId === key);\n    ShopPurchaseData[key] = (_item$RemainingUses = item === null || item === void 0 ? void 0 : item.RemainingUses) !== null && _item$RemainingUses !== void 0 ? _item$RemainingUses : 0;\n  }\n\n  GameUI.update();\n  const userData = await PlayFab.GetUserData();\n  ShopPurchaseData.unlockedCosmetics = (_userData$Data$Cosmet = (_userData$Data$Cosmet2 = userData.Data.Cosmetics) === null || _userData$Data$Cosmet2 === void 0 ? void 0 : (_userData$Data$Cosmet3 = _userData$Data$Cosmet2.Value) === null || _userData$Data$Cosmet3 === void 0 ? void 0 : _userData$Data$Cosmet3.split(\",\")) !== null && _userData$Data$Cosmet !== void 0 ? _userData$Data$Cosmet : [];\n  GameUI.update();\n}\n\nexport async function purchaseShopItem(key, cost, cosmeticId) {\n  await PlayFab.PurchaseItem(key, cost, \"ST\");\n\n  if (cosmeticId !== undefined) {\n    await storeCosmetic(cosmeticId);\n  }\n\n  syncIAP();\n}\n\nasync function storeCosmetic(id) {\n  var _userData$Data$Cosmet4, _userData$Data, _userData$Data$Cosmet5, _userData$Data$Cosmet6;\n\n  const userData = await PlayFab.GetUserData();\n  const cosmetics = new Set((_userData$Data$Cosmet4 = (_userData$Data = userData.Data) === null || _userData$Data === void 0 ? void 0 : (_userData$Data$Cosmet5 = _userData$Data.Cosmetics) === null || _userData$Data$Cosmet5 === void 0 ? void 0 : (_userData$Data$Cosmet6 = _userData$Data$Cosmet5.Value) === null || _userData$Data$Cosmet6 === void 0 ? void 0 : _userData$Data$Cosmet6.split(\",\")) !== null && _userData$Data$Cosmet4 !== void 0 ? _userData$Data$Cosmet4 : []);\n  cosmetics.add(id);\n  const updatedCosmetics = [...cosmetics];\n  await PlayFab.UpdateUserData({\n    Cosmetics: updatedCosmetics.join(\",\")\n  });\n  ShopPurchaseData.unlockedCosmetics = updatedCosmetics;\n  GameUI.update();\n}","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/steam/steam-purchases.js"],"names":["MAC","openExternalLink","PlayFab","loginPlayFabWithSteam","ticket","screenName","LoginWithSteam","UpdateUserTitleDisplayName","validatePurchases","syncIAP","purchaseIAP","std","itemId","quantity","annotation","order","StartPurchase","orderId","OrderId","currency","providerName","result","PayForPurchase","pendingValidations","push","txnId","ProviderData","validateTimeout","isValidating","retryValidation","clearTimeout","orders","validatePurchase","timeout","setTimeout","confirm","ConfirmPurchase","purchaseName","Items","ItemId","purchaseInstance","ItemInstanceId","ConsumeItem","stdsBought","Number","replace","filter","item","AddUserVirtualCurrency","GameUI","notify","info","hasPendingPurchaseConfirmations","length","userInventory","GetUserInventory","ShopPurchaseData","totalSTD","VirtualCurrency","ST","key","Object","keys","GameDatabase","shopPurchases","Inventory","find","x","RemainingUses","update","userData","GetUserData","unlockedCosmetics","Data","Cosmetics","Value","split","purchaseShopItem","cost","cosmeticId","PurchaseItem","undefined","storeCosmetic","id","cosmetics","Set","add","updatedCosmetics","UpdateUserData","join"],"mappings":"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","sourcesContent":["import { MAC } from \"@/env\";\r\nimport { openExternalLink } from \"@/utility/open-external-link\";\r\nimport * as PlayFab from \"./bindings/playfab\";\r\n\r\nexport async function loginPlayFabWithSteam(ticket, screenName) {\r\n  await PlayFab.LoginWithSteam(ticket);\r\n  PlayFab.UpdateUserTitleDisplayName(screenName);\r\n  validatePurchases();\r\n  syncIAP();\r\n}\r\n\r\nexport async function purchaseIAP(std) {\r\n  const itemId = `${std}STD`;\r\n  const quantity = 1;\r\n  const annotation = \"Purchased via in-game store\";\r\n  const order = await PlayFab.StartPurchase(itemId, quantity, annotation);\r\n\r\n  const orderId = order.OrderId;\r\n  const currency = \"RM\";\r\n  const providerName = \"Steam\";\r\n  const result = await PlayFab.PayForPurchase(orderId, currency, providerName);\r\n\r\n  pendingValidations.push(result.OrderId);\r\n\r\n  if (MAC) {\r\n    const txnId = result.ProviderData;\r\n    openExternalLink(`https://store.steampowered.com/checkout/approvetxn/${txnId}/?returnurl=steam`);\r\n  }\r\n}\r\n\r\nlet validateTimeout = 0;\r\nlet pendingValidations = [];\r\nlet isValidating = false;\r\nlet retryValidation = false;\r\n\r\nexport async function validatePurchases() {\r\n  if (isValidating) {\r\n    retryValidation = true;\r\n    return;\r\n  }\r\n\r\n  clearTimeout(validateTimeout);\r\n  isValidating = true;\r\n  // Copy pendingValidations, because it will be modified in validatePurchase\r\n  const orders = [...pendingValidations];\r\n  for (const order of orders) {\r\n    try {\r\n      await validatePurchase(order);\r\n    } catch {\r\n      // Do nothing, will be retried.\r\n    }\r\n  }\r\n  isValidating = false;\r\n  const timeout = retryValidation ? 0 : 2000;\r\n  validateTimeout = setTimeout(validatePurchases, timeout);\r\n  retryValidation = false;\r\n}\r\n\r\nasync function validatePurchase(orderId) {\r\n  const confirm = await PlayFab.ConfirmPurchase(orderId);\r\n  const purchaseName = confirm.Items[0].ItemId;\r\n  const purchaseInstance = confirm.Items[0].ItemInstanceId;\r\n\r\n  await PlayFab.ConsumeItem(purchaseInstance, 1);\r\n  const stdsBought = Number(purchaseName.replace(\"STD\", \"\"));\r\n  pendingValidations = pendingValidations.filter(item => item !== orderId);\r\n  await PlayFab.AddUserVirtualCurrency(stdsBought, \"ST\");\r\n  GameUI.notify.info(`${stdsBought} STDs Obtained!`);\r\n  syncIAP();\r\n}\r\n\r\nexport function hasPendingPurchaseConfirmations() {\r\n  return MAC && pendingValidations.length > 0;\r\n}\r\n\r\nasync function syncIAP() {\r\n  const userInventory = await PlayFab.GetUserInventory();\r\n  ShopPurchaseData.totalSTD = userInventory.VirtualCurrency?.ST ?? 0;\r\n  for (const key of Object.keys(GameDatabase.shopPurchases)) {\r\n    const item = userInventory.Inventory.find(x => x.ItemId === key);\r\n    ShopPurchaseData[key] = item?.RemainingUses ?? 0;\r\n  }\r\n  GameUI.update();\r\n\r\n  const userData = await PlayFab.GetUserData();\r\n  ShopPurchaseData.unlockedCosmetics = userData.Data.Cosmetics?.Value?.split(\",\") ?? [];\r\n  GameUI.update();\r\n}\r\n\r\nexport async function purchaseShopItem(key, cost, cosmeticId) {\r\n  await PlayFab.PurchaseItem(key, cost, \"ST\");\r\n  if (cosmeticId !== undefined) {\r\n    await storeCosmetic(cosmeticId);\r\n  }\r\n  syncIAP();\r\n}\r\n\r\nasync function storeCosmetic(id) {\r\n  const userData = await PlayFab.GetUserData();\r\n  const cosmetics = new Set(userData.Data?.Cosmetics?.Value?.split(\",\") ?? []);\r\n  cosmetics.add(id);\r\n  const updatedCosmetics = [...cosmetics];\r\n  await PlayFab.UpdateUserData({\r\n    Cosmetics: updatedCosmetics.join(\",\")\r\n  });\r\n\r\n  ShopPurchaseData.unlockedCosmetics = updatedCosmetics;\r\n  GameUI.update();\r\n}\r\n"]},"metadata":{},"sourceType":"module"}