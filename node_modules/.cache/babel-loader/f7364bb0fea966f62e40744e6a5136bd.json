{"ast":null,"code":"import \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array.flat.js\";\nimport \"core-js/modules/es.array.unscopables.flat.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport { GameMechanicState } from \"../../game-mechanics\";\nimport { deepmergeAll } from \"@/utility/deepmerge\";\n\nclass SingularityMilestoneState extends GameMechanicState {\n  constructor(config) {\n    const effect = config.effect;\n    const configCopy = deepmergeAll([{}, config]);\n\n    configCopy.effect = () => effect(this.completions);\n\n    super(configCopy);\n    this._rawEffect = effect;\n  }\n\n  get start() {\n    return this.config.start;\n  }\n\n  get repeat() {\n    return this.config.repeat;\n  }\n\n  get limit() {\n    return this.config.limit;\n  }\n\n  get isUnique() {\n    return this.repeat === 0;\n  }\n\n  get isUnlocked() {\n    return Currency.singularities.gte(this.start);\n  }\n\n  get increaseThreshold() {\n    return this.config.increaseThreshold;\n  }\n\n  nerfCompletions(completions) {\n    const softcap = this.increaseThreshold;\n    if (!softcap || completions < softcap) return completions;\n    return softcap + (completions - softcap) / 3;\n  }\n\n  unnerfCompletions(completions) {\n    const softcap = this.increaseThreshold;\n    if (!softcap || completions < softcap) return completions;\n    return softcap + (completions - softcap) * 3;\n  }\n\n  get previousGoal() {\n    if (this.isUnique) return 1;\n    if (!this.isUnlocked) return 0;\n    return this.start * Math.pow(this.repeat, this.unnerfCompletions(this.completions) - 1);\n  }\n\n  get nextGoal() {\n    if (this.isUnique) return this.start;\n    return this.start * Math.pow(this.repeat, this.unnerfCompletions(this.completions + 1) - 1);\n  }\n\n  get rawCompletions() {\n    if (this.isUnique) return this.isUnlocked ? 1 : 0;\n    if (!this.isUnlocked) return 0;\n    return 1 + (Math.log(Currency.singularities.value) - Math.log(this.start)) / Math.log(this.repeat);\n  }\n\n  get completions() {\n    return Math.min(Math.floor(this.nerfCompletions(this.rawCompletions)), this.limit);\n  }\n\n  get remainingSingularities() {\n    return this.nextGoal - Currency.singularities.value;\n  }\n\n  get progressToNext() {\n    const prog = (Currency.singularities.value - this.previousGoal) / this.nextGoal;\n    return formatPercents(Math.clampMax(prog, 1));\n  }\n\n  get isMaxed() {\n    return this.isUnique && this.isUnlocked || this.completions >= this.limit;\n  }\n\n  get effectDisplay() {\n    if (Number.isFinite(this.effectValue)) return this.config.effectFormat(this.effectValue);\n    return \"N/A\";\n  }\n\n  get nextEffectDisplay() {\n    return this.config.effectFormat(this._rawEffect(this.completions + 1));\n  }\n\n  get description() {\n    return this.config.description;\n  }\n\n  get canBeApplied() {\n    return this.isUnlocked && !Pelle.isDisabled(\"singularity\");\n  }\n\n}\n\nexport const SingularityMilestone = mapGameDataToObject(GameDatabase.celestials.singularityMilestones, config => new SingularityMilestoneState(config));\nexport const SingularityMilestones = {\n  all: SingularityMilestone.all,\n  lastNotified: player.celestials.laitela.lastCheckedMilestones,\n\n  get sorted() {\n    return this.all.sort((a, b) => a.remainingSingularities - b.remainingSingularities);\n  },\n\n  sortedForCompletions(moveNewToTop) {\n    const options = player.celestials.laitela.singularitySorting; // Sorting functions for singularity milestones, values are generally around 0 to 2ish. Should generally attempt\n    // to return unique values for all milestones for the sake of stable sorting\n\n    let sortFn;\n\n    switch (options.sortResource) {\n      case SINGULARITY_MILESTONE_SORT.SINGULARITIES_TO_NEXT:\n        sortFn = m => {\n          // If it's maxed, we order based on the final goal value - higher goals are sorted later\n          if (m.isMaxed) return 1 + Math.log10(m.isUnique ? m.nextGoal : m.previousGoal) / 1000;\n          return Math.log10(m.remainingSingularities) / 100;\n        };\n\n        break;\n\n      case SINGULARITY_MILESTONE_SORT.CURRENT_COMPLETIONS:\n        // Also counts partial completion on the current step\n        sortFn = m => {\n          // For never-completed repeatable milestones, this is zero and will cause NaN bugs if we don't set it to 1\n          const prev = Math.clampMin(m.previousGoal, 1);\n          const part = Math.clamp(Math.log(Currency.singularities.value / prev) / Math.log(m.nextGoal / prev), 0, 1);\n          return (m.completions + part) / 20;\n        };\n\n        break;\n\n      case SINGULARITY_MILESTONE_SORT.PERCENT_COMPLETIONS:\n        // Orders infinite milestones based on completion count, putting them after all limited ones even if\n        // they're completed\n        sortFn = m => {\n          const limit = Number.isFinite(m.limit) ? m.limit : 100;\n          const currComp = Math.log(Currency.singularities.value / m.previousGoal) / Math.log(m.nextGoal / m.previousGoal);\n          return Math.clampMax((m.completions + currComp) / limit, 1) + (Number.isFinite(m.limit) ? 0 : 1);\n        };\n\n        break;\n\n      case SINGULARITY_MILESTONE_SORT.FINAL_COMPLETION:\n        // Sorts infinite milestones as if they end at 50 steps; for any given number of completions, this\n        // treats infinite milestones with larger steps as if they complete at a higher value\n        sortFn = m => {\n          const limit = Number.isFinite(m.limit) ? m.limit : 50;\n          return Math.log10(m.config.start * Math.pow(m.config.repeat, limit - 1)) / 100;\n        };\n\n        break;\n\n      case SINGULARITY_MILESTONE_SORT.MOST_RECENT:\n        sortFn = m => {\n          if (!m.isUnlocked) return 1 + Math.log10(m.start) / 1000; // For unique milestones, previousGoal is actually 1 and nextGoal contains the completion amount\n\n          return Math.log10(m.isUnique ? m.nextGoal : m.previousGoal) / 100;\n        };\n\n        break;\n\n      default:\n        throw new Error(\"Unrecognized Singularity Milestone sorting option (order)\");\n    } // Shift the fully completed milestones to the front or back with a constant offset which should be larger\n    // than the value that the sort function should ever evaluate to\n\n\n    let completedVal;\n\n    switch (options.showCompleted) {\n      case COMPLETED_MILESTONES.FIRST:\n        completedVal = 10;\n        break;\n\n      case COMPLETED_MILESTONES.LAST:\n        completedVal = -10;\n        break;\n\n      case COMPLETED_MILESTONES.IGNORED:\n        completedVal = 0;\n        break;\n\n      default:\n        throw new Error(\"Unrecognized Singularity Milestone sorting option (completed milestones)\");\n    } // Compose the functions together; possibly reverse the final order and bring new milestones to the top\n\n\n    const isNew = m => m.previousGoal > player.celestials.laitela.lastCheckedMilestones && moveNewToTop ? 20 : 0;\n\n    const compFn = m => (m.isMaxed ? completedVal : 0) + (options.sortOrder ? sortFn(m) : -sortFn(m)) + isNew(m);\n\n    return this.sorted.sort((a, b) => compFn(b) - compFn(a));\n  },\n\n  get nextMilestoneGroup() {\n    return this.sortedForCompletions(false).filter(m => !m.isMaxed).slice(0, 6);\n  },\n\n  get unseenMilestones() {\n    const laitela = player.celestials.laitela;\n    return SingularityMilestoneThresholds.filter(s => s > laitela.lastCheckedMilestones && Currency.singularities.gte(s));\n  },\n\n  get unnotifiedMilestones() {\n    return SingularityMilestoneThresholds.filter(s => s > this.lastNotified && Currency.singularities.gte(s));\n  }\n\n}; // Sorted list of all the values where a singularity milestone exists, used for \"new milestone\" styling\n\nconst SingularityMilestoneThresholds = function () {\n  return SingularityMilestones.all.map(m => Array.range(0, Math.min(50, m.limit)).filter(r => !m.increaseThreshold || r <= m.increaseThreshold || r > m.increaseThreshold && (r - m.increaseThreshold) % 3 === 2).map(r => m.start * Math.pow(m.repeat, r))).flat(Infinity).filter(n => n < 1e100).sort((a, b) => a - b);\n}();\n\nexport const Singularity = {\n  get cap() {\n    return 200 * Math.pow(10, player.celestials.laitela.singularityCapIncreases);\n  },\n\n  get gainPerCapIncrease() {\n    return SingularityMilestone.improvedSingularityCap.effectOrDefault(11);\n  },\n\n  get singularitiesGained() {\n    return Math.floor(Math.pow(this.gainPerCapIncrease, player.celestials.laitela.singularityCapIncreases) * SingularityMilestone.singularityMult.effectOrDefault(1) * (1 + ImaginaryUpgrade(10).effectOrDefault(0)));\n  },\n\n  // Time (in seconds) to go from 0 DE to the condensing requirement\n  get timePerCondense() {\n    return this.cap / Currency.darkEnergy.productionPerSecond;\n  },\n\n  // Time (in seconds) to reach the condensing requirement from *current* DE\n  get timeUntilCap() {\n    return (this.cap - Currency.darkEnergy.value) / Currency.darkEnergy.productionPerSecond;\n  },\n\n  // Total additional time auto-condense will wait after reaching the condensing requirement\n  get timeDelayFromAuto() {\n    return this.timePerCondense * (SingularityMilestone.autoCondense.effectOrDefault(Infinity) - 1);\n  },\n\n  get capIsReached() {\n    return Currency.darkEnergy.gte(this.cap);\n  },\n\n  increaseCap() {\n    if (player.celestials.laitela.singularityCapIncreases >= 50) return;\n    player.celestials.laitela.singularityCapIncreases++;\n  },\n\n  decreaseCap() {\n    if (player.celestials.laitela.singularityCapIncreases === 0) return;\n    player.celestials.laitela.singularityCapIncreases--;\n  },\n\n  perform() {\n    if (!this.capIsReached || Pelle.isDoomed) return;\n    EventHub.dispatch(GAME_EVENT.SINGULARITY_RESET_BEFORE);\n    Currency.darkEnergy.reset();\n    Currency.singularities.add(this.singularitiesGained);\n\n    for (const quote of Laitela.quotes.all) {\n      if (quote.requirement) {\n        quote.show();\n      }\n    }\n\n    EventHub.dispatch(GAME_EVENT.SINGULARITY_RESET_AFTER);\n  }\n\n};\nEventHub.logic.on(GAME_EVENT.GAME_LOAD, () => SingularityMilestones.lastNotified = Currency.singularities.value);\nEventHub.logic.on(GAME_EVENT.SINGULARITY_RESET_AFTER, () => {\n  const newMilestones = SingularityMilestones.unnotifiedMilestones.length;\n  if (newMilestones === 0) return;\n  if (newMilestones === 1) GameUI.notify.blackHole(`You reached a Singularity milestone!`);else GameUI.notify.blackHole(`You reached ${formatInt(newMilestones)} Singularity milestones!`);\n  SingularityMilestones.lastNotified = Currency.singularities.value;\n});","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/celestials/laitela/singularity.js"],"names":["GameMechanicState","deepmergeAll","SingularityMilestoneState","constructor","config","effect","configCopy","completions","_rawEffect","start","repeat","limit","isUnique","isUnlocked","Currency","singularities","gte","increaseThreshold","nerfCompletions","softcap","unnerfCompletions","previousGoal","Math","pow","nextGoal","rawCompletions","log","value","min","floor","remainingSingularities","progressToNext","prog","formatPercents","clampMax","isMaxed","effectDisplay","Number","isFinite","effectValue","effectFormat","nextEffectDisplay","description","canBeApplied","Pelle","isDisabled","SingularityMilestone","mapGameDataToObject","GameDatabase","celestials","singularityMilestones","SingularityMilestones","all","lastNotified","player","laitela","lastCheckedMilestones","sorted","sort","a","b","sortedForCompletions","moveNewToTop","options","singularitySorting","sortFn","sortResource","SINGULARITY_MILESTONE_SORT","SINGULARITIES_TO_NEXT","m","log10","CURRENT_COMPLETIONS","prev","clampMin","part","clamp","PERCENT_COMPLETIONS","currComp","FINAL_COMPLETION","MOST_RECENT","Error","completedVal","showCompleted","COMPLETED_MILESTONES","FIRST","LAST","IGNORED","isNew","compFn","sortOrder","nextMilestoneGroup","filter","slice","unseenMilestones","SingularityMilestoneThresholds","s","unnotifiedMilestones","map","Array","range","r","flat","Infinity","n","Singularity","cap","singularityCapIncreases","gainPerCapIncrease","improvedSingularityCap","effectOrDefault","singularitiesGained","singularityMult","ImaginaryUpgrade","timePerCondense","darkEnergy","productionPerSecond","timeUntilCap","timeDelayFromAuto","autoCondense","capIsReached","increaseCap","decreaseCap","perform","isDoomed","EventHub","dispatch","GAME_EVENT","SINGULARITY_RESET_BEFORE","reset","add","quote","Laitela","quotes","requirement","show","SINGULARITY_RESET_AFTER","logic","on","GAME_LOAD","newMilestones","length","GameUI","notify","blackHole","formatInt"],"mappings":";;;;;AAAA,SAASA,iBAAT,QAAkC,sBAAlC;AAEA,SAASC,YAAT,QAA6B,qBAA7B;;AAEA,MAAMC,yBAAN,SAAwCF,iBAAxC,CAA0D;AACxDG,EAAAA,WAAW,CAACC,MAAD,EAAS;AAClB,UAAMC,MAAM,GAAGD,MAAM,CAACC,MAAtB;AACA,UAAMC,UAAU,GAAGL,YAAY,CAAC,CAAC,EAAD,EAAKG,MAAL,CAAD,CAA/B;;AACAE,IAAAA,UAAU,CAACD,MAAX,GAAoB,MAAMA,MAAM,CAAC,KAAKE,WAAN,CAAhC;;AACA,UAAMD,UAAN;AACA,SAAKE,UAAL,GAAkBH,MAAlB;AACD;;AAEQ,MAALI,KAAK,GAAG;AACV,WAAO,KAAKL,MAAL,CAAYK,KAAnB;AACD;;AAES,MAANC,MAAM,GAAG;AACX,WAAO,KAAKN,MAAL,CAAYM,MAAnB;AACD;;AAEQ,MAALC,KAAK,GAAG;AACV,WAAO,KAAKP,MAAL,CAAYO,KAAnB;AACD;;AAEW,MAARC,QAAQ,GAAG;AACb,WAAO,KAAKF,MAAL,KAAgB,CAAvB;AACD;;AAEa,MAAVG,UAAU,GAAG;AACf,WAAOC,QAAQ,CAACC,aAAT,CAAuBC,GAAvB,CAA2B,KAAKP,KAAhC,CAAP;AACD;;AAEoB,MAAjBQ,iBAAiB,GAAG;AACtB,WAAO,KAAKb,MAAL,CAAYa,iBAAnB;AACD;;AAEDC,EAAAA,eAAe,CAACX,WAAD,EAAc;AAC3B,UAAMY,OAAO,GAAG,KAAKF,iBAArB;AACA,QAAI,CAACE,OAAD,IAAaZ,WAAW,GAAGY,OAA/B,EAAyC,OAAOZ,WAAP;AACzC,WAAOY,OAAO,GAAG,CAACZ,WAAW,GAAGY,OAAf,IAA0B,CAA3C;AACD;;AAEDC,EAAAA,iBAAiB,CAACb,WAAD,EAAc;AAC7B,UAAMY,OAAO,GAAG,KAAKF,iBAArB;AACA,QAAI,CAACE,OAAD,IAAaZ,WAAW,GAAGY,OAA/B,EAAyC,OAAOZ,WAAP;AACzC,WAAOY,OAAO,GAAG,CAACZ,WAAW,GAAGY,OAAf,IAA0B,CAA3C;AACD;;AAEe,MAAZE,YAAY,GAAG;AACjB,QAAI,KAAKT,QAAT,EAAmB,OAAO,CAAP;AACnB,QAAI,CAAC,KAAKC,UAAV,EAAsB,OAAO,CAAP;AACtB,WAAO,KAAKJ,KAAL,GAAaa,IAAI,CAACC,GAAL,CAAS,KAAKb,MAAd,EAAsB,KAAKU,iBAAL,CAAuB,KAAKb,WAA5B,IAA2C,CAAjE,CAApB;AACD;;AAEW,MAARiB,QAAQ,GAAG;AACb,QAAI,KAAKZ,QAAT,EAAmB,OAAO,KAAKH,KAAZ;AACnB,WAAO,KAAKA,KAAL,GAAaa,IAAI,CAACC,GAAL,CAAS,KAAKb,MAAd,EAAsB,KAAKU,iBAAL,CAAuB,KAAKb,WAAL,GAAmB,CAA1C,IAA+C,CAArE,CAApB;AACD;;AAEiB,MAAdkB,cAAc,GAAG;AACnB,QAAI,KAAKb,QAAT,EAAmB,OAAO,KAAKC,UAAL,GAAkB,CAAlB,GAAsB,CAA7B;AACnB,QAAI,CAAC,KAAKA,UAAV,EAAsB,OAAO,CAAP;AACtB,WAAO,IAAI,CAACS,IAAI,CAACI,GAAL,CAASZ,QAAQ,CAACC,aAAT,CAAuBY,KAAhC,IAAyCL,IAAI,CAACI,GAAL,CAAS,KAAKjB,KAAd,CAA1C,IAAkEa,IAAI,CAACI,GAAL,CAAS,KAAKhB,MAAd,CAA7E;AACD;;AAEc,MAAXH,WAAW,GAAG;AAChB,WAAOe,IAAI,CAACM,GAAL,CAASN,IAAI,CAACO,KAAL,CAAW,KAAKX,eAAL,CAAqB,KAAKO,cAA1B,CAAX,CAAT,EAAgE,KAAKd,KAArE,CAAP;AACD;;AAEyB,MAAtBmB,sBAAsB,GAAG;AAC3B,WAAO,KAAKN,QAAL,GAAgBV,QAAQ,CAACC,aAAT,CAAuBY,KAA9C;AACD;;AAEiB,MAAdI,cAAc,GAAG;AACnB,UAAMC,IAAI,GAAG,CAAClB,QAAQ,CAACC,aAAT,CAAuBY,KAAvB,GAA+B,KAAKN,YAArC,IAAqD,KAAKG,QAAvE;AACA,WAAOS,cAAc,CAACX,IAAI,CAACY,QAAL,CAAcF,IAAd,EAAoB,CAApB,CAAD,CAArB;AACD;;AAEU,MAAPG,OAAO,GAAG;AACZ,WAAQ,KAAKvB,QAAL,IAAiB,KAAKC,UAAvB,IAAuC,KAAKN,WAAL,IAAoB,KAAKI,KAAvE;AACD;;AAEgB,MAAbyB,aAAa,GAAG;AAClB,QAAIC,MAAM,CAACC,QAAP,CAAgB,KAAKC,WAArB,CAAJ,EAAuC,OAAO,KAAKnC,MAAL,CAAYoC,YAAZ,CAAyB,KAAKD,WAA9B,CAAP;AACvC,WAAO,KAAP;AACD;;AAEoB,MAAjBE,iBAAiB,GAAG;AACtB,WAAO,KAAKrC,MAAL,CAAYoC,YAAZ,CAAyB,KAAKhC,UAAL,CAAgB,KAAKD,WAAL,GAAmB,CAAnC,CAAzB,CAAP;AACD;;AAEc,MAAXmC,WAAW,GAAG;AAChB,WAAO,KAAKtC,MAAL,CAAYsC,WAAnB;AACD;;AAEe,MAAZC,YAAY,GAAG;AACjB,WAAO,KAAK9B,UAAL,IAAmB,CAAC+B,KAAK,CAACC,UAAN,CAAiB,aAAjB,CAA3B;AACD;;AA9FuD;;AAiG1D,OAAO,MAAMC,oBAAoB,GAAGC,mBAAmB,CACrDC,YAAY,CAACC,UAAb,CAAwBC,qBAD6B,EAErD9C,MAAM,IAAI,IAAIF,yBAAJ,CAA8BE,MAA9B,CAF2C,CAAhD;AAKP,OAAO,MAAM+C,qBAAqB,GAAG;AACnCC,EAAAA,GAAG,EAAEN,oBAAoB,CAACM,GADS;AAEnCC,EAAAA,YAAY,EAAEC,MAAM,CAACL,UAAP,CAAkBM,OAAlB,CAA0BC,qBAFL;;AAInC,MAAIC,MAAJ,GAAa;AACX,WAAO,KAAKL,GAAL,CAASM,IAAT,CAAc,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,CAAC7B,sBAAF,GAA2B8B,CAAC,CAAC9B,sBAArD,CAAP;AACD,GANkC;;AAQnC+B,EAAAA,oBAAoB,CAACC,YAAD,EAAe;AACjC,UAAMC,OAAO,GAAGT,MAAM,CAACL,UAAP,CAAkBM,OAAlB,CAA0BS,kBAA1C,CADiC,CAGjC;AACA;;AACA,QAAIC,MAAJ;;AACA,YAAQF,OAAO,CAACG,YAAhB;AACE,WAAKC,0BAA0B,CAACC,qBAAhC;AACEH,QAAAA,MAAM,GAAGI,CAAC,IAAI;AACZ;AACA,cAAIA,CAAC,CAAClC,OAAN,EAAe,OAAO,IAAIb,IAAI,CAACgD,KAAL,CAAWD,CAAC,CAACzD,QAAF,GAAayD,CAAC,CAAC7C,QAAf,GAA0B6C,CAAC,CAAChD,YAAvC,IAAuD,IAAlE;AACf,iBAAOC,IAAI,CAACgD,KAAL,CAAWD,CAAC,CAACvC,sBAAb,IAAuC,GAA9C;AACD,SAJD;;AAKA;;AACF,WAAKqC,0BAA0B,CAACI,mBAAhC;AACE;AACAN,QAAAA,MAAM,GAAGI,CAAC,IAAI;AACZ;AACA,gBAAMG,IAAI,GAAGlD,IAAI,CAACmD,QAAL,CAAcJ,CAAC,CAAChD,YAAhB,EAA8B,CAA9B,CAAb;AACA,gBAAMqD,IAAI,GAAGpD,IAAI,CAACqD,KAAL,CAAWrD,IAAI,CAACI,GAAL,CAASZ,QAAQ,CAACC,aAAT,CAAuBY,KAAvB,GAA+B6C,IAAxC,IAAgDlD,IAAI,CAACI,GAAL,CAAS2C,CAAC,CAAC7C,QAAF,GAAagD,IAAtB,CAA3D,EAAwF,CAAxF,EAA2F,CAA3F,CAAb;AACA,iBAAO,CAACH,CAAC,CAAC9D,WAAF,GAAgBmE,IAAjB,IAAyB,EAAhC;AACD,SALD;;AAMA;;AACF,WAAKP,0BAA0B,CAACS,mBAAhC;AACE;AACA;AACAX,QAAAA,MAAM,GAAGI,CAAC,IAAI;AACZ,gBAAM1D,KAAK,GAAG0B,MAAM,CAACC,QAAP,CAAgB+B,CAAC,CAAC1D,KAAlB,IAA2B0D,CAAC,CAAC1D,KAA7B,GAAqC,GAAnD;AACA,gBAAMkE,QAAQ,GAAGvD,IAAI,CAACI,GAAL,CAASZ,QAAQ,CAACC,aAAT,CAAuBY,KAAvB,GAA+B0C,CAAC,CAAChD,YAA1C,IACfC,IAAI,CAACI,GAAL,CAAS2C,CAAC,CAAC7C,QAAF,GAAa6C,CAAC,CAAChD,YAAxB,CADF;AAEA,iBAAOC,IAAI,CAACY,QAAL,CAAc,CAACmC,CAAC,CAAC9D,WAAF,GAAgBsE,QAAjB,IAA6BlE,KAA3C,EAAkD,CAAlD,KAAwD0B,MAAM,CAACC,QAAP,CAAgB+B,CAAC,CAAC1D,KAAlB,IAA2B,CAA3B,GAA+B,CAAvF,CAAP;AACD,SALD;;AAMA;;AACF,WAAKwD,0BAA0B,CAACW,gBAAhC;AACE;AACA;AACAb,QAAAA,MAAM,GAAGI,CAAC,IAAI;AACZ,gBAAM1D,KAAK,GAAG0B,MAAM,CAACC,QAAP,CAAgB+B,CAAC,CAAC1D,KAAlB,IAA2B0D,CAAC,CAAC1D,KAA7B,GAAqC,EAAnD;AACA,iBAAOW,IAAI,CAACgD,KAAL,CAAWD,CAAC,CAACjE,MAAF,CAASK,KAAT,GAAiBa,IAAI,CAACC,GAAL,CAAS8C,CAAC,CAACjE,MAAF,CAASM,MAAlB,EAA0BC,KAAK,GAAG,CAAlC,CAA5B,IAAoE,GAA3E;AACD,SAHD;;AAIA;;AACF,WAAKwD,0BAA0B,CAACY,WAAhC;AACEd,QAAAA,MAAM,GAAGI,CAAC,IAAI;AACZ,cAAI,CAACA,CAAC,CAACxD,UAAP,EAAmB,OAAO,IAAIS,IAAI,CAACgD,KAAL,CAAWD,CAAC,CAAC5D,KAAb,IAAsB,IAAjC,CADP,CAEZ;;AACA,iBAAOa,IAAI,CAACgD,KAAL,CAAWD,CAAC,CAACzD,QAAF,GAAayD,CAAC,CAAC7C,QAAf,GAA0B6C,CAAC,CAAChD,YAAvC,IAAuD,GAA9D;AACD,SAJD;;AAKA;;AACF;AACE,cAAM,IAAI2D,KAAJ,CAAU,2DAAV,CAAN;AA3CJ,KANiC,CAoDjC;AACA;;;AACA,QAAIC,YAAJ;;AACA,YAAQlB,OAAO,CAACmB,aAAhB;AACE,WAAKC,oBAAoB,CAACC,KAA1B;AACEH,QAAAA,YAAY,GAAG,EAAf;AACA;;AACF,WAAKE,oBAAoB,CAACE,IAA1B;AACEJ,QAAAA,YAAY,GAAG,CAAC,EAAhB;AACA;;AACF,WAAKE,oBAAoB,CAACG,OAA1B;AACEL,QAAAA,YAAY,GAAG,CAAf;AACA;;AACF;AACE,cAAM,IAAID,KAAJ,CAAU,0EAAV,CAAN;AAXJ,KAvDiC,CAqEjC;;;AACA,UAAMO,KAAK,GAAGlB,CAAC,IAAMA,CAAC,CAAChD,YAAF,GAAiBiC,MAAM,CAACL,UAAP,CAAkBM,OAAlB,CAA0BC,qBAA3C,IAAoEM,YAArE,GAAqF,EAArF,GAA0F,CAA9G;;AACA,UAAM0B,MAAM,GAAGnB,CAAC,IAAI,CAACA,CAAC,CAAClC,OAAF,GAAY8C,YAAZ,GAA2B,CAA5B,KAAkClB,OAAO,CAAC0B,SAAR,GAAoBxB,MAAM,CAACI,CAAD,CAA1B,GAAgC,CAACJ,MAAM,CAACI,CAAD,CAAzE,IAAgFkB,KAAK,CAAClB,CAAD,CAAzG;;AACA,WAAO,KAAKZ,MAAL,CAAYC,IAAZ,CAAiB,CAACC,CAAD,EAAIC,CAAJ,KAAU4B,MAAM,CAAC5B,CAAD,CAAN,GAAY4B,MAAM,CAAC7B,CAAD,CAA7C,CAAP;AACD,GAjFkC;;AAmFnC,MAAI+B,kBAAJ,GAAyB;AACvB,WAAO,KAAK7B,oBAAL,CAA0B,KAA1B,EAAiC8B,MAAjC,CAAwCtB,CAAC,IAAI,CAACA,CAAC,CAAClC,OAAhD,EAAyDyD,KAAzD,CAA+D,CAA/D,EAAkE,CAAlE,CAAP;AACD,GArFkC;;AAuFnC,MAAIC,gBAAJ,GAAuB;AACrB,UAAMtC,OAAO,GAAGD,MAAM,CAACL,UAAP,CAAkBM,OAAlC;AACA,WAAOuC,8BAA8B,CAClCH,MADI,CACGI,CAAC,IAAIA,CAAC,GAAGxC,OAAO,CAACC,qBAAZ,IAAqC1C,QAAQ,CAACC,aAAT,CAAuBC,GAAvB,CAA2B+E,CAA3B,CAD7C,CAAP;AAED,GA3FkC;;AA6FnC,MAAIC,oBAAJ,GAA2B;AACzB,WAAOF,8BAA8B,CAACH,MAA/B,CAAsCI,CAAC,IAAIA,CAAC,GAAG,KAAK1C,YAAT,IAAyBvC,QAAQ,CAACC,aAAT,CAAuBC,GAAvB,CAA2B+E,CAA3B,CAApE,CAAP;AACD;;AA/FkC,CAA9B,C,CAkGP;;AACA,MAAMD,8BAA8B,GAAI,YAAW;AACjD,SAAO3C,qBAAqB,CAACC,GAAtB,CACJ6C,GADI,CACA5B,CAAC,IAAI6B,KAAK,CAACC,KAAN,CAAY,CAAZ,EAAe7E,IAAI,CAACM,GAAL,CAAS,EAAT,EAAayC,CAAC,CAAC1D,KAAf,CAAf,EACPgF,MADO,CACAS,CAAC,IAAI,CAAC/B,CAAC,CAACpD,iBAAH,IAAwBmF,CAAC,IAAI/B,CAAC,CAACpD,iBAA/B,IACVmF,CAAC,GAAG/B,CAAC,CAACpD,iBAAN,IAA4B,CAACmF,CAAC,GAAG/B,CAAC,CAACpD,iBAAP,IAA4B,CAA7B,KAAoC,CAF1D,EAGPgF,GAHO,CAGHG,CAAC,IAAI/B,CAAC,CAAC5D,KAAF,GAAUa,IAAI,CAACC,GAAL,CAAS8C,CAAC,CAAC3D,MAAX,EAAmB0F,CAAnB,CAHZ,CADL,EAKJC,IALI,CAKCC,QALD,EAMJX,MANI,CAMGY,CAAC,IAAIA,CAAC,GAAG,KANZ,EAOJ7C,IAPI,CAOC,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,GAAGC,CAPf,CAAP;AAQD,CATuC,EAAxC;;AAWA,OAAO,MAAM4C,WAAW,GAAG;AACzB,MAAIC,GAAJ,GAAU;AACR,WAAO,MAAMnF,IAAI,CAACC,GAAL,CAAS,EAAT,EAAa+B,MAAM,CAACL,UAAP,CAAkBM,OAAlB,CAA0BmD,uBAAvC,CAAb;AACD,GAHwB;;AAKzB,MAAIC,kBAAJ,GAAyB;AACvB,WAAO7D,oBAAoB,CAAC8D,sBAArB,CAA4CC,eAA5C,CAA4D,EAA5D,CAAP;AACD,GAPwB;;AASzB,MAAIC,mBAAJ,GAA0B;AACxB,WAAOxF,IAAI,CAACO,KAAL,CAAWP,IAAI,CAACC,GAAL,CAAS,KAAKoF,kBAAd,EAAkCrD,MAAM,CAACL,UAAP,CAAkBM,OAAlB,CAA0BmD,uBAA5D,IAChB5D,oBAAoB,CAACiE,eAArB,CAAqCF,eAArC,CAAqD,CAArD,CADgB,IAEf,IAAIG,gBAAgB,CAAC,EAAD,CAAhB,CAAqBH,eAArB,CAAqC,CAArC,CAFW,CAAX,CAAP;AAGD,GAbwB;;AAezB;AACA,MAAII,eAAJ,GAAsB;AACpB,WAAO,KAAKR,GAAL,GAAW3F,QAAQ,CAACoG,UAAT,CAAoBC,mBAAtC;AACD,GAlBwB;;AAoBzB;AACA,MAAIC,YAAJ,GAAmB;AACjB,WAAO,CAAC,KAAKX,GAAL,GAAW3F,QAAQ,CAACoG,UAAT,CAAoBvF,KAAhC,IAAyCb,QAAQ,CAACoG,UAAT,CAAoBC,mBAApE;AACD,GAvBwB;;AAyBzB;AACA,MAAIE,iBAAJ,GAAwB;AACtB,WAAO,KAAKJ,eAAL,IAAwBnE,oBAAoB,CAACwE,YAArB,CAAkCT,eAAlC,CAAkDP,QAAlD,IAA8D,CAAtF,CAAP;AACD,GA5BwB;;AA8BzB,MAAIiB,YAAJ,GAAmB;AACjB,WAAOzG,QAAQ,CAACoG,UAAT,CAAoBlG,GAApB,CAAwB,KAAKyF,GAA7B,CAAP;AACD,GAhCwB;;AAkCzBe,EAAAA,WAAW,GAAG;AACZ,QAAIlE,MAAM,CAACL,UAAP,CAAkBM,OAAlB,CAA0BmD,uBAA1B,IAAqD,EAAzD,EAA6D;AAC7DpD,IAAAA,MAAM,CAACL,UAAP,CAAkBM,OAAlB,CAA0BmD,uBAA1B;AACD,GArCwB;;AAuCzBe,EAAAA,WAAW,GAAG;AACZ,QAAInE,MAAM,CAACL,UAAP,CAAkBM,OAAlB,CAA0BmD,uBAA1B,KAAsD,CAA1D,EAA6D;AAC7DpD,IAAAA,MAAM,CAACL,UAAP,CAAkBM,OAAlB,CAA0BmD,uBAA1B;AACD,GA1CwB;;AA4CzBgB,EAAAA,OAAO,GAAG;AACR,QAAI,CAAC,KAAKH,YAAN,IAAsB3E,KAAK,CAAC+E,QAAhC,EAA0C;AAE1CC,IAAAA,QAAQ,CAACC,QAAT,CAAkBC,UAAU,CAACC,wBAA7B;AAEAjH,IAAAA,QAAQ,CAACoG,UAAT,CAAoBc,KAApB;AACAlH,IAAAA,QAAQ,CAACC,aAAT,CAAuBkH,GAAvB,CAA2B,KAAKnB,mBAAhC;;AAEA,SAAK,MAAMoB,KAAX,IAAoBC,OAAO,CAACC,MAAR,CAAehF,GAAnC,EAAwC;AACtC,UAAI8E,KAAK,CAACG,WAAV,EAAuB;AACrBH,QAAAA,KAAK,CAACI,IAAN;AACD;AACF;;AAEDV,IAAAA,QAAQ,CAACC,QAAT,CAAkBC,UAAU,CAACS,uBAA7B;AACD;;AA3DwB,CAApB;AA8DPX,QAAQ,CAACY,KAAT,CAAeC,EAAf,CAAkBX,UAAU,CAACY,SAA7B,EAAwC,MAAMvF,qBAAqB,CAACE,YAAtB,GAAqCvC,QAAQ,CAACC,aAAT,CAAuBY,KAA1G;AAEAiG,QAAQ,CAACY,KAAT,CAAeC,EAAf,CAAkBX,UAAU,CAACS,uBAA7B,EAAsD,MAAM;AAC1D,QAAMI,aAAa,GAAGxF,qBAAqB,CAAC6C,oBAAtB,CAA2C4C,MAAjE;AACA,MAAID,aAAa,KAAK,CAAtB,EAAyB;AACzB,MAAIA,aAAa,KAAK,CAAtB,EAAyBE,MAAM,CAACC,MAAP,CAAcC,SAAd,CAAyB,sCAAzB,EAAzB,KACKF,MAAM,CAACC,MAAP,CAAcC,SAAd,CAAyB,eAAcC,SAAS,CAACL,aAAD,CAAgB,0BAAhE;AACLxF,EAAAA,qBAAqB,CAACE,YAAtB,GAAqCvC,QAAQ,CAACC,aAAT,CAAuBY,KAA5D;AACD,CAND","sourcesContent":["import { GameMechanicState } from \"../../game-mechanics\";\r\n\r\nimport { deepmergeAll } from \"@/utility/deepmerge\";\r\n\r\nclass SingularityMilestoneState extends GameMechanicState {\r\n  constructor(config) {\r\n    const effect = config.effect;\r\n    const configCopy = deepmergeAll([{}, config]);\r\n    configCopy.effect = () => effect(this.completions);\r\n    super(configCopy);\r\n    this._rawEffect = effect;\r\n  }\r\n\r\n  get start() {\r\n    return this.config.start;\r\n  }\r\n\r\n  get repeat() {\r\n    return this.config.repeat;\r\n  }\r\n\r\n  get limit() {\r\n    return this.config.limit;\r\n  }\r\n\r\n  get isUnique() {\r\n    return this.repeat === 0;\r\n  }\r\n\r\n  get isUnlocked() {\r\n    return Currency.singularities.gte(this.start);\r\n  }\r\n\r\n  get increaseThreshold() {\r\n    return this.config.increaseThreshold;\r\n  }\r\n\r\n  nerfCompletions(completions) {\r\n    const softcap = this.increaseThreshold;\r\n    if (!softcap || (completions < softcap)) return completions;\r\n    return softcap + (completions - softcap) / 3;\r\n  }\r\n\r\n  unnerfCompletions(completions) {\r\n    const softcap = this.increaseThreshold;\r\n    if (!softcap || (completions < softcap)) return completions;\r\n    return softcap + (completions - softcap) * 3;\r\n  }\r\n\r\n  get previousGoal() {\r\n    if (this.isUnique) return 1;\r\n    if (!this.isUnlocked) return 0;\r\n    return this.start * Math.pow(this.repeat, this.unnerfCompletions(this.completions) - 1);\r\n  }\r\n\r\n  get nextGoal() {\r\n    if (this.isUnique) return this.start;\r\n    return this.start * Math.pow(this.repeat, this.unnerfCompletions(this.completions + 1) - 1);\r\n  }\r\n\r\n  get rawCompletions() {\r\n    if (this.isUnique) return this.isUnlocked ? 1 : 0;\r\n    if (!this.isUnlocked) return 0;\r\n    return 1 + (Math.log(Currency.singularities.value) - Math.log(this.start)) / Math.log(this.repeat);\r\n  }\r\n\r\n  get completions() {\r\n    return Math.min(Math.floor(this.nerfCompletions(this.rawCompletions)), this.limit);\r\n  }\r\n\r\n  get remainingSingularities() {\r\n    return this.nextGoal - Currency.singularities.value;\r\n  }\r\n\r\n  get progressToNext() {\r\n    const prog = (Currency.singularities.value - this.previousGoal) / this.nextGoal;\r\n    return formatPercents(Math.clampMax(prog, 1));\r\n  }\r\n\r\n  get isMaxed() {\r\n    return (this.isUnique && this.isUnlocked) || (this.completions >= this.limit);\r\n  }\r\n\r\n  get effectDisplay() {\r\n    if (Number.isFinite(this.effectValue)) return this.config.effectFormat(this.effectValue);\r\n    return \"N/A\";\r\n  }\r\n\r\n  get nextEffectDisplay() {\r\n    return this.config.effectFormat(this._rawEffect(this.completions + 1));\r\n  }\r\n\r\n  get description() {\r\n    return this.config.description;\r\n  }\r\n\r\n  get canBeApplied() {\r\n    return this.isUnlocked && !Pelle.isDisabled(\"singularity\");\r\n  }\r\n}\r\n\r\nexport const SingularityMilestone = mapGameDataToObject(\r\n  GameDatabase.celestials.singularityMilestones,\r\n  config => new SingularityMilestoneState(config)\r\n);\r\n\r\nexport const SingularityMilestones = {\r\n  all: SingularityMilestone.all,\r\n  lastNotified: player.celestials.laitela.lastCheckedMilestones,\r\n\r\n  get sorted() {\r\n    return this.all.sort((a, b) => a.remainingSingularities - b.remainingSingularities);\r\n  },\r\n\r\n  sortedForCompletions(moveNewToTop) {\r\n    const options = player.celestials.laitela.singularitySorting;\r\n\r\n    // Sorting functions for singularity milestones, values are generally around 0 to 2ish. Should generally attempt\r\n    // to return unique values for all milestones for the sake of stable sorting\r\n    let sortFn;\r\n    switch (options.sortResource) {\r\n      case SINGULARITY_MILESTONE_SORT.SINGULARITIES_TO_NEXT:\r\n        sortFn = m => {\r\n          // If it's maxed, we order based on the final goal value - higher goals are sorted later\r\n          if (m.isMaxed) return 1 + Math.log10(m.isUnique ? m.nextGoal : m.previousGoal) / 1000;\r\n          return Math.log10(m.remainingSingularities) / 100;\r\n        };\r\n        break;\r\n      case SINGULARITY_MILESTONE_SORT.CURRENT_COMPLETIONS:\r\n        // Also counts partial completion on the current step\r\n        sortFn = m => {\r\n          // For never-completed repeatable milestones, this is zero and will cause NaN bugs if we don't set it to 1\r\n          const prev = Math.clampMin(m.previousGoal, 1);\r\n          const part = Math.clamp(Math.log(Currency.singularities.value / prev) / Math.log(m.nextGoal / prev), 0, 1);\r\n          return (m.completions + part) / 20;\r\n        };\r\n        break;\r\n      case SINGULARITY_MILESTONE_SORT.PERCENT_COMPLETIONS:\r\n        // Orders infinite milestones based on completion count, putting them after all limited ones even if\r\n        // they're completed\r\n        sortFn = m => {\r\n          const limit = Number.isFinite(m.limit) ? m.limit : 100;\r\n          const currComp = Math.log(Currency.singularities.value / m.previousGoal) /\r\n            Math.log(m.nextGoal / m.previousGoal);\r\n          return Math.clampMax((m.completions + currComp) / limit, 1) + (Number.isFinite(m.limit) ? 0 : 1);\r\n        };\r\n        break;\r\n      case SINGULARITY_MILESTONE_SORT.FINAL_COMPLETION:\r\n        // Sorts infinite milestones as if they end at 50 steps; for any given number of completions, this\r\n        // treats infinite milestones with larger steps as if they complete at a higher value\r\n        sortFn = m => {\r\n          const limit = Number.isFinite(m.limit) ? m.limit : 50;\r\n          return Math.log10(m.config.start * Math.pow(m.config.repeat, limit - 1)) / 100;\r\n        };\r\n        break;\r\n      case SINGULARITY_MILESTONE_SORT.MOST_RECENT:\r\n        sortFn = m => {\r\n          if (!m.isUnlocked) return 1 + Math.log10(m.start) / 1000;\r\n          // For unique milestones, previousGoal is actually 1 and nextGoal contains the completion amount\r\n          return Math.log10(m.isUnique ? m.nextGoal : m.previousGoal) / 100;\r\n        };\r\n        break;\r\n      default:\r\n        throw new Error(\"Unrecognized Singularity Milestone sorting option (order)\");\r\n    }\r\n\r\n    // Shift the fully completed milestones to the front or back with a constant offset which should be larger\r\n    // than the value that the sort function should ever evaluate to\r\n    let completedVal;\r\n    switch (options.showCompleted) {\r\n      case COMPLETED_MILESTONES.FIRST:\r\n        completedVal = 10;\r\n        break;\r\n      case COMPLETED_MILESTONES.LAST:\r\n        completedVal = -10;\r\n        break;\r\n      case COMPLETED_MILESTONES.IGNORED:\r\n        completedVal = 0;\r\n        break;\r\n      default:\r\n        throw new Error(\"Unrecognized Singularity Milestone sorting option (completed milestones)\");\r\n    }\r\n\r\n    // Compose the functions together; possibly reverse the final order and bring new milestones to the top\r\n    const isNew = m => ((m.previousGoal > player.celestials.laitela.lastCheckedMilestones && moveNewToTop) ? 20 : 0);\r\n    const compFn = m => (m.isMaxed ? completedVal : 0) + (options.sortOrder ? sortFn(m) : -sortFn(m)) + isNew(m);\r\n    return this.sorted.sort((a, b) => compFn(b) - compFn(a));\r\n  },\r\n\r\n  get nextMilestoneGroup() {\r\n    return this.sortedForCompletions(false).filter(m => !m.isMaxed).slice(0, 6);\r\n  },\r\n\r\n  get unseenMilestones() {\r\n    const laitela = player.celestials.laitela;\r\n    return SingularityMilestoneThresholds\r\n      .filter(s => s > laitela.lastCheckedMilestones && Currency.singularities.gte(s));\r\n  },\r\n\r\n  get unnotifiedMilestones() {\r\n    return SingularityMilestoneThresholds.filter(s => s > this.lastNotified && Currency.singularities.gte(s));\r\n  }\r\n};\r\n\r\n// Sorted list of all the values where a singularity milestone exists, used for \"new milestone\" styling\r\nconst SingularityMilestoneThresholds = (function() {\r\n  return SingularityMilestones.all\r\n    .map(m => Array.range(0, Math.min(50, m.limit))\r\n      .filter(r => !m.increaseThreshold || r <= m.increaseThreshold ||\r\n        (r > m.increaseThreshold && ((r - m.increaseThreshold) % 3) === 2))\r\n      .map(r => m.start * Math.pow(m.repeat, r)))\r\n    .flat(Infinity)\r\n    .filter(n => n < 1e100)\r\n    .sort((a, b) => a - b);\r\n}());\r\n\r\nexport const Singularity = {\r\n  get cap() {\r\n    return 200 * Math.pow(10, player.celestials.laitela.singularityCapIncreases);\r\n  },\r\n\r\n  get gainPerCapIncrease() {\r\n    return SingularityMilestone.improvedSingularityCap.effectOrDefault(11);\r\n  },\r\n\r\n  get singularitiesGained() {\r\n    return Math.floor(Math.pow(this.gainPerCapIncrease, player.celestials.laitela.singularityCapIncreases) *\r\n      SingularityMilestone.singularityMult.effectOrDefault(1) *\r\n      (1 + ImaginaryUpgrade(10).effectOrDefault(0)));\r\n  },\r\n\r\n  // Time (in seconds) to go from 0 DE to the condensing requirement\r\n  get timePerCondense() {\r\n    return this.cap / Currency.darkEnergy.productionPerSecond;\r\n  },\r\n\r\n  // Time (in seconds) to reach the condensing requirement from *current* DE\r\n  get timeUntilCap() {\r\n    return (this.cap - Currency.darkEnergy.value) / Currency.darkEnergy.productionPerSecond;\r\n  },\r\n\r\n  // Total additional time auto-condense will wait after reaching the condensing requirement\r\n  get timeDelayFromAuto() {\r\n    return this.timePerCondense * (SingularityMilestone.autoCondense.effectOrDefault(Infinity) - 1);\r\n  },\r\n\r\n  get capIsReached() {\r\n    return Currency.darkEnergy.gte(this.cap);\r\n  },\r\n\r\n  increaseCap() {\r\n    if (player.celestials.laitela.singularityCapIncreases >= 50) return;\r\n    player.celestials.laitela.singularityCapIncreases++;\r\n  },\r\n\r\n  decreaseCap() {\r\n    if (player.celestials.laitela.singularityCapIncreases === 0) return;\r\n    player.celestials.laitela.singularityCapIncreases--;\r\n  },\r\n\r\n  perform() {\r\n    if (!this.capIsReached || Pelle.isDoomed) return;\r\n\r\n    EventHub.dispatch(GAME_EVENT.SINGULARITY_RESET_BEFORE);\r\n\r\n    Currency.darkEnergy.reset();\r\n    Currency.singularities.add(this.singularitiesGained);\r\n\r\n    for (const quote of Laitela.quotes.all) {\r\n      if (quote.requirement) {\r\n        quote.show();\r\n      }\r\n    }\r\n\r\n    EventHub.dispatch(GAME_EVENT.SINGULARITY_RESET_AFTER);\r\n  }\r\n};\r\n\r\nEventHub.logic.on(GAME_EVENT.GAME_LOAD, () => SingularityMilestones.lastNotified = Currency.singularities.value);\r\n\r\nEventHub.logic.on(GAME_EVENT.SINGULARITY_RESET_AFTER, () => {\r\n  const newMilestones = SingularityMilestones.unnotifiedMilestones.length;\r\n  if (newMilestones === 0) return;\r\n  if (newMilestones === 1) GameUI.notify.blackHole(`You reached a Singularity milestone!`);\r\n  else GameUI.notify.blackHole(`You reached ${formatInt(newMilestones)} Singularity milestones!`);\r\n  SingularityMilestones.lastNotified = Currency.singularities.value;\r\n});\r\n"]},"metadata":{},"sourceType":"module"}