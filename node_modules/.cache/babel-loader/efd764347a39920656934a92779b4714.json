{"ast":null,"code":"import \"core-js/modules/es.json.stringify.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.typed-array.from.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.typed-array.uint8-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.array.reduce-right.js\";\n\n/* eslint-disable import/extensions */\nimport pako from \"pako/dist/pako.esm.mjs\";\n/* eslint-enable import/extensions */\n\nexport const GameSaveSerializer = {\n  serialize(save) {\n    const json = JSON.stringify(save, this.jsonConverter);\n    return this.encodeText(json, \"savefile\");\n  },\n\n  // eslint-disable-next-line no-unused-vars\n  jsonConverter(key, value) {\n    if (value === Infinity) {\n      return \"Infinity\";\n    }\n\n    if (value instanceof Set) {\n      return Array.from(value.keys());\n    }\n\n    return value;\n  },\n\n  deserialize(data) {\n    if (typeof data !== \"string\") return undefined;\n\n    try {\n      const json = this.decodeText(data, \"savefile\"); // eslint-disable-next-line no-unused-vars\n\n      return JSON.parse(json, (k, v) => v === Infinity ? \"Infinity\" : v);\n    } catch (e) {\n      return undefined;\n    }\n  },\n\n  // Define these now so we don't keep creating new ones, which vaguely seems bad.\n  encoder: new TextEncoder(),\n  decoder: new TextDecoder(),\n  // These are magic strings that savefiles/automator scripts should start with.\n  // Due to the way atob/btoa work, old saves (before the reality update and for\n  // a significant part of its development) always started with eYJ even though\n  // it wasn't explicitly added. If you want to make a mod of AD, you may want to\n  // rename \"savefile\" to \"modless savefile\" or something and create a new\n  // \"savefile\" or \"mod savefile\" property with a string like\n  // \"AntimatterDimensions[mod name]SavefileFormatAAA\", so that people don't\n  // confuse your saves with AD saves but can still import AD saves (this will\n  // also require changing some other code slightly, particularly decode).\n  startingString: {\n    savefile: \"AntimatterDimensionsSavefileFormat\",\n    \"automator script\": \"AntimatterDimensionsAutomatorScriptFormat\",\n    \"automator data\": \"AntimatterDimensionsAutomatorDataFormat\",\n    \"glyph filter\": \"AntimatterDimensionsGlyphFilterFormat\"\n  },\n  // The ending strings aren't as verbose so that we can save a little space.\n  endingString: {\n    savefile: \"EndOfSavefile\",\n    \"automator script\": \"EndOfAutomatorScript\",\n    \"automator data\": \"EndOfAutomatorData\",\n    \"glyph filter\": \"EndOfGlyphFilter\"\n  },\n  // This should always be three characters long, and should ideally go AAA, AAB, AAC, etc.\n  // so that we can do inequality tests on it to compare versions (though skipping a version\n  // shouldn't be a problem).\n  version: \"AAB\",\n  // Steps are given in encoding order.\n  // Export and cloud save use the same steps because the maximum ~15% saving\n  // from having them be different seems not to be worth it.\n  // It's important that `this` is what it should be in these function calls\n  // (encoder/decoded for the first element, window for the fourth)\n  // which is why we shouldn't do e.g. { encode: encoder.encode, decode: encoder.decode }\n  // In the fifth element, order of operations is important: we don't want to encode 0s we added in encoding\n  // (i.e. + -> 0b -> 0ab is undesired) or to accidentally decode 0ac -> 0c -> / (slash)\n  // when encoding says (as it should) 0c -> 0ac.\n  // These functions contain the code that does different things in different versions.\n  // Right now we only have code for steps to only apply in certain versions; add a condition to the step.\n  // It wouldn't be too hard to allow steps to depend on version though.\n  steps: [// This step transforms saves into unsigned 8-bit arrays, as pako requires.\n  {\n    encode: x => GameSaveSerializer.encoder.encode(x),\n    decode: x => GameSaveSerializer.decoder.decode(x)\n  }, // This step is  where the compression actually happens. The pako library works with unsigned 8-bit arrays.\n  {\n    encode: x => pako.deflate(x),\n    decode: x => pako.inflate(x)\n  }, // This step converts from unsigned 8-bit arrays to strings with codepoints less than 256.\n  // We need to do this outselves because GameSaveSerializer.decoder would give us unicode sometimes.\n  {\n    encode: x => Array.from(x).map(i => String.fromCharCode(i)).join(\"\"),\n    decode: x => Uint8Array.from(Array.from(x).map(i => i.charCodeAt(0)))\n  }, // This step makes the characters in saves printable. At this point in the process, all characters\n  // will already have codepoints less than 256 (from the previous step), so emoji in the original save\n  // won't break this.\n  {\n    encode: x => btoa(x),\n    decode: x => atob(x)\n  }, // This step removes + and /, because if they occur, you can double-click on a save and get\n  // everything up to the first + or /, which can be hard to debug. We also remove = (always trailing)\n  // because btoa just ignores it. These regex have no potentially-unicode characters, I think,\n  // and they're applied to strings with just ASCII anyway, but I'm adding u to make Codeacy happy.\n  {\n    encode: x => x.replace(/=+$/g, \"\").replace(/0/g, \"0a\").replace(/\\+/g, \"0b\").replace(/\\//g, \"0c\"),\n    decode: x => x.replace(/0b/g, \"+\").replace(/0c/g, \"/\").replace(/0a/g, \"0\")\n  }, {\n    encode: (x, type) => x + GameSaveSerializer.endingString[type],\n    decode: (x, type) => x.slice(0, x.length - GameSaveSerializer.endingString[type].length),\n    condition: version => version >= \"AAB\"\n  }],\n\n  getSteps(type, version) {\n    // This is a version marker, as well as indicating to players that this is from AD\n    // and whether it's a save or automator script. We can change the last 3 letters\n    // of the string savefiles start with from AAA to something else,\n    // if we want a new version of savefile encoding.\n    return this.steps.filter(i => !i.condition || i.condition(version)).concat({\n      encode: x => `${GameSaveSerializer.startingString[type] + GameSaveSerializer.version}${x}`,\n      decode: x => x.slice(GameSaveSerializer.startingString[type].length + 3)\n    });\n  },\n\n  // Apply each step's encode function in encoding order.\n  encodeText(text, type) {\n    return this.getSteps(type, this.version).reduce((x, step) => step.encode(x, type), text);\n  },\n\n  // Apply each step's decode function, in decoding order (which is the reverse\n  // of encoding order). We only do this if we recognize the string which tells\n  // us the save version. If we don't see it, we assume the save's old and just\n  // use atob. If you're adding a new savefile version, make sure its length is\n  // three characters and alter the encoding/decoding functions as is described\n  // in the comment above the definition of steps. If you're making a mod, then\n  // add another case to this conditional. Old saves (before the reality update\n  // and for a significant part of its development) always started with eYJ and\n  // old automator scripts (where this function is also used) are very unlikely\n  // to start with our magic string because it is longer than a few characters.\n  decodeText(text, type) {\n    if (text.startsWith(this.startingString[type])) {\n      const len = this.startingString[type].length;\n      const version = text.slice(len, len + 3);\n      return this.getSteps(type, version).reduceRight((x, step) => step.decode(x, type), text);\n    }\n\n    return atob(text);\n  }\n\n};","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/storage/serializer.js"],"names":["pako","GameSaveSerializer","serialize","save","json","JSON","stringify","jsonConverter","encodeText","key","value","Infinity","Set","Array","from","keys","deserialize","data","undefined","decodeText","parse","k","v","e","encoder","TextEncoder","decoder","TextDecoder","startingString","savefile","endingString","version","steps","encode","x","decode","deflate","inflate","map","i","String","fromCharCode","join","Uint8Array","charCodeAt","btoa","atob","replace","type","slice","length","condition","getSteps","filter","concat","text","reduce","step","startsWith","len","reduceRight"],"mappings":"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","sourcesContent":["/* eslint-disable import/extensions */\r\nimport pako from \"pako/dist/pako.esm.mjs\";\r\n/* eslint-enable import/extensions */\r\n\r\nexport const GameSaveSerializer = {\r\n  serialize(save) {\r\n    const json = JSON.stringify(save, this.jsonConverter);\r\n    return this.encodeText(json, \"savefile\");\r\n  },\r\n  // eslint-disable-next-line no-unused-vars\r\n  jsonConverter(key, value) {\r\n    if (value === Infinity) {\r\n      return \"Infinity\";\r\n    }\r\n    if (value instanceof Set) {\r\n      return Array.from(value.keys());\r\n    }\r\n    return value;\r\n  },\r\n  deserialize(data) {\r\n    if (typeof data !== \"string\") return undefined;\r\n    try {\r\n      const json = this.decodeText(data, \"savefile\");\r\n      // eslint-disable-next-line no-unused-vars\r\n      return JSON.parse(json, (k, v) => ((v === Infinity) ? \"Infinity\" : v));\r\n    } catch (e) {\r\n      return undefined;\r\n    }\r\n  },\r\n  // Define these now so we don't keep creating new ones, which vaguely seems bad.\r\n  encoder: new TextEncoder(),\r\n  decoder: new TextDecoder(),\r\n  // These are magic strings that savefiles/automator scripts should start with.\r\n  // Due to the way atob/btoa work, old saves (before the reality update and for\r\n  // a significant part of its development) always started with eYJ even though\r\n  // it wasn't explicitly added. If you want to make a mod of AD, you may want to\r\n  // rename \"savefile\" to \"modless savefile\" or something and create a new\r\n  // \"savefile\" or \"mod savefile\" property with a string like\r\n  // \"AntimatterDimensions[mod name]SavefileFormatAAA\", so that people don't\r\n  // confuse your saves with AD saves but can still import AD saves (this will\r\n  // also require changing some other code slightly, particularly decode).\r\n  startingString: {\r\n    savefile: \"AntimatterDimensionsSavefileFormat\",\r\n    \"automator script\": \"AntimatterDimensionsAutomatorScriptFormat\",\r\n    \"automator data\": \"AntimatterDimensionsAutomatorDataFormat\",\r\n    \"glyph filter\": \"AntimatterDimensionsGlyphFilterFormat\",\r\n  },\r\n  // The ending strings aren't as verbose so that we can save a little space.\r\n  endingString: {\r\n    savefile: \"EndOfSavefile\",\r\n    \"automator script\": \"EndOfAutomatorScript\",\r\n    \"automator data\": \"EndOfAutomatorData\",\r\n    \"glyph filter\": \"EndOfGlyphFilter\",\r\n  },\r\n  // This should always be three characters long, and should ideally go AAA, AAB, AAC, etc.\r\n  // so that we can do inequality tests on it to compare versions (though skipping a version\r\n  // shouldn't be a problem).\r\n  version: \"AAB\",\r\n  // Steps are given in encoding order.\r\n  // Export and cloud save use the same steps because the maximum ~15% saving\r\n  // from having them be different seems not to be worth it.\r\n  // It's important that `this` is what it should be in these function calls\r\n  // (encoder/decoded for the first element, window for the fourth)\r\n  // which is why we shouldn't do e.g. { encode: encoder.encode, decode: encoder.decode }\r\n  // In the fifth element, order of operations is important: we don't want to encode 0s we added in encoding\r\n  // (i.e. + -> 0b -> 0ab is undesired) or to accidentally decode 0ac -> 0c -> / (slash)\r\n  // when encoding says (as it should) 0c -> 0ac.\r\n  // These functions contain the code that does different things in different versions.\r\n  // Right now we only have code for steps to only apply in certain versions; add a condition to the step.\r\n  // It wouldn't be too hard to allow steps to depend on version though.\r\n  steps: [\r\n    // This step transforms saves into unsigned 8-bit arrays, as pako requires.\r\n    { encode: x => GameSaveSerializer.encoder.encode(x), decode: x => GameSaveSerializer.decoder.decode(x) },\r\n    // This step is  where the compression actually happens. The pako library works with unsigned 8-bit arrays.\r\n    { encode: x => pako.deflate(x), decode: x => pako.inflate(x) },\r\n    // This step converts from unsigned 8-bit arrays to strings with codepoints less than 256.\r\n    // We need to do this outselves because GameSaveSerializer.decoder would give us unicode sometimes.\r\n    {\r\n      encode: x => Array.from(x).map(i => String.fromCharCode(i)).join(\"\"),\r\n      decode: x => Uint8Array.from(Array.from(x).map(i => i.charCodeAt(0)))\r\n    },\r\n    // This step makes the characters in saves printable. At this point in the process, all characters\r\n    // will already have codepoints less than 256 (from the previous step), so emoji in the original save\r\n    // won't break this.\r\n    { encode: x => btoa(x), decode: x => atob(x) },\r\n    // This step removes + and /, because if they occur, you can double-click on a save and get\r\n    // everything up to the first + or /, which can be hard to debug. We also remove = (always trailing)\r\n    // because btoa just ignores it. These regex have no potentially-unicode characters, I think,\r\n    // and they're applied to strings with just ASCII anyway, but I'm adding u to make Codeacy happy.\r\n    {\r\n      encode: x => x.replace(/=+$/gu, \"\").replace(/0/gu, \"0a\").replace(/\\+/gu, \"0b\").replace(/\\//gu, \"0c\"),\r\n      decode: x => x.replace(/0b/gu, \"+\").replace(/0c/gu, \"/\").replace(/0a/gu, \"0\")\r\n    },\r\n    {\r\n      encode: (x, type) => x + GameSaveSerializer.endingString[type],\r\n      decode: (x, type) => x.slice(0, x.length - GameSaveSerializer.endingString[type].length),\r\n      condition: version => version >= \"AAB\"\r\n    }\r\n  ],\r\n  getSteps(type, version) {\r\n    // This is a version marker, as well as indicating to players that this is from AD\r\n    // and whether it's a save or automator script. We can change the last 3 letters\r\n    // of the string savefiles start with from AAA to something else,\r\n    // if we want a new version of savefile encoding.\r\n    return this.steps.filter(i => (!i.condition) || i.condition(version)).concat({\r\n      encode: x => `${GameSaveSerializer.startingString[type] + GameSaveSerializer.version}${x}`,\r\n      decode: x => x.slice(GameSaveSerializer.startingString[type].length + 3)\r\n    });\r\n  },\r\n  // Apply each step's encode function in encoding order.\r\n  encodeText(text, type) {\r\n    return this.getSteps(type, this.version).reduce((x, step) => step.encode(x, type), text);\r\n  },\r\n  // Apply each step's decode function, in decoding order (which is the reverse\r\n  // of encoding order). We only do this if we recognize the string which tells\r\n  // us the save version. If we don't see it, we assume the save's old and just\r\n  // use atob. If you're adding a new savefile version, make sure its length is\r\n  // three characters and alter the encoding/decoding functions as is described\r\n  // in the comment above the definition of steps. If you're making a mod, then\r\n  // add another case to this conditional. Old saves (before the reality update\r\n  // and for a significant part of its development) always started with eYJ and\r\n  // old automator scripts (where this function is also used) are very unlikely\r\n  // to start with our magic string because it is longer than a few characters.\r\n  decodeText(text, type) {\r\n    if (text.startsWith(this.startingString[type])) {\r\n      const len = this.startingString[type].length;\r\n      const version = text.slice(len, len + 3);\r\n      return this.getSteps(type, version).reduceRight((x, step) => step.decode(x, type), text);\r\n    }\r\n    return atob(text);\r\n  }\r\n};\r\n"]},"metadata":{},"sourceType":"module"}