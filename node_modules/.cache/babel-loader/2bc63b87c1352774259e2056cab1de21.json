{"ast":null,"code":"import { AutobuyerState } from \"./autobuyer\";\nexport class IPMultAutobuyerState extends AutobuyerState {\n  get data() {\n    return player.auto.ipMultBuyer;\n  }\n\n  get name() {\n    return `Infinity Point Multiplier`;\n  }\n\n  get isUnlocked() {\n    return EternityMilestone.autobuyerIPMult.isReached && !Pelle.isDoomed;\n  }\n\n  get hasUnlimitedBulk() {\n    return true;\n  }\n\n  tick() {\n    InfinityUpgrade.ipMult.buyMax();\n  }\n\n}\nexport class EPMultAutobuyerState extends AutobuyerState {\n  get data() {\n    return player.auto.epMultBuyer;\n  }\n\n  get name() {\n    return `Eternity Point Multiplier`;\n  }\n\n  get isUnlocked() {\n    return RealityUpgrade(13).isBought && !Pelle.isDoomed;\n  }\n\n  get hasUnlimitedBulk() {\n    return true;\n  }\n\n  tick() {\n    // While the active check is normally automatically handled with the global autobuyer ticking method, we also\n    // call this from the TD autobuyers in order to make sure this is executed before TDs are purchased. Simply\n    // reordering the autobuyer call order is undesirable because much of the codebase relies on autobuyers being\n    // grouped as they are, and many other autobuyers in the 5xEP group must execute *after* dimensions\n    if (!this.isActive) return;\n    applyEU2();\n    EternityUpgrade.epMult.buyMax(true);\n  }\n\n}","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/autobuyers/prestige-currency-multiplier-autobuyer.js"],"names":["AutobuyerState","IPMultAutobuyerState","data","player","auto","ipMultBuyer","name","isUnlocked","EternityMilestone","autobuyerIPMult","isReached","Pelle","isDoomed","hasUnlimitedBulk","tick","InfinityUpgrade","ipMult","buyMax","EPMultAutobuyerState","epMultBuyer","RealityUpgrade","isBought","isActive","applyEU2","EternityUpgrade","epMult"],"mappings":"AAAA,SAASA,cAAT,QAA+B,aAA/B;AAEA,OAAO,MAAMC,oBAAN,SAAmCD,cAAnC,CAAkD;AAC/C,MAAJE,IAAI,GAAG;AACT,WAAOC,MAAM,CAACC,IAAP,CAAYC,WAAnB;AACD;;AAEO,MAAJC,IAAI,GAAG;AACT,WAAQ,2BAAR;AACD;;AAEa,MAAVC,UAAU,GAAG;AACf,WAAOC,iBAAiB,CAACC,eAAlB,CAAkCC,SAAlC,IAA+C,CAACC,KAAK,CAACC,QAA7D;AACD;;AAEmB,MAAhBC,gBAAgB,GAAG;AACrB,WAAO,IAAP;AACD;;AAEDC,EAAAA,IAAI,GAAG;AACLC,IAAAA,eAAe,CAACC,MAAhB,CAAuBC,MAAvB;AACD;;AAnBsD;AAsBzD,OAAO,MAAMC,oBAAN,SAAmClB,cAAnC,CAAkD;AAC/C,MAAJE,IAAI,GAAG;AACT,WAAOC,MAAM,CAACC,IAAP,CAAYe,WAAnB;AACD;;AAEO,MAAJb,IAAI,GAAG;AACT,WAAQ,2BAAR;AACD;;AAEa,MAAVC,UAAU,GAAG;AACf,WAAOa,cAAc,CAAC,EAAD,CAAd,CAAmBC,QAAnB,IAA+B,CAACV,KAAK,CAACC,QAA7C;AACD;;AAEmB,MAAhBC,gBAAgB,GAAG;AACrB,WAAO,IAAP;AACD;;AAEDC,EAAAA,IAAI,GAAG;AACL;AACA;AACA;AACA;AACA,QAAI,CAAC,KAAKQ,QAAV,EAAoB;AACpBC,IAAAA,QAAQ;AACRC,IAAAA,eAAe,CAACC,MAAhB,CAAuBR,MAAvB,CAA8B,IAA9B;AACD;;AAzBsD","sourcesContent":["import { AutobuyerState } from \"./autobuyer\";\r\n\r\nexport class IPMultAutobuyerState extends AutobuyerState {\r\n  get data() {\r\n    return player.auto.ipMultBuyer;\r\n  }\r\n\r\n  get name() {\r\n    return `Infinity Point Multiplier`;\r\n  }\r\n\r\n  get isUnlocked() {\r\n    return EternityMilestone.autobuyerIPMult.isReached && !Pelle.isDoomed;\r\n  }\r\n\r\n  get hasUnlimitedBulk() {\r\n    return true;\r\n  }\r\n\r\n  tick() {\r\n    InfinityUpgrade.ipMult.buyMax();\r\n  }\r\n}\r\n\r\nexport class EPMultAutobuyerState extends AutobuyerState {\r\n  get data() {\r\n    return player.auto.epMultBuyer;\r\n  }\r\n\r\n  get name() {\r\n    return `Eternity Point Multiplier`;\r\n  }\r\n\r\n  get isUnlocked() {\r\n    return RealityUpgrade(13).isBought && !Pelle.isDoomed;\r\n  }\r\n\r\n  get hasUnlimitedBulk() {\r\n    return true;\r\n  }\r\n\r\n  tick() {\r\n    // While the active check is normally automatically handled with the global autobuyer ticking method, we also\r\n    // call this from the TD autobuyers in order to make sure this is executed before TDs are purchased. Simply\r\n    // reordering the autobuyer call order is undesirable because much of the codebase relies on autobuyers being\r\n    // grouped as they are, and many other autobuyers in the 5xEP group must execute *after* dimensions\r\n    if (!this.isActive) return;\r\n    applyEU2();\r\n    EternityUpgrade.epMult.buyMax(true);\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}