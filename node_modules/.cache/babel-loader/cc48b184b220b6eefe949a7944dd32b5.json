{"ast":null,"code":"import \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.constructor.js\";\nimport \"core-js/modules/es.regexp.dot-all.js\";\nimport \"core-js/modules/es.array.flat-map.js\";\nimport \"core-js/modules/es.array.unscopables.flat-map.js\";\n// Note: chevrotain doesn't play well with unicode regex\n\n/* eslint-disable require-unicode-regexp */\n\n/* eslint-disable camelcase */\nimport { createToken, Lexer } from \"chevrotain\";\nimport { DC } from \"../constants\";\n\nconst createCategory = name => createToken({\n  name,\n  pattern: Lexer.NA,\n  longer_alt: Identifier\n}); // Shorthand for creating tokens and adding them to a list\n\n\nconst tokenLists = {}; // eslint-disable-next-line max-params\n\nconst createInCategory = (category, name, pattern, props = {}) => {\n  const categories = [category];\n  if (props.extraCategories) categories.push(...props.extraCategories);\n  const token = createToken({\n    name,\n    pattern,\n    categories,\n    longer_alt: Identifier\n  });\n  const categoryName = Array.isArray(category) ? category[0].name : category.name;\n  if (tokenLists[categoryName] === undefined) tokenLists[categoryName] = [];\n  tokenLists[categoryName].push(token);\n  const patternWord = pattern.toString().match(/^\\/([0-9A-Za-z\\u017F\\u212A]*)\\/[A-Za-z\\u017F\\u212A]*$/i);\n  if (patternWord && patternWord[1]) token.$autocomplete = patternWord[1];\n  Object.assign(token, props);\n  return token;\n};\n\nconst HSpace = createToken({\n  name: \"HSpace\",\n  pattern: /[ \\t]+/,\n  group: Lexer.SKIPPED\n});\nconst EOL = createToken({\n  name: \"EOL\",\n  line_breaks: true,\n  pattern: /[ \\t\\r]*\\n\\s*/,\n  label: \"End of line\"\n});\nconst StringLiteral = createToken({\n  name: \"StringLiteral\",\n  pattern: /\".*\"/\n});\nconst StringLiteralSingleQuote = createToken({\n  name: \"StringLiteralSingleQuote\",\n  pattern: /'.*'/\n});\nconst Comment = createToken({\n  name: \"Comment\",\n  pattern: /(#|\\/\\/)[^\\n]*/\n});\nconst NumberLiteral = createToken({\n  name: \"NumberLiteral\",\n  pattern: /-?(0|[1-9]\\d*)(\\.\\d+)?([eE][+-]?\\d+)?/\n});\nconst BlackHoleStr = createToken({\n  name: \"BlackHoleStr\",\n  pattern: /[Bb][Hh][12]/\n});\nconst Identifier = createToken({\n  name: \"Identifier\",\n  pattern: /[a-zA-Z_][a-zA-Z_0-9]*/\n});\nconst ComparisonOperator = createToken({\n  name: \"ComparisonOperator\",\n  pattern: Lexer.NA\n});\nconst AutomatorCurrency = createCategory(\"AutomatorCurrency\");\nconst PrestigeEvent = createCategory(\"PrestigeEvent\");\nconst StudyPath = createCategory(\"StudyPath\");\nconst TimeUnit = createCategory(\"TimeUnit\");\ncreateInCategory(ComparisonOperator, \"OpGTE\", />=/, {\n  $autocomplete: \">=\",\n  $compare: (a, b) => Decimal.gte(a, b)\n});\ncreateInCategory(ComparisonOperator, \"OpLTE\", /<=/, {\n  $autocomplete: \"<=\",\n  $compare: (a, b) => Decimal.lte(a, b)\n});\ncreateInCategory(ComparisonOperator, \"OpGT\", />/, {\n  $autocomplete: \">\",\n  $compare: (a, b) => Decimal.gt(a, b)\n});\ncreateInCategory(ComparisonOperator, \"OpLT\", /</, {\n  $autocomplete: \"<\",\n  $compare: (a, b) => Decimal.lt(a, b)\n});\nconst OpEQ = createInCategory(ComparisonOperator, \"OpEQ\", /==/, {\n  $compare: (a, b) => Decimal.eq(a, b)\n}); // EqualSign is a single = which is defined for both comparisons and define\n\nconst EqualSign = createToken({\n  name: \"EqualSign\",\n  pattern: /=/,\n  categories: ComparisonOperator,\n  label: \"=\",\n  longer_alt: OpEQ\n});\n\nEqualSign.$compare = (a, b) => Decimal.eq(a, b);\n\ncreateInCategory(AutomatorCurrency, \"EP\", /ep/i, {\n  $getter: () => Currency.eternityPoints.value\n});\ncreateInCategory(AutomatorCurrency, \"IP\", /ip/i, {\n  $getter: () => Currency.infinityPoints.value\n});\ncreateInCategory(AutomatorCurrency, \"AM\", /am/i, {\n  $getter: () => Currency.antimatter.value\n});\ncreateInCategory(AutomatorCurrency, \"DT\", /dt/i, {\n  $getter: () => Currency.dilatedTime.value\n});\ncreateInCategory(AutomatorCurrency, \"TP\", /tp/i, {\n  $getter: () => Currency.tachyonParticles.value\n});\ncreateInCategory(AutomatorCurrency, \"RG\", /rg/i, {\n  $getter: () => new Decimal(Replicanti.galaxies.total)\n});\ncreateInCategory(AutomatorCurrency, \"RM\", /rm/i, {\n  $getter: () => Currency.realityMachines.value\n});\ncreateInCategory(AutomatorCurrency, \"infinities\", /infinities/i, {\n  $getter: () => Currency.infinities.value\n});\ncreateInCategory(AutomatorCurrency, \"bankedInfinities\", /banked[ \\t]+infinities/i, {\n  $autocomplete: \"banked infinities\",\n  $getter: () => Currency.infinitiesBanked.value\n});\ncreateInCategory(AutomatorCurrency, \"eternities\", /eternities/i, {\n  $getter: () => Currency.eternities.value\n});\ncreateInCategory(AutomatorCurrency, \"realities\", /realities/i, {\n  $getter: () => Currency.realities.value\n});\ncreateInCategory(AutomatorCurrency, \"PendingIP\", /pending[ \\t]+ip/i, {\n  $autocomplete: \"pending IP\",\n  $getter: () => Player.canCrunch ? gainedInfinityPoints() : DC.D0\n});\ncreateInCategory(AutomatorCurrency, \"PendingEP\", /pending[ \\t]+ep/i, {\n  $autocomplete: \"pending EP\",\n  $getter: () => Player.canEternity ? gainedEternityPoints() : DC.D0\n});\ncreateInCategory(AutomatorCurrency, \"PendingTP\", /pending[ \\t]+tp/i, {\n  $autocomplete: \"pending TP\",\n  $getter: () => player.dilation.active ? getTachyonGain() : DC.D0\n});\ncreateInCategory(AutomatorCurrency, \"PendingRM\", /pending[ \\t]+rm/i, {\n  $autocomplete: \"pending RM\",\n  $getter: () => isRealityAvailable() ? MachineHandler.gainedRealityMachines : DC.D0\n});\ncreateInCategory(AutomatorCurrency, \"PendingGlyphLevel\", /pending[ \\t]+glyph[ \\t]+level/i, {\n  $autocomplete: \"pending Glyph level\",\n  $getter: () => new Decimal(isRealityAvailable() ? gainedGlyphLevel().actualLevel : 0)\n});\ncreateInCategory(AutomatorCurrency, \"Rep\", /rep(licanti)?/i, {\n  $autocomplete: \"rep\",\n  $getter: () => Replicanti.amount\n});\ncreateInCategory(AutomatorCurrency, \"TT\", /(tt|time theorems?)/i, {\n  $autocomplete: \"TT\",\n  $getter: () => Currency.timeTheorems.value\n});\ncreateInCategory(AutomatorCurrency, \"TotalTT\", /total[ \\t]+tt/i, {\n  $autocomplete: \"total TT\",\n  $getter: () => player.timestudy.theorem.plus(TimeTheorems.calculateTimeStudiesCost())\n});\ncreateInCategory(AutomatorCurrency, \"TotalCompletions\", /total[ \\t]+completions/i, {\n  $autocomplete: \"total completions\",\n  $getter: () => EternityChallenges.completions\n});\ncreateInCategory(AutomatorCurrency, \"PendingCompletions\", /pending[ \\t]+completions/i, {\n  $autocomplete: \"pending completions\",\n  $getter: () => {\n    // If we are not in an EC, pretend like we have a ton of completions so any check for sufficient\n    // completions returns true\n    if (!EternityChallenge.isRunning) return Decimal.NUMBER_MAX_VALUE;\n    return EternityChallenge.current.gainedCompletionStatus.totalCompletions;\n  }\n});\ncreateInCategory(AutomatorCurrency, \"FilterScore\", /filter[ \\t]+score/i, {\n  $autocomplete: \"filter score\",\n  $getter: () => {\n    // If the filter isn't unlocked somehow, return the most negative number in order to ensure it's nonblocking\n    if (!EffarigUnlock.glyphFilter.isUnlocked) return -Number.MAX_VALUE;\n    const choices = GlyphSelection.glyphList(GlyphSelection.choiceCount, gainedGlyphLevel(), {\n      isChoosingGlyph: false\n    });\n    const bestGlyph = AutoGlyphProcessor.pick(choices);\n    return AutoGlyphProcessor.filterValue(bestGlyph);\n  },\n  $unlocked: () => EffarigUnlock.glyphFilter.isUnlocked\n}); // Space theorems can't be abbreviated as \"ST\" in the actual script content because then the lexer becomes unable\n// to match it due to the fact that \"start\" (ec/dilation) also begins with those characters. As a workaround, ST\n// uses the full string \"space theorems\" as does the \"total ST\" variant (for consistency)\n\ncreateInCategory(AutomatorCurrency, \"ST\", /space[ \\t]+theorems/i, {\n  $autocomplete: \"space theorems\",\n  $getter: () => V.availableST,\n  $unlocked: () => V.spaceTheorems > 0\n});\ncreateInCategory(AutomatorCurrency, \"TotalST\", /total[ \\t]+space[ \\t]+theorems/i, {\n  $autocomplete: \"total space theorems\",\n  $getter: () => V.spaceTheorems,\n  $unlocked: () => V.spaceTheorems > 0\n});\n\nfor (let i = 1; i <= 12; ++i) {\n  const id = i;\n  createInCategory(AutomatorCurrency, `EC${i}`, new RegExp(`ec${i} completions`, \"i\"), {\n    $autocomplete: `ec${i} completions`,\n    // eslint-disable-next-line no-loop-func\n    $getter: () => EternityChallenge(id).completions\n  });\n} // $prestigeLevel is used by things that wait for a prestige event. Something waiting for\n// eternity will be triggered by something waiting for reality, for example.\n\n\ncreateInCategory(PrestigeEvent, \"Infinity\", /infinity/i, {\n  extraCategories: [StudyPath],\n  $autobuyer: () => Autobuyer.bigCrunch,\n  $autobuyerDurationMode: AUTO_CRUNCH_MODE.TIME,\n  $autobuyerXHighestMode: AUTO_CRUNCH_MODE.X_HIGHEST,\n  $autobuyerCurrencyMode: AUTO_CRUNCH_MODE.AMOUNT,\n  $prestigeAvailable: () => Player.canCrunch,\n  $prestige: () => bigCrunchResetRequest(true),\n  $prestigeLevel: 1,\n  $prestigeCurrency: \"IP\",\n  $studyPath: TIME_STUDY_PATH.INFINITY_DIM\n});\ncreateInCategory(PrestigeEvent, \"Eternity\", /eternity/i, {\n  $autobuyer: () => Autobuyer.eternity,\n  $autobuyerDurationMode: AUTO_ETERNITY_MODE.TIME,\n  $autobuyerXHighestMode: AUTO_ETERNITY_MODE.X_HIGHEST,\n  $autobuyerCurrencyMode: AUTO_ETERNITY_MODE.AMOUNT,\n  $prestigeAvailable: () => Player.canEternity,\n  $prestigeLevel: 2,\n  $prestigeCurrency: \"EP\",\n  $prestige: () => eternity(false, true),\n  $respec: () => {\n    player.respec = true;\n  }\n});\ncreateInCategory(PrestigeEvent, \"Reality\", /reality/i, {\n  $autobuyer: () => Autobuyer.reality,\n  $autobuyerCurrencyMode: AUTO_REALITY_MODE.RM,\n  $prestigeAvailable: () => isRealityAvailable(),\n  $prestigeLevel: 3,\n  $prestigeCurrency: \"RM\",\n  $prestige: () => autoReality(),\n  $respec: () => {\n    player.reality.respec = true;\n  }\n});\ncreateInCategory(StudyPath, \"Idle\", /idle/i, {\n  $studyPath: TIME_STUDY_PATH.IDLE\n});\ncreateInCategory(StudyPath, \"Passive\", /passive/i, {\n  $studyPath: TIME_STUDY_PATH.PASSIVE\n});\ncreateInCategory(StudyPath, \"Active\", /active/i, {\n  $studyPath: TIME_STUDY_PATH.ACTIVE\n});\ncreateInCategory(StudyPath, \"Antimatter\", /antimatter/i, {\n  $studyPath: TIME_STUDY_PATH.ANTIMATTER_DIM\n});\ncreateInCategory(StudyPath, \"Time\", /time/i, {\n  $studyPath: TIME_STUDY_PATH.TIME_DIM\n});\ncreateInCategory(StudyPath, \"Light\", /light/i, {\n  $studyPath: TIME_STUDY_PATH.LIGHT\n});\ncreateInCategory(StudyPath, \"Dark\", /dark/i, {\n  $studyPath: TIME_STUDY_PATH.DARK\n});\ncreateInCategory(TimeUnit, \"Milliseconds\", /ms/i, {\n  $autocomplete: \"ms\",\n  $scale: 1\n});\ncreateInCategory(TimeUnit, \"Seconds\", /s(ec(onds?)?)?/i, {\n  $autocomplete: \"sec\",\n  $scale: 1000\n});\ncreateInCategory(TimeUnit, \"Minutes\", /m(in(utes?)?)?/i, {\n  $autocomplete: \"min\",\n  $scale: 60 * 1000\n});\ncreateInCategory(TimeUnit, \"Hours\", /h(ours?)?/i, {\n  $autocomplete: \"hours\",\n  $scale: 3600 * 1000\n});\nconst Keyword = createToken({\n  name: \"Keyword\",\n  pattern: Lexer.NA,\n  longer_alt: Identifier\n});\nconst keywordTokens = [];\n\nconst createKeyword = (name, pattern, props = {}) => {\n  const categories = [Keyword];\n  if (props.extraCategories) categories.push(...props.extraCategories);\n  const token = createToken({\n    name,\n    pattern,\n    categories,\n    longer_alt: Identifier\n  });\n  token.$autocomplete = name.toLocaleLowerCase();\n  keywordTokens.push(token);\n  Object.assign(token, props);\n  return token;\n};\n\ncreateKeyword(\"Auto\", /auto/i);\ncreateKeyword(\"Buy\", /buy/i); // Necessary to hide it from Codemirror's tab auto-completion\n\ncreateKeyword(\"Blob\", /blob\\s\\s/i, {\n  $unlocked: () => false\n});\ncreateKeyword(\"If\", /if/i);\ncreateKeyword(\"Load\", /load/i);\ncreateKeyword(\"Notify\", /notify/i);\ncreateKeyword(\"Nowait\", /nowait/i);\ncreateKeyword(\"Off\", /off/i);\ncreateKeyword(\"On\", /on/i);\ncreateKeyword(\"Pause\", /pause/i); // Names are a little special, because they can be named anything (like ec12 or wait)\n// So, we consume the label at the same time as we consume the preset. In order to report\n// errors, we also match just the word name. And, we have to not match comments.\n\ncreateKeyword(\"Name\", /name([ \\t]+(\\/(?!\\/)|[^\\n#/])*)?/i);\ncreateKeyword(\"Id\", /id\\b([ \\t]+\\d)?/i);\ncreateKeyword(\"Purchase\", /purchase/i);\ncreateKeyword(\"Respec\", /respec/i);\ncreateKeyword(\"Restart\", /restart/i);\ncreateKeyword(\"Start\", /start/i);\ncreateKeyword(\"Stop\", /stop/i);\ncreateKeyword(\"Studies\", /studies/i);\ncreateKeyword(\"Unlock\", /unlock/i);\ncreateKeyword(\"Until\", /until/i);\ncreateKeyword(\"Use\", /use/i);\ncreateKeyword(\"Wait\", /wait/i);\ncreateKeyword(\"While\", /while/i);\ncreateKeyword(\"BlackHole\", /black[ \\t]+hole/i, {\n  $autocomplete: \"black hole\",\n  $unlocked: () => BlackHole(1).isUnlocked\n});\ncreateKeyword(\"StoreGameTime\", /stored?[ \\t]+game[ \\t]+time/i, {\n  $autocomplete: \"store game time\",\n  $unlocked: () => Enslaved.isUnlocked\n});\ncreateKeyword(\"Dilation\", /dilation/i);\ncreateKeyword(\"EC\", /ec/i);\ncreateKeyword(\"XHighest\", /x[ \\t]+highest/i, {\n  $autocomplete: \"x highest\"\n}); // We allow ECLiteral to consume lots of digits because that makes error reporting more\n// clear (it's nice to say ec123 is an invalid ec)\n\nconst ECLiteral = createToken({\n  name: \"ECLiteral\",\n  pattern: /ec[1-9][0-9]*/i,\n  longer_alt: Identifier\n});\nconst LCurly = createToken({\n  name: \"LCurly\",\n  pattern: /[ \\t]*{/\n});\nconst RCurly = createToken({\n  name: \"RCurly\",\n  pattern: /[ \\t]*}/\n});\nconst Comma = createToken({\n  name: \"Comma\",\n  pattern: /,/\n});\nconst Pipe = createToken({\n  name: \"Pipe\",\n  pattern: /\\|/,\n  label: \"|\"\n});\nconst Dash = createToken({\n  name: \"Dash\",\n  pattern: /-/,\n  label: \"-\"\n});\nconst Exclamation = createToken({\n  name: \"Exclamation\",\n  pattern: /!/,\n  label: \"!\"\n}); // The order here is the order the lexer looks for tokens in.\n\nexport const automatorTokens = [HSpace, StringLiteral, StringLiteralSingleQuote, Comment, EOL, ComparisonOperator, ...tokenLists.ComparisonOperator, LCurly, RCurly, Comma, EqualSign, Pipe, Dash, Exclamation, BlackHoleStr, NumberLiteral, AutomatorCurrency, ...tokenLists.AutomatorCurrency, ECLiteral, Keyword, ...keywordTokens, PrestigeEvent, ...tokenLists.PrestigeEvent, StudyPath, ...tokenLists.StudyPath, TimeUnit, ...tokenLists.TimeUnit, Identifier]; // Labels only affect error messages and Diagrams.\n\nLCurly.LABEL = \"'{'\";\nRCurly.LABEL = \"'}'\";\nNumberLiteral.LABEL = \"Number\";\nComma.LABEL = \"❟\";\nexport const lexer = new Lexer(automatorTokens, {\n  positionTracking: \"full\",\n  ensureOptimizations: true\n}); // The lexer uses an ID system that's separate from indices into the token array\n\nexport const tokenIds = [];\n\nfor (const token of lexer.lexerDefinition) {\n  tokenIds[token.tokenTypeIdx] = token;\n} // We use this while building up the grammar\n\n\nexport const tokenMap = automatorTokens.mapToObject(e => e.name, e => e);\nconst automatorCurrencyNames = tokenLists.AutomatorCurrency.map(i => i.$autocomplete.toUpperCase());\nexport const standardizeAutomatorValues = function (x) {\n  try {\n    if (automatorCurrencyNames.includes(x.toUpperCase())) return x.toUpperCase();\n  } catch (_unused) {\n    // This only happens if the input is a number or Decimal, in which case we don't attempt to change any formatting\n    // and simply return\n    return x;\n  }\n\n  for (const i of tokenLists.AutomatorCurrency) {\n    // Check for a match of the full string.\n    if (x.match(i.PATTERN) && x.match(i.PATTERN)[0].length === x.length) {\n      return i.$autocomplete.toUpperCase();\n    }\n  } // If we get to this point, we haven't matched a currency name and instead assume it's a defined constant and\n  // return it without any format changes since these are case-sensitive\n\n\n  return x;\n}; // In order to disallow individual words within command key words/phrases, we need to ignore certain patterns (mostly\n// ones with special regex characters), split the rest of them up across all spaces and tabs, and then flatten the\n// final resulting array. Note that this technically duplicates words present in multiple phrases (eg. \"pending\")\n\nconst ignoredPatterns = [\"Identifier\", \"LCurly\", \"RCurly\"];\nexport const forbiddenConstantPatterns = lexer.lexerDefinition.filter(p => !ignoredPatterns.includes(p.name)).map(p => p.PATTERN.source).flatMap(p => p.includes(\"(\") || p.includes(\")\") ? p : p.split(\"[ \\\\t]+\"));","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/automator/lexer.js"],"names":["createToken","Lexer","DC","createCategory","name","pattern","NA","longer_alt","Identifier","tokenLists","createInCategory","category","props","categories","extraCategories","push","token","categoryName","Array","isArray","undefined","patternWord","toString","match","$autocomplete","Object","assign","HSpace","group","SKIPPED","EOL","line_breaks","label","StringLiteral","StringLiteralSingleQuote","Comment","NumberLiteral","BlackHoleStr","ComparisonOperator","AutomatorCurrency","PrestigeEvent","StudyPath","TimeUnit","$compare","a","b","Decimal","gte","lte","gt","lt","OpEQ","eq","EqualSign","$getter","Currency","eternityPoints","value","infinityPoints","antimatter","dilatedTime","tachyonParticles","Replicanti","galaxies","total","realityMachines","infinities","infinitiesBanked","eternities","realities","Player","canCrunch","gainedInfinityPoints","D0","canEternity","gainedEternityPoints","player","dilation","active","getTachyonGain","isRealityAvailable","MachineHandler","gainedRealityMachines","gainedGlyphLevel","actualLevel","amount","timeTheorems","timestudy","theorem","plus","TimeTheorems","calculateTimeStudiesCost","EternityChallenges","completions","EternityChallenge","isRunning","NUMBER_MAX_VALUE","current","gainedCompletionStatus","totalCompletions","EffarigUnlock","glyphFilter","isUnlocked","Number","MAX_VALUE","choices","GlyphSelection","glyphList","choiceCount","isChoosingGlyph","bestGlyph","AutoGlyphProcessor","pick","filterValue","$unlocked","V","availableST","spaceTheorems","i","id","RegExp","$autobuyer","Autobuyer","bigCrunch","$autobuyerDurationMode","AUTO_CRUNCH_MODE","TIME","$autobuyerXHighestMode","X_HIGHEST","$autobuyerCurrencyMode","AMOUNT","$prestigeAvailable","$prestige","bigCrunchResetRequest","$prestigeLevel","$prestigeCurrency","$studyPath","TIME_STUDY_PATH","INFINITY_DIM","eternity","AUTO_ETERNITY_MODE","$respec","respec","reality","AUTO_REALITY_MODE","RM","autoReality","IDLE","PASSIVE","ACTIVE","ANTIMATTER_DIM","TIME_DIM","LIGHT","DARK","$scale","Keyword","keywordTokens","createKeyword","toLocaleLowerCase","BlackHole","Enslaved","ECLiteral","LCurly","RCurly","Comma","Pipe","Dash","Exclamation","automatorTokens","LABEL","lexer","positionTracking","ensureOptimizations","tokenIds","lexerDefinition","tokenTypeIdx","tokenMap","mapToObject","e","automatorCurrencyNames","map","toUpperCase","standardizeAutomatorValues","x","includes","PATTERN","length","ignoredPatterns","forbiddenConstantPatterns","filter","p","source","flatMap","split"],"mappings":"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","sourcesContent":["// Note: chevrotain doesn't play well with unicode regex\r\n/* eslint-disable require-unicode-regexp */\r\n/* eslint-disable camelcase */\r\nimport { createToken, Lexer } from \"chevrotain\";\r\n\r\nimport { DC } from \"../constants\";\r\n\r\nconst createCategory = name => createToken({ name, pattern: Lexer.NA, longer_alt: Identifier });\r\n\r\n// Shorthand for creating tokens and adding them to a list\r\nconst tokenLists = {};\r\n// eslint-disable-next-line max-params\r\nconst createInCategory = (category, name, pattern, props = {}) => {\r\n  const categories = [category];\r\n  if (props.extraCategories) categories.push(...props.extraCategories);\r\n  const token = createToken({\r\n    name,\r\n    pattern,\r\n    categories,\r\n    longer_alt: Identifier,\r\n  });\r\n  const categoryName = Array.isArray(category) ? category[0].name : category.name;\r\n  if (tokenLists[categoryName] === undefined) tokenLists[categoryName] = [];\r\n  tokenLists[categoryName].push(token);\r\n  const patternWord = pattern.toString().match(/^\\/([a-zA-Z0-9]*)\\/[a-zA-Z]*$/ui);\r\n  if (patternWord && patternWord[1]) token.$autocomplete = patternWord[1];\r\n  Object.assign(token, props);\r\n  return token;\r\n};\r\n\r\nconst HSpace = createToken({\r\n  name: \"HSpace\",\r\n  pattern: /[ \\t]+/,\r\n  group: Lexer.SKIPPED\r\n});\r\n\r\nconst EOL = createToken({\r\n  name: \"EOL\",\r\n  line_breaks: true,\r\n  pattern: /[ \\t\\r]*\\n\\s*/,\r\n  label: \"End of line\",\r\n});\r\n\r\nconst StringLiteral = createToken({\r\n  name: \"StringLiteral\",\r\n  pattern: /\".*\"/,\r\n});\r\n\r\nconst StringLiteralSingleQuote = createToken({\r\n  name: \"StringLiteralSingleQuote\",\r\n  pattern: /'.*'/,\r\n});\r\n\r\nconst Comment = createToken({\r\n  name: \"Comment\",\r\n  pattern: /(#|\\/\\/)[^\\n]*/,\r\n});\r\n\r\nconst NumberLiteral = createToken({\r\n  name: \"NumberLiteral\",\r\n  pattern: /-?(0|[1-9]\\d*)(\\.\\d+)?([eE][+-]?\\d+)?/,\r\n});\r\n\r\nconst BlackHoleStr = createToken({\r\n  name: \"BlackHoleStr\",\r\n  pattern: /[Bb][Hh][12]/,\r\n});\r\n\r\nconst Identifier = createToken({\r\n  name: \"Identifier\",\r\n  pattern: /[a-zA-Z_][a-zA-Z_0-9]*/,\r\n});\r\n\r\nconst ComparisonOperator = createToken({\r\n  name: \"ComparisonOperator\",\r\n  pattern: Lexer.NA,\r\n});\r\n\r\nconst AutomatorCurrency = createCategory(\"AutomatorCurrency\");\r\nconst PrestigeEvent = createCategory(\"PrestigeEvent\");\r\nconst StudyPath = createCategory(\"StudyPath\");\r\nconst TimeUnit = createCategory(\"TimeUnit\");\r\n\r\ncreateInCategory(ComparisonOperator, \"OpGTE\", />=/, {\r\n  $autocomplete: \">=\",\r\n  $compare: (a, b) => Decimal.gte(a, b),\r\n});\r\ncreateInCategory(ComparisonOperator, \"OpLTE\", /<=/, {\r\n  $autocomplete: \"<=\",\r\n  $compare: (a, b) => Decimal.lte(a, b),\r\n});\r\ncreateInCategory(ComparisonOperator, \"OpGT\", />/, {\r\n  $autocomplete: \">\",\r\n  $compare: (a, b) => Decimal.gt(a, b),\r\n});\r\ncreateInCategory(ComparisonOperator, \"OpLT\", /</, {\r\n  $autocomplete: \"<\",\r\n  $compare: (a, b) => Decimal.lt(a, b),\r\n});\r\nconst OpEQ = createInCategory(ComparisonOperator, \"OpEQ\", /==/, {\r\n  $compare: (a, b) => Decimal.eq(a, b),\r\n});\r\n// EqualSign is a single = which is defined for both comparisons and define\r\nconst EqualSign = createToken({\r\n  name: \"EqualSign\",\r\n  pattern: /=/,\r\n  categories: ComparisonOperator,\r\n  label: \"=\",\r\n  longer_alt: OpEQ,\r\n});\r\nEqualSign.$compare = (a, b) => Decimal.eq(a, b);\r\n\r\ncreateInCategory(AutomatorCurrency, \"EP\", /ep/i, { $getter: () => Currency.eternityPoints.value });\r\ncreateInCategory(AutomatorCurrency, \"IP\", /ip/i, { $getter: () => Currency.infinityPoints.value });\r\ncreateInCategory(AutomatorCurrency, \"AM\", /am/i, { $getter: () => Currency.antimatter.value });\r\ncreateInCategory(AutomatorCurrency, \"DT\", /dt/i, { $getter: () => Currency.dilatedTime.value });\r\ncreateInCategory(AutomatorCurrency, \"TP\", /tp/i, { $getter: () => Currency.tachyonParticles.value });\r\ncreateInCategory(AutomatorCurrency, \"RG\", /rg/i, { $getter: () => new Decimal(Replicanti.galaxies.total) });\r\ncreateInCategory(AutomatorCurrency, \"RM\", /rm/i, { $getter: () => Currency.realityMachines.value });\r\n\r\ncreateInCategory(AutomatorCurrency, \"infinities\", /infinities/i, { $getter: () => Currency.infinities.value });\r\ncreateInCategory(AutomatorCurrency, \"bankedInfinities\", /banked[ \\t]+infinities/i, {\r\n  $autocomplete: \"banked infinities\",\r\n  $getter: () => Currency.infinitiesBanked.value\r\n});\r\ncreateInCategory(AutomatorCurrency, \"eternities\", /eternities/i, { $getter: () => Currency.eternities.value });\r\ncreateInCategory(AutomatorCurrency, \"realities\", /realities/i, { $getter: () => Currency.realities.value });\r\n\r\ncreateInCategory(AutomatorCurrency, \"PendingIP\", /pending[ \\t]+ip/i, {\r\n  $autocomplete: \"pending IP\",\r\n  $getter: () => (Player.canCrunch ? gainedInfinityPoints() : DC.D0)\r\n});\r\ncreateInCategory(AutomatorCurrency, \"PendingEP\", /pending[ \\t]+ep/i, {\r\n  $autocomplete: \"pending EP\",\r\n  $getter: () => (Player.canEternity ? gainedEternityPoints() : DC.D0)\r\n});\r\ncreateInCategory(AutomatorCurrency, \"PendingTP\", /pending[ \\t]+tp/i, {\r\n  $autocomplete: \"pending TP\",\r\n  $getter: () => (player.dilation.active ? getTachyonGain() : DC.D0),\r\n});\r\ncreateInCategory(AutomatorCurrency, \"PendingRM\", /pending[ \\t]+rm/i, {\r\n  $autocomplete: \"pending RM\",\r\n  $getter: () => (isRealityAvailable() ? MachineHandler.gainedRealityMachines : DC.D0)\r\n});\r\ncreateInCategory(AutomatorCurrency, \"PendingGlyphLevel\", /pending[ \\t]+glyph[ \\t]+level/i, {\r\n  $autocomplete: \"pending Glyph level\",\r\n  $getter: () => new Decimal(isRealityAvailable() ? gainedGlyphLevel().actualLevel : 0),\r\n});\r\n\r\ncreateInCategory(AutomatorCurrency, \"Rep\", /rep(licanti)?/i, {\r\n  $autocomplete: \"rep\",\r\n  $getter: () => Replicanti.amount,\r\n});\r\ncreateInCategory(AutomatorCurrency, \"TT\", /(tt|time theorems?)/i, {\r\n  $autocomplete: \"TT\",\r\n  $getter: () => Currency.timeTheorems.value,\r\n});\r\ncreateInCategory(AutomatorCurrency, \"TotalTT\", /total[ \\t]+tt/i, {\r\n  $autocomplete: \"total TT\",\r\n  $getter: () => player.timestudy.theorem.plus(TimeTheorems.calculateTimeStudiesCost()),\r\n});\r\n\r\ncreateInCategory(AutomatorCurrency, \"TotalCompletions\", /total[ \\t]+completions/i, {\r\n  $autocomplete: \"total completions\",\r\n  $getter: () => EternityChallenges.completions,\r\n});\r\n\r\ncreateInCategory(AutomatorCurrency, \"PendingCompletions\", /pending[ \\t]+completions/i, {\r\n  $autocomplete: \"pending completions\",\r\n  $getter: () => {\r\n    // If we are not in an EC, pretend like we have a ton of completions so any check for sufficient\r\n    // completions returns true\r\n    if (!EternityChallenge.isRunning) return Decimal.NUMBER_MAX_VALUE;\r\n    return EternityChallenge.current.gainedCompletionStatus.totalCompletions;\r\n  }\r\n});\r\n\r\ncreateInCategory(AutomatorCurrency, \"FilterScore\", /filter[ \\t]+score/i, {\r\n  $autocomplete: \"filter score\",\r\n  $getter: () => {\r\n    // If the filter isn't unlocked somehow, return the most negative number in order to ensure it's nonblocking\r\n    if (!EffarigUnlock.glyphFilter.isUnlocked) return -Number.MAX_VALUE;\r\n    const choices = GlyphSelection.glyphList(GlyphSelection.choiceCount, gainedGlyphLevel(),\r\n      { isChoosingGlyph: false });\r\n    const bestGlyph = AutoGlyphProcessor.pick(choices);\r\n    return AutoGlyphProcessor.filterValue(bestGlyph);\r\n  },\r\n  $unlocked: () => EffarigUnlock.glyphFilter.isUnlocked,\r\n});\r\n\r\n// Space theorems can't be abbreviated as \"ST\" in the actual script content because then the lexer becomes unable\r\n// to match it due to the fact that \"start\" (ec/dilation) also begins with those characters. As a workaround, ST\r\n// uses the full string \"space theorems\" as does the \"total ST\" variant (for consistency)\r\ncreateInCategory(AutomatorCurrency, \"ST\", /space[ \\t]+theorems/i, {\r\n  $autocomplete: \"space theorems\",\r\n  $getter: () => V.availableST,\r\n  $unlocked: () => V.spaceTheorems > 0,\r\n});\r\ncreateInCategory(AutomatorCurrency, \"TotalST\", /total[ \\t]+space[ \\t]+theorems/i, {\r\n  $autocomplete: \"total space theorems\",\r\n  $getter: () => V.spaceTheorems,\r\n  $unlocked: () => V.spaceTheorems > 0,\r\n});\r\n\r\nfor (let i = 1; i <= 12; ++i) {\r\n  const id = i;\r\n  createInCategory(AutomatorCurrency, `EC${i}`, new RegExp(`ec${i} completions`, \"i\"), {\r\n    $autocomplete: `ec${i} completions`,\r\n    // eslint-disable-next-line no-loop-func\r\n    $getter: () => EternityChallenge(id).completions\r\n  });\r\n}\r\n\r\n// $prestigeLevel is used by things that wait for a prestige event. Something waiting for\r\n// eternity will be triggered by something waiting for reality, for example.\r\ncreateInCategory(PrestigeEvent, \"Infinity\", /infinity/i, {\r\n  extraCategories: [StudyPath],\r\n  $autobuyer: () => Autobuyer.bigCrunch,\r\n  $autobuyerDurationMode: AUTO_CRUNCH_MODE.TIME,\r\n  $autobuyerXHighestMode: AUTO_CRUNCH_MODE.X_HIGHEST,\r\n  $autobuyerCurrencyMode: AUTO_CRUNCH_MODE.AMOUNT,\r\n  $prestigeAvailable: () => Player.canCrunch,\r\n  $prestige: () => bigCrunchResetRequest(true),\r\n  $prestigeLevel: 1,\r\n  $prestigeCurrency: \"IP\",\r\n  $studyPath: TIME_STUDY_PATH.INFINITY_DIM,\r\n});\r\ncreateInCategory(PrestigeEvent, \"Eternity\", /eternity/i, {\r\n  $autobuyer: () => Autobuyer.eternity,\r\n  $autobuyerDurationMode: AUTO_ETERNITY_MODE.TIME,\r\n  $autobuyerXHighestMode: AUTO_ETERNITY_MODE.X_HIGHEST,\r\n  $autobuyerCurrencyMode: AUTO_ETERNITY_MODE.AMOUNT,\r\n  $prestigeAvailable: () => Player.canEternity,\r\n  $prestigeLevel: 2,\r\n  $prestigeCurrency: \"EP\",\r\n  $prestige: () => eternity(false, true),\r\n  $respec: () => {\r\n    player.respec = true;\r\n  },\r\n});\r\ncreateInCategory(PrestigeEvent, \"Reality\", /reality/i, {\r\n  $autobuyer: () => Autobuyer.reality,\r\n  $autobuyerCurrencyMode: AUTO_REALITY_MODE.RM,\r\n  $prestigeAvailable: () => isRealityAvailable(),\r\n  $prestigeLevel: 3,\r\n  $prestigeCurrency: \"RM\",\r\n  $prestige: () => autoReality(),\r\n  $respec: () => {\r\n    player.reality.respec = true;\r\n  },\r\n});\r\n\r\ncreateInCategory(StudyPath, \"Idle\", /idle/i, { $studyPath: TIME_STUDY_PATH.IDLE });\r\ncreateInCategory(StudyPath, \"Passive\", /passive/i, { $studyPath: TIME_STUDY_PATH.PASSIVE });\r\ncreateInCategory(StudyPath, \"Active\", /active/i, { $studyPath: TIME_STUDY_PATH.ACTIVE });\r\ncreateInCategory(StudyPath, \"Antimatter\", /antimatter/i, { $studyPath: TIME_STUDY_PATH.ANTIMATTER_DIM });\r\ncreateInCategory(StudyPath, \"Time\", /time/i, { $studyPath: TIME_STUDY_PATH.TIME_DIM });\r\ncreateInCategory(StudyPath, \"Light\", /light/i, { $studyPath: TIME_STUDY_PATH.LIGHT });\r\ncreateInCategory(StudyPath, \"Dark\", /dark/i, { $studyPath: TIME_STUDY_PATH.DARK });\r\n\r\ncreateInCategory(TimeUnit, \"Milliseconds\", /ms/i, {\r\n  $autocomplete: \"ms\",\r\n  $scale: 1,\r\n});\r\ncreateInCategory(TimeUnit, \"Seconds\", /s(ec(onds?)?)?/i, {\r\n  $autocomplete: \"sec\",\r\n  $scale: 1000,\r\n});\r\ncreateInCategory(TimeUnit, \"Minutes\", /m(in(utes?)?)?/i, {\r\n  $autocomplete: \"min\",\r\n  $scale: 60 * 1000,\r\n});\r\ncreateInCategory(TimeUnit, \"Hours\", /h(ours?)?/i, {\r\n  $autocomplete: \"hours\",\r\n  $scale: 3600 * 1000,\r\n});\r\n\r\nconst Keyword = createToken({\r\n  name: \"Keyword\",\r\n  pattern: Lexer.NA,\r\n  longer_alt: Identifier,\r\n});\r\n\r\nconst keywordTokens = [];\r\nconst createKeyword = (name, pattern, props = {}) => {\r\n  const categories = [Keyword];\r\n  if (props.extraCategories) categories.push(...props.extraCategories);\r\n  const token = createToken({\r\n    name,\r\n    pattern,\r\n    categories,\r\n    longer_alt: Identifier,\r\n  });\r\n  token.$autocomplete = name.toLocaleLowerCase();\r\n  keywordTokens.push(token);\r\n  Object.assign(token, props);\r\n  return token;\r\n};\r\n\r\ncreateKeyword(\"Auto\", /auto/i);\r\ncreateKeyword(\"Buy\", /buy/i);\r\n// Necessary to hide it from Codemirror's tab auto-completion\r\ncreateKeyword(\"Blob\", /blob\\s\\s/i, {\r\n  $unlocked: () => false,\r\n});\r\ncreateKeyword(\"If\", /if/i);\r\ncreateKeyword(\"Load\", /load/i);\r\ncreateKeyword(\"Notify\", /notify/i);\r\ncreateKeyword(\"Nowait\", /nowait/i);\r\ncreateKeyword(\"Off\", /off/i);\r\ncreateKeyword(\"On\", /on/i);\r\ncreateKeyword(\"Pause\", /pause/i);\r\n// Names are a little special, because they can be named anything (like ec12 or wait)\r\n// So, we consume the label at the same time as we consume the preset. In order to report\r\n// errors, we also match just the word name. And, we have to not match comments.\r\ncreateKeyword(\"Name\", /name([ \\t]+(\\/(?!\\/)|[^\\n#/])*)?/i);\r\ncreateKeyword(\"Id\", /id\\b([ \\t]+\\d)?/i);\r\ncreateKeyword(\"Purchase\", /purchase/i);\r\ncreateKeyword(\"Respec\", /respec/i);\r\ncreateKeyword(\"Restart\", /restart/i);\r\ncreateKeyword(\"Start\", /start/i);\r\ncreateKeyword(\"Stop\", /stop/i);\r\ncreateKeyword(\"Studies\", /studies/i);\r\ncreateKeyword(\"Unlock\", /unlock/i);\r\ncreateKeyword(\"Until\", /until/i);\r\ncreateKeyword(\"Use\", /use/i);\r\ncreateKeyword(\"Wait\", /wait/i);\r\ncreateKeyword(\"While\", /while/i);\r\ncreateKeyword(\"BlackHole\", /black[ \\t]+hole/i, {\r\n  $autocomplete: \"black hole\",\r\n  $unlocked: () => BlackHole(1).isUnlocked,\r\n});\r\ncreateKeyword(\"StoreGameTime\", /stored?[ \\t]+game[ \\t]+time/i, {\r\n  $autocomplete: \"store game time\",\r\n  $unlocked: () => Enslaved.isUnlocked,\r\n});\r\n\r\ncreateKeyword(\"Dilation\", /dilation/i);\r\ncreateKeyword(\"EC\", /ec/i);\r\ncreateKeyword(\"XHighest\", /x[ \\t]+highest/i, {\r\n  $autocomplete: \"x highest\",\r\n});\r\n\r\n// We allow ECLiteral to consume lots of digits because that makes error reporting more\r\n// clear (it's nice to say ec123 is an invalid ec)\r\nconst ECLiteral = createToken({\r\n  name: \"ECLiteral\",\r\n  pattern: /ec[1-9][0-9]*/i,\r\n  longer_alt: Identifier,\r\n});\r\n\r\nconst LCurly = createToken({ name: \"LCurly\", pattern: /[ \\t]*{/ });\r\nconst RCurly = createToken({ name: \"RCurly\", pattern: /[ \\t]*}/ });\r\nconst Comma = createToken({ name: \"Comma\", pattern: /,/ });\r\nconst Pipe = createToken({ name: \"Pipe\", pattern: /\\|/, label: \"|\" });\r\nconst Dash = createToken({ name: \"Dash\", pattern: /-/, label: \"-\" });\r\nconst Exclamation = createToken({ name: \"Exclamation\", pattern: /!/, label: \"!\" });\r\n\r\n// The order here is the order the lexer looks for tokens in.\r\nexport const automatorTokens = [\r\n  HSpace, StringLiteral, StringLiteralSingleQuote, Comment, EOL,\r\n  ComparisonOperator, ...tokenLists.ComparisonOperator,\r\n  LCurly, RCurly, Comma, EqualSign, Pipe, Dash, Exclamation,\r\n  BlackHoleStr, NumberLiteral,\r\n  AutomatorCurrency, ...tokenLists.AutomatorCurrency,\r\n  ECLiteral,\r\n  Keyword, ...keywordTokens,\r\n  PrestigeEvent, ...tokenLists.PrestigeEvent,\r\n  StudyPath, ...tokenLists.StudyPath,\r\n  TimeUnit, ...tokenLists.TimeUnit,\r\n  Identifier,\r\n];\r\n\r\n// Labels only affect error messages and Diagrams.\r\nLCurly.LABEL = \"'{'\";\r\nRCurly.LABEL = \"'}'\";\r\nNumberLiteral.LABEL = \"Number\";\r\nComma.LABEL = \"❟\";\r\n\r\nexport const lexer = new Lexer(automatorTokens, {\r\n  positionTracking: \"full\",\r\n  ensureOptimizations: true\r\n});\r\n\r\n// The lexer uses an ID system that's separate from indices into the token array\r\nexport const tokenIds = [];\r\nfor (const token of lexer.lexerDefinition) {\r\n  tokenIds[token.tokenTypeIdx] = token;\r\n}\r\n\r\n// We use this while building up the grammar\r\nexport const tokenMap = automatorTokens.mapToObject(e => e.name, e => e);\r\n\r\nconst automatorCurrencyNames = tokenLists.AutomatorCurrency.map(i => i.$autocomplete.toUpperCase());\r\n\r\nexport const standardizeAutomatorValues = function(x) {\r\n  try {\r\n    if (automatorCurrencyNames.includes(x.toUpperCase())) return x.toUpperCase();\r\n  } catch {\r\n    // This only happens if the input is a number or Decimal, in which case we don't attempt to change any formatting\r\n    // and simply return\r\n    return x;\r\n  }\r\n  for (const i of tokenLists.AutomatorCurrency) {\r\n    // Check for a match of the full string.\r\n    if (x.match(i.PATTERN) && x.match(i.PATTERN)[0].length === x.length) {\r\n      return i.$autocomplete.toUpperCase();\r\n    }\r\n  }\r\n  // If we get to this point, we haven't matched a currency name and instead assume it's a defined constant and\r\n  // return it without any format changes since these are case-sensitive\r\n  return x;\r\n};\r\n\r\n// In order to disallow individual words within command key words/phrases, we need to ignore certain patterns (mostly\r\n// ones with special regex characters), split the rest of them up across all spaces and tabs, and then flatten the\r\n// final resulting array. Note that this technically duplicates words present in multiple phrases (eg. \"pending\")\r\nconst ignoredPatterns = [\"Identifier\", \"LCurly\", \"RCurly\"];\r\nexport const forbiddenConstantPatterns = lexer.lexerDefinition\r\n  .filter(p => !ignoredPatterns.includes(p.name))\r\n  .map(p => p.PATTERN.source)\r\n  .flatMap(p => ((p.includes(\"(\") || p.includes(\")\")) ? p : p.split(\"[ \\\\t]+\")));\r\n"]},"metadata":{},"sourceType":"module"}