{"ast":null,"code":"import \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n\n/* eslint-disable import/extensions */\nimport pako from \"pako/dist/pako.esm.mjs\";\n/* eslint-enable import/extensions */\n\nimport { createUserWithEmailAndPassword, getAuth, GoogleAuthProvider, signInWithEmailAndPassword, signInWithPopup, signOut } from \"firebase/auth\";\nimport { get, getDatabase, ref, set } from \"firebase/database\";\nimport { initializeApp } from \"firebase/app\";\nimport { sha512_256 } from \"js-sha512\";\nimport { STEAM } from \"@/env\";\nimport { decodeBase64Binary } from \"./base64-binary\";\nimport { firebaseConfig } from \"./firebase-config\";\nimport { ProgressChecker } from \"./progress-checker\";\nimport { SteamRuntime } from \"@/steam\";\nconst hasFirebaseConfig = firebaseConfig.apiKey !== null;\n\nif (hasFirebaseConfig) {\n  initializeApp(firebaseConfig);\n}\n\nexport const Cloud = {\n  provider: hasFirebaseConfig ? new GoogleAuthProvider() : null,\n  auth: hasFirebaseConfig ? getAuth() : null,\n  db: hasFirebaseConfig ? getDatabase() : null,\n  user: null,\n  lastCloudHash: null,\n\n  get isAvailable() {\n    return hasFirebaseConfig;\n  },\n\n  resetTempState() {\n    this.lastCloudHash = null;\n    GameStorage.lastCloudSave = Date.now();\n    GameIntervals.checkCloudSave.restart();\n  },\n\n  get loggedIn() {\n    return this.user !== null;\n  },\n\n  async login() {\n    if (!this.isAvailable) {\n      return;\n    }\n\n    try {\n      await signInWithPopup(this.auth, this.provider);\n      ShopPurchaseData.syncSTD();\n      if (player.options.hideGoogleName) GameUI.notify.success(`Successfully logged in to Google Account`);else GameUI.notify.success(`Successfully logged in as ${this.user.displayName}`);\n      if (ShopPurchaseData.isIAPEnabled) Speedrun.setSTDUse(true);\n    } catch (e) {\n      GameUI.notify.error(\"Google Account login failed\");\n    }\n  },\n\n  async loginWithSteam(accountId, staticAccountId, screenName) {\n    if (!this.isAvailable) {\n      return;\n    }\n\n    if (this.loggedIn) {\n      Cloud.user.displayName = screenName;\n      return;\n    }\n\n    const email = `${accountId}@ad.com`;\n    const pass = staticAccountId;\n    let error = undefined;\n    await signInWithEmailAndPassword(this.auth, email, pass).catch(() => createUserWithEmailAndPassword(this.auth, email, pass)).catch(x => error = x);\n\n    if (error !== undefined) {\n      // eslint-disable-next-line no-console\n      console.log(`Firebase Login Error: ${error}`);\n      return;\n    }\n\n    Cloud.user.displayName = screenName;\n  },\n\n  // NOTE: This function is largely untested due to not being used at any place within web reality code\n  async loadMobile() {\n    if (!this.user) return;\n    const snapshot = await get(ref(this.db, `users/${this.user.id}/player`));\n\n    if (snapshot.exists) {\n      const encoded = snapshot.val();\n      const uintArray = decodeBase64Binary(encoded.replace(/\\x2D/g, \"+\").replace(/_/g, \"/\"));\n      const save = pako.ungzip(uintArray, {\n        to: \"string\"\n      });\n    }\n  },\n\n  compareSaves(cloud, local, hash) {\n    // This try/except will generally only throw an exception if the cloud save is somehow malformed.\n    // In practice this should only happen for saves which are really old, or from very early development.\n    // This will be handled upstream by showing a modal notifying the player of the invalid data and giving them\n    // options to resolve it without needing to open up the console.\n    // Note: This could also technically happen if the local save is malformed instead - this shouldn't\n    // happen unless the player is overtly cheating through the console, and in that case it seems unreasonable\n    // to attempt to handle such open-ended behavior gracefully\n    try {\n      return {\n        farther: ProgressChecker.compareSaveProgress(cloud, local),\n        older: ProgressChecker.compareSaveTimes(cloud, local),\n        differentName: (cloud === null || cloud === void 0 ? void 0 : cloud.options.saveFileName) !== (local === null || local === void 0 ? void 0 : local.options.saveFileName),\n        hashMismatch: this.lastCloudHash && this.lastCloudHash !== hash\n      };\n    } catch (e) {\n      return null;\n    }\n  },\n\n  async saveCheck(forceModal = false) {\n    if (!this.isAvailable) {\n      return;\n    }\n\n    const saveId = GameStorage.currentSlot;\n    const cloudSave = await this.load();\n\n    if (cloudSave === null) {\n      this.save();\n    } else {\n      const thisCloudHash = sha512_256(GameSaveSerializer.serialize(cloudSave));\n      if (!this.lastCloudHash) this.lastCloudHash = thisCloudHash;\n      const localSave = GameStorage.saves[saveId];\n      const saveComparison = this.compareSaves(cloudSave, localSave, thisCloudHash);\n\n      const overwriteAndSendCloudSave = () => this.save(); // If the comparison fails, we assume the cloud data is corrupted and show the relevant modal\n\n\n      if (!saveComparison) {\n        Modal.addCloudConflict(saveId, saveComparison, cloudSave, localSave, overwriteAndSendCloudSave);\n        Modal.cloudInvalidData.show({\n          isSaving: true\n        });\n        return;\n      } // Bring up the modal if cloud saving will overwrite a cloud save which is older or possibly farther\n\n\n      const hasBoth = cloudSave && localSave; // NOTE THIS CHECK IS INTENTIONALLY DIFFERENT FROM THE LOAD CHECK\n\n      const hasConflict = hasBoth && saveComparison && (saveComparison.older === -1 || saveComparison.farther === -1 || saveComparison.differentName || saveComparison.hashMismatch);\n\n      if (forceModal || hasConflict && player.options.showCloudModal) {\n        Modal.addCloudConflict(saveId, saveComparison, cloudSave, localSave, overwriteAndSendCloudSave);\n        Modal.cloudSaveConflict.show();\n      } else if (!hasConflict || player.options.forceCloudOverwrite) {\n        overwriteAndSendCloudSave();\n      }\n    }\n  },\n\n  save() {\n    if (!this.user) return;\n    if (GlyphSelection.active || ui.$viewModel.modal.progressBar !== undefined) return;\n    if (player.options.syncSaveIntervals) GameStorage.save();\n    const serializedSave = GameSaveSerializer.serialize(GameStorage.saves[GameStorage.currentSlot]);\n    this.lastCloudHash = sha512_256(serializedSave);\n    GameStorage.lastCloudSave = Date.now();\n    GameIntervals.checkCloudSave.restart();\n    const slot = GameStorage.currentSlot;\n    this.writeToCloudDB(slot, serializedSave); // TODO We should revisit this (and the below in loadCheck) at some point after the steam-web merge\n    // since the hiding motivation was identifying info, and Steam usernames are generally more publicly\n    // visible than Google info. Also affects the visibility of the button in the Options/Saving subtab\n\n    if (STEAM) {\n      GameUI.notify.info(`Game saved (slot ${slot + 1}) to cloud as user ${this.user.displayName}`);\n      return;\n    }\n\n    if (player.options.hideGoogleName) GameUI.notify.info(`Game saved (slot ${slot + 1}) to cloud`);else GameUI.notify.info(`Game saved (slot ${slot + 1}) to cloud as user ${this.user.displayName}`);\n  },\n\n  async loadCheck() {\n    if (!this.isAvailable) {\n      return;\n    }\n\n    const save = await this.load();\n\n    if (save === null) {\n      if (player.options.hideGoogleName) GameUI.notify.info(`No cloud save for current Google Account`);else GameUI.notify.info(`No cloud save for user ${this.user.displayName}`);\n    } else {\n      const cloudSave = save;\n      const saveId = GameStorage.currentSlot;\n      const localSave = GameStorage.saves[saveId];\n      const saveComparison = this.compareSaves(cloudSave, localSave); // eslint-disable-next-line no-loop-func\n\n      const overwriteLocalSave = () => {\n        GameStorage.overwriteSlot(saveId, cloudSave);\n\n        if (STEAM) {\n          GameUI.notify.info(`Cloud save loaded`);\n          return;\n        }\n\n        if (player.options.hideGoogleName) GameUI.notify.info(`Cloud save (slot ${saveId + 1}) loaded`);else GameUI.notify.info(`Cloud save (slot ${saveId + 1}) loaded for user ${this.user.displayName}`);\n      }; // If the comparison fails, we assume the cloud data is corrupted and show the relevant modal\n\n\n      if (!saveComparison) {\n        Modal.addCloudConflict(saveId, saveComparison, cloudSave, localSave, overwriteLocalSave);\n        Modal.cloudInvalidData.show({\n          isSaving: false\n        });\n        return;\n      } // Bring up the modal if cloud loading will overwrite a local save which is older or possibly farther\n\n\n      const hasBoth = cloudSave && localSave;\n      const hasConflict = hasBoth && (saveComparison.older === 1 || saveComparison.farther !== -1 || saveComparison.differentName);\n\n      if (hasConflict) {\n        Modal.addCloudConflict(saveId, saveComparison, cloudSave, localSave, overwriteLocalSave);\n        Modal.cloudLoadConflict.show();\n      } else {\n        overwriteLocalSave();\n      }\n    }\n  },\n\n  async load() {\n    let singleSlot = await this.readFromCloudDB(GameStorage.currentSlot);\n    if (singleSlot.exists()) return GameSaveSerializer.deserialize(singleSlot.val()); // An optimization to reduce cloud save operations was done which migrates the format from an old one where all\n    // slots were saved together to a new one where all three are saved in separate spots. This part of the code should\n    // only be reached and executed if this migration hasn't happened yet, in which case we migrate and try again. If\n    // it's *still* empty, then there was nothing to migrate in the first place\n\n    await this.separateSaveSlots();\n    singleSlot = await this.readFromCloudDB(GameStorage.currentSlot);\n    if (singleSlot.exists()) return GameSaveSerializer.deserialize(singleSlot.val());\n    return null;\n  },\n\n  // The initial implementation of cloud saving combined all save files in the same DB entry, but we have since changed\n  // it so that they're all saved in separate slots. The database itself retains the single-entry data until the first\n  // player load attempt after this change, at which point this is called client-side to do a one-time format migration\n  // Before the migration, saves were stored in \".../web\" and afterward they have been moved to \".../web/1\" and similar\n  async separateSaveSlots() {\n    const oldData = await this.readFromCloudDB(null);\n    if (!oldData.exists()) return;\n    const allData = GameSaveSerializer.deserialize(oldData.val());\n    if (!allData) return;\n\n    for (const slot of Object.keys(allData.saves)) {\n      const newData = GameSaveSerializer.serialize(allData.saves[slot]);\n      await this.writeToCloudDB(Number(slot), newData);\n    }\n  },\n\n  readFromCloudDB(slot) {\n    const slotStr = slot === null ? \"\" : `/${slot}`;\n    return get(ref(this.db, `users/${this.user.id}/web${slotStr}`));\n  },\n\n  writeToCloudDB(slot, data) {\n    const slotStr = slot === null ? \"\" : `/${slot}`;\n    return set(ref(this.db, `users/${this.user.id}/web${slotStr}`), data);\n  },\n\n  logout() {\n    if (!this.isAvailable) {\n      return;\n    }\n\n    signOut(this.auth);\n    ShopPurchaseData.clearLocalSTD();\n  },\n\n  init() {\n    if (!this.isAvailable) {\n      return;\n    }\n\n    getAuth().onAuthStateChanged(user => {\n      if (user) {\n        this.user = {\n          id: user.uid,\n          displayName: STEAM ? SteamRuntime.screenName : user.displayName,\n          email: user.email\n        };\n\n        if (!STEAM) {\n          ShopPurchaseData.syncSTD();\n        }\n      } else {\n        this.user = null;\n      }\n    });\n  }\n\n};","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/storage/cloud-saving.js"],"names":["pako","createUserWithEmailAndPassword","getAuth","GoogleAuthProvider","signInWithEmailAndPassword","signInWithPopup","signOut","get","getDatabase","ref","set","initializeApp","sha512_256","STEAM","decodeBase64Binary","firebaseConfig","ProgressChecker","SteamRuntime","hasFirebaseConfig","apiKey","Cloud","provider","auth","db","user","lastCloudHash","isAvailable","resetTempState","GameStorage","lastCloudSave","Date","now","GameIntervals","checkCloudSave","restart","loggedIn","login","ShopPurchaseData","syncSTD","player","options","hideGoogleName","GameUI","notify","success","displayName","isIAPEnabled","Speedrun","setSTDUse","e","error","loginWithSteam","accountId","staticAccountId","screenName","email","pass","undefined","catch","x","console","log","loadMobile","snapshot","id","exists","encoded","val","uintArray","replace","save","ungzip","to","compareSaves","cloud","local","hash","farther","compareSaveProgress","older","compareSaveTimes","differentName","saveFileName","hashMismatch","saveCheck","forceModal","saveId","currentSlot","cloudSave","load","thisCloudHash","GameSaveSerializer","serialize","localSave","saves","saveComparison","overwriteAndSendCloudSave","Modal","addCloudConflict","cloudInvalidData","show","isSaving","hasBoth","hasConflict","showCloudModal","cloudSaveConflict","forceCloudOverwrite","GlyphSelection","active","ui","$viewModel","modal","progressBar","syncSaveIntervals","serializedSave","slot","writeToCloudDB","info","loadCheck","overwriteLocalSave","overwriteSlot","cloudLoadConflict","singleSlot","readFromCloudDB","deserialize","separateSaveSlots","oldData","allData","Object","keys","newData","Number","slotStr","data","logout","clearLocalSTD","init","onAuthStateChanged","uid"],"mappings":"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","sourcesContent":["/* eslint-disable import/extensions */\r\nimport pako from \"pako/dist/pako.esm.mjs\";\r\n/* eslint-enable import/extensions */\r\n\r\nimport {\r\n  createUserWithEmailAndPassword,\r\n  getAuth,\r\n  GoogleAuthProvider,\r\n  signInWithEmailAndPassword,\r\n  signInWithPopup,\r\n  signOut\r\n} from \"firebase/auth\";\r\nimport { get, getDatabase, ref, set } from \"firebase/database\";\r\nimport { initializeApp } from \"firebase/app\";\r\nimport { sha512_256 } from \"js-sha512\";\r\n\r\nimport { STEAM } from \"@/env\";\r\n\r\nimport { decodeBase64Binary } from \"./base64-binary\";\r\nimport { firebaseConfig } from \"./firebase-config\";\r\nimport { ProgressChecker } from \"./progress-checker\";\r\nimport { SteamRuntime } from \"@/steam\";\r\n\r\nconst hasFirebaseConfig = firebaseConfig.apiKey !== null;\r\nif (hasFirebaseConfig) {\r\n  initializeApp(firebaseConfig);\r\n}\r\n\r\nexport const Cloud = {\r\n  provider: hasFirebaseConfig ? new GoogleAuthProvider() : null,\r\n  auth: hasFirebaseConfig ? getAuth() : null,\r\n  db: hasFirebaseConfig ? getDatabase() : null,\r\n  user: null,\r\n  lastCloudHash: null,\r\n\r\n  get isAvailable() {\r\n    return hasFirebaseConfig;\r\n  },\r\n\r\n  resetTempState() {\r\n    this.lastCloudHash = null;\r\n    GameStorage.lastCloudSave = Date.now();\r\n    GameIntervals.checkCloudSave.restart();\r\n  },\r\n\r\n  get loggedIn() {\r\n    return this.user !== null;\r\n  },\r\n\r\n  async login() {\r\n    if (!this.isAvailable) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      await signInWithPopup(this.auth, this.provider);\r\n      ShopPurchaseData.syncSTD();\r\n      if (player.options.hideGoogleName) GameUI.notify.success(`Successfully logged in to Google Account`);\r\n      else GameUI.notify.success(`Successfully logged in as ${this.user.displayName}`);\r\n      if (ShopPurchaseData.isIAPEnabled) Speedrun.setSTDUse(true);\r\n    } catch (e) {\r\n      GameUI.notify.error(\"Google Account login failed\");\r\n    }\r\n  },\r\n\r\n  async loginWithSteam(accountId, staticAccountId, screenName) {\r\n    if (!this.isAvailable) {\r\n      return;\r\n    }\r\n\r\n    if (this.loggedIn) {\r\n      Cloud.user.displayName = screenName;\r\n      return;\r\n    }\r\n\r\n    const email = `${accountId}@ad.com`;\r\n    const pass = staticAccountId;\r\n    let error = undefined;\r\n\r\n    await signInWithEmailAndPassword(this.auth, email, pass)\r\n      .catch(() => createUserWithEmailAndPassword(this.auth, email, pass))\r\n      .catch(x => error = x);\r\n\r\n    if (error !== undefined) {\r\n      // eslint-disable-next-line no-console\r\n      console.log(`Firebase Login Error: ${error}`);\r\n      return;\r\n    }\r\n\r\n    Cloud.user.displayName = screenName;\r\n  },\r\n\r\n  // NOTE: This function is largely untested due to not being used at any place within web reality code\r\n  async loadMobile() {\r\n    if (!this.user) return;\r\n    const snapshot = await get(ref(this.db, `users/${this.user.id}/player`));\r\n    if (snapshot.exists) {\r\n      const encoded = snapshot.val();\r\n      const uintArray = decodeBase64Binary(encoded.replace(/-/gu, \"+\").replace(/_/gu, \"/\"));\r\n      const save = pako.ungzip(uintArray, { to: \"string\" });\r\n    }\r\n  },\r\n\r\n  compareSaves(cloud, local, hash) {\r\n    // This try/except will generally only throw an exception if the cloud save is somehow malformed.\r\n    // In practice this should only happen for saves which are really old, or from very early development.\r\n    // This will be handled upstream by showing a modal notifying the player of the invalid data and giving them\r\n    // options to resolve it without needing to open up the console.\r\n    // Note: This could also technically happen if the local save is malformed instead - this shouldn't\r\n    // happen unless the player is overtly cheating through the console, and in that case it seems unreasonable\r\n    // to attempt to handle such open-ended behavior gracefully\r\n    try {\r\n      return {\r\n        farther: ProgressChecker.compareSaveProgress(cloud, local),\r\n        older: ProgressChecker.compareSaveTimes(cloud, local),\r\n        differentName: cloud?.options.saveFileName !== local?.options.saveFileName,\r\n        hashMismatch: this.lastCloudHash && this.lastCloudHash !== hash,\r\n      };\r\n    } catch (e) {\r\n      return null;\r\n    }\r\n  },\r\n\r\n  async saveCheck(forceModal = false) {\r\n    if (!this.isAvailable) {\r\n      return;\r\n    }\r\n\r\n    const saveId = GameStorage.currentSlot;\r\n    const cloudSave = await this.load();\r\n    if (cloudSave === null) {\r\n      this.save();\r\n    } else {\r\n      const thisCloudHash = sha512_256(GameSaveSerializer.serialize(cloudSave));\r\n      if (!this.lastCloudHash) this.lastCloudHash = thisCloudHash;\r\n      const localSave = GameStorage.saves[saveId];\r\n      const saveComparison = this.compareSaves(cloudSave, localSave, thisCloudHash);\r\n      const overwriteAndSendCloudSave = () => this.save();\r\n\r\n      // If the comparison fails, we assume the cloud data is corrupted and show the relevant modal\r\n      if (!saveComparison) {\r\n        Modal.addCloudConflict(saveId, saveComparison, cloudSave, localSave, overwriteAndSendCloudSave);\r\n        Modal.cloudInvalidData.show({ isSaving: true });\r\n        return;\r\n      }\r\n\r\n      // Bring up the modal if cloud saving will overwrite a cloud save which is older or possibly farther\r\n      const hasBoth = cloudSave && localSave;\r\n      // NOTE THIS CHECK IS INTENTIONALLY DIFFERENT FROM THE LOAD CHECK\r\n      const hasConflict = hasBoth && saveComparison && (saveComparison.older === -1 || saveComparison.farther === -1 ||\r\n        saveComparison.differentName || saveComparison.hashMismatch);\r\n      if (forceModal || (hasConflict && player.options.showCloudModal)) {\r\n        Modal.addCloudConflict(saveId, saveComparison, cloudSave, localSave, overwriteAndSendCloudSave);\r\n        Modal.cloudSaveConflict.show();\r\n      } else if (!hasConflict || player.options.forceCloudOverwrite) {\r\n        overwriteAndSendCloudSave();\r\n      }\r\n    }\r\n  },\r\n\r\n  save() {\r\n    if (!this.user) return;\r\n    if (GlyphSelection.active || ui.$viewModel.modal.progressBar !== undefined) return;\r\n    if (player.options.syncSaveIntervals) GameStorage.save();\r\n    const serializedSave = GameSaveSerializer.serialize(GameStorage.saves[GameStorage.currentSlot]);\r\n\r\n    this.lastCloudHash = sha512_256(serializedSave);\r\n    GameStorage.lastCloudSave = Date.now();\r\n    GameIntervals.checkCloudSave.restart();\r\n\r\n    const slot = GameStorage.currentSlot;\r\n    this.writeToCloudDB(slot, serializedSave);\r\n\r\n    // TODO We should revisit this (and the below in loadCheck) at some point after the steam-web merge\r\n    // since the hiding motivation was identifying info, and Steam usernames are generally more publicly\r\n    // visible than Google info. Also affects the visibility of the button in the Options/Saving subtab\r\n    if (STEAM) {\r\n      GameUI.notify.info(`Game saved (slot ${slot + 1}) to cloud as user ${this.user.displayName}`);\r\n      return;\r\n    }\r\n\r\n    if (player.options.hideGoogleName) GameUI.notify.info(`Game saved (slot ${slot + 1}) to cloud`);\r\n    else GameUI.notify.info(`Game saved (slot ${slot + 1}) to cloud as user ${this.user.displayName}`);\r\n  },\r\n\r\n  async loadCheck() {\r\n    if (!this.isAvailable) {\r\n      return;\r\n    }\r\n\r\n    const save = await this.load();\r\n    if (save === null) {\r\n      if (player.options.hideGoogleName) GameUI.notify.info(`No cloud save for current Google Account`);\r\n      else GameUI.notify.info(`No cloud save for user ${this.user.displayName}`);\r\n    } else {\r\n      const cloudSave = save;\r\n      const saveId = GameStorage.currentSlot;\r\n      const localSave = GameStorage.saves[saveId];\r\n      const saveComparison = this.compareSaves(cloudSave, localSave);\r\n\r\n      // eslint-disable-next-line no-loop-func\r\n      const overwriteLocalSave = () => {\r\n        GameStorage.overwriteSlot(saveId, cloudSave);\r\n\r\n        if (STEAM) {\r\n          GameUI.notify.info(`Cloud save loaded`);\r\n          return;\r\n        }\r\n\r\n        if (player.options.hideGoogleName) GameUI.notify.info(`Cloud save (slot ${saveId + 1}) loaded`);\r\n        else GameUI.notify.info(`Cloud save (slot ${saveId + 1}) loaded for user ${this.user.displayName}`);\r\n      };\r\n\r\n      // If the comparison fails, we assume the cloud data is corrupted and show the relevant modal\r\n      if (!saveComparison) {\r\n        Modal.addCloudConflict(saveId, saveComparison, cloudSave, localSave, overwriteLocalSave);\r\n        Modal.cloudInvalidData.show({ isSaving: false });\r\n        return;\r\n      }\r\n\r\n      // Bring up the modal if cloud loading will overwrite a local save which is older or possibly farther\r\n      const hasBoth = cloudSave && localSave;\r\n      const hasConflict = hasBoth && (saveComparison.older === 1 || saveComparison.farther !== -1 ||\r\n        saveComparison.differentName);\r\n      if (hasConflict) {\r\n        Modal.addCloudConflict(saveId, saveComparison, cloudSave, localSave, overwriteLocalSave);\r\n        Modal.cloudLoadConflict.show();\r\n      } else {\r\n        overwriteLocalSave();\r\n      }\r\n    }\r\n  },\r\n\r\n  async load() {\r\n    let singleSlot = await this.readFromCloudDB(GameStorage.currentSlot);\r\n    if (singleSlot.exists()) return GameSaveSerializer.deserialize(singleSlot.val());\r\n\r\n    // An optimization to reduce cloud save operations was done which migrates the format from an old one where all\r\n    // slots were saved together to a new one where all three are saved in separate spots. This part of the code should\r\n    // only be reached and executed if this migration hasn't happened yet, in which case we migrate and try again. If\r\n    // it's *still* empty, then there was nothing to migrate in the first place\r\n    await this.separateSaveSlots();\r\n    singleSlot = await this.readFromCloudDB(GameStorage.currentSlot);\r\n    if (singleSlot.exists()) return GameSaveSerializer.deserialize(singleSlot.val());\r\n\r\n    return null;\r\n  },\r\n\r\n  // The initial implementation of cloud saving combined all save files in the same DB entry, but we have since changed\r\n  // it so that they're all saved in separate slots. The database itself retains the single-entry data until the first\r\n  // player load attempt after this change, at which point this is called client-side to do a one-time format migration\r\n  // Before the migration, saves were stored in \".../web\" and afterward they have been moved to \".../web/1\" and similar\r\n  async separateSaveSlots() {\r\n    const oldData = await this.readFromCloudDB(null);\r\n    if (!oldData.exists()) return;\r\n    const allData = GameSaveSerializer.deserialize(oldData.val());\r\n    if (!allData) return;\r\n\r\n    for (const slot of Object.keys(allData.saves)) {\r\n      const newData = GameSaveSerializer.serialize(allData.saves[slot]);\r\n      await this.writeToCloudDB(Number(slot), newData);\r\n    }\r\n  },\r\n\r\n  readFromCloudDB(slot) {\r\n    const slotStr = slot === null ? \"\" : `/${slot}`;\r\n    return get(ref(this.db, `users/${this.user.id}/web${slotStr}`));\r\n  },\r\n\r\n  writeToCloudDB(slot, data) {\r\n    const slotStr = slot === null ? \"\" : `/${slot}`;\r\n    return set(ref(this.db, `users/${this.user.id}/web${slotStr}`), data);\r\n  },\r\n\r\n  logout() {\r\n    if (!this.isAvailable) {\r\n      return;\r\n    }\r\n\r\n    signOut(this.auth);\r\n    ShopPurchaseData.clearLocalSTD();\r\n  },\r\n\r\n  init() {\r\n    if (!this.isAvailable) {\r\n      return;\r\n    }\r\n\r\n    getAuth().onAuthStateChanged(user => {\r\n      if (user) {\r\n        this.user = {\r\n          id: user.uid,\r\n          displayName: STEAM\r\n            ? SteamRuntime.screenName\r\n            : user.displayName,\r\n          email: user.email,\r\n        };\r\n        if (!STEAM) {\r\n          ShopPurchaseData.syncSTD();\r\n        }\r\n      } else {\r\n        this.user = null;\r\n      }\r\n    });\r\n  },\r\n};\r\n"]},"metadata":{},"sourceType":"module"}