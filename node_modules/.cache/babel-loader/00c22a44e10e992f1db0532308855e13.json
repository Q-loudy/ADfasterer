{"ast":null,"code":"import \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport { lexer, tokenIds } from \"./lexer\";\nimport { compile } from \"./compiler\";\nimport { parser } from \"./parser\";\n\nfunction walkSuggestion(suggestion, prefix, output) {\n  const hasAutocomplete = suggestion.$autocomplete && suggestion.$autocomplete.startsWith(prefix) && suggestion.$autocomplete !== prefix;\n  const isUnlocked = suggestion.$unlocked ? suggestion.$unlocked() : true;\n  if (hasAutocomplete && isUnlocked) output.add(suggestion.$autocomplete);\n\n  for (const s of suggestion.categoryMatches) {\n    walkSuggestion(tokenIds[s], prefix, output);\n  }\n} // eslint-disable-next-line no-unused-vars\n\n\nCodeMirror.registerHelper(\"lint\", \"automato\", (contents, _, editor) => {\n  const doc = editor.getDoc();\n  const errors = compile(contents, true).errors;\n  return errors.map(e => ({\n    message: e.info,\n    severity: \"error\",\n    from: doc.posFromIndex(e.startOffset),\n    to: doc.posFromIndex(e.endOffset + 1)\n  }));\n});\nCodeMirror.registerHelper(\"hint\", \"anyword\", editor => {\n  const cursor = editor.getDoc().getCursor();\n  let start = cursor.ch;\n  const end = cursor.ch;\n  const line = editor.getLine(cursor.line);\n\n  while (start && /[0-9A-Z_a-z]/.test(line.charAt(start - 1))) --start;\n\n  const lineStart = line.slice(0, start);\n  const currentPrefix = line.slice(start, end);\n  const lineLex = lexer.tokenize(lineStart);\n  if (lineLex.errors.length > 0) return undefined;\n  const rawSuggestions = parser.computeContentAssist(\"command\", lineLex.tokens);\n  const suggestions = new Set();\n\n  for (const s of rawSuggestions) {\n    if (s.ruleStack[1] === \"badCommand\") continue;\n    walkSuggestion(s.nextTokenType, currentPrefix, suggestions);\n  }\n\n  return {\n    list: Array.from(suggestions),\n    from: CodeMirror.Pos(cursor.line, start),\n    to: CodeMirror.Pos(cursor.line, end)\n  };\n});\nconst commentRule = {\n  regex: /(\\/\\/|#)(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*/,\n  token: \"comment\",\n  next: \"start\"\n}; // This is a state machine which determines the syntax highlighting for the automator. Top-level props define\n// the states, the array entries define the transition rules which are checked in order of appearance, and next\n// specifies which state to transition to after consuming the given regex. Without an entry for \"next\" the state\n// machine will remain in the same state and run the transition check after consuming the regex. The \"next\" prop\n// in the line with \"sol\" is a fallback transition which will be followed if none of the rules are matched.\n// Matches to the regexes will color the matched text according to the specified color of cm-[token] in liquibyte.css\n// Note: This has no bearing on the actual functionality and behavior of the automator itself and is purely visual.\n\nCodeMirror.defineSimpleMode(\"automato\", {\n  // The start state contains the rules that are intially used\n  start: [commentRule, {\n    regex: /[s\\u017F]tudie[s\\u017F][\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]+/i,\n    token: \"keyword\",\n    next: \"studiesArgs\"\n  }, {\n    regex: /blob[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF][\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]/i,\n    token: \"blob\"\n  }, {\n    // eslint-disable-next-line max-len\n    regex: /(auto|if|pau[s\\u017F]e|[s\\u017F]tudie[s\\u017F]|time[\\t ]+theorem[s\\u017F]?|[s\\u017F]pace[\\t ]+theorem[s\\u017F]?|until|wait|while|blac[k\\u212A][\\t ]+hole|[s\\u017F]tored?[\\t ]+game[\\t ]+time|notify)[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]/i,\n    token: \"keyword\",\n    next: \"commandArgs\"\n  }, {\n    regex: /[s\\u017F]top/i,\n    token: \"keyword\",\n    next: \"commandDone\"\n  }, {\n    regex: /[s\\u017F]tart[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]|unloc[k\\u212A][\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]/i,\n    token: \"keyword\",\n    next: \"startUnlock\"\n  }, {\n    regex: /infinity(?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+|eternity(?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+|reality(?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+|pau[s\\u017F]e(?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+|re[s\\u017F]tart(?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+/i,\n    token: \"error\",\n    next: \"commandDone\"\n  }, {\n    regex: /infinity|eternity|reality/i,\n    token: \"keyword\",\n    next: \"prestige\"\n  }, {\n    regex: /pau[s\\u017F]e|re[s\\u017F]tart/i,\n    token: \"keyword\",\n    next: \"commandDone\"\n  }, {\n    regex: /\\}/i,\n    dedent: true\n  }, {\n    regex: /(?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]/i,\n    token: \"error\",\n    next: \"commandDone\"\n  }],\n  studiesArgs: [commentRule, {\n    sol: true,\n    next: \"start\"\n  }, {\n    regex: /load([\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]+|$)/i,\n    token: \"variable-2\",\n    next: \"studiesLoad\"\n  }, {\n    regex: /re[s\\u017F]pec/i,\n    token: \"variable-2\",\n    next: \"commandDone\"\n  }, {\n    regex: /purcha[s\\u017F]e/i,\n    token: \"variable-2\",\n    next: \"studiesList\"\n  }, {\n    regex: /nowait([\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]+|$)/i,\n    token: \"property\"\n  }],\n  studiesList: [commentRule, {\n    sol: true,\n    next: \"start\"\n  }, {\n    regex: /(antimatter|infinity|time)(?=[\\t-\\r ,\\|\\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]|$)/i,\n    token: \"number\"\n  }, {\n    regex: /(active|pa[s\\u017F][s\\u017F]ive|idle)(?=[\\t-\\r ,\\|\\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]|$)/i,\n    token: \"number\"\n  }, {\n    regex: /(light|dar[k\\u212A])(?=[\\t-\\r ,\\|\\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]|$)/i,\n    token: \"number\"\n  }, {\n    regex: /([1-9][0-9]+)(?=[\\t-\\r !,\\x2D\\|\\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]|$)/i,\n    token: \"number\"\n  }, {\n    regex: /[A-Z_a-z][0-9A-Z_a-z]*/,\n    token: \"variable\",\n    next: \"commandDone\"\n  }, {\n    regex: /!$/i,\n    token: \"variable-2\"\n  }, {\n    regex: /([1-9]|1[0-2])(?=!|$)/i,\n    token: \"number\"\n  }],\n  studiesLoad: [commentRule, {\n    sol: true,\n    next: \"start\"\n  }, {\n    regex: /id([\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]+|$)/i,\n    token: \"variable-2\",\n    next: \"studiesLoadId\"\n  }, {\n    regex: /name([\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]+|$)/i,\n    token: \"variable-2\",\n    next: \"studiesLoadPreset\"\n  }, {\n    regex: /(?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+/i,\n    token: \"error\"\n  }],\n  studiesLoadId: [commentRule, {\n    sol: true,\n    next: \"start\"\n  }, {\n    regex: /[0-9]/i,\n    token: \"qualifier\",\n    next: \"commandDone\"\n  }],\n  studiesLoadPreset: [commentRule, {\n    sol: true,\n    next: \"start\"\n  }, {\n    regex: /(\\/(?!\\/)|(?:(?![\\t-\\r #\\/\\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF])[\\s\\S]))+/i,\n    token: \"qualifier\",\n    next: \"commandDone\"\n  }],\n  prestige: [commentRule, {\n    sol: true,\n    next: \"start\"\n  }, {\n    regex: /nowait([\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]|$)/i,\n    token: \"property\"\n  }, {\n    regex: /re[s\\u017F]pec/i,\n    token: \"variable-2\"\n  }],\n  commandDone: [commentRule, {\n    sol: true,\n    next: \"start\"\n  }, // This seems necessary to have a closing curly brace de-indent automatically in some cases\n  {\n    regex: /\\}/i,\n    dedent: true\n  }, {\n    regex: /(?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+/i,\n    token: \"error\"\n  }],\n  startUnlock: [commentRule, {\n    sol: true,\n    next: \"start\"\n  }, {\n    regex: /ec[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]?(1[0-2]|[1-9])|dilation/i,\n    token: \"variable-2\",\n    next: \"commandDone\"\n  }, {\n    regex: /nowait([\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]|$)/i,\n    token: \"property\"\n  }],\n  commandArgs: [commentRule, {\n    sol: true,\n    next: \"start\"\n  }, {\n    regex: /<=|>=|<|>/i,\n    token: \"operator\"\n  }, {\n    regex: /nowait([\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]|$)/i,\n    token: \"property\"\n  }, {\n    regex: /\"(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*\"/i,\n    token: \"string\",\n    next: \"commandDone\"\n  }, {\n    regex: /'(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*'/i,\n    token: \"string\",\n    next: \"commandDone\"\n  }, {\n    regex: /(on|off|bh1|bh2|dilation|load|re[s\\u017F]pec)([\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]|$)/i,\n    token: \"variable-2\"\n  }, {\n    regex: /(eternity|reality|u[s\\u017F]e)([\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]|$)/i,\n    token: \"variable-2\"\n  }, {\n    regex: /(antimatter|infinity|time)([\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]|$|(?=,))/i,\n    token: \"variable-2\"\n  }, {\n    regex: /(active|pa[s\\u017F][s\\u017F]ive|idle)([\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]|$|(?=,))/i,\n    token: \"variable-2\"\n  }, {\n    regex: /(light|dar[k\\u212A])([\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]|$|(?=,))/i,\n    token: \"variable-2\"\n  }, {\n    regex: /x[\\t ]+highe[s\\u017F]t([\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]|$)/i,\n    token: \"variable-2\"\n  }, {\n    regex: /pending[\\t ]+(completion[s\\u017F]|ip|ep|tp|rm|glyph[\\t ]+level)([\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]|$)/i,\n    token: \"variable-2\"\n  }, {\n    regex: /total[\\t ]+(completion[s\\u017F]|tt|[s\\u017F]pace theorem[s\\u017F])([\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]|$)/i,\n    token: \"variable-2\"\n  }, {\n    regex: /filter[\\t ]+[s\\u017F]core/i,\n    token: \"variable-2\"\n  }, {\n    regex: /ec(1[0-2]|[1-9])[\\t ]+completion[s\\u017F]([\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]|$)/i,\n    token: \"variable-2\"\n  }, {\n    regex: /(am|ip|ep|all)([\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]|$)/i,\n    token: \"variable-2\"\n  }, {\n    regex: /(rm|rg|dt|tp|tt|[s\\u017F]pace theorem[s\\u017F]|(ban[k\\u212A]ed )?infinitie[s\\u017F]|eternitie[s\\u017F]|realitie[s\\u017F]|rep(licanti)?)([\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]|$)/i,\n    token: \"variable-2\"\n  }, {\n    regex: / [s\\u017F]ec(ond[s\\u017F] ?) ?| min(ute[s\\u017F] ?) ?| hour[s\\u017F] ?/i,\n    token: \"variable-2\"\n  }, {\n    regex: /([0-9]+:[0-5][0-9]:[0-5][0-9]|[0-5]?[0-9]:[0-5][0-9]|t[1-4])/i,\n    token: \"number\"\n  }, {\n    regex: /\\x2D?(0|[1-9][0-9]*)(\\.[0-9]+)?([Ee][\\+\\x2D]?[0-9]+)?/i,\n    token: \"number\"\n  }, {\n    regex: /[A-Z_a-z][0-9A-Z_a-z]*/,\n    token: \"variable\"\n  }, {\n    regex: /\\{/i,\n    indent: true,\n    next: \"commandDone\"\n  }, // This seems necessary to have a closing curly brace de-indent automatically in some cases\n  {\n    regex: /\\}/i,\n    dedent: true\n  }],\n  // The meta property contains global information about the mode. It\n  // can contain properties like lineComment, which are supported by\n  // all modes, and also directives like dontIndentStates, which are\n  // specific to simple modes.\n  meta: {\n    lineComment: \"//\",\n    electricChars: \"}\"\n  }\n});","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/automator/automator-codemirror.js"],"names":["lexer","tokenIds","compile","parser","walkSuggestion","suggestion","prefix","output","hasAutocomplete","$autocomplete","startsWith","isUnlocked","$unlocked","add","s","categoryMatches","CodeMirror","registerHelper","contents","_","editor","doc","getDoc","errors","map","e","message","info","severity","from","posFromIndex","startOffset","to","endOffset","cursor","getCursor","start","ch","end","line","getLine","test","charAt","lineStart","slice","currentPrefix","lineLex","tokenize","length","undefined","rawSuggestions","computeContentAssist","tokens","suggestions","Set","ruleStack","nextTokenType","list","Array","Pos","commentRule","regex","token","next","defineSimpleMode","dedent","studiesArgs","sol","studiesList","studiesLoad","studiesLoadId","studiesLoadPreset","prestige","commandDone","startUnlock","commandArgs","indent","meta","lineComment","electricChars"],"mappings":"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","sourcesContent":["import { lexer, tokenIds } from \"./lexer\";\r\nimport { compile } from \"./compiler\";\r\nimport { parser } from \"./parser\";\r\n\r\nfunction walkSuggestion(suggestion, prefix, output) {\r\n  const hasAutocomplete = suggestion.$autocomplete &&\r\n    suggestion.$autocomplete.startsWith(prefix) && suggestion.$autocomplete !== prefix;\r\n  const isUnlocked = suggestion.$unlocked ? suggestion.$unlocked() : true;\r\n  if (hasAutocomplete && isUnlocked) output.add(suggestion.$autocomplete);\r\n  for (const s of suggestion.categoryMatches) {\r\n    walkSuggestion(tokenIds[s], prefix, output);\r\n  }\r\n}\r\n\r\n// eslint-disable-next-line no-unused-vars\r\nCodeMirror.registerHelper(\"lint\", \"automato\", (contents, _, editor) => {\r\n  const doc = editor.getDoc();\r\n  const errors = compile(contents, true).errors;\r\n  return errors.map(e => ({\r\n    message: e.info,\r\n    severity: \"error\",\r\n    from: doc.posFromIndex(e.startOffset),\r\n    to: doc.posFromIndex(e.endOffset + 1),\r\n  }));\r\n});\r\n\r\nCodeMirror.registerHelper(\"hint\", \"anyword\", editor => {\r\n  const cursor = editor.getDoc().getCursor();\r\n  let start = cursor.ch;\r\n  const end = cursor.ch;\r\n  const line = editor.getLine(cursor.line);\r\n  while (start && /\\w/u.test(line.charAt(start - 1)))--start;\r\n  const lineStart = line.slice(0, start);\r\n  const currentPrefix = line.slice(start, end);\r\n  const lineLex = lexer.tokenize(lineStart);\r\n  if (lineLex.errors.length > 0) return undefined;\r\n  const rawSuggestions = parser.computeContentAssist(\"command\", lineLex.tokens);\r\n  const suggestions = new Set();\r\n  for (const s of rawSuggestions) {\r\n    if (s.ruleStack[1] === \"badCommand\") continue;\r\n    walkSuggestion(s.nextTokenType, currentPrefix, suggestions);\r\n  }\r\n  return {\r\n    list: Array.from(suggestions),\r\n    from: CodeMirror.Pos(cursor.line, start),\r\n    to: CodeMirror.Pos(cursor.line, end)\r\n  };\r\n});\r\n\r\nconst commentRule = { regex: /(\\/\\/|#).*/u, token: \"comment\", next: \"start\" };\r\n\r\n// This is a state machine which determines the syntax highlighting for the automator. Top-level props define\r\n// the states, the array entries define the transition rules which are checked in order of appearance, and next\r\n// specifies which state to transition to after consuming the given regex. Without an entry for \"next\" the state\r\n// machine will remain in the same state and run the transition check after consuming the regex. The \"next\" prop\r\n// in the line with \"sol\" is a fallback transition which will be followed if none of the rules are matched.\r\n// Matches to the regexes will color the matched text according to the specified color of cm-[token] in liquibyte.css\r\n// Note: This has no bearing on the actual functionality and behavior of the automator itself and is purely visual.\r\nCodeMirror.defineSimpleMode(\"automato\", {\r\n  // The start state contains the rules that are intially used\r\n  start: [\r\n    commentRule,\r\n    { regex: /studies\\s+/ui, token: \"keyword\", next: \"studiesArgs\" },\r\n    { regex: /blob\\s\\s/ui, token: \"blob\" },\r\n    {\r\n      // eslint-disable-next-line max-len\r\n      regex: /(auto|if|pause|studies|time[ \\t]+theorems?|space[ \\t]+theorems?|until|wait|while|black[ \\t]+hole|stored?[ \\t]+game[ \\t]+time|notify)\\s/ui,\r\n      token: \"keyword\",\r\n      next: \"commandArgs\"\r\n    },\r\n    {\r\n      regex: /stop/ui,\r\n      token: \"keyword\",\r\n      next: \"commandDone\"\r\n    },\r\n    {\r\n      regex: /start\\s|unlock\\s/ui,\r\n      token: \"keyword\",\r\n      next: \"startUnlock\"\r\n    },\r\n    { regex: /infinity\\S+|eternity\\S+|reality\\S+|pause\\S+|restart\\S+/ui, token: \"error\", next: \"commandDone\" },\r\n    { regex: /infinity|eternity|reality/ui, token: \"keyword\", next: \"prestige\" },\r\n    { regex: /pause|restart/ui, token: \"keyword\", next: \"commandDone\" },\r\n    { regex: /\\}/ui, dedent: true },\r\n    { regex: /\\S+\\s/ui, token: \"error\", next: \"commandDone\" },\r\n  ],\r\n  studiesArgs: [\r\n    commentRule,\r\n    { sol: true, next: \"start\" },\r\n    { regex: /load(\\s+|$)/ui, token: \"variable-2\", next: \"studiesLoad\" },\r\n    { regex: /respec/ui, token: \"variable-2\", next: \"commandDone\" },\r\n    { regex: /purchase/ui, token: \"variable-2\", next: \"studiesList\" },\r\n    { regex: /nowait(\\s+|$)/ui, token: \"property\" },\r\n  ],\r\n  studiesList: [\r\n    commentRule,\r\n    { sol: true, next: \"start\" },\r\n    { regex: /(antimatter|infinity|time)(?=[\\s,|]|$)/ui, token: \"number\" },\r\n    { regex: /(active|passive|idle)(?=[\\s,|]|$)/ui, token: \"number\" },\r\n    { regex: /(light|dark)(?=[\\s,|]|$)/ui, token: \"number\" },\r\n    { regex: /([1-9][0-9]+)(?=[\\s,!|-]|$)/ui, token: \"number\" },\r\n    { regex: /[a-zA-Z_][a-zA-Z_0-9]*/u, token: \"variable\", next: \"commandDone\" },\r\n    { regex: /!$/ui, token: \"variable-2\" },\r\n    { regex: /([1-9]|1[0-2])(?=!|$)/ui, token: \"number\" },\r\n  ],\r\n  studiesLoad: [\r\n    commentRule,\r\n    { sol: true, next: \"start\" },\r\n    { regex: /id(\\s+|$)/ui, token: \"variable-2\", next: \"studiesLoadId\" },\r\n    { regex: /name(\\s+|$)/ui, token: \"variable-2\", next: \"studiesLoadPreset\" },\r\n    { regex: /\\S+/ui, token: \"error\" },\r\n  ],\r\n  studiesLoadId: [\r\n    commentRule,\r\n    { sol: true, next: \"start\" },\r\n    { regex: /\\d/ui, token: \"qualifier\", next: \"commandDone\" },\r\n  ],\r\n  studiesLoadPreset: [\r\n    commentRule,\r\n    { sol: true, next: \"start\" },\r\n    { regex: /(\\/(?!\\/)|[^\\s#/])+/ui, token: \"qualifier\", next: \"commandDone\" },\r\n  ],\r\n  prestige: [\r\n    commentRule,\r\n    { sol: true, next: \"start\" },\r\n    { regex: /nowait(\\s|$)/ui, token: \"property\" },\r\n    { regex: /respec/ui, token: \"variable-2\" },\r\n  ],\r\n  commandDone: [\r\n    commentRule,\r\n    { sol: true, next: \"start\" },\r\n    // This seems necessary to have a closing curly brace de-indent automatically in some cases\r\n    { regex: /\\}/ui, dedent: true },\r\n    { regex: /\\S+/ui, token: \"error\" },\r\n  ],\r\n  startUnlock: [\r\n    commentRule,\r\n    { sol: true, next: \"start\" },\r\n    {\r\n      regex: /ec\\s?(1[0-2]|[1-9])|dilation/ui,\r\n      token: \"variable-2\",\r\n      next: \"commandDone\",\r\n    },\r\n    { regex: /nowait(\\s|$)/ui, token: \"property\" },\r\n  ],\r\n  commandArgs: [\r\n    commentRule,\r\n    { sol: true, next: \"start\" },\r\n    { regex: /<=|>=|<|>/ui, token: \"operator\" },\r\n    { regex: /nowait(\\s|$)/ui, token: \"property\" },\r\n    { regex: /\".*\"/ui, token: \"string\", next: \"commandDone\" },\r\n    { regex: /'.*'/ui, token: \"string\", next: \"commandDone\" },\r\n    { regex: /(on|off|bh1|bh2|dilation|load|respec)(\\s|$)/ui, token: \"variable-2\" },\r\n    { regex: /(eternity|reality|use)(\\s|$)/ui, token: \"variable-2\" },\r\n    { regex: /(antimatter|infinity|time)(\\s|$|(?=,))/ui, token: \"variable-2\" },\r\n    { regex: /(active|passive|idle)(\\s|$|(?=,))/ui, token: \"variable-2\" },\r\n    { regex: /(light|dark)(\\s|$|(?=,))/ui, token: \"variable-2\" },\r\n    { regex: /x[\\t ]+highest(\\s|$)/ui, token: \"variable-2\" },\r\n    { regex: /pending[\\t ]+(completions|ip|ep|tp|rm|glyph[\\t ]+level)(\\s|$)/ui, token: \"variable-2\" },\r\n    { regex: /total[\\t ]+(completions|tt|space theorems)(\\s|$)/ui, token: \"variable-2\" },\r\n    { regex: /filter[ \\t]+score/ui, token: \"variable-2\" },\r\n    { regex: /ec(1[0-2]|[1-9])[\\t ]+completions(\\s|$)/ui, token: \"variable-2\" },\r\n    { regex: /(am|ip|ep|all)(\\s|$)/ui, token: \"variable-2\" },\r\n    {\r\n      regex: /(rm|rg|dt|tp|tt|space theorems|(banked )?infinities|eternities|realities|rep(licanti)?)(\\s|$)/ui,\r\n      token: \"variable-2\",\r\n    },\r\n    { regex: / sec(onds ?) ?| min(utes ?) ?| hours ?/ui, token: \"variable-2\" },\r\n    { regex: /([0-9]+:[0-5][0-9]:[0-5][0-9]|[0-5]?[0-9]:[0-5][0-9]|t[1-4])/ui, token: \"number\" },\r\n    { regex: /-?(0|[1-9]\\d*)(\\.\\d+)?([eE][+-]?\\d+)?/ui, token: \"number\" },\r\n    { regex: /[a-zA-Z_][a-zA-Z_0-9]*/u, token: \"variable\" },\r\n    { regex: /\\{/ui, indent: true, next: \"commandDone\" },\r\n    // This seems necessary to have a closing curly brace de-indent automatically in some cases\r\n    { regex: /\\}/ui, dedent: true },\r\n  ],\r\n\r\n  // The meta property contains global information about the mode. It\r\n  // can contain properties like lineComment, which are supported by\r\n  // all modes, and also directives like dontIndentStates, which are\r\n  // specific to simple modes.\r\n  meta: {\r\n    lineComment: \"//\",\r\n    electricChars: \"}\",\r\n  }\r\n});\r\n"]},"metadata":{},"sourceType":"module"}