{"ast":null,"code":"import \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.string.replace-all.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport { compile } from \"./compiler\";\nexport const AUTOMATOR_COMMAND_STATUS = Object.freeze({\n  NEXT_INSTRUCTION: 0,\n  NEXT_TICK_SAME_INSTRUCTION: 1,\n  NEXT_TICK_NEXT_INSTRUCTION: 2,\n  // This is used to handle some special cases, like branches/loops:\n  SAME_INSTRUCTION: 3,\n  SKIP_INSTRUCTION: 4,\n  HALT: 5,\n  RESTART: 6\n});\nexport const AUTOMATOR_MODE = Object.freeze({\n  PAUSE: 1,\n  RUN: 2,\n  SINGLE_STEP: 3\n});\nexport const AUTOMATOR_VAR_TYPES = {\n  NUMBER: {\n    id: 0,\n    name: \"number\"\n  },\n  STUDIES: {\n    id: 1,\n    name: \"studies\"\n  },\n  DURATION: {\n    id: 2,\n    name: \"duration\"\n  },\n  UNKNOWN: {\n    id: -1,\n    name: \"unknown\"\n  }\n};\nexport const AUTOMATOR_TYPE = Object.freeze({\n  TEXT: 0,\n  BLOCK: 1\n});\n/**\r\n * This object represents a single entry on the execution stack. It's a combination\r\n * of transient and persistent values -- we don't store the compiled script or indices\r\n * in the player object, but they are part of the stack.\r\n */\n\nclass AutomatorStackEntry {\n  constructor(stackIndex) {\n    this._stackIndex = stackIndex;\n    this._commandIndex = 0;\n  } // This is used when a new thing is put on the stack (rather than us creating objects\n  // when loading a game)\n\n\n  initializeNew(commands) {\n    this._commands = commands;\n    this._commandIndex = 0;\n    this.persistent = {\n      lineNumber: commands[0].lineNumber,\n      commandState: null\n    };\n  }\n\n  get commandIndex() {\n    return this._commandIndex;\n  }\n\n  set commandIndex(value) {\n    this._commandIndex = value;\n    this.lineNumber = this._commands[value].lineNumber;\n  }\n\n  get lineNumber() {\n    return this.persistent.lineNumber;\n  }\n\n  set lineNumber(value) {\n    this.persistent.lineNumber = value;\n  }\n  /**\r\n  * @returns {object|null} commandState used by commands to track their own data, such as remaining wait time\r\n  */\n\n\n  get commandState() {\n    return this.persistent.commandState;\n  }\n\n  set commandState(value) {\n    this.persistent.commandState = value;\n  }\n\n  get persistent() {\n    return player.reality.automator.state.stack[this._stackIndex];\n  }\n\n  set persistent(value) {\n    player.reality.automator.state.stack[this._stackIndex] = value;\n  }\n\n  get commands() {\n    return this._commands;\n  }\n\n  set commands(value) {\n    this._commands = value;\n  }\n\n}\n\nexport class AutomatorScript {\n  constructor(id) {\n    this._id = id;\n    this.compile();\n  }\n\n  get id() {\n    return this._id;\n  }\n\n  get name() {\n    return this.persistent.name;\n  }\n\n  set name(value) {\n    this.persistent.name = value;\n  }\n\n  get persistent() {\n    return player.reality.automator.scripts[this._id];\n  }\n\n  get commands() {\n    return this._compiled;\n  }\n\n  get text() {\n    return this.persistent.content;\n  }\n\n  save(content) {\n    if (AutomatorData.isWithinLimit()) this.persistent.content = content;\n    this.compile();\n  }\n\n  compile() {\n    this._compiled = compile(this.text).compiled;\n  }\n\n  static create(name, content = \"\") {\n    const scripts = Object.keys(player.reality.automator.scripts);\n    const missingIndex = scripts.findIndex((x, y) => y + 1 !== Number(x));\n    let id = 1 + (missingIndex === -1 ? scripts.length : missingIndex); // On a fresh save, this executes before player is properly initialized\n\n    if (!player.reality.automator.scripts || id === 0) id = 1;\n    player.reality.automator.scripts[id] = {\n      id,\n      name,\n      content\n    };\n    return new AutomatorScript(id);\n  }\n\n}\nexport const AutomatorData = {\n  // Used for getting the correct EC count in event log\n  lastECCompletionCount: 0,\n  // Used as a flag to make sure that wait commands only add one entry to the log instead of every execution attempt\n  isWaiting: false,\n  waitStart: 0,\n  lastEvent: 0,\n  eventLog: [],\n  isEditorFullscreen: false,\n  needsRecompile: true,\n  cachedErrors: 0,\n  // This is to hold finished script templates as text in order to make the custom blocks for blockmato\n  blockTemplates: [],\n  undoBuffer: [],\n  redoBuffer: [],\n  charsSinceLastUndoState: 0,\n  MAX_ALLOWED_SCRIPT_CHARACTERS: 10000,\n  MAX_ALLOWED_TOTAL_CHARACTERS: 60000,\n  MAX_ALLOWED_SCRIPT_NAME_LENGTH: 15,\n  MAX_ALLOWED_SCRIPT_COUNT: 20,\n  MAX_ALLOWED_CONSTANT_NAME_LENGTH: 20,\n  // Note that a study string with ALL studies in unshortened form without duplicated studies is ~230 characters\n  MAX_ALLOWED_CONSTANT_VALUE_LENGTH: 250,\n  MAX_ALLOWED_CONSTANT_COUNT: 30,\n  MIN_CHARS_BETWEEN_UNDOS: 10,\n  MAX_UNDO_ENTRIES: 30,\n\n  scriptIndex() {\n    return player.reality.automator.state.editorScript;\n  },\n\n  currentScriptName() {\n    return player.reality.automator.scripts[this.scriptIndex()].name;\n  },\n\n  currentScriptText(index) {\n    var _player$reality$autom;\n\n    const toCheck = index || this.scriptIndex();\n    return (_player$reality$autom = player.reality.automator.scripts[toCheck]) === null || _player$reality$autom === void 0 ? void 0 : _player$reality$autom.content;\n  },\n\n  createNewScript(content, name) {\n    const newScript = AutomatorScript.create(name, content);\n    GameUI.notify.automator(`Imported Script \"${name}\"`);\n    player.reality.automator.state.editorScript = newScript.id;\n    AutomatorData.clearUndoData();\n    EventHub.dispatch(GAME_EVENT.AUTOMATOR_SAVE_CHANGED);\n  },\n\n  recalculateErrors() {\n    const toCheck = this.currentScriptText();\n    this.cachedErrors = compile(toCheck).errors;\n    this.cachedErrors.sort((a, b) => a.startLine - b.startLine);\n  },\n\n  currentErrors() {\n    if (this.needsRecompile) {\n      this.recalculateErrors();\n      this.needsRecompile = false;\n    }\n\n    return this.cachedErrors;\n  },\n\n  logCommandEvent(message, line) {\n    const currTime = Date.now();\n    this.eventLog.push({\n      // Messages often overflow the 120 col limit and extra spacing gets included in the message - remove it\n      message: message.replaceAll(/[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]?\\n[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]+/g, \" \"),\n      line: AutomatorBackend.translateLineNumber(line),\n      thisReality: Time.thisRealityRealTime.totalSeconds,\n      timestamp: currTime,\n      timegap: currTime - this.lastEvent\n    });\n    this.lastEvent = currTime; // Remove the oldest entry if the log is too large\n\n    if (this.eventLog.length > player.options.automatorEvents.maxEntries) this.eventLog.shift();\n  },\n\n  clearEventLog() {\n    this.eventLog = [];\n    this.lastEvent = 0;\n  },\n\n  // We need to get the current character count from the editor itself instead of the player object, because otherwise\n  // any changes made after getting above either limit will never be saved. Note that if the player is on the automator\n  // subtab before the automator is unlocked, editor is undefined\n  singleScriptCharacters() {\n    var _AutomatorTextUI$edit, _AutomatorTextUI$edit2;\n\n    return player.reality.automator.type === AUTOMATOR_TYPE.TEXT ? (_AutomatorTextUI$edit = (_AutomatorTextUI$edit2 = AutomatorTextUI.editor) === null || _AutomatorTextUI$edit2 === void 0 ? void 0 : _AutomatorTextUI$edit2.getDoc().getValue().length) !== null && _AutomatorTextUI$edit !== void 0 ? _AutomatorTextUI$edit : 0 : BlockAutomator.parseLines(BlockAutomator.lines).join(\"\\n\").length;\n  },\n\n  totalScriptCharacters() {\n    return Object.values(player.reality.automator.scripts).filter(s => s.id !== this.scriptIndex()).map(s => s.content.length).reduce((sum, len) => sum + len, 0) + this.singleScriptCharacters();\n  },\n\n  isWithinLimit() {\n    return this.singleScriptCharacters() <= this.MAX_ALLOWED_SCRIPT_CHARACTERS && this.totalScriptCharacters() <= this.MAX_ALLOWED_TOTAL_CHARACTERS;\n  },\n\n  // This must be called every time the current script or editor mode are changed\n  clearUndoData() {\n    this.undoBuffer = [];\n    this.redoBuffer = [];\n    this.charsSinceLastUndoState = 0;\n  },\n\n  // We only save an undo state every so often based on the number of characters that have been modified\n  // since the last state. This gets passed in as a parameter and gets called every time any typing is done,\n  // but only actually does something when that threshold is reached.\n  pushUndoData(data, newChars) {\n    // If the buffer is empty, then we need to immediately write to the buffer (ignoring character changes)\n    // because otherwise edits can't be fully undone back to the very first change\n    this.charsSinceLastUndoState += newChars;\n    const pastGap = this.charsSinceLastUndoState <= this.MIN_CHARS_BETWEEN_UNDOS;\n    if (pastGap && this.undoBuffer.length !== 0) return;\n    if (this.undoBuffer[this.undoBuffer.length - 1] !== data) this.undoBuffer.push(data);\n    if (this.undoBuffer.length > this.MAX_UNDO_ENTRIES) this.undoBuffer.shift();\n    this.charsSinceLastUndoState = 0;\n  },\n\n  pushRedoData(data) {\n    if (this.redoBuffer[this.redoBuffer.length - 1] !== data) this.redoBuffer.push(data);\n  },\n\n  // These following two methods pop the top entry off of the undo/redo stack and then push it\n  // onto the *other* stack before modifying all the relevant UI elements and player props. These\n  // could in principle be combined into one function to reduce boilerplace, but keeping them\n  // separate is probably more readable externally\n  undoScriptEdit() {\n    if (this.undoBuffer.length === 0 || Tabs.current._currentSubtab.name !== \"Automator\") return;\n    const undoContent = this.undoBuffer.pop();\n    this.pushRedoData(this.currentScriptText());\n    player.reality.automator.scripts[this.scriptIndex()].content = undoContent;\n    AutomatorBackend.saveScript(this.scriptIndex(), undoContent);\n    if (player.reality.automator.type === AUTOMATOR_TYPE.TEXT) AutomatorTextUI.editor.setValue(undoContent);else BlockAutomator.updateEditor(undoContent);\n  },\n\n  redoScriptEdit() {\n    if (this.redoBuffer.length === 0 || Tabs.current._currentSubtab.name !== \"Automator\") return;\n    const redoContent = this.redoBuffer.pop(); // We call this with a value which is always higher than said threshold, forcing the current text to be pushed\n\n    this.pushUndoData(this.currentScriptText(), 2 * this.MIN_CHARS_BETWEEN_UNDOS);\n    player.reality.automator.scripts[this.scriptIndex()].content = redoContent;\n    AutomatorBackend.saveScript(this.scriptIndex(), redoContent);\n    if (player.reality.automator.type === AUTOMATOR_TYPE.TEXT) AutomatorTextUI.editor.setValue(redoContent);else BlockAutomator.updateEditor(redoContent);\n  }\n\n};\nexport const LineEnum = {\n  Active: \"active\",\n  Event: \"event\",\n  Error: \"error\"\n}; // Manages line highlighting in a way which is agnostic to the current editor mode (line or block). Ironically this is\n// actually easier to manage in block mode as the Vue components render each line individually and we can just\n// conditionally add classes in the template. The highlighting in text mode needs to be spliced and removed inline\n// within the CodeMirror editor\n\nexport const AutomatorHighlighter = {\n  lines: {\n    active: -1,\n    event: -1,\n    error: -1\n  },\n\n  updateHighlightedLine(line, key) {\n    if (player.reality.automator.type === AUTOMATOR_TYPE.TEXT && line !== -1) {\n      if (!AutomatorTextUI.editor) return;\n      this.removeHighlightedTextLine(key);\n      this.addHighlightedTextLine(line, key);\n    } else {\n      this.lines[key] = line;\n    }\n  },\n\n  // We need to specifically remove the highlighting class from the old line before splicing it in for the new line\n  removeHighlightedTextLine(key) {\n    const removedLine = this.lines[key] - 1;\n    AutomatorTextUI.editor.removeLineClass(removedLine, \"background\", `c-automator-editor__${key}-line`);\n    AutomatorTextUI.editor.removeLineClass(removedLine, \"gutter\", `c-automator-editor__${key}-line-gutter`);\n    this.lines[key] = -1;\n  },\n\n  addHighlightedTextLine(line, key) {\n    AutomatorTextUI.editor.addLineClass(line - 1, \"background\", `c-automator-editor__${key}-line`);\n    AutomatorTextUI.editor.addLineClass(line - 1, \"gutter\", `c-automator-editor__${key}-line-gutter`);\n    this.lines[key] = line;\n  },\n\n  clearAllHighlightedLines() {\n    for (const lineType of Object.values(LineEnum)) {\n      if (player.reality.automator.type === AUTOMATOR_TYPE.TEXT && AutomatorTextUI.editor) {\n        for (let line = 0; line < AutomatorTextUI.editor.doc.size; line++) {\n          AutomatorTextUI.editor.removeLineClass(line, \"background\", `c-automator-editor__${lineType}-line`);\n          AutomatorTextUI.editor.removeLineClass(line, \"gutter\", `c-automator-editor__${lineType}-line-gutter`);\n        }\n      }\n\n      this.lines[lineType] = -1;\n    }\n  }\n\n}; // Manages line highlighting in a way which is agnostic to the current editor mode (line or block)\n\nexport const AutomatorScroller = {\n  // Block editor counts lines differently due to modified loop structure; this method handles that internally\n  scrollToRawLine(line) {\n    const targetLine = player.reality.automator.type === AUTOMATOR_TYPE.TEXT ? line : AutomatorBackend.translateLineNumber(line);\n    this.scrollToLine(targetLine);\n  },\n\n  scrollToLine(line) {\n    let editor, textHeight, lineToScroll;\n\n    if (player.reality.automator.type === AUTOMATOR_TYPE.TEXT) {\n      // We can't use CodeMirror's scrollIntoView() method as that forces the entire viewport to keep the line in view.\n      // This can potentially cause a softlock with \"follow execution\" enabled on sufficiently short screens.\n      editor = document.querySelector(\".CodeMirror-scroll\");\n      textHeight = AutomatorTextUI.editor.defaultTextHeight();\n      lineToScroll = line + 1;\n    } else {\n      editor = BlockAutomator.editor;\n      textHeight = 34.5;\n      lineToScroll = line;\n    } // In both cases we might potentially try to scroll before the editor has properly initialized (ie. the automator\n    // itself ends up loading up faster than the editor UI element)\n\n\n    if (!editor) return;\n    const paddedHeight = editor.clientHeight - 40;\n    const newScrollPos = textHeight * (lineToScroll - 1);\n    if (newScrollPos > editor.scrollTop + paddedHeight) editor.scrollTo(0, newScrollPos - paddedHeight);\n    if (newScrollPos < editor.scrollTop) editor.scrollTo(0, newScrollPos);\n\n    if (player.reality.automator.type === AUTOMATOR_TYPE.BLOCK) {\n      BlockAutomator.gutter.style.bottom = `${editor.scrollTop}px`;\n    }\n  }\n\n};\nexport const AutomatorBackend = {\n  MAX_COMMANDS_PER_UPDATE: 100,\n  hasJustCompleted: false,\n  _scripts: [],\n\n  get state() {\n    return player.reality.automator.state;\n  },\n\n  // The Automator may be paused at some instruction, but still be on.\n  get isOn() {\n    return !this.stack.isEmpty;\n  },\n\n  /**\r\n  * @returns {AUTOMATOR_MODE}\r\n  */\n  get mode() {\n    return this.state.mode;\n  },\n\n  set mode(value) {\n    this.state.mode = value;\n  },\n\n  get isRunning() {\n    return this.isOn && this.mode === AUTOMATOR_MODE.RUN;\n  },\n\n  findRawScriptObject(id) {\n    const scripts = player.reality.automator.scripts;\n    const index = Object.values(scripts).findIndex(s => s.id === id);\n    return scripts[parseInt(Object.keys(scripts)[index], 10)];\n  },\n\n  get currentRunningScript() {\n    return this.findRawScriptObject(this.state.topLevelScript);\n  },\n\n  get currentEditingScript() {\n    return this.findRawScriptObject(player.reality.automator.state.editorScript);\n  },\n\n  get scriptName() {\n    var _this$currentRunningS, _this$currentRunningS2;\n\n    return (_this$currentRunningS = (_this$currentRunningS2 = this.currentRunningScript) === null || _this$currentRunningS2 === void 0 ? void 0 : _this$currentRunningS2.name) !== null && _this$currentRunningS !== void 0 ? _this$currentRunningS : \"\";\n  },\n\n  hasDuplicateName(name) {\n    const nameArray = Object.values(player.reality.automator.scripts).map(s => s.name);\n    return nameArray.filter(n => n === name).length > 1;\n  },\n\n  // Scripts are internally stored and run as text, but block mode has a different layout for loops that\n  // shifts a lot of commands around. Therefore we need to conditionally change it based on mode in order\n  // to make sure the player is presented with the correct line number\n  translateLineNumber(num) {\n    if (player.reality.automator.type === AUTOMATOR_TYPE.TEXT) return num;\n    return BlockAutomator.lineNumber(num);\n  },\n\n  get currentLineNumber() {\n    if (!this.stack.top) return -1;\n    return this.translateLineNumber(this.stack.top.lineNumber);\n  },\n\n  get currentInterval() {\n    return Math.clampMin(Math.pow(0.994, Currency.realities.value) * 500, 1);\n  },\n\n  get currentRawText() {\n    var _this$currentRunningS3, _this$currentRunningS4;\n\n    return (_this$currentRunningS3 = (_this$currentRunningS4 = this.currentRunningScript) === null || _this$currentRunningS4 === void 0 ? void 0 : _this$currentRunningS4.content) !== null && _this$currentRunningS3 !== void 0 ? _this$currentRunningS3 : \"\";\n  },\n\n  get currentScriptLength() {\n    return this.currentRawText.split(\"\\n\").length;\n  },\n\n  // Finds which study presets are referenced within the specified script\n  getUsedPresets(scriptID) {\n    const script = this.findRawScriptObject(scriptID);\n    if (!script) return null;\n    const foundPresets = new Set();\n    const lines = script.content.split(\"\\n\");\n\n    for (const rawLine of lines) {\n      const matchPresetID = rawLine.match(/[s\\u017F]tudie[s\\u017F]( nowait)? load id ([1-6])/i);\n      if (matchPresetID) foundPresets.add(Number(matchPresetID[2]) - 1);\n      const matchPresetName = rawLine.match(/[s\\u017F]tudie[s\\u017F]( nowait)? load name ((?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+)/i);\n\n      if (matchPresetName) {\n        // A script might pass the regex match, but actually be referencing a preset which doesn't exist by name\n        const presetID = player.timestudy.presets.findIndex(p => p.name === matchPresetName[2]);\n        if (presetID !== -1) foundPresets.add(presetID);\n      }\n    }\n\n    const presets = Array.from(foundPresets);\n    presets.sort();\n    return presets;\n  },\n\n  // Finds which constants are referenced within the specified script\n  getUsedConstants(scriptID) {\n    const script = this.findRawScriptObject(scriptID);\n    if (!script) return null;\n    const foundConstants = new Set();\n    const lines = script.content.split(\"\\n\");\n\n    for (const rawLine of lines) {\n      const availableConstants = Object.keys(player.reality.automator.constants); // Needs a space-padded regex match so that (for example) a constant \"unl\" doesn't match to an unlock command\n      // Additionally we need a negative lookbehind in order to ignore matches with presets which have the same name\n\n      for (const key of availableConstants) {\n        if (rawLine.match(`(?<![Nn][Aa][Mm][Ee])\\\\s${key}(\\\\s|$)`)) foundConstants.add(key);\n      }\n    }\n\n    const constants = Array.from(foundConstants);\n    constants.sort();\n    return constants;\n  },\n\n  // All modifications to constants should go these four methods in order to properly update both the constant prop and\n  // the sorting order prop while keeping them consistent with each other\n  addConstant(constantName, value) {\n    if (Object.keys(player.reality.automator.constants).length >= AutomatorData.MAX_ALLOWED_CONSTANT_COUNT) return;\n    player.reality.automator.constants[constantName] = value;\n    player.reality.automator.constantSortOrder.push(constantName);\n    EventHub.dispatch(GAME_EVENT.AUTOMATOR_CONSTANT_CHANGED);\n  },\n\n  modifyConstant(constantName, newValue) {\n    if (Object.keys(player.reality.automator.constants).includes(constantName)) {\n      player.reality.automator.constants[constantName] = newValue;\n      EventHub.dispatch(GAME_EVENT.AUTOMATOR_CONSTANT_CHANGED);\n    } else {\n      this.addConstant(constantName, newValue);\n    }\n  },\n\n  renameConstant(oldName, newName) {\n    const data = player.reality.automator.constants[oldName];\n    player.reality.automator.constants[newName] = data;\n    delete player.reality.automator.constants[oldName];\n    const index = player.reality.automator.constantSortOrder.indexOf(oldName);\n    if (index !== -1) player.reality.automator.constantSortOrder[index] = newName;\n    EventHub.dispatch(GAME_EVENT.AUTOMATOR_CONSTANT_CHANGED);\n  },\n\n  deleteConstant(constantName) {\n    delete player.reality.automator.constants[constantName];\n    const index = player.reality.automator.constantSortOrder.indexOf(constantName);\n    if (index > -1) player.reality.automator.constantSortOrder.splice(index, 1);\n    EventHub.dispatch(GAME_EVENT.AUTOMATOR_CONSTANT_CHANGED);\n  },\n\n  // We can't just concatenate different parts of script data together or use some kind of delimiting character string\n  // due to the fact that comments can essentially contain character sequences with nearly arbitrary content and\n  // length. Instead, we take the approach of concatenating all data together with their lengths prepended at the start\n  // of each respective data string. For example:\n  //    [\"blob\", \"11,21,31\"] => \"00004blob0000811,21,31\"\n  // Note that the whole string can be unambiguously parsed from left-to-right regardless of the actual data contents.\n  // All numerical values are assumed to be exactly 5 characters long for consistency and since the script length limit\n  // is 5 digits long.\n  serializeAutomatorData(dataArray) {\n    const paddedNumber = num => `0000${num}`.slice(-5);\n\n    const segments = [];\n\n    for (const data of dataArray) {\n      segments.push(`${paddedNumber(data.length)}${data}`);\n    }\n\n    return segments.join(\"\");\n  },\n\n  // Inverse of the operation performed by serializeAutomatorData(). Can throw an error for malformed inputs, but this\n  // will always be caught farther up the call chain and interpreted properly as an invalid dataString.\n  deserializeAutomatorData(dataString) {\n    if (dataString === \"\") throw new Error(\"Attempted deserialization of empty string\");\n    const dataArray = [];\n    let remainingData = dataString;\n\n    while (remainingData.length > 0) {\n      const segmentLength = Number(remainingData.slice(0, 5));\n      remainingData = remainingData.substr(5);\n\n      if (Number.isNaN(segmentLength) || remainingData.length < segmentLength) {\n        throw new Error(\"Inconsistent or malformed serialized automator data\");\n      } else {\n        const segmentData = remainingData.slice(0, segmentLength);\n        remainingData = remainingData.substr(segmentLength);\n        dataArray.push(segmentData);\n      }\n    }\n\n    return dataArray;\n  },\n\n  // This exports only the text contents of the currently-visible script\n  exportCurrentScriptContents() {\n    // Cut off leading and trailing whitespace\n    const trimmed = AutomatorData.currentScriptText().replace(/^[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]*((?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*?)[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]*$/, \"$1\");\n    if (trimmed.length === 0) return null; // Serialize the script name and content\n\n    const name = AutomatorData.currentScriptName();\n    return GameSaveSerializer.encodeText(this.serializeAutomatorData([name, trimmed]), \"automator script\");\n  },\n\n  // This parses script content from an encoded export string; does not actually import anything\n  parseScriptContents(rawInput) {\n    let decoded, parts;\n\n    try {\n      decoded = GameSaveSerializer.decodeText(rawInput, \"automator script\");\n      parts = this.deserializeAutomatorData(decoded);\n    } catch (e) {\n      return null;\n    }\n\n    return {\n      name: parts[0],\n      content: parts[1]\n    };\n  },\n\n  // Creates a new script from the supplied import string\n  importScriptContents(rawInput) {\n    const parsed = this.parseScriptContents(rawInput);\n    AutomatorData.createNewScript(parsed.content, parsed.name);\n    this.initializeFromSave();\n  },\n\n  // This exports the selected script along with any constants and study presets it uses or references\n  exportFullScriptData(scriptID) {\n    const script = this.findRawScriptObject(scriptID);\n    const trimmed = script.content.replace(/^[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]*((?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*?)[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]*$/, \"$1\");\n    if (trimmed.length === 0) return null;\n    const foundPresets = new Set();\n    const foundConstants = new Set();\n    const lines = trimmed.split(\"\\n\"); // We find just the keys first, the rest of the associated data is serialized later\n\n    for (const rawLine of lines) {\n      const matchPresetID = rawLine.match(/[s\\u017F]tudie[s\\u017F]( nowait)? load id ([1-6])/i);\n      if (matchPresetID) foundPresets.add(Number(matchPresetID[2]) - 1);\n      const matchPresetName = rawLine.match(/[s\\u017F]tudie[s\\u017F]( nowait)? load name ((?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+)/i);\n\n      if (matchPresetName) {\n        // A script might pass the regex match, but actually be referencing a preset which doesn't exist by name\n        const presetID = player.timestudy.presets.findIndex(p => p.name === matchPresetName[2]);\n        if (presetID !== -1) foundPresets.add(presetID);\n      }\n\n      const availableConstants = Object.keys(player.reality.automator.constants);\n\n      for (const key of availableConstants) if (rawLine.match(`\\\\s${key}(\\\\s|$)`)) foundConstants.add(key);\n    } // Serialize presets\n\n\n    const presets = [];\n\n    for (const id of Array.from(foundPresets)) {\n      var _preset$name, _preset$studies;\n\n      const preset = player.timestudy.presets[id];\n      presets.push(`${id}:${(_preset$name = preset === null || preset === void 0 ? void 0 : preset.name) !== null && _preset$name !== void 0 ? _preset$name : \"\"}:${(_preset$studies = preset === null || preset === void 0 ? void 0 : preset.studies) !== null && _preset$studies !== void 0 ? _preset$studies : \"\"}`);\n    } // Serialize constants\n\n\n    const constants = [];\n\n    for (const name of Array.from(foundConstants)) {\n      constants.push(`${name}:${player.reality.automator.constants[name]}`);\n    } // Serialize all the variables for the full data export\n\n\n    const serialized = this.serializeAutomatorData([script.name, presets.join(\"*\"), constants.join(\"*\"), trimmed]);\n    return GameSaveSerializer.encodeText(serialized, \"automator data\");\n  },\n\n  // This parses scripts which also have attached information in the form of associated constants and study presets.\n  // Note that it doesn't actually import or assign the data to the save file at this point.\n  parseFullScriptData(rawInput) {\n    let decoded, parts;\n\n    try {\n      decoded = GameSaveSerializer.decodeText(rawInput, \"automator data\");\n      parts = this.deserializeAutomatorData(decoded);\n    } catch (e) {\n      return null;\n    }\n\n    if (parts.length !== 4) return null; // Parse preset data (needs the conditional because otherwise it'll use the empty string to assign 0/undef/undef)\n\n    const presetData = parts[1];\n    const presets = [];\n\n    if (presetData) {\n      for (const preset of presetData.split(\"*\")) {\n        const props = preset.split(\":\");\n        presets.push({\n          id: Number(props[0]),\n          name: props[1],\n          studies: props[2]\n        });\n      }\n    }\n\n    presets.sort((a, b) => a.id - b.id); // Parse constant data\n\n    const constantData = parts[2];\n    const constants = [];\n\n    for (const constant of constantData.split(\"*\")) {\n      if (constant === \"\") continue;\n      const props = constant.split(\":\");\n      constants.push({\n        key: props[0],\n        value: props[1]\n      });\n    }\n\n    return {\n      name: parts[0],\n      presets,\n      constants,\n      content: parts[3]\n    };\n  },\n\n  // This imports a given script, with options supplied for ignoring included presets and constants\n  // within the import data.\n  importFullScriptData(rawInput, ignore) {\n    const parsed = this.parseFullScriptData(rawInput);\n    AutomatorData.createNewScript(parsed.content, parsed.name);\n\n    if (!ignore.presets) {\n      for (const preset of parsed.presets) {\n        player.timestudy.presets[preset.id] = {\n          name: preset.name,\n          studies: preset.studies\n        };\n      }\n    }\n\n    if (!ignore.constants) {\n      for (const constant of parsed.constants) {\n        this.modifyConstant(constant.key, constant.value);\n      }\n    }\n\n    this.initializeFromSave();\n  },\n\n  update(diff) {\n    if (!this.isOn) return;\n    let stack;\n\n    switch (this.mode) {\n      case AUTOMATOR_MODE.PAUSE:\n        return;\n\n      case AUTOMATOR_MODE.SINGLE_STEP:\n        this.singleStep();\n        stack = AutomatorBackend.stack.top; // If single step completes the last line and repeat is off, the command stack will be empty and\n        // scrolling will cause an error\n\n        if (stack && this.state.followExecution) AutomatorScroller.scrollToRawLine(stack.lineNumber);\n        this.state.mode = AUTOMATOR_MODE.PAUSE;\n        return;\n\n      case AUTOMATOR_MODE.RUN:\n        break;\n\n      default:\n        this.stop();\n        return;\n    }\n\n    player.reality.automator.execTimer += diff;\n    const commandsThisUpdate = Math.min(Math.floor(player.reality.automator.execTimer / this.currentInterval), this.MAX_COMMANDS_PER_UPDATE);\n    player.reality.automator.execTimer -= commandsThisUpdate * this.currentInterval;\n\n    for (let count = 0; count < commandsThisUpdate && this.isRunning; ++count) {\n      if (!this.step()) break;\n    }\n  },\n\n  step() {\n    if (this.stack.isEmpty) return false;\n\n    for (let steps = 0; steps < 100 && !this.hasJustCompleted; steps++) {\n      switch (this.runCurrentCommand()) {\n        case AUTOMATOR_COMMAND_STATUS.SAME_INSTRUCTION:\n          return true;\n\n        case AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION:\n          return this.nextCommand();\n\n        case AUTOMATOR_COMMAND_STATUS.NEXT_TICK_SAME_INSTRUCTION:\n          return false;\n\n        case AUTOMATOR_COMMAND_STATUS.NEXT_TICK_NEXT_INSTRUCTION:\n          this.nextCommand();\n          return false;\n\n        case AUTOMATOR_COMMAND_STATUS.SKIP_INSTRUCTION:\n          this.nextCommand();\n          break;\n\n        case AUTOMATOR_COMMAND_STATUS.HALT:\n          this.stop();\n          return false;\n\n        case AUTOMATOR_COMMAND_STATUS.RESTART:\n          this.restart();\n          return false;\n      } // We need to break out of the loop if the last commands are all SKIP_INSTRUCTION, or else it'll start\n      // trying to execute from an undefined stack if it isn't set to automatically repeat\n\n\n      if (!this.stack.top) this.hasJustCompleted = true;\n    } // This should in practice never happen by accident due to it requiring 100 consecutive commands that don't do\n    // anything (looping a smaller group of no-ops will instead trigger the loop check every tick). Nevertheless,\n    // better to not have an explicit infinite loop so that the game doesn't hang if the player decides to be funny\n    // and input 3000 comments in a row. If hasJustCompleted is true, then we actually broke out because the end of\n    // the script has no-ops and we just looped through them, and therefore shouldn't show these messages\n\n\n    if (!this.hasJustCompleted) {\n      GameUI.notify.error(\"Automator halted - too many consecutive no-ops detected\");\n      AutomatorData.logCommandEvent(\"Automator halted due to excessive no-op commands\", this.currentLineNumber);\n    }\n\n    this.stop();\n    return false;\n  },\n\n  singleStep() {\n    if (this.stack.isEmpty) return; // SAME_INSTRUCTION is used to enter blocks; this means we've successfully\n    // advanced a line. Otherwise, we always advance a line, regardless of return\n    // state.\n    // HALT and RESTART are exceptions, as these are called by commands which force\n    // program flow to do something else other than simply advancing to the next line\n\n    switch (this.runCurrentCommand()) {\n      case AUTOMATOR_COMMAND_STATUS.NEXT_TICK_SAME_INSTRUCTION:\n        break;\n\n      case AUTOMATOR_COMMAND_STATUS.HALT:\n        this.stop();\n        break;\n\n      case AUTOMATOR_COMMAND_STATUS.RESTART:\n        this.restart();\n        break;\n\n      default:\n        this.nextCommand();\n        break;\n    }\n  },\n\n  runCurrentCommand() {\n    const S = this.stack.top;\n    const cmdState = S.commands[S.commandIndex].run(S);\n    return cmdState;\n  },\n\n  nextCommand() {\n    const S = this.stack.top;\n\n    if (S.commandIndex >= S.commands.length - 1) {\n      this.stack.pop();\n\n      if (this.stack.isEmpty) {\n        // With the debug output on, running short scripts gets very spammy, working around that\n        // return false here makes sure that a single instruction script executes one tick at a time\n        if (this.state.repeat) {\n          this.start(this.state.topLevelScript, AUTOMATOR_MODE.RUN, false);\n          return false;\n        }\n\n        this.stop();\n      } else if (this.stack.top.commandState && this.stack.top.commandState.advanceOnPop) {\n        AutomatorData.logCommandEvent(`Exiting IF block`, this.stack.top.commandState.ifEndLine);\n        return this.nextCommand();\n      }\n    } else {\n      S.commandState = null;\n      ++S.commandIndex;\n    }\n\n    return true;\n  },\n\n  push(commands) {\n    // We do not allow empty scripts on the stack.\n    if (commands.length === 0) return;\n    this.stack.push(commands);\n  },\n\n  findScript(id) {\n    return this._scripts.find(e => e.id === id);\n  },\n\n  _createDefaultScript() {\n    const defaultScript = AutomatorScript.create(\"New Script\");\n    this._scripts = [defaultScript];\n    this.state.topLevelScript = defaultScript.id;\n    return defaultScript.id;\n  },\n\n  initializeFromSave() {\n    const scriptIds = Object.keys(player.reality.automator.scripts).map(id => parseInt(id, 10));\n\n    if (scriptIds.length === 0) {\n      scriptIds.push(this._createDefaultScript());\n    } else {\n      this._scripts = scriptIds.map(s => new AutomatorScript(s));\n    }\n\n    if (!scriptIds.includes(this.state.topLevelScript)) this.state.topLevelScript = scriptIds[0];\n    const currentScript = this.findScript(this.state.topLevelScript);\n\n    if (currentScript.commands) {\n      const commands = currentScript.commands;\n      if (!this.stack.initializeFromSave(commands)) this.reset(commands);\n    } else {\n      this.stack.clear();\n    }\n  },\n\n  // Note: This gets run every time any edit or mode conversion is done\n  saveScript(id, data) {\n    const script = this.findScript(id);\n    if (!script) return; // Add the old data to the undo buffer; there are internal checks which prevent it from saving too often.\n    // For performance, the contents of the script aren't actually checked (this would be an unavoidable O(n) cost).\n    // Instead we naively assume length changes are pure insertions and deletions, which does mean we're ignoring\n    // a few edge cases when changes are really substitutions that massively change the content\n\n    const oldData = script.persistent.content;\n    const lenChange = Math.abs(oldData.length - data.length);\n    AutomatorData.pushUndoData(oldData, lenChange);\n    script.save(data);\n    if (id === this.state.topLevelScript) this.stop();\n  },\n\n  newScript() {\n    // Make sure the new script has a unique name\n    const scriptNames = AutomatorBackend._scripts.map(s => s.name);\n\n    let newScript;\n\n    if (scriptNames.includes(\"New Script\")) {\n      let newIndex = 2;\n\n      while (scriptNames.includes(`New Script (${newIndex})`)) newIndex++;\n\n      newScript = AutomatorScript.create(`New Script (${newIndex})`);\n    } else {\n      newScript = AutomatorScript.create(\"New Script\");\n    }\n\n    this._scripts.push(newScript);\n\n    return newScript;\n  },\n\n  // Note that deleting scripts leaves gaps in the automator script indexing since automator scripts can't be\n  // dynamically re-indexed while the automator is running without causing a stutter from recompiling scripts.\n  deleteScript(id) {\n    // We need to delete scripts from two places - in the savefile and compiled AutomatorScript Objects\n    const saveId = Object.values(player.reality.automator.scripts).findIndex(s => s.id === id);\n    delete player.reality.automator.scripts[parseInt(Object.keys(player.reality.automator.scripts)[saveId], 10)];\n\n    const idx = this._scripts.findIndex(e => e.id === id);\n\n    this._scripts.splice(idx, 1);\n\n    if (this._scripts.length === 0) {\n      this._createDefaultScript();\n\n      this.clearEditor();\n    }\n\n    if (id === this.state.topLevelScript) {\n      this.stop();\n      this.state.topLevelScript = this._scripts[0].id;\n    }\n\n    EventHub.dispatch(GAME_EVENT.AUTOMATOR_SAVE_CHANGED);\n  },\n\n  toggleRepeat() {\n    this.state.repeat = !this.state.repeat;\n  },\n\n  toggleForceRestart() {\n    this.state.forceRestart = !this.state.forceRestart;\n  },\n\n  toggleFollowExecution() {\n    this.state.followExecution = !this.state.followExecution;\n    this.jumpToActiveLine();\n  },\n\n  jumpToActiveLine() {\n    const state = this.state;\n    const focusedScript = state.topLevelScript === state.editorScript;\n\n    if (focusedScript && this.isRunning && state.followExecution) {\n      AutomatorScroller.scrollToRawLine(AutomatorBackend.stack.top.lineNumber);\n    }\n  },\n\n  reset(commands) {\n    this.stack.clear();\n    this.push(commands);\n  },\n\n  stop() {\n    this.stack.clear();\n    this.state.mode = AUTOMATOR_MODE.PAUSE;\n    this.hasJustCompleted = true;\n    AutomatorHighlighter.clearAllHighlightedLines();\n  },\n\n  pause() {\n    this.state.mode = AUTOMATOR_MODE.PAUSE;\n  },\n\n  start(scriptID = this.state.topLevelScript, initialMode = AUTOMATOR_MODE.RUN, compile = true) {\n    // Automator execution behaves oddly across new games, so we explicitly stop it from running if not unlocked\n    if (!Player.automatorUnlocked) return;\n    this.hasJustCompleted = false;\n    this.state.topLevelScript = scriptID;\n    player.reality.automator.execTimer = 0;\n    const scriptObject = this.findScript(scriptID);\n    if (!scriptObject) return;\n    if (compile) scriptObject.compile();\n\n    if (scriptObject.commands) {\n      this.reset(scriptObject.commands);\n      this.state.mode = initialMode;\n    }\n\n    AutomatorData.isWaiting = false;\n    if (player.options.automatorEvents.clearOnRestart) AutomatorData.clearEventLog();\n  },\n\n  restart() {\n    // Sometimes this leads to start getting called twice in quick succession but it's close enough\n    // that there's usually no command in between (possibly same tick).\n    this.start(this.state.topLevelScript, AUTOMATOR_MODE.RUN);\n    if (this.stack.isEmpty) return;\n    this.reset(this.stack._data[0].commands);\n  },\n\n  changeModes(scriptID) {\n    Tutorial.moveOn(TUTORIAL_STATE.AUTOMATOR);\n\n    if (player.reality.automator.type === AUTOMATOR_TYPE.BLOCK) {\n      // This saves the script after converting it.\n      BlockAutomator.parseTextFromBlocks();\n      player.reality.automator.type = AUTOMATOR_TYPE.TEXT;\n    } else {\n      const toConvert = AutomatorTextUI.editor.getDoc().getValue(); // Needs to be called to update the lines prop in the BlockAutomator object\n\n      BlockAutomator.updateEditor(toConvert);\n      AutomatorBackend.saveScript(scriptID, toConvert);\n      player.reality.automator.type = AUTOMATOR_TYPE.BLOCK;\n    }\n\n    AutomatorHighlighter.clearAllHighlightedLines();\n    EventHub.ui.dispatch(GAME_EVENT.AUTOMATOR_TYPE_CHANGED);\n  },\n\n  clearEditor() {\n    if (player.reality.automator.type === AUTOMATOR_TYPE.BLOCK) {\n      BlockAutomator.clearEditor();\n    } else {\n      AutomatorTextUI.clearEditor();\n    }\n  },\n\n  stack: {\n    _data: [],\n\n    push(commands) {\n      const newEntry = new AutomatorStackEntry(this.length);\n      newEntry.initializeNew(commands);\n\n      this._data.push(newEntry);\n    },\n\n    pop() {\n      if (this._data.length === 0) return;\n      player.reality.automator.state.stack.pop();\n\n      this._data.pop();\n    },\n\n    clear() {\n      this._data = [];\n      player.reality.automator.state.stack.length = 0;\n    },\n\n    initializeFromSave(commands) {\n      this._data = [];\n      const playerStack = player.reality.automator.state.stack;\n      let currentCommands = commands;\n\n      for (let depth = 0; depth < playerStack.length; ++depth) {\n        const playerEntry = playerStack[depth];\n        const newEntry = new AutomatorStackEntry(depth);\n        newEntry.commands = currentCommands;\n        const foundIndex = currentCommands.findIndex(e => e.lineNumber === playerEntry.lineNumber);\n\n        if (foundIndex === -1) {\n          // Could not match stack state to script, have to reset automato\n          return false;\n        }\n\n        newEntry.commandIndex = foundIndex;\n\n        this._data.push(newEntry); // Are we inside a code block?\n\n\n        if (depth !== playerStack.length - 1) {\n          if (currentCommands[foundIndex].blockCommands === undefined) {\n            return false;\n          }\n\n          currentCommands = currentCommands[foundIndex].blockCommands;\n        }\n      }\n\n      return true;\n    },\n\n    get top() {\n      return this._data[this.length - 1];\n    },\n\n    get length() {\n      if (this._data.length !== player.reality.automator.state.stack.length) {\n        throw new Error(\"Inconsistent stack length\");\n      }\n\n      return this._data.length;\n    },\n\n    get isEmpty() {\n      return this._data.length === 0;\n    }\n\n  }\n};","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/automator/automator-backend.js"],"names":["compile","AUTOMATOR_COMMAND_STATUS","Object","freeze","NEXT_INSTRUCTION","NEXT_TICK_SAME_INSTRUCTION","NEXT_TICK_NEXT_INSTRUCTION","SAME_INSTRUCTION","SKIP_INSTRUCTION","HALT","RESTART","AUTOMATOR_MODE","PAUSE","RUN","SINGLE_STEP","AUTOMATOR_VAR_TYPES","NUMBER","id","name","STUDIES","DURATION","UNKNOWN","AUTOMATOR_TYPE","TEXT","BLOCK","AutomatorStackEntry","constructor","stackIndex","_stackIndex","_commandIndex","initializeNew","commands","_commands","persistent","lineNumber","commandState","commandIndex","value","player","reality","automator","state","stack","AutomatorScript","_id","scripts","_compiled","text","content","save","AutomatorData","isWithinLimit","compiled","create","keys","missingIndex","findIndex","x","y","Number","length","lastECCompletionCount","isWaiting","waitStart","lastEvent","eventLog","isEditorFullscreen","needsRecompile","cachedErrors","blockTemplates","undoBuffer","redoBuffer","charsSinceLastUndoState","MAX_ALLOWED_SCRIPT_CHARACTERS","MAX_ALLOWED_TOTAL_CHARACTERS","MAX_ALLOWED_SCRIPT_NAME_LENGTH","MAX_ALLOWED_SCRIPT_COUNT","MAX_ALLOWED_CONSTANT_NAME_LENGTH","MAX_ALLOWED_CONSTANT_VALUE_LENGTH","MAX_ALLOWED_CONSTANT_COUNT","MIN_CHARS_BETWEEN_UNDOS","MAX_UNDO_ENTRIES","scriptIndex","editorScript","currentScriptName","currentScriptText","index","toCheck","createNewScript","newScript","GameUI","notify","clearUndoData","EventHub","dispatch","GAME_EVENT","AUTOMATOR_SAVE_CHANGED","recalculateErrors","errors","sort","a","b","startLine","currentErrors","logCommandEvent","message","line","currTime","Date","now","push","replaceAll","AutomatorBackend","translateLineNumber","thisReality","Time","thisRealityRealTime","totalSeconds","timestamp","timegap","options","automatorEvents","maxEntries","shift","clearEventLog","singleScriptCharacters","type","AutomatorTextUI","editor","getDoc","getValue","BlockAutomator","parseLines","lines","join","totalScriptCharacters","values","filter","s","map","reduce","sum","len","pushUndoData","data","newChars","pastGap","pushRedoData","undoScriptEdit","Tabs","current","_currentSubtab","undoContent","pop","saveScript","setValue","updateEditor","redoScriptEdit","redoContent","LineEnum","Active","Event","Error","AutomatorHighlighter","active","event","error","updateHighlightedLine","key","removeHighlightedTextLine","addHighlightedTextLine","removedLine","removeLineClass","addLineClass","clearAllHighlightedLines","lineType","doc","size","AutomatorScroller","scrollToRawLine","targetLine","scrollToLine","textHeight","lineToScroll","document","querySelector","defaultTextHeight","paddedHeight","clientHeight","newScrollPos","scrollTop","scrollTo","gutter","style","bottom","MAX_COMMANDS_PER_UPDATE","hasJustCompleted","_scripts","isOn","isEmpty","mode","isRunning","findRawScriptObject","parseInt","currentRunningScript","topLevelScript","currentEditingScript","scriptName","hasDuplicateName","nameArray","n","num","currentLineNumber","top","currentInterval","Math","clampMin","pow","Currency","realities","currentRawText","currentScriptLength","split","getUsedPresets","scriptID","script","foundPresets","Set","rawLine","matchPresetID","match","add","matchPresetName","presetID","timestudy","presets","p","Array","from","getUsedConstants","foundConstants","availableConstants","constants","addConstant","constantName","constantSortOrder","AUTOMATOR_CONSTANT_CHANGED","modifyConstant","newValue","includes","renameConstant","oldName","newName","indexOf","deleteConstant","splice","serializeAutomatorData","dataArray","paddedNumber","slice","segments","deserializeAutomatorData","dataString","remainingData","segmentLength","substr","isNaN","segmentData","exportCurrentScriptContents","trimmed","replace","GameSaveSerializer","encodeText","parseScriptContents","rawInput","decoded","parts","decodeText","e","importScriptContents","parsed","initializeFromSave","exportFullScriptData","preset","studies","serialized","parseFullScriptData","presetData","props","constantData","constant","importFullScriptData","ignore","update","diff","singleStep","followExecution","stop","execTimer","commandsThisUpdate","min","floor","count","step","steps","runCurrentCommand","nextCommand","restart","S","cmdState","run","repeat","start","advanceOnPop","ifEndLine","findScript","find","_createDefaultScript","defaultScript","scriptIds","currentScript","reset","clear","oldData","lenChange","abs","scriptNames","newIndex","deleteScript","saveId","idx","clearEditor","toggleRepeat","toggleForceRestart","forceRestart","toggleFollowExecution","jumpToActiveLine","focusedScript","pause","initialMode","Player","automatorUnlocked","scriptObject","clearOnRestart","_data","changeModes","Tutorial","moveOn","TUTORIAL_STATE","AUTOMATOR","parseTextFromBlocks","toConvert","ui","AUTOMATOR_TYPE_CHANGED","newEntry","playerStack","currentCommands","depth","playerEntry","foundIndex","blockCommands","undefined"],"mappings":";;;;;;AAAA,SAASA,OAAT,QAAwB,YAAxB;AAEA,OAAO,MAAMC,wBAAwB,GAAGC,MAAM,CAACC,MAAP,CAAc;AACpDC,EAAAA,gBAAgB,EAAE,CADkC;AAEpDC,EAAAA,0BAA0B,EAAE,CAFwB;AAGpDC,EAAAA,0BAA0B,EAAE,CAHwB;AAIpD;AACAC,EAAAA,gBAAgB,EAAE,CALkC;AAMpDC,EAAAA,gBAAgB,EAAE,CANkC;AAOpDC,EAAAA,IAAI,EAAE,CAP8C;AAQpDC,EAAAA,OAAO,EAAE;AAR2C,CAAd,CAAjC;AAWP,OAAO,MAAMC,cAAc,GAAGT,MAAM,CAACC,MAAP,CAAc;AAC1CS,EAAAA,KAAK,EAAE,CADmC;AAE1CC,EAAAA,GAAG,EAAE,CAFqC;AAG1CC,EAAAA,WAAW,EAAE;AAH6B,CAAd,CAAvB;AAOP,OAAO,MAAMC,mBAAmB,GAAG;AACjCC,EAAAA,MAAM,EAAE;AAAEC,IAAAA,EAAE,EAAE,CAAN;AAASC,IAAAA,IAAI,EAAE;AAAf,GADyB;AAEjCC,EAAAA,OAAO,EAAE;AAAEF,IAAAA,EAAE,EAAE,CAAN;AAASC,IAAAA,IAAI,EAAE;AAAf,GAFwB;AAGjCE,EAAAA,QAAQ,EAAE;AAAEH,IAAAA,EAAE,EAAE,CAAN;AAASC,IAAAA,IAAI,EAAE;AAAf,GAHuB;AAIjCG,EAAAA,OAAO,EAAE;AAAEJ,IAAAA,EAAE,EAAE,CAAC,CAAP;AAAUC,IAAAA,IAAI,EAAE;AAAhB;AAJwB,CAA5B;AAOP,OAAO,MAAMI,cAAc,GAAGpB,MAAM,CAACC,MAAP,CAAc;AAC1CoB,EAAAA,IAAI,EAAE,CADoC;AAE1CC,EAAAA,KAAK,EAAE;AAFmC,CAAd,CAAvB;AAKP;AACA;AACA;AACA;AACA;;AACA,MAAMC,mBAAN,CAA0B;AACxBC,EAAAA,WAAW,CAACC,UAAD,EAAa;AACtB,SAAKC,WAAL,GAAmBD,UAAnB;AACA,SAAKE,aAAL,GAAqB,CAArB;AACD,GAJuB,CAMxB;AACA;;;AACAC,EAAAA,aAAa,CAACC,QAAD,EAAW;AACtB,SAAKC,SAAL,GAAiBD,QAAjB;AACA,SAAKF,aAAL,GAAqB,CAArB;AACA,SAAKI,UAAL,GAAkB;AAChBC,MAAAA,UAAU,EAAEH,QAAQ,CAAC,CAAD,CAAR,CAAYG,UADR;AAEhBC,MAAAA,YAAY,EAAE;AAFE,KAAlB;AAID;;AAEe,MAAZC,YAAY,GAAG;AACjB,WAAO,KAAKP,aAAZ;AACD;;AAEe,MAAZO,YAAY,CAACC,KAAD,EAAQ;AACtB,SAAKR,aAAL,GAAqBQ,KAArB;AACA,SAAKH,UAAL,GAAkB,KAAKF,SAAL,CAAeK,KAAf,EAAsBH,UAAxC;AACD;;AAEa,MAAVA,UAAU,GAAG;AACf,WAAO,KAAKD,UAAL,CAAgBC,UAAvB;AACD;;AAEa,MAAVA,UAAU,CAACG,KAAD,EAAQ;AACpB,SAAKJ,UAAL,CAAgBC,UAAhB,GAA6BG,KAA7B;AACD;AAED;AACF;AACA;;;AACkB,MAAZF,YAAY,GAAG;AACjB,WAAO,KAAKF,UAAL,CAAgBE,YAAvB;AACD;;AAEe,MAAZA,YAAY,CAACE,KAAD,EAAQ;AACtB,SAAKJ,UAAL,CAAgBE,YAAhB,GAA+BE,KAA/B;AACD;;AAEa,MAAVJ,UAAU,GAAG;AACf,WAAOK,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyBC,KAAzB,CAA+BC,KAA/B,CAAqC,KAAKd,WAA1C,CAAP;AACD;;AAEa,MAAVK,UAAU,CAACI,KAAD,EAAQ;AACpBC,IAAAA,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyBC,KAAzB,CAA+BC,KAA/B,CAAqC,KAAKd,WAA1C,IAAyDS,KAAzD;AACD;;AAEW,MAARN,QAAQ,GAAG;AACb,WAAO,KAAKC,SAAZ;AACD;;AAEW,MAARD,QAAQ,CAACM,KAAD,EAAQ;AAClB,SAAKL,SAAL,GAAiBK,KAAjB;AACD;;AA3DuB;;AA8D1B,OAAO,MAAMM,eAAN,CAAsB;AAC3BjB,EAAAA,WAAW,CAACT,EAAD,EAAK;AACd,SAAK2B,GAAL,GAAW3B,EAAX;AACA,SAAKjB,OAAL;AACD;;AAEK,MAAFiB,EAAE,GAAG;AACP,WAAO,KAAK2B,GAAZ;AACD;;AAEO,MAAJ1B,IAAI,GAAG;AACT,WAAO,KAAKe,UAAL,CAAgBf,IAAvB;AACD;;AAEO,MAAJA,IAAI,CAACmB,KAAD,EAAQ;AACd,SAAKJ,UAAL,CAAgBf,IAAhB,GAAuBmB,KAAvB;AACD;;AAEa,MAAVJ,UAAU,GAAG;AACf,WAAOK,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyBK,OAAzB,CAAiC,KAAKD,GAAtC,CAAP;AACD;;AAEW,MAARb,QAAQ,GAAG;AACb,WAAO,KAAKe,SAAZ;AACD;;AAEO,MAAJC,IAAI,GAAG;AACT,WAAO,KAAKd,UAAL,CAAgBe,OAAvB;AACD;;AAEDC,EAAAA,IAAI,CAACD,OAAD,EAAU;AACZ,QAAIE,aAAa,CAACC,aAAd,EAAJ,EAAmC,KAAKlB,UAAL,CAAgBe,OAAhB,GAA0BA,OAA1B;AACnC,SAAKhD,OAAL;AACD;;AAEDA,EAAAA,OAAO,GAAG;AACR,SAAK8C,SAAL,GAAiB9C,OAAO,CAAC,KAAK+C,IAAN,CAAP,CAAmBK,QAApC;AACD;;AAEY,SAANC,MAAM,CAACnC,IAAD,EAAO8B,OAAO,GAAG,EAAjB,EAAqB;AAChC,UAAMH,OAAO,GAAG3C,MAAM,CAACoD,IAAP,CAAYhB,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyBK,OAArC,CAAhB;AACA,UAAMU,YAAY,GAAGV,OAAO,CAACW,SAAR,CAAkB,CAACC,CAAD,EAAIC,CAAJ,KAAUA,CAAC,GAAG,CAAJ,KAAUC,MAAM,CAACF,CAAD,CAA5C,CAArB;AACA,QAAIxC,EAAE,GAAG,KAAKsC,YAAY,KAAK,CAAC,CAAlB,GAAsBV,OAAO,CAACe,MAA9B,GAAuCL,YAA5C,CAAT,CAHgC,CAIhC;;AACA,QAAI,CAACjB,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyBK,OAA1B,IAAqC5B,EAAE,KAAK,CAAhD,EAAmDA,EAAE,GAAG,CAAL;AACnDqB,IAAAA,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyBK,OAAzB,CAAiC5B,EAAjC,IAAuC;AACrCA,MAAAA,EADqC;AAErCC,MAAAA,IAFqC;AAGrC8B,MAAAA;AAHqC,KAAvC;AAKA,WAAO,IAAIL,eAAJ,CAAoB1B,EAApB,CAAP;AACD;;AAnD0B;AAsD7B,OAAO,MAAMiC,aAAa,GAAG;AAC3B;AACAW,EAAAA,qBAAqB,EAAE,CAFI;AAG3B;AACAC,EAAAA,SAAS,EAAE,KAJgB;AAK3BC,EAAAA,SAAS,EAAE,CALgB;AAM3BC,EAAAA,SAAS,EAAE,CANgB;AAO3BC,EAAAA,QAAQ,EAAE,EAPiB;AAQ3BC,EAAAA,kBAAkB,EAAE,KARO;AAS3BC,EAAAA,cAAc,EAAE,IATW;AAU3BC,EAAAA,YAAY,EAAE,CAVa;AAW3B;AACAC,EAAAA,cAAc,EAAE,EAZW;AAa3BC,EAAAA,UAAU,EAAE,EAbe;AAc3BC,EAAAA,UAAU,EAAE,EAde;AAe3BC,EAAAA,uBAAuB,EAAE,CAfE;AAiB3BC,EAAAA,6BAA6B,EAAE,KAjBJ;AAkB3BC,EAAAA,4BAA4B,EAAE,KAlBH;AAmB3BC,EAAAA,8BAA8B,EAAE,EAnBL;AAoB3BC,EAAAA,wBAAwB,EAAE,EApBC;AAqB3BC,EAAAA,gCAAgC,EAAE,EArBP;AAsB3B;AACAC,EAAAA,iCAAiC,EAAE,GAvBR;AAwB3BC,EAAAA,0BAA0B,EAAE,EAxBD;AAyB3BC,EAAAA,uBAAuB,EAAE,EAzBE;AA0B3BC,EAAAA,gBAAgB,EAAE,EA1BS;;AA4B3BC,EAAAA,WAAW,GAAG;AACZ,WAAO5C,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyBC,KAAzB,CAA+B0C,YAAtC;AACD,GA9B0B;;AA+B3BC,EAAAA,iBAAiB,GAAG;AAClB,WAAO9C,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyBK,OAAzB,CAAiC,KAAKqC,WAAL,EAAjC,EAAqDhE,IAA5D;AACD,GAjC0B;;AAkC3BmE,EAAAA,iBAAiB,CAACC,KAAD,EAAQ;AAAA;;AACvB,UAAMC,OAAO,GAAGD,KAAK,IAAI,KAAKJ,WAAL,EAAzB;AACA,oCAAO5C,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyBK,OAAzB,CAAiC0C,OAAjC,CAAP,0DAAO,sBAA2CvC,OAAlD;AACD,GArC0B;;AAsC3BwC,EAAAA,eAAe,CAACxC,OAAD,EAAU9B,IAAV,EAAgB;AAC7B,UAAMuE,SAAS,GAAG9C,eAAe,CAACU,MAAhB,CAAuBnC,IAAvB,EAA6B8B,OAA7B,CAAlB;AACA0C,IAAAA,MAAM,CAACC,MAAP,CAAcnD,SAAd,CAAyB,oBAAmBtB,IAAK,GAAjD;AACAoB,IAAAA,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyBC,KAAzB,CAA+B0C,YAA/B,GAA8CM,SAAS,CAACxE,EAAxD;AACAiC,IAAAA,aAAa,CAAC0C,aAAd;AACAC,IAAAA,QAAQ,CAACC,QAAT,CAAkBC,UAAU,CAACC,sBAA7B;AACD,GA5C0B;;AA6C3BC,EAAAA,iBAAiB,GAAG;AAClB,UAAMV,OAAO,GAAG,KAAKF,iBAAL,EAAhB;AACA,SAAKjB,YAAL,GAAoBpE,OAAO,CAACuF,OAAD,CAAP,CAAiBW,MAArC;AACA,SAAK9B,YAAL,CAAkB+B,IAAlB,CAAuB,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,CAACE,SAAF,GAAcD,CAAC,CAACC,SAAjD;AACD,GAjD0B;;AAkD3BC,EAAAA,aAAa,GAAG;AACd,QAAI,KAAKpC,cAAT,EAAyB;AACvB,WAAK8B,iBAAL;AACA,WAAK9B,cAAL,GAAsB,KAAtB;AACD;;AACD,WAAO,KAAKC,YAAZ;AACD,GAxD0B;;AAyD3BoC,EAAAA,eAAe,CAACC,OAAD,EAAUC,IAAV,EAAgB;AAC7B,UAAMC,QAAQ,GAAGC,IAAI,CAACC,GAAL,EAAjB;AACA,SAAK5C,QAAL,CAAc6C,IAAd,CAAmB;AACjB;AACAL,MAAAA,OAAO,EAAEA,OAAO,CAACM,UAAR,CAAmB,6IAAnB,EAAiC,GAAjC,CAFQ;AAGjBL,MAAAA,IAAI,EAAEM,gBAAgB,CAACC,mBAAjB,CAAqCP,IAArC,CAHW;AAIjBQ,MAAAA,WAAW,EAAEC,IAAI,CAACC,mBAAL,CAAyBC,YAJrB;AAKjBC,MAAAA,SAAS,EAAEX,QALM;AAMjBY,MAAAA,OAAO,EAAEZ,QAAQ,GAAG,KAAK3C;AANR,KAAnB;AAQA,SAAKA,SAAL,GAAiB2C,QAAjB,CAV6B,CAW7B;;AACA,QAAI,KAAK1C,QAAL,CAAcL,MAAd,GAAuBtB,MAAM,CAACkF,OAAP,CAAeC,eAAf,CAA+BC,UAA1D,EAAsE,KAAKzD,QAAL,CAAc0D,KAAd;AACvE,GAtE0B;;AAuE3BC,EAAAA,aAAa,GAAG;AACd,SAAK3D,QAAL,GAAgB,EAAhB;AACA,SAAKD,SAAL,GAAiB,CAAjB;AACD,GA1E0B;;AA2E3B;AACA;AACA;AACA6D,EAAAA,sBAAsB,GAAG;AAAA;;AACvB,WAAOvF,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyBsF,IAAzB,KAAkCxG,cAAc,CAACC,IAAjD,sDACHwG,eAAe,CAACC,MADb,2DACH,uBAAwBC,MAAxB,GAAiCC,QAAjC,GAA4CtE,MADzC,yEACmD,CADnD,GAEHuE,cAAc,CAACC,UAAf,CAA0BD,cAAc,CAACE,KAAzC,EAAgDC,IAAhD,CAAqD,IAArD,EAA2D1E,MAF/D;AAGD,GAlF0B;;AAmF3B2E,EAAAA,qBAAqB,GAAG;AACtB,WAAOrI,MAAM,CAACsI,MAAP,CAAclG,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyBK,OAAvC,EACJ4F,MADI,CACGC,CAAC,IAAIA,CAAC,CAACzH,EAAF,KAAS,KAAKiE,WAAL,EADjB,EAEJyD,GAFI,CAEAD,CAAC,IAAIA,CAAC,CAAC1F,OAAF,CAAUY,MAFf,EAGJgF,MAHI,CAGG,CAACC,GAAD,EAAMC,GAAN,KAAcD,GAAG,GAAGC,GAHvB,EAG4B,CAH5B,IAIL,KAAKjB,sBAAL,EAJF;AAKD,GAzF0B;;AA0F3B1E,EAAAA,aAAa,GAAG;AACd,WAAO,KAAK0E,sBAAL,MAAiC,KAAKpD,6BAAtC,IACL,KAAK8D,qBAAL,MAAgC,KAAK7D,4BADvC;AAED,GA7F0B;;AA+F3B;AACAkB,EAAAA,aAAa,GAAG;AACd,SAAKtB,UAAL,GAAkB,EAAlB;AACA,SAAKC,UAAL,GAAkB,EAAlB;AACA,SAAKC,uBAAL,GAA+B,CAA/B;AACD,GApG0B;;AAqG3B;AACA;AACA;AACAuE,EAAAA,YAAY,CAACC,IAAD,EAAOC,QAAP,EAAiB;AAC3B;AACA;AACA,SAAKzE,uBAAL,IAAgCyE,QAAhC;AACA,UAAMC,OAAO,GAAG,KAAK1E,uBAAL,IAAgC,KAAKQ,uBAArD;AACA,QAAIkE,OAAO,IAAI,KAAK5E,UAAL,CAAgBV,MAAhB,KAA2B,CAA1C,EAA6C;AAE7C,QAAI,KAAKU,UAAL,CAAgB,KAAKA,UAAL,CAAgBV,MAAhB,GAAyB,CAAzC,MAAgDoF,IAApD,EAA0D,KAAK1E,UAAL,CAAgBwC,IAAhB,CAAqBkC,IAArB;AAC1D,QAAI,KAAK1E,UAAL,CAAgBV,MAAhB,GAAyB,KAAKqB,gBAAlC,EAAoD,KAAKX,UAAL,CAAgBqD,KAAhB;AACpD,SAAKnD,uBAAL,GAA+B,CAA/B;AACD,GAlH0B;;AAmH3B2E,EAAAA,YAAY,CAACH,IAAD,EAAO;AACjB,QAAI,KAAKzE,UAAL,CAAgB,KAAKA,UAAL,CAAgBX,MAAhB,GAAyB,CAAzC,MAAgDoF,IAApD,EAA0D,KAAKzE,UAAL,CAAgBuC,IAAhB,CAAqBkC,IAArB;AAC3D,GArH0B;;AAsH3B;AACA;AACA;AACA;AACAI,EAAAA,cAAc,GAAG;AACf,QAAI,KAAK9E,UAAL,CAAgBV,MAAhB,KAA2B,CAA3B,IAAgCyF,IAAI,CAACC,OAAL,CAAaC,cAAb,CAA4BrI,IAA5B,KAAqC,WAAzE,EAAsF;AAEtF,UAAMsI,WAAW,GAAG,KAAKlF,UAAL,CAAgBmF,GAAhB,EAApB;AACA,SAAKN,YAAL,CAAkB,KAAK9D,iBAAL,EAAlB;AACA/C,IAAAA,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyBK,OAAzB,CAAiC,KAAKqC,WAAL,EAAjC,EAAqDlC,OAArD,GAA+DwG,WAA/D;AAEAxC,IAAAA,gBAAgB,CAAC0C,UAAjB,CAA4B,KAAKxE,WAAL,EAA5B,EAAgDsE,WAAhD;AACA,QAAIlH,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyBsF,IAAzB,KAAkCxG,cAAc,CAACC,IAArD,EAA2DwG,eAAe,CAACC,MAAhB,CAAuB2B,QAAvB,CAAgCH,WAAhC,EAA3D,KACKrB,cAAc,CAACyB,YAAf,CAA4BJ,WAA5B;AACN,GApI0B;;AAqI3BK,EAAAA,cAAc,GAAG;AACf,QAAI,KAAKtF,UAAL,CAAgBX,MAAhB,KAA2B,CAA3B,IAAgCyF,IAAI,CAACC,OAAL,CAAaC,cAAb,CAA4BrI,IAA5B,KAAqC,WAAzE,EAAsF;AAEtF,UAAM4I,WAAW,GAAG,KAAKvF,UAAL,CAAgBkF,GAAhB,EAApB,CAHe,CAIf;;AACA,SAAKV,YAAL,CAAkB,KAAK1D,iBAAL,EAAlB,EAA4C,IAAI,KAAKL,uBAArD;AACA1C,IAAAA,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyBK,OAAzB,CAAiC,KAAKqC,WAAL,EAAjC,EAAqDlC,OAArD,GAA+D8G,WAA/D;AAEA9C,IAAAA,gBAAgB,CAAC0C,UAAjB,CAA4B,KAAKxE,WAAL,EAA5B,EAAgD4E,WAAhD;AACA,QAAIxH,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyBsF,IAAzB,KAAkCxG,cAAc,CAACC,IAArD,EAA2DwG,eAAe,CAACC,MAAhB,CAAuB2B,QAAvB,CAAgCG,WAAhC,EAA3D,KACK3B,cAAc,CAACyB,YAAf,CAA4BE,WAA5B;AACN;;AAhJ0B,CAAtB;AAmJP,OAAO,MAAMC,QAAQ,GAAG;AAAEC,EAAAA,MAAM,EAAE,QAAV;AAAoBC,EAAAA,KAAK,EAAE,OAA3B;AAAoCC,EAAAA,KAAK,EAAE;AAA3C,CAAjB,C,CAEP;AACA;AACA;AACA;;AACA,OAAO,MAAMC,oBAAoB,GAAG;AAClC9B,EAAAA,KAAK,EAAE;AACL+B,IAAAA,MAAM,EAAE,CAAC,CADJ;AAELC,IAAAA,KAAK,EAAE,CAAC,CAFH;AAGLC,IAAAA,KAAK,EAAE,CAAC;AAHH,GAD2B;;AAOlCC,EAAAA,qBAAqB,CAAC7D,IAAD,EAAO8D,GAAP,EAAY;AAC/B,QAAIlI,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyBsF,IAAzB,KAAkCxG,cAAc,CAACC,IAAjD,IAAyDmF,IAAI,KAAK,CAAC,CAAvE,EAA0E;AACxE,UAAI,CAACqB,eAAe,CAACC,MAArB,EAA6B;AAC7B,WAAKyC,yBAAL,CAA+BD,GAA/B;AACA,WAAKE,sBAAL,CAA4BhE,IAA5B,EAAkC8D,GAAlC;AACD,KAJD,MAIO;AACL,WAAKnC,KAAL,CAAWmC,GAAX,IAAkB9D,IAAlB;AACD;AACF,GAfiC;;AAiBlC;AACA+D,EAAAA,yBAAyB,CAACD,GAAD,EAAM;AAC7B,UAAMG,WAAW,GAAG,KAAKtC,KAAL,CAAWmC,GAAX,IAAkB,CAAtC;AACAzC,IAAAA,eAAe,CAACC,MAAhB,CAAuB4C,eAAvB,CAAuCD,WAAvC,EAAoD,YAApD,EAAmE,uBAAsBH,GAAI,OAA7F;AACAzC,IAAAA,eAAe,CAACC,MAAhB,CAAuB4C,eAAvB,CAAuCD,WAAvC,EAAoD,QAApD,EAA+D,uBAAsBH,GAAI,cAAzF;AACA,SAAKnC,KAAL,CAAWmC,GAAX,IAAkB,CAAC,CAAnB;AACD,GAvBiC;;AAwBlCE,EAAAA,sBAAsB,CAAChE,IAAD,EAAO8D,GAAP,EAAY;AAChCzC,IAAAA,eAAe,CAACC,MAAhB,CAAuB6C,YAAvB,CAAoCnE,IAAI,GAAG,CAA3C,EAA8C,YAA9C,EAA6D,uBAAsB8D,GAAI,OAAvF;AACAzC,IAAAA,eAAe,CAACC,MAAhB,CAAuB6C,YAAvB,CAAoCnE,IAAI,GAAG,CAA3C,EAA8C,QAA9C,EAAyD,uBAAsB8D,GAAI,cAAnF;AACA,SAAKnC,KAAL,CAAWmC,GAAX,IAAkB9D,IAAlB;AACD,GA5BiC;;AA8BlCoE,EAAAA,wBAAwB,GAAG;AACzB,SAAK,MAAMC,QAAX,IAAuB7K,MAAM,CAACsI,MAAP,CAAcuB,QAAd,CAAvB,EAAgD;AAC9C,UAAIzH,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyBsF,IAAzB,KAAkCxG,cAAc,CAACC,IAAjD,IAAyDwG,eAAe,CAACC,MAA7E,EAAqF;AACnF,aAAK,IAAItB,IAAI,GAAG,CAAhB,EAAmBA,IAAI,GAAGqB,eAAe,CAACC,MAAhB,CAAuBgD,GAAvB,CAA2BC,IAArD,EAA2DvE,IAAI,EAA/D,EAAmE;AACjEqB,UAAAA,eAAe,CAACC,MAAhB,CAAuB4C,eAAvB,CAAuClE,IAAvC,EAA6C,YAA7C,EAA4D,uBAAsBqE,QAAS,OAA3F;AACAhD,UAAAA,eAAe,CAACC,MAAhB,CAAuB4C,eAAvB,CAAuClE,IAAvC,EAA6C,QAA7C,EAAwD,uBAAsBqE,QAAS,cAAvF;AACD;AACF;;AACD,WAAK1C,KAAL,CAAW0C,QAAX,IAAuB,CAAC,CAAxB;AACD;AACF;;AAxCiC,CAA7B,C,CA2CP;;AACA,OAAO,MAAMG,iBAAiB,GAAG;AAC/B;AACAC,EAAAA,eAAe,CAACzE,IAAD,EAAO;AACpB,UAAM0E,UAAU,GAAG9I,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyBsF,IAAzB,KAAkCxG,cAAc,CAACC,IAAjD,GACfmF,IADe,GAEfM,gBAAgB,CAACC,mBAAjB,CAAqCP,IAArC,CAFJ;AAGA,SAAK2E,YAAL,CAAkBD,UAAlB;AACD,GAP8B;;AAS/BC,EAAAA,YAAY,CAAC3E,IAAD,EAAO;AACjB,QAAIsB,MAAJ,EAAYsD,UAAZ,EAAwBC,YAAxB;;AACA,QAAIjJ,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyBsF,IAAzB,KAAkCxG,cAAc,CAACC,IAArD,EAA2D;AACzD;AACA;AACAyG,MAAAA,MAAM,GAAGwD,QAAQ,CAACC,aAAT,CAAuB,oBAAvB,CAAT;AACAH,MAAAA,UAAU,GAAGvD,eAAe,CAACC,MAAhB,CAAuB0D,iBAAvB,EAAb;AACAH,MAAAA,YAAY,GAAG7E,IAAI,GAAG,CAAtB;AACD,KAND,MAMO;AACLsB,MAAAA,MAAM,GAAGG,cAAc,CAACH,MAAxB;AACAsD,MAAAA,UAAU,GAAG,IAAb;AACAC,MAAAA,YAAY,GAAG7E,IAAf;AACD,KAZgB,CAcjB;AACA;;;AACA,QAAI,CAACsB,MAAL,EAAa;AAEb,UAAM2D,YAAY,GAAG3D,MAAM,CAAC4D,YAAP,GAAsB,EAA3C;AACA,UAAMC,YAAY,GAAGP,UAAU,IAAIC,YAAY,GAAG,CAAnB,CAA/B;AACA,QAAIM,YAAY,GAAG7D,MAAM,CAAC8D,SAAP,GAAmBH,YAAtC,EAAoD3D,MAAM,CAAC+D,QAAP,CAAgB,CAAhB,EAAmBF,YAAY,GAAGF,YAAlC;AACpD,QAAIE,YAAY,GAAG7D,MAAM,CAAC8D,SAA1B,EAAqC9D,MAAM,CAAC+D,QAAP,CAAgB,CAAhB,EAAmBF,YAAnB;;AACrC,QAAIvJ,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyBsF,IAAzB,KAAkCxG,cAAc,CAACE,KAArD,EAA4D;AAC1D2G,MAAAA,cAAc,CAAC6D,MAAf,CAAsBC,KAAtB,CAA4BC,MAA5B,GAAsC,GAAElE,MAAM,CAAC8D,SAAU,IAAzD;AACD;AACF;;AAlC8B,CAA1B;AAqCP,OAAO,MAAM9E,gBAAgB,GAAG;AAC9BmF,EAAAA,uBAAuB,EAAE,GADK;AAE9BC,EAAAA,gBAAgB,EAAE,KAFY;AAG9BC,EAAAA,QAAQ,EAAE,EAHoB;;AAK9B,MAAI5J,KAAJ,GAAY;AACV,WAAOH,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyBC,KAAhC;AACD,GAP6B;;AAS9B;AACA,MAAI6J,IAAJ,GAAW;AACT,WAAO,CAAC,KAAK5J,KAAL,CAAW6J,OAAnB;AACD,GAZ6B;;AAc9B;AACF;AACA;AACE,MAAIC,IAAJ,GAAW;AACT,WAAO,KAAK/J,KAAL,CAAW+J,IAAlB;AACD,GAnB6B;;AAqB9B,MAAIA,IAAJ,CAASnK,KAAT,EAAgB;AACd,SAAKI,KAAL,CAAW+J,IAAX,GAAkBnK,KAAlB;AACD,GAvB6B;;AAyB9B,MAAIoK,SAAJ,GAAgB;AACd,WAAO,KAAKH,IAAL,IAAa,KAAKE,IAAL,KAAc7L,cAAc,CAACE,GAAjD;AACD,GA3B6B;;AA6B9B6L,EAAAA,mBAAmB,CAACzL,EAAD,EAAK;AACtB,UAAM4B,OAAO,GAAGP,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyBK,OAAzC;AACA,UAAMyC,KAAK,GAAGpF,MAAM,CAACsI,MAAP,CAAc3F,OAAd,EAAuBW,SAAvB,CAAiCkF,CAAC,IAAIA,CAAC,CAACzH,EAAF,KAASA,EAA/C,CAAd;AACA,WAAO4B,OAAO,CAAC8J,QAAQ,CAACzM,MAAM,CAACoD,IAAP,CAAYT,OAAZ,EAAqByC,KAArB,CAAD,EAA8B,EAA9B,CAAT,CAAd;AACD,GAjC6B;;AAmC9B,MAAIsH,oBAAJ,GAA2B;AACzB,WAAO,KAAKF,mBAAL,CAAyB,KAAKjK,KAAL,CAAWoK,cAApC,CAAP;AACD,GArC6B;;AAuC9B,MAAIC,oBAAJ,GAA2B;AACzB,WAAO,KAAKJ,mBAAL,CAAyBpK,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyBC,KAAzB,CAA+B0C,YAAxD,CAAP;AACD,GAzC6B;;AA2C9B,MAAI4H,UAAJ,GAAiB;AAAA;;AACf,8DAAO,KAAKH,oBAAZ,2DAAO,uBAA2B1L,IAAlC,yEAA0C,EAA1C;AACD,GA7C6B;;AA+C9B8L,EAAAA,gBAAgB,CAAC9L,IAAD,EAAO;AACrB,UAAM+L,SAAS,GAAG/M,MAAM,CAACsI,MAAP,CAAclG,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyBK,OAAvC,EAAgD8F,GAAhD,CAAoDD,CAAC,IAAIA,CAAC,CAACxH,IAA3D,CAAlB;AACA,WAAO+L,SAAS,CAACxE,MAAV,CAAiByE,CAAC,IAAIA,CAAC,KAAKhM,IAA5B,EAAkC0C,MAAlC,GAA2C,CAAlD;AACD,GAlD6B;;AAoD9B;AACA;AACA;AACAqD,EAAAA,mBAAmB,CAACkG,GAAD,EAAM;AACvB,QAAI7K,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyBsF,IAAzB,KAAkCxG,cAAc,CAACC,IAArD,EAA2D,OAAO4L,GAAP;AAC3D,WAAOhF,cAAc,CAACjG,UAAf,CAA0BiL,GAA1B,CAAP;AACD,GA1D6B;;AA4D9B,MAAIC,iBAAJ,GAAwB;AACtB,QAAI,CAAC,KAAK1K,KAAL,CAAW2K,GAAhB,EAAqB,OAAO,CAAC,CAAR;AACrB,WAAO,KAAKpG,mBAAL,CAAyB,KAAKvE,KAAL,CAAW2K,GAAX,CAAenL,UAAxC,CAAP;AACD,GA/D6B;;AAiE9B,MAAIoL,eAAJ,GAAsB;AACpB,WAAOC,IAAI,CAACC,QAAL,CAAcD,IAAI,CAACE,GAAL,CAAS,KAAT,EAAgBC,QAAQ,CAACC,SAAT,CAAmBtL,KAAnC,IAA4C,GAA1D,EAA+D,CAA/D,CAAP;AACD,GAnE6B;;AAqE9B,MAAIuL,cAAJ,GAAqB;AAAA;;AACnB,+DAAO,KAAKhB,oBAAZ,2DAAO,uBAA2B5J,OAAlC,2EAA6C,EAA7C;AACD,GAvE6B;;AAyE9B,MAAI6K,mBAAJ,GAA0B;AACxB,WAAO,KAAKD,cAAL,CAAoBE,KAApB,CAA0B,IAA1B,EAAgClK,MAAvC;AACD,GA3E6B;;AA6E9B;AACAmK,EAAAA,cAAc,CAACC,QAAD,EAAW;AACvB,UAAMC,MAAM,GAAG,KAAKvB,mBAAL,CAAyBsB,QAAzB,CAAf;AACA,QAAI,CAACC,MAAL,EAAa,OAAO,IAAP;AAEb,UAAMC,YAAY,GAAG,IAAIC,GAAJ,EAArB;AACA,UAAM9F,KAAK,GAAG4F,MAAM,CAACjL,OAAP,CAAe8K,KAAf,CAAqB,IAArB,CAAd;;AACA,SAAK,MAAMM,OAAX,IAAsB/F,KAAtB,EAA6B;AAC3B,YAAMgG,aAAa,GAAGD,OAAO,CAACE,KAAR,CAAc,oDAAd,CAAtB;AACA,UAAID,aAAJ,EAAmBH,YAAY,CAACK,GAAb,CAAiB5K,MAAM,CAAC0K,aAAa,CAAC,CAAD,CAAd,CAAN,GAA2B,CAA5C;AACnB,YAAMG,eAAe,GAAGJ,OAAO,CAACE,KAAR,CAAc,ySAAd,CAAxB;;AACA,UAAIE,eAAJ,EAAqB;AACnB;AACA,cAAMC,QAAQ,GAAGnM,MAAM,CAACoM,SAAP,CAAiBC,OAAjB,CAAyBnL,SAAzB,CAAmCoL,CAAC,IAAIA,CAAC,CAAC1N,IAAF,KAAWsN,eAAe,CAAC,CAAD,CAAlE,CAAjB;AACA,YAAIC,QAAQ,KAAK,CAAC,CAAlB,EAAqBP,YAAY,CAACK,GAAb,CAAiBE,QAAjB;AACtB;AACF;;AACD,UAAME,OAAO,GAAGE,KAAK,CAACC,IAAN,CAAWZ,YAAX,CAAhB;AACAS,IAAAA,OAAO,CAACxI,IAAR;AACA,WAAOwI,OAAP;AACD,GAjG6B;;AAmG9B;AACAI,EAAAA,gBAAgB,CAACf,QAAD,EAAW;AACzB,UAAMC,MAAM,GAAG,KAAKvB,mBAAL,CAAyBsB,QAAzB,CAAf;AACA,QAAI,CAACC,MAAL,EAAa,OAAO,IAAP;AAEb,UAAMe,cAAc,GAAG,IAAIb,GAAJ,EAAvB;AACA,UAAM9F,KAAK,GAAG4F,MAAM,CAACjL,OAAP,CAAe8K,KAAf,CAAqB,IAArB,CAAd;;AACA,SAAK,MAAMM,OAAX,IAAsB/F,KAAtB,EAA6B;AAC3B,YAAM4G,kBAAkB,GAAG/O,MAAM,CAACoD,IAAP,CAAYhB,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyB0M,SAArC,CAA3B,CAD2B,CAE3B;AACA;;AACA,WAAK,MAAM1E,GAAX,IAAkByE,kBAAlB,EAAsC;AACpC,YAAIb,OAAO,CAACE,KAAR,CAAe,2BAA0B9D,GAAI,SAA7C,CAAJ,EAA4DwE,cAAc,CAACT,GAAf,CAAmB/D,GAAnB;AAC7D;AACF;;AACD,UAAM0E,SAAS,GAAGL,KAAK,CAACC,IAAN,CAAWE,cAAX,CAAlB;AACAE,IAAAA,SAAS,CAAC/I,IAAV;AACA,WAAO+I,SAAP;AACD,GArH6B;;AAuH9B;AACA;AACAC,EAAAA,WAAW,CAACC,YAAD,EAAe/M,KAAf,EAAsB;AAC/B,QAAInC,MAAM,CAACoD,IAAP,CAAYhB,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyB0M,SAArC,EAAgDtL,MAAhD,IAA0DV,aAAa,CAAC6B,0BAA5E,EAAwG;AACxGzC,IAAAA,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyB0M,SAAzB,CAAmCE,YAAnC,IAAmD/M,KAAnD;AACAC,IAAAA,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyB6M,iBAAzB,CAA2CvI,IAA3C,CAAgDsI,YAAhD;AACAvJ,IAAAA,QAAQ,CAACC,QAAT,CAAkBC,UAAU,CAACuJ,0BAA7B;AACD,GA9H6B;;AA+H9BC,EAAAA,cAAc,CAACH,YAAD,EAAeI,QAAf,EAAyB;AACrC,QAAItP,MAAM,CAACoD,IAAP,CAAYhB,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyB0M,SAArC,EAAgDO,QAAhD,CAAyDL,YAAzD,CAAJ,EAA4E;AAC1E9M,MAAAA,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyB0M,SAAzB,CAAmCE,YAAnC,IAAmDI,QAAnD;AACA3J,MAAAA,QAAQ,CAACC,QAAT,CAAkBC,UAAU,CAACuJ,0BAA7B;AACD,KAHD,MAGO;AACL,WAAKH,WAAL,CAAiBC,YAAjB,EAA+BI,QAA/B;AACD;AACF,GAtI6B;;AAuI9BE,EAAAA,cAAc,CAACC,OAAD,EAAUC,OAAV,EAAmB;AAC/B,UAAM5G,IAAI,GAAG1G,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyB0M,SAAzB,CAAmCS,OAAnC,CAAb;AACArN,IAAAA,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyB0M,SAAzB,CAAmCU,OAAnC,IAA8C5G,IAA9C;AACA,WAAO1G,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyB0M,SAAzB,CAAmCS,OAAnC,CAAP;AAEA,UAAMrK,KAAK,GAAGhD,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyB6M,iBAAzB,CAA2CQ,OAA3C,CAAmDF,OAAnD,CAAd;AACA,QAAIrK,KAAK,KAAK,CAAC,CAAf,EAAkBhD,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyB6M,iBAAzB,CAA2C/J,KAA3C,IAAoDsK,OAApD;AAClB/J,IAAAA,QAAQ,CAACC,QAAT,CAAkBC,UAAU,CAACuJ,0BAA7B;AACD,GA/I6B;;AAgJ9BQ,EAAAA,cAAc,CAACV,YAAD,EAAe;AAC3B,WAAO9M,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyB0M,SAAzB,CAAmCE,YAAnC,CAAP;AACA,UAAM9J,KAAK,GAAGhD,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyB6M,iBAAzB,CAA2CQ,OAA3C,CAAmDT,YAAnD,CAAd;AACA,QAAI9J,KAAK,GAAG,CAAC,CAAb,EAAgBhD,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyB6M,iBAAzB,CAA2CU,MAA3C,CAAkDzK,KAAlD,EAAyD,CAAzD;AAChBO,IAAAA,QAAQ,CAACC,QAAT,CAAkBC,UAAU,CAACuJ,0BAA7B;AACD,GArJ6B;;AAuJ9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAU,EAAAA,sBAAsB,CAACC,SAAD,EAAY;AAChC,UAAMC,YAAY,GAAG/C,GAAG,IAAK,OAAMA,GAAI,EAAX,CAAagD,KAAb,CAAmB,CAAC,CAApB,CAA5B;;AACA,UAAMC,QAAQ,GAAG,EAAjB;;AACA,SAAK,MAAMpH,IAAX,IAAmBiH,SAAnB,EAA8B;AAC5BG,MAAAA,QAAQ,CAACtJ,IAAT,CAAe,GAAEoJ,YAAY,CAAClH,IAAI,CAACpF,MAAN,CAAc,GAAEoF,IAAK,EAAlD;AACD;;AACD,WAAOoH,QAAQ,CAAC9H,IAAT,CAAc,EAAd,CAAP;AACD,GAtK6B;;AAwK9B;AACA;AACA+H,EAAAA,wBAAwB,CAACC,UAAD,EAAa;AACnC,QAAIA,UAAU,KAAK,EAAnB,EAAuB,MAAM,IAAIpG,KAAJ,CAAU,2CAAV,CAAN;AACvB,UAAM+F,SAAS,GAAG,EAAlB;AACA,QAAIM,aAAa,GAAGD,UAApB;;AACA,WAAOC,aAAa,CAAC3M,MAAd,GAAuB,CAA9B,EAAiC;AAC/B,YAAM4M,aAAa,GAAG7M,MAAM,CAAC4M,aAAa,CAACJ,KAAd,CAAoB,CAApB,EAAuB,CAAvB,CAAD,CAA5B;AACAI,MAAAA,aAAa,GAAGA,aAAa,CAACE,MAAd,CAAqB,CAArB,CAAhB;;AACA,UAAI9M,MAAM,CAAC+M,KAAP,CAAaF,aAAb,KAA+BD,aAAa,CAAC3M,MAAd,GAAuB4M,aAA1D,EAAyE;AACvE,cAAM,IAAItG,KAAJ,CAAU,qDAAV,CAAN;AACD,OAFD,MAEO;AACL,cAAMyG,WAAW,GAAGJ,aAAa,CAACJ,KAAd,CAAoB,CAApB,EAAuBK,aAAvB,CAApB;AACAD,QAAAA,aAAa,GAAGA,aAAa,CAACE,MAAd,CAAqBD,aAArB,CAAhB;AACAP,QAAAA,SAAS,CAACnJ,IAAV,CAAe6J,WAAf;AACD;AACF;;AACD,WAAOV,SAAP;AACD,GA1L6B;;AA4L9B;AACAW,EAAAA,2BAA2B,GAAG;AAC5B;AACA,UAAMC,OAAO,GAAG3N,aAAa,CAACmC,iBAAd,GAAkCyL,OAAlC,CAA0C,8SAA1C,EAA4D,IAA5D,CAAhB;AACA,QAAID,OAAO,CAACjN,MAAR,KAAmB,CAAvB,EAA0B,OAAO,IAAP,CAHE,CAI5B;;AACA,UAAM1C,IAAI,GAAGgC,aAAa,CAACkC,iBAAd,EAAb;AACA,WAAO2L,kBAAkB,CAACC,UAAnB,CAA8B,KAAKhB,sBAAL,CAA4B,CAAC9O,IAAD,EAAO2P,OAAP,CAA5B,CAA9B,EAA4E,kBAA5E,CAAP;AACD,GApM6B;;AAsM9B;AACAI,EAAAA,mBAAmB,CAACC,QAAD,EAAW;AAC5B,QAAIC,OAAJ,EAAaC,KAAb;;AACA,QAAI;AACFD,MAAAA,OAAO,GAAGJ,kBAAkB,CAACM,UAAnB,CAA8BH,QAA9B,EAAwC,kBAAxC,CAAV;AACAE,MAAAA,KAAK,GAAG,KAAKf,wBAAL,CAA8Bc,OAA9B,CAAR;AACD,KAHD,CAGE,OAAOG,CAAP,EAAU;AACV,aAAO,IAAP;AACD;;AAED,WAAO;AACLpQ,MAAAA,IAAI,EAAEkQ,KAAK,CAAC,CAAD,CADN;AAELpO,MAAAA,OAAO,EAAEoO,KAAK,CAAC,CAAD;AAFT,KAAP;AAID,GApN6B;;AAsN9B;AACAG,EAAAA,oBAAoB,CAACL,QAAD,EAAW;AAC7B,UAAMM,MAAM,GAAG,KAAKP,mBAAL,CAAyBC,QAAzB,CAAf;AACAhO,IAAAA,aAAa,CAACsC,eAAd,CAA8BgM,MAAM,CAACxO,OAArC,EAA8CwO,MAAM,CAACtQ,IAArD;AACA,SAAKuQ,kBAAL;AACD,GA3N6B;;AA6N9B;AACAC,EAAAA,oBAAoB,CAAC1D,QAAD,EAAW;AAC7B,UAAMC,MAAM,GAAG,KAAKvB,mBAAL,CAAyBsB,QAAzB,CAAf;AACA,UAAM6C,OAAO,GAAG5C,MAAM,CAACjL,OAAP,CAAe8N,OAAf,CAAuB,8SAAvB,EAAyC,IAAzC,CAAhB;AACA,QAAID,OAAO,CAACjN,MAAR,KAAmB,CAAvB,EAA0B,OAAO,IAAP;AAE1B,UAAMsK,YAAY,GAAG,IAAIC,GAAJ,EAArB;AACA,UAAMa,cAAc,GAAG,IAAIb,GAAJ,EAAvB;AACA,UAAM9F,KAAK,GAAGwI,OAAO,CAAC/C,KAAR,CAAc,IAAd,CAAd,CAP6B,CAQ7B;;AACA,SAAK,MAAMM,OAAX,IAAsB/F,KAAtB,EAA6B;AAC3B,YAAMgG,aAAa,GAAGD,OAAO,CAACE,KAAR,CAAc,oDAAd,CAAtB;AACA,UAAID,aAAJ,EAAmBH,YAAY,CAACK,GAAb,CAAiB5K,MAAM,CAAC0K,aAAa,CAAC,CAAD,CAAd,CAAN,GAA2B,CAA5C;AACnB,YAAMG,eAAe,GAAGJ,OAAO,CAACE,KAAR,CAAc,ySAAd,CAAxB;;AACA,UAAIE,eAAJ,EAAqB;AACnB;AACA,cAAMC,QAAQ,GAAGnM,MAAM,CAACoM,SAAP,CAAiBC,OAAjB,CAAyBnL,SAAzB,CAAmCoL,CAAC,IAAIA,CAAC,CAAC1N,IAAF,KAAWsN,eAAe,CAAC,CAAD,CAAlE,CAAjB;AACA,YAAIC,QAAQ,KAAK,CAAC,CAAlB,EAAqBP,YAAY,CAACK,GAAb,CAAiBE,QAAjB;AACtB;;AACD,YAAMQ,kBAAkB,GAAG/O,MAAM,CAACoD,IAAP,CAAYhB,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyB0M,SAArC,CAA3B;;AACA,WAAK,MAAM1E,GAAX,IAAkByE,kBAAlB,EAAsC,IAAIb,OAAO,CAACE,KAAR,CAAe,MAAK9D,GAAI,SAAxB,CAAJ,EAAuCwE,cAAc,CAACT,GAAf,CAAmB/D,GAAnB;AAC9E,KApB4B,CAsB7B;;;AACA,UAAMmE,OAAO,GAAG,EAAhB;;AACA,SAAK,MAAM1N,EAAX,IAAiB4N,KAAK,CAACC,IAAN,CAAWZ,YAAX,CAAjB,EAA2C;AAAA;;AACzC,YAAMyD,MAAM,GAAGrP,MAAM,CAACoM,SAAP,CAAiBC,OAAjB,CAAyB1N,EAAzB,CAAf;AACA0N,MAAAA,OAAO,CAAC7H,IAAR,CAAc,GAAE7F,EAAG,IAAN,gBAAS0Q,MAAT,aAASA,MAAT,uBAASA,MAAM,CAAEzQ,IAAjB,uDAAyB,EAAG,IAA5B,mBAA+ByQ,MAA/B,aAA+BA,MAA/B,uBAA+BA,MAAM,CAAEC,OAAvC,6DAAkD,EAAG,EAAlE;AACD,KA3B4B,CA6B7B;;;AACA,UAAM1C,SAAS,GAAG,EAAlB;;AACA,SAAK,MAAMhO,IAAX,IAAmB2N,KAAK,CAACC,IAAN,CAAWE,cAAX,CAAnB,EAA+C;AAC7CE,MAAAA,SAAS,CAACpI,IAAV,CAAgB,GAAE5F,IAAK,IAAGoB,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyB0M,SAAzB,CAAmChO,IAAnC,CAAyC,EAAnE;AACD,KAjC4B,CAmC7B;;;AACA,UAAM2Q,UAAU,GAAG,KAAK7B,sBAAL,CAA4B,CAAC/B,MAAM,CAAC/M,IAAR,EAAcyN,OAAO,CAACrG,IAAR,CAAa,GAAb,CAAd,EAAiC4G,SAAS,CAAC5G,IAAV,CAAe,GAAf,CAAjC,EAAsDuI,OAAtD,CAA5B,CAAnB;AACA,WAAOE,kBAAkB,CAACC,UAAnB,CAA8Ba,UAA9B,EAA0C,gBAA1C,CAAP;AACD,GApQ6B;;AAsQ9B;AACA;AACAC,EAAAA,mBAAmB,CAACZ,QAAD,EAAW;AAC5B,QAAIC,OAAJ,EAAaC,KAAb;;AACA,QAAI;AACFD,MAAAA,OAAO,GAAGJ,kBAAkB,CAACM,UAAnB,CAA8BH,QAA9B,EAAwC,gBAAxC,CAAV;AACAE,MAAAA,KAAK,GAAG,KAAKf,wBAAL,CAA8Bc,OAA9B,CAAR;AACD,KAHD,CAGE,OAAOG,CAAP,EAAU;AACV,aAAO,IAAP;AACD;;AACD,QAAIF,KAAK,CAACxN,MAAN,KAAiB,CAArB,EAAwB,OAAO,IAAP,CARI,CAU5B;;AACA,UAAMmO,UAAU,GAAGX,KAAK,CAAC,CAAD,CAAxB;AACA,UAAMzC,OAAO,GAAG,EAAhB;;AACA,QAAIoD,UAAJ,EAAgB;AACd,WAAK,MAAMJ,MAAX,IAAqBI,UAAU,CAACjE,KAAX,CAAiB,GAAjB,CAArB,EAA4C;AAC1C,cAAMkE,KAAK,GAAGL,MAAM,CAAC7D,KAAP,CAAa,GAAb,CAAd;AACAa,QAAAA,OAAO,CAAC7H,IAAR,CAAa;AACX7F,UAAAA,EAAE,EAAE0C,MAAM,CAACqO,KAAK,CAAC,CAAD,CAAN,CADC;AAEX9Q,UAAAA,IAAI,EAAE8Q,KAAK,CAAC,CAAD,CAFA;AAGXJ,UAAAA,OAAO,EAAEI,KAAK,CAAC,CAAD;AAHH,SAAb;AAKD;AACF;;AACDrD,IAAAA,OAAO,CAACxI,IAAR,CAAa,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,CAACnF,EAAF,GAAOoF,CAAC,CAACpF,EAAhC,EAvB4B,CAyB5B;;AACA,UAAMgR,YAAY,GAAGb,KAAK,CAAC,CAAD,CAA1B;AACA,UAAMlC,SAAS,GAAG,EAAlB;;AACA,SAAK,MAAMgD,QAAX,IAAuBD,YAAY,CAACnE,KAAb,CAAmB,GAAnB,CAAvB,EAAgD;AAC9C,UAAIoE,QAAQ,KAAK,EAAjB,EAAqB;AACrB,YAAMF,KAAK,GAAGE,QAAQ,CAACpE,KAAT,CAAe,GAAf,CAAd;AACAoB,MAAAA,SAAS,CAACpI,IAAV,CAAe;AACb0D,QAAAA,GAAG,EAAEwH,KAAK,CAAC,CAAD,CADG;AAEb3P,QAAAA,KAAK,EAAE2P,KAAK,CAAC,CAAD;AAFC,OAAf;AAID;;AAED,WAAO;AACL9Q,MAAAA,IAAI,EAAEkQ,KAAK,CAAC,CAAD,CADN;AAELzC,MAAAA,OAFK;AAGLO,MAAAA,SAHK;AAILlM,MAAAA,OAAO,EAAEoO,KAAK,CAAC,CAAD;AAJT,KAAP;AAMD,GAnT6B;;AAqT9B;AACA;AACAe,EAAAA,oBAAoB,CAACjB,QAAD,EAAWkB,MAAX,EAAmB;AACrC,UAAMZ,MAAM,GAAG,KAAKM,mBAAL,CAAyBZ,QAAzB,CAAf;AACAhO,IAAAA,aAAa,CAACsC,eAAd,CAA8BgM,MAAM,CAACxO,OAArC,EAA8CwO,MAAM,CAACtQ,IAArD;;AAEA,QAAI,CAACkR,MAAM,CAACzD,OAAZ,EAAqB;AACnB,WAAK,MAAMgD,MAAX,IAAqBH,MAAM,CAAC7C,OAA5B,EAAqC;AACnCrM,QAAAA,MAAM,CAACoM,SAAP,CAAiBC,OAAjB,CAAyBgD,MAAM,CAAC1Q,EAAhC,IAAsC;AAAEC,UAAAA,IAAI,EAAEyQ,MAAM,CAACzQ,IAAf;AAAqB0Q,UAAAA,OAAO,EAAED,MAAM,CAACC;AAArC,SAAtC;AACD;AACF;;AAED,QAAI,CAACQ,MAAM,CAAClD,SAAZ,EAAuB;AACrB,WAAK,MAAMgD,QAAX,IAAuBV,MAAM,CAACtC,SAA9B,EAAyC;AACvC,aAAKK,cAAL,CAAoB2C,QAAQ,CAAC1H,GAA7B,EAAkC0H,QAAQ,CAAC7P,KAA3C;AACD;AACF;;AAED,SAAKoP,kBAAL;AACD,GAxU6B;;AA0U9BY,EAAAA,MAAM,CAACC,IAAD,EAAO;AACX,QAAI,CAAC,KAAKhG,IAAV,EAAgB;AAChB,QAAI5J,KAAJ;;AACA,YAAQ,KAAK8J,IAAb;AACE,WAAK7L,cAAc,CAACC,KAApB;AACE;;AACF,WAAKD,cAAc,CAACG,WAApB;AACE,aAAKyR,UAAL;AACA7P,QAAAA,KAAK,GAAGsE,gBAAgB,CAACtE,KAAjB,CAAuB2K,GAA/B,CAFF,CAGE;AACA;;AACA,YAAI3K,KAAK,IAAI,KAAKD,KAAL,CAAW+P,eAAxB,EAAyCtH,iBAAiB,CAACC,eAAlB,CAAkCzI,KAAK,CAACR,UAAxC;AACzC,aAAKO,KAAL,CAAW+J,IAAX,GAAkB7L,cAAc,CAACC,KAAjC;AACA;;AACF,WAAKD,cAAc,CAACE,GAApB;AACE;;AACF;AACE,aAAK4R,IAAL;AACA;AAfJ;;AAkBAnQ,IAAAA,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyBkQ,SAAzB,IAAsCJ,IAAtC;AACA,UAAMK,kBAAkB,GAAGpF,IAAI,CAACqF,GAAL,CACzBrF,IAAI,CAACsF,KAAL,CAAWvQ,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyBkQ,SAAzB,GAAqC,KAAKpF,eAArD,CADyB,EAC8C,KAAKnB,uBADnD,CAA3B;AAGA7J,IAAAA,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyBkQ,SAAzB,IAAsCC,kBAAkB,GAAG,KAAKrF,eAAhE;;AAEA,SAAK,IAAIwF,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGH,kBAAR,IAA8B,KAAKlG,SAAvD,EAAkE,EAAEqG,KAApE,EAA2E;AACzE,UAAI,CAAC,KAAKC,IAAL,EAAL,EAAkB;AACnB;AACF,GAxW6B;;AA0W9BA,EAAAA,IAAI,GAAG;AACL,QAAI,KAAKrQ,KAAL,CAAW6J,OAAf,EAAwB,OAAO,KAAP;;AACxB,SAAK,IAAIyG,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAG,GAAR,IAAe,CAAC,KAAK5G,gBAAzC,EAA2D4G,KAAK,EAAhE,EAAoE;AAClE,cAAQ,KAAKC,iBAAL,EAAR;AACE,aAAKhT,wBAAwB,CAACM,gBAA9B;AACE,iBAAO,IAAP;;AACF,aAAKN,wBAAwB,CAACG,gBAA9B;AACE,iBAAO,KAAK8S,WAAL,EAAP;;AACF,aAAKjT,wBAAwB,CAACI,0BAA9B;AACE,iBAAO,KAAP;;AACF,aAAKJ,wBAAwB,CAACK,0BAA9B;AACE,eAAK4S,WAAL;AACA,iBAAO,KAAP;;AACF,aAAKjT,wBAAwB,CAACO,gBAA9B;AACE,eAAK0S,WAAL;AACA;;AACF,aAAKjT,wBAAwB,CAACQ,IAA9B;AACE,eAAKgS,IAAL;AACA,iBAAO,KAAP;;AACF,aAAKxS,wBAAwB,CAACS,OAA9B;AACE,eAAKyS,OAAL;AACA,iBAAO,KAAP;AAlBJ,OADkE,CAsBlE;AACA;;;AACA,UAAI,CAAC,KAAKzQ,KAAL,CAAW2K,GAAhB,EAAqB,KAAKjB,gBAAL,GAAwB,IAAxB;AACtB,KA3BI,CA6BL;AACA;AACA;AACA;AACA;;;AACA,QAAI,CAAC,KAAKA,gBAAV,EAA4B;AAC1B1G,MAAAA,MAAM,CAACC,MAAP,CAAc2E,KAAd,CAAoB,yDAApB;AACApH,MAAAA,aAAa,CAACsD,eAAd,CAA8B,kDAA9B,EAAkF,KAAK4G,iBAAvF;AACD;;AAED,SAAKqF,IAAL;AACA,WAAO,KAAP;AACD,GAnZ6B;;AAqZ9BF,EAAAA,UAAU,GAAG;AACX,QAAI,KAAK7P,KAAL,CAAW6J,OAAf,EAAwB,OADb,CAEX;AACA;AACA;AACA;AACA;;AACA,YAAQ,KAAK0G,iBAAL,EAAR;AACE,WAAKhT,wBAAwB,CAACI,0BAA9B;AACE;;AACF,WAAKJ,wBAAwB,CAACQ,IAA9B;AACE,aAAKgS,IAAL;AACA;;AACF,WAAKxS,wBAAwB,CAACS,OAA9B;AACE,aAAKyS,OAAL;AACA;;AACF;AACE,aAAKD,WAAL;AACA;AAXJ;AAaD,GAza6B;;AA2a9BD,EAAAA,iBAAiB,GAAG;AAClB,UAAMG,CAAC,GAAG,KAAK1Q,KAAL,CAAW2K,GAArB;AACA,UAAMgG,QAAQ,GAAGD,CAAC,CAACrR,QAAF,CAAWqR,CAAC,CAAChR,YAAb,EAA2BkR,GAA3B,CAA+BF,CAA/B,CAAjB;AACA,WAAOC,QAAP;AACD,GA/a6B;;AAib9BH,EAAAA,WAAW,GAAG;AACZ,UAAME,CAAC,GAAG,KAAK1Q,KAAL,CAAW2K,GAArB;;AACA,QAAI+F,CAAC,CAAChR,YAAF,IAAkBgR,CAAC,CAACrR,QAAF,CAAW6B,MAAX,GAAoB,CAA1C,EAA6C;AAC3C,WAAKlB,KAAL,CAAW+G,GAAX;;AACA,UAAI,KAAK/G,KAAL,CAAW6J,OAAf,EAAwB;AACtB;AACA;AACA,YAAI,KAAK9J,KAAL,CAAW8Q,MAAf,EAAuB;AACrB,eAAKC,KAAL,CAAW,KAAK/Q,KAAL,CAAWoK,cAAtB,EAAsClM,cAAc,CAACE,GAArD,EAA0D,KAA1D;AACA,iBAAO,KAAP;AACD;;AACD,aAAK4R,IAAL;AACD,OARD,MAQO,IAAI,KAAK/P,KAAL,CAAW2K,GAAX,CAAelL,YAAf,IAA+B,KAAKO,KAAL,CAAW2K,GAAX,CAAelL,YAAf,CAA4BsR,YAA/D,EAA6E;AAClFvQ,QAAAA,aAAa,CAACsD,eAAd,CAA+B,kBAA/B,EAAkD,KAAK9D,KAAL,CAAW2K,GAAX,CAAelL,YAAf,CAA4BuR,SAA9E;AACA,eAAO,KAAKR,WAAL,EAAP;AACD;AACF,KAdD,MAcO;AACLE,MAAAA,CAAC,CAACjR,YAAF,GAAiB,IAAjB;AACA,QAAEiR,CAAC,CAAChR,YAAJ;AACD;;AACD,WAAO,IAAP;AACD,GAtc6B;;AAwc9B0E,EAAAA,IAAI,CAAC/E,QAAD,EAAW;AACb;AACA,QAAIA,QAAQ,CAAC6B,MAAT,KAAoB,CAAxB,EAA2B;AAC3B,SAAKlB,KAAL,CAAWoE,IAAX,CAAgB/E,QAAhB;AACD,GA5c6B;;AA8c9B4R,EAAAA,UAAU,CAAC1S,EAAD,EAAK;AACb,WAAO,KAAKoL,QAAL,CAAcuH,IAAd,CAAmBtC,CAAC,IAAIA,CAAC,CAACrQ,EAAF,KAASA,EAAjC,CAAP;AACD,GAhd6B;;AAkd9B4S,EAAAA,oBAAoB,GAAG;AACrB,UAAMC,aAAa,GAAGnR,eAAe,CAACU,MAAhB,CAAuB,YAAvB,CAAtB;AACA,SAAKgJ,QAAL,GAAgB,CAACyH,aAAD,CAAhB;AACA,SAAKrR,KAAL,CAAWoK,cAAX,GAA4BiH,aAAa,CAAC7S,EAA1C;AACA,WAAO6S,aAAa,CAAC7S,EAArB;AACD,GAvd6B;;AAyd9BwQ,EAAAA,kBAAkB,GAAG;AACnB,UAAMsC,SAAS,GAAG7T,MAAM,CAACoD,IAAP,CAAYhB,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyBK,OAArC,EAA8C8F,GAA9C,CAAkD1H,EAAE,IAAI0L,QAAQ,CAAC1L,EAAD,EAAK,EAAL,CAAhE,CAAlB;;AACA,QAAI8S,SAAS,CAACnQ,MAAV,KAAqB,CAAzB,EAA4B;AAC1BmQ,MAAAA,SAAS,CAACjN,IAAV,CAAe,KAAK+M,oBAAL,EAAf;AACD,KAFD,MAEO;AACL,WAAKxH,QAAL,GAAgB0H,SAAS,CAACpL,GAAV,CAAcD,CAAC,IAAI,IAAI/F,eAAJ,CAAoB+F,CAApB,CAAnB,CAAhB;AACD;;AACD,QAAI,CAACqL,SAAS,CAACtE,QAAV,CAAmB,KAAKhN,KAAL,CAAWoK,cAA9B,CAAL,EAAoD,KAAKpK,KAAL,CAAWoK,cAAX,GAA4BkH,SAAS,CAAC,CAAD,CAArC;AACpD,UAAMC,aAAa,GAAG,KAAKL,UAAL,CAAgB,KAAKlR,KAAL,CAAWoK,cAA3B,CAAtB;;AACA,QAAImH,aAAa,CAACjS,QAAlB,EAA4B;AAC1B,YAAMA,QAAQ,GAAGiS,aAAa,CAACjS,QAA/B;AACA,UAAI,CAAC,KAAKW,KAAL,CAAW+O,kBAAX,CAA8B1P,QAA9B,CAAL,EAA8C,KAAKkS,KAAL,CAAWlS,QAAX;AAC/C,KAHD,MAGO;AACL,WAAKW,KAAL,CAAWwR,KAAX;AACD;AACF,GAxe6B;;AA0e9B;AACAxK,EAAAA,UAAU,CAACzI,EAAD,EAAK+H,IAAL,EAAW;AACnB,UAAMiF,MAAM,GAAG,KAAK0F,UAAL,CAAgB1S,EAAhB,CAAf;AACA,QAAI,CAACgN,MAAL,EAAa,OAFM,CAInB;AACA;AACA;AACA;;AACA,UAAMkG,OAAO,GAAGlG,MAAM,CAAChM,UAAP,CAAkBe,OAAlC;AACA,UAAMoR,SAAS,GAAG7G,IAAI,CAAC8G,GAAL,CAASF,OAAO,CAACvQ,MAAR,GAAiBoF,IAAI,CAACpF,MAA/B,CAAlB;AACAV,IAAAA,aAAa,CAAC6F,YAAd,CAA2BoL,OAA3B,EAAoCC,SAApC;AAEAnG,IAAAA,MAAM,CAAChL,IAAP,CAAY+F,IAAZ;AACA,QAAI/H,EAAE,KAAK,KAAKwB,KAAL,CAAWoK,cAAtB,EAAsC,KAAK4F,IAAL;AACvC,GAzf6B;;AA2f9BhN,EAAAA,SAAS,GAAG;AACV;AACA,UAAM6O,WAAW,GAAGtN,gBAAgB,CAACqF,QAAjB,CAA0B1D,GAA1B,CAA8BD,CAAC,IAAIA,CAAC,CAACxH,IAArC,CAApB;;AACA,QAAIuE,SAAJ;;AACA,QAAI6O,WAAW,CAAC7E,QAAZ,CAAqB,YAArB,CAAJ,EAAwC;AACtC,UAAI8E,QAAQ,GAAG,CAAf;;AACA,aAAOD,WAAW,CAAC7E,QAAZ,CAAsB,eAAc8E,QAAS,GAA7C,CAAP,EAAyDA,QAAQ;;AACjE9O,MAAAA,SAAS,GAAG9C,eAAe,CAACU,MAAhB,CAAwB,eAAckR,QAAS,GAA/C,CAAZ;AACD,KAJD,MAIO;AACL9O,MAAAA,SAAS,GAAG9C,eAAe,CAACU,MAAhB,CAAuB,YAAvB,CAAZ;AACD;;AAED,SAAKgJ,QAAL,CAAcvF,IAAd,CAAmBrB,SAAnB;;AACA,WAAOA,SAAP;AACD,GAzgB6B;;AA2gB9B;AACA;AACA+O,EAAAA,YAAY,CAACvT,EAAD,EAAK;AACf;AACA,UAAMwT,MAAM,GAAGvU,MAAM,CAACsI,MAAP,CAAclG,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyBK,OAAvC,EAAgDW,SAAhD,CAA0DkF,CAAC,IAAIA,CAAC,CAACzH,EAAF,KAASA,EAAxE,CAAf;AACA,WAAOqB,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyBK,OAAzB,CAAiC8J,QAAQ,CAACzM,MAAM,CAACoD,IAAP,CAAYhB,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyBK,OAArC,EAA8C4R,MAA9C,CAAD,EAAwD,EAAxD,CAAzC,CAAP;;AACA,UAAMC,GAAG,GAAG,KAAKrI,QAAL,CAAc7I,SAAd,CAAwB8N,CAAC,IAAIA,CAAC,CAACrQ,EAAF,KAASA,EAAtC,CAAZ;;AACA,SAAKoL,QAAL,CAAc0D,MAAd,CAAqB2E,GAArB,EAA0B,CAA1B;;AACA,QAAI,KAAKrI,QAAL,CAAczI,MAAd,KAAyB,CAA7B,EAAgC;AAC9B,WAAKiQ,oBAAL;;AACA,WAAKc,WAAL;AACD;;AACD,QAAI1T,EAAE,KAAK,KAAKwB,KAAL,CAAWoK,cAAtB,EAAsC;AACpC,WAAK4F,IAAL;AACA,WAAKhQ,KAAL,CAAWoK,cAAX,GAA4B,KAAKR,QAAL,CAAc,CAAd,EAAiBpL,EAA7C;AACD;;AACD4E,IAAAA,QAAQ,CAACC,QAAT,CAAkBC,UAAU,CAACC,sBAA7B;AACD,GA5hB6B;;AA8hB9B4O,EAAAA,YAAY,GAAG;AACb,SAAKnS,KAAL,CAAW8Q,MAAX,GAAoB,CAAC,KAAK9Q,KAAL,CAAW8Q,MAAhC;AACD,GAhiB6B;;AAkiB9BsB,EAAAA,kBAAkB,GAAG;AACnB,SAAKpS,KAAL,CAAWqS,YAAX,GAA0B,CAAC,KAAKrS,KAAL,CAAWqS,YAAtC;AACD,GApiB6B;;AAsiB9BC,EAAAA,qBAAqB,GAAG;AACtB,SAAKtS,KAAL,CAAW+P,eAAX,GAA6B,CAAC,KAAK/P,KAAL,CAAW+P,eAAzC;AACA,SAAKwC,gBAAL;AACD,GAziB6B;;AA2iB9BA,EAAAA,gBAAgB,GAAG;AACjB,UAAMvS,KAAK,GAAG,KAAKA,KAAnB;AACA,UAAMwS,aAAa,GAAGxS,KAAK,CAACoK,cAAN,KAAyBpK,KAAK,CAAC0C,YAArD;;AACA,QAAI8P,aAAa,IAAI,KAAKxI,SAAtB,IAAmChK,KAAK,CAAC+P,eAA7C,EAA8D;AAC5DtH,MAAAA,iBAAiB,CAACC,eAAlB,CAAkCnE,gBAAgB,CAACtE,KAAjB,CAAuB2K,GAAvB,CAA2BnL,UAA7D;AACD;AACF,GAjjB6B;;AAmjB9B+R,EAAAA,KAAK,CAAClS,QAAD,EAAW;AACd,SAAKW,KAAL,CAAWwR,KAAX;AACA,SAAKpN,IAAL,CAAU/E,QAAV;AACD,GAtjB6B;;AAwjB9B0Q,EAAAA,IAAI,GAAG;AACL,SAAK/P,KAAL,CAAWwR,KAAX;AACA,SAAKzR,KAAL,CAAW+J,IAAX,GAAkB7L,cAAc,CAACC,KAAjC;AACA,SAAKwL,gBAAL,GAAwB,IAAxB;AACAjC,IAAAA,oBAAoB,CAACW,wBAArB;AACD,GA7jB6B;;AA+jB9BoK,EAAAA,KAAK,GAAG;AACN,SAAKzS,KAAL,CAAW+J,IAAX,GAAkB7L,cAAc,CAACC,KAAjC;AACD,GAjkB6B;;AAmkB9B4S,EAAAA,KAAK,CAACxF,QAAQ,GAAG,KAAKvL,KAAL,CAAWoK,cAAvB,EAAuCsI,WAAW,GAAGxU,cAAc,CAACE,GAApE,EAAyEb,OAAO,GAAG,IAAnF,EAAyF;AAC5F;AACA,QAAI,CAACoV,MAAM,CAACC,iBAAZ,EAA+B;AAC/B,SAAKjJ,gBAAL,GAAwB,KAAxB;AACA,SAAK3J,KAAL,CAAWoK,cAAX,GAA4BmB,QAA5B;AACA1L,IAAAA,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyBkQ,SAAzB,GAAqC,CAArC;AACA,UAAM4C,YAAY,GAAG,KAAK3B,UAAL,CAAgB3F,QAAhB,CAArB;AACA,QAAI,CAACsH,YAAL,EAAmB;AACnB,QAAItV,OAAJ,EAAasV,YAAY,CAACtV,OAAb;;AACb,QAAIsV,YAAY,CAACvT,QAAjB,EAA2B;AACzB,WAAKkS,KAAL,CAAWqB,YAAY,CAACvT,QAAxB;AACA,WAAKU,KAAL,CAAW+J,IAAX,GAAkB2I,WAAlB;AACD;;AACDjS,IAAAA,aAAa,CAACY,SAAd,GAA0B,KAA1B;AACA,QAAIxB,MAAM,CAACkF,OAAP,CAAeC,eAAf,CAA+B8N,cAAnC,EAAmDrS,aAAa,CAAC0E,aAAd;AACpD,GAllB6B;;AAolB9BuL,EAAAA,OAAO,GAAG;AACR;AACA;AACA,SAAKK,KAAL,CAAW,KAAK/Q,KAAL,CAAWoK,cAAtB,EAAsClM,cAAc,CAACE,GAArD;AACA,QAAI,KAAK6B,KAAL,CAAW6J,OAAf,EAAwB;AACxB,SAAK0H,KAAL,CAAW,KAAKvR,KAAL,CAAW8S,KAAX,CAAiB,CAAjB,EAAoBzT,QAA/B;AACD,GA1lB6B;;AA4lB9B0T,EAAAA,WAAW,CAACzH,QAAD,EAAW;AACpB0H,IAAAA,QAAQ,CAACC,MAAT,CAAgBC,cAAc,CAACC,SAA/B;;AACA,QAAIvT,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyBsF,IAAzB,KAAkCxG,cAAc,CAACE,KAArD,EAA4D;AAC1D;AACA2G,MAAAA,cAAc,CAAC2N,mBAAf;AACAxT,MAAAA,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyBsF,IAAzB,GAAgCxG,cAAc,CAACC,IAA/C;AACD,KAJD,MAIO;AACL,YAAMwU,SAAS,GAAGhO,eAAe,CAACC,MAAhB,CAAuBC,MAAvB,GAAgCC,QAAhC,EAAlB,CADK,CAEL;;AACAC,MAAAA,cAAc,CAACyB,YAAf,CAA4BmM,SAA5B;AACA/O,MAAAA,gBAAgB,CAAC0C,UAAjB,CAA4BsE,QAA5B,EAAsC+H,SAAtC;AACAzT,MAAAA,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyBsF,IAAzB,GAAgCxG,cAAc,CAACE,KAA/C;AACD;;AACD2I,IAAAA,oBAAoB,CAACW,wBAArB;AACAjF,IAAAA,QAAQ,CAACmQ,EAAT,CAAYlQ,QAAZ,CAAqBC,UAAU,CAACkQ,sBAAhC;AACD,GA3mB6B;;AA6mB9BtB,EAAAA,WAAW,GAAG;AACZ,QAAIrS,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyBsF,IAAzB,KAAkCxG,cAAc,CAACE,KAArD,EAA4D;AAC1D2G,MAAAA,cAAc,CAACwM,WAAf;AACD,KAFD,MAEO;AACL5M,MAAAA,eAAe,CAAC4M,WAAhB;AACD;AACF,GAnnB6B;;AAqnB9BjS,EAAAA,KAAK,EAAE;AACL8S,IAAAA,KAAK,EAAE,EADF;;AAEL1O,IAAAA,IAAI,CAAC/E,QAAD,EAAW;AACb,YAAMmU,QAAQ,GAAG,IAAIzU,mBAAJ,CAAwB,KAAKmC,MAA7B,CAAjB;AACAsS,MAAAA,QAAQ,CAACpU,aAAT,CAAuBC,QAAvB;;AACA,WAAKyT,KAAL,CAAW1O,IAAX,CAAgBoP,QAAhB;AACD,KANI;;AAOLzM,IAAAA,GAAG,GAAG;AACJ,UAAI,KAAK+L,KAAL,CAAW5R,MAAX,KAAsB,CAA1B,EAA6B;AAC7BtB,MAAAA,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyBC,KAAzB,CAA+BC,KAA/B,CAAqC+G,GAArC;;AACA,WAAK+L,KAAL,CAAW/L,GAAX;AACD,KAXI;;AAYLyK,IAAAA,KAAK,GAAG;AACN,WAAKsB,KAAL,GAAa,EAAb;AACAlT,MAAAA,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyBC,KAAzB,CAA+BC,KAA/B,CAAqCkB,MAArC,GAA8C,CAA9C;AACD,KAfI;;AAgBL6N,IAAAA,kBAAkB,CAAC1P,QAAD,EAAW;AAC3B,WAAKyT,KAAL,GAAa,EAAb;AACA,YAAMW,WAAW,GAAG7T,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyBC,KAAzB,CAA+BC,KAAnD;AACA,UAAI0T,eAAe,GAAGrU,QAAtB;;AACA,WAAK,IAAIsU,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGF,WAAW,CAACvS,MAAxC,EAAgD,EAAEyS,KAAlD,EAAyD;AACvD,cAAMC,WAAW,GAAGH,WAAW,CAACE,KAAD,CAA/B;AACA,cAAMH,QAAQ,GAAG,IAAIzU,mBAAJ,CAAwB4U,KAAxB,CAAjB;AACAH,QAAAA,QAAQ,CAACnU,QAAT,GAAoBqU,eAApB;AACA,cAAMG,UAAU,GAAGH,eAAe,CAAC5S,SAAhB,CAA0B8N,CAAC,IAAIA,CAAC,CAACpP,UAAF,KAAiBoU,WAAW,CAACpU,UAA5D,CAAnB;;AACA,YAAIqU,UAAU,KAAK,CAAC,CAApB,EAAuB;AACrB;AACA,iBAAO,KAAP;AACD;;AACDL,QAAAA,QAAQ,CAAC9T,YAAT,GAAwBmU,UAAxB;;AACA,aAAKf,KAAL,CAAW1O,IAAX,CAAgBoP,QAAhB,EAVuD,CAWvD;;;AACA,YAAIG,KAAK,KAAKF,WAAW,CAACvS,MAAZ,GAAqB,CAAnC,EAAsC;AACpC,cAAIwS,eAAe,CAACG,UAAD,CAAf,CAA4BC,aAA5B,KAA8CC,SAAlD,EAA6D;AAC3D,mBAAO,KAAP;AACD;;AACDL,UAAAA,eAAe,GAAGA,eAAe,CAACG,UAAD,CAAf,CAA4BC,aAA9C;AACD;AACF;;AACD,aAAO,IAAP;AACD,KAxCI;;AAyCL,QAAInJ,GAAJ,GAAU;AACR,aAAO,KAAKmI,KAAL,CAAW,KAAK5R,MAAL,GAAc,CAAzB,CAAP;AACD,KA3CI;;AA4CL,QAAIA,MAAJ,GAAa;AACX,UAAI,KAAK4R,KAAL,CAAW5R,MAAX,KAAsBtB,MAAM,CAACC,OAAP,CAAeC,SAAf,CAAyBC,KAAzB,CAA+BC,KAA/B,CAAqCkB,MAA/D,EAAuE;AACrE,cAAM,IAAIsG,KAAJ,CAAU,2BAAV,CAAN;AACD;;AACD,aAAO,KAAKsL,KAAL,CAAW5R,MAAlB;AACD,KAjDI;;AAkDL,QAAI2I,OAAJ,GAAc;AACZ,aAAO,KAAKiJ,KAAL,CAAW5R,MAAX,KAAsB,CAA7B;AACD;;AApDI;AArnBuB,CAAzB","sourcesContent":["import { compile } from \"./compiler\";\r\n\r\nexport const AUTOMATOR_COMMAND_STATUS = Object.freeze({\r\n  NEXT_INSTRUCTION: 0,\r\n  NEXT_TICK_SAME_INSTRUCTION: 1,\r\n  NEXT_TICK_NEXT_INSTRUCTION: 2,\r\n  // This is used to handle some special cases, like branches/loops:\r\n  SAME_INSTRUCTION: 3,\r\n  SKIP_INSTRUCTION: 4,\r\n  HALT: 5,\r\n  RESTART: 6,\r\n});\r\n\r\nexport const AUTOMATOR_MODE = Object.freeze({\r\n  PAUSE: 1,\r\n  RUN: 2,\r\n  SINGLE_STEP: 3,\r\n});\r\n\r\n\r\nexport const AUTOMATOR_VAR_TYPES = {\r\n  NUMBER: { id: 0, name: \"number\" },\r\n  STUDIES: { id: 1, name: \"studies\" },\r\n  DURATION: { id: 2, name: \"duration\" },\r\n  UNKNOWN: { id: -1, name: \"unknown\" },\r\n};\r\n\r\nexport const AUTOMATOR_TYPE = Object.freeze({\r\n  TEXT: 0,\r\n  BLOCK: 1\r\n});\r\n\r\n/**\r\n * This object represents a single entry on the execution stack. It's a combination\r\n * of transient and persistent values -- we don't store the compiled script or indices\r\n * in the player object, but they are part of the stack.\r\n */\r\nclass AutomatorStackEntry {\r\n  constructor(stackIndex) {\r\n    this._stackIndex = stackIndex;\r\n    this._commandIndex = 0;\r\n  }\r\n\r\n  // This is used when a new thing is put on the stack (rather than us creating objects\r\n  // when loading a game)\r\n  initializeNew(commands) {\r\n    this._commands = commands;\r\n    this._commandIndex = 0;\r\n    this.persistent = {\r\n      lineNumber: commands[0].lineNumber,\r\n      commandState: null,\r\n    };\r\n  }\r\n\r\n  get commandIndex() {\r\n    return this._commandIndex;\r\n  }\r\n\r\n  set commandIndex(value) {\r\n    this._commandIndex = value;\r\n    this.lineNumber = this._commands[value].lineNumber;\r\n  }\r\n\r\n  get lineNumber() {\r\n    return this.persistent.lineNumber;\r\n  }\r\n\r\n  set lineNumber(value) {\r\n    this.persistent.lineNumber = value;\r\n  }\r\n\r\n  /**\r\n  * @returns {object|null} commandState used by commands to track their own data, such as remaining wait time\r\n  */\r\n  get commandState() {\r\n    return this.persistent.commandState;\r\n  }\r\n\r\n  set commandState(value) {\r\n    this.persistent.commandState = value;\r\n  }\r\n\r\n  get persistent() {\r\n    return player.reality.automator.state.stack[this._stackIndex];\r\n  }\r\n\r\n  set persistent(value) {\r\n    player.reality.automator.state.stack[this._stackIndex] = value;\r\n  }\r\n\r\n  get commands() {\r\n    return this._commands;\r\n  }\r\n\r\n  set commands(value) {\r\n    this._commands = value;\r\n  }\r\n}\r\n\r\nexport class AutomatorScript {\r\n  constructor(id) {\r\n    this._id = id;\r\n    this.compile();\r\n  }\r\n\r\n  get id() {\r\n    return this._id;\r\n  }\r\n\r\n  get name() {\r\n    return this.persistent.name;\r\n  }\r\n\r\n  set name(value) {\r\n    this.persistent.name = value;\r\n  }\r\n\r\n  get persistent() {\r\n    return player.reality.automator.scripts[this._id];\r\n  }\r\n\r\n  get commands() {\r\n    return this._compiled;\r\n  }\r\n\r\n  get text() {\r\n    return this.persistent.content;\r\n  }\r\n\r\n  save(content) {\r\n    if (AutomatorData.isWithinLimit()) this.persistent.content = content;\r\n    this.compile();\r\n  }\r\n\r\n  compile() {\r\n    this._compiled = compile(this.text).compiled;\r\n  }\r\n\r\n  static create(name, content = \"\") {\r\n    const scripts = Object.keys(player.reality.automator.scripts);\r\n    const missingIndex = scripts.findIndex((x, y) => y + 1 !== Number(x));\r\n    let id = 1 + (missingIndex === -1 ? scripts.length : missingIndex);\r\n    // On a fresh save, this executes before player is properly initialized\r\n    if (!player.reality.automator.scripts || id === 0) id = 1;\r\n    player.reality.automator.scripts[id] = {\r\n      id,\r\n      name,\r\n      content,\r\n    };\r\n    return new AutomatorScript(id);\r\n  }\r\n}\r\n\r\nexport const AutomatorData = {\r\n  // Used for getting the correct EC count in event log\r\n  lastECCompletionCount: 0,\r\n  // Used as a flag to make sure that wait commands only add one entry to the log instead of every execution attempt\r\n  isWaiting: false,\r\n  waitStart: 0,\r\n  lastEvent: 0,\r\n  eventLog: [],\r\n  isEditorFullscreen: false,\r\n  needsRecompile: true,\r\n  cachedErrors: 0,\r\n  // This is to hold finished script templates as text in order to make the custom blocks for blockmato\r\n  blockTemplates: [],\r\n  undoBuffer: [],\r\n  redoBuffer: [],\r\n  charsSinceLastUndoState: 0,\r\n\r\n  MAX_ALLOWED_SCRIPT_CHARACTERS: 10000,\r\n  MAX_ALLOWED_TOTAL_CHARACTERS: 60000,\r\n  MAX_ALLOWED_SCRIPT_NAME_LENGTH: 15,\r\n  MAX_ALLOWED_SCRIPT_COUNT: 20,\r\n  MAX_ALLOWED_CONSTANT_NAME_LENGTH: 20,\r\n  // Note that a study string with ALL studies in unshortened form without duplicated studies is ~230 characters\r\n  MAX_ALLOWED_CONSTANT_VALUE_LENGTH: 250,\r\n  MAX_ALLOWED_CONSTANT_COUNT: 30,\r\n  MIN_CHARS_BETWEEN_UNDOS: 10,\r\n  MAX_UNDO_ENTRIES: 30,\r\n\r\n  scriptIndex() {\r\n    return player.reality.automator.state.editorScript;\r\n  },\r\n  currentScriptName() {\r\n    return player.reality.automator.scripts[this.scriptIndex()].name;\r\n  },\r\n  currentScriptText(index) {\r\n    const toCheck = index || this.scriptIndex();\r\n    return player.reality.automator.scripts[toCheck]?.content;\r\n  },\r\n  createNewScript(content, name) {\r\n    const newScript = AutomatorScript.create(name, content);\r\n    GameUI.notify.automator(`Imported Script \"${name}\"`);\r\n    player.reality.automator.state.editorScript = newScript.id;\r\n    AutomatorData.clearUndoData();\r\n    EventHub.dispatch(GAME_EVENT.AUTOMATOR_SAVE_CHANGED);\r\n  },\r\n  recalculateErrors() {\r\n    const toCheck = this.currentScriptText();\r\n    this.cachedErrors = compile(toCheck).errors;\r\n    this.cachedErrors.sort((a, b) => a.startLine - b.startLine);\r\n  },\r\n  currentErrors() {\r\n    if (this.needsRecompile) {\r\n      this.recalculateErrors();\r\n      this.needsRecompile = false;\r\n    }\r\n    return this.cachedErrors;\r\n  },\r\n  logCommandEvent(message, line) {\r\n    const currTime = Date.now();\r\n    this.eventLog.push({\r\n      // Messages often overflow the 120 col limit and extra spacing gets included in the message - remove it\r\n      message: message.replaceAll(/\\s?\\n\\s+/gu, \" \"),\r\n      line: AutomatorBackend.translateLineNumber(line),\r\n      thisReality: Time.thisRealityRealTime.totalSeconds,\r\n      timestamp: currTime,\r\n      timegap: currTime - this.lastEvent\r\n    });\r\n    this.lastEvent = currTime;\r\n    // Remove the oldest entry if the log is too large\r\n    if (this.eventLog.length > player.options.automatorEvents.maxEntries) this.eventLog.shift();\r\n  },\r\n  clearEventLog() {\r\n    this.eventLog = [];\r\n    this.lastEvent = 0;\r\n  },\r\n  // We need to get the current character count from the editor itself instead of the player object, because otherwise\r\n  // any changes made after getting above either limit will never be saved. Note that if the player is on the automator\r\n  // subtab before the automator is unlocked, editor is undefined\r\n  singleScriptCharacters() {\r\n    return player.reality.automator.type === AUTOMATOR_TYPE.TEXT\r\n      ? AutomatorTextUI.editor?.getDoc().getValue().length ?? 0\r\n      : BlockAutomator.parseLines(BlockAutomator.lines).join(\"\\n\").length;\r\n  },\r\n  totalScriptCharacters() {\r\n    return Object.values(player.reality.automator.scripts)\r\n      .filter(s => s.id !== this.scriptIndex())\r\n      .map(s => s.content.length)\r\n      .reduce((sum, len) => sum + len, 0) +\r\n      this.singleScriptCharacters();\r\n  },\r\n  isWithinLimit() {\r\n    return this.singleScriptCharacters() <= this.MAX_ALLOWED_SCRIPT_CHARACTERS &&\r\n      this.totalScriptCharacters() <= this.MAX_ALLOWED_TOTAL_CHARACTERS;\r\n  },\r\n\r\n  // This must be called every time the current script or editor mode are changed\r\n  clearUndoData() {\r\n    this.undoBuffer = [];\r\n    this.redoBuffer = [];\r\n    this.charsSinceLastUndoState = 0;\r\n  },\r\n  // We only save an undo state every so often based on the number of characters that have been modified\r\n  // since the last state. This gets passed in as a parameter and gets called every time any typing is done,\r\n  // but only actually does something when that threshold is reached.\r\n  pushUndoData(data, newChars) {\r\n    // If the buffer is empty, then we need to immediately write to the buffer (ignoring character changes)\r\n    // because otherwise edits can't be fully undone back to the very first change\r\n    this.charsSinceLastUndoState += newChars;\r\n    const pastGap = this.charsSinceLastUndoState <= this.MIN_CHARS_BETWEEN_UNDOS;\r\n    if (pastGap && this.undoBuffer.length !== 0) return;\r\n\r\n    if (this.undoBuffer[this.undoBuffer.length - 1] !== data) this.undoBuffer.push(data);\r\n    if (this.undoBuffer.length > this.MAX_UNDO_ENTRIES) this.undoBuffer.shift();\r\n    this.charsSinceLastUndoState = 0;\r\n  },\r\n  pushRedoData(data) {\r\n    if (this.redoBuffer[this.redoBuffer.length - 1] !== data) this.redoBuffer.push(data);\r\n  },\r\n  // These following two methods pop the top entry off of the undo/redo stack and then push it\r\n  // onto the *other* stack before modifying all the relevant UI elements and player props. These\r\n  // could in principle be combined into one function to reduce boilerplace, but keeping them\r\n  // separate is probably more readable externally\r\n  undoScriptEdit() {\r\n    if (this.undoBuffer.length === 0 || Tabs.current._currentSubtab.name !== \"Automator\") return;\r\n\r\n    const undoContent = this.undoBuffer.pop();\r\n    this.pushRedoData(this.currentScriptText());\r\n    player.reality.automator.scripts[this.scriptIndex()].content = undoContent;\r\n\r\n    AutomatorBackend.saveScript(this.scriptIndex(), undoContent);\r\n    if (player.reality.automator.type === AUTOMATOR_TYPE.TEXT) AutomatorTextUI.editor.setValue(undoContent);\r\n    else BlockAutomator.updateEditor(undoContent);\r\n  },\r\n  redoScriptEdit() {\r\n    if (this.redoBuffer.length === 0 || Tabs.current._currentSubtab.name !== \"Automator\") return;\r\n\r\n    const redoContent = this.redoBuffer.pop();\r\n    // We call this with a value which is always higher than said threshold, forcing the current text to be pushed\r\n    this.pushUndoData(this.currentScriptText(), 2 * this.MIN_CHARS_BETWEEN_UNDOS);\r\n    player.reality.automator.scripts[this.scriptIndex()].content = redoContent;\r\n\r\n    AutomatorBackend.saveScript(this.scriptIndex(), redoContent);\r\n    if (player.reality.automator.type === AUTOMATOR_TYPE.TEXT) AutomatorTextUI.editor.setValue(redoContent);\r\n    else BlockAutomator.updateEditor(redoContent);\r\n  }\r\n};\r\n\r\nexport const LineEnum = { Active: \"active\", Event: \"event\", Error: \"error\" };\r\n\r\n// Manages line highlighting in a way which is agnostic to the current editor mode (line or block). Ironically this is\r\n// actually easier to manage in block mode as the Vue components render each line individually and we can just\r\n// conditionally add classes in the template. The highlighting in text mode needs to be spliced and removed inline\r\n// within the CodeMirror editor\r\nexport const AutomatorHighlighter = {\r\n  lines: {\r\n    active: -1,\r\n    event: -1,\r\n    error: -1,\r\n  },\r\n\r\n  updateHighlightedLine(line, key) {\r\n    if (player.reality.automator.type === AUTOMATOR_TYPE.TEXT && line !== -1) {\r\n      if (!AutomatorTextUI.editor) return;\r\n      this.removeHighlightedTextLine(key);\r\n      this.addHighlightedTextLine(line, key);\r\n    } else {\r\n      this.lines[key] = line;\r\n    }\r\n  },\r\n\r\n  // We need to specifically remove the highlighting class from the old line before splicing it in for the new line\r\n  removeHighlightedTextLine(key) {\r\n    const removedLine = this.lines[key] - 1;\r\n    AutomatorTextUI.editor.removeLineClass(removedLine, \"background\", `c-automator-editor__${key}-line`);\r\n    AutomatorTextUI.editor.removeLineClass(removedLine, \"gutter\", `c-automator-editor__${key}-line-gutter`);\r\n    this.lines[key] = -1;\r\n  },\r\n  addHighlightedTextLine(line, key) {\r\n    AutomatorTextUI.editor.addLineClass(line - 1, \"background\", `c-automator-editor__${key}-line`);\r\n    AutomatorTextUI.editor.addLineClass(line - 1, \"gutter\", `c-automator-editor__${key}-line-gutter`);\r\n    this.lines[key] = line;\r\n  },\r\n\r\n  clearAllHighlightedLines() {\r\n    for (const lineType of Object.values(LineEnum)) {\r\n      if (player.reality.automator.type === AUTOMATOR_TYPE.TEXT && AutomatorTextUI.editor) {\r\n        for (let line = 0; line < AutomatorTextUI.editor.doc.size; line++) {\r\n          AutomatorTextUI.editor.removeLineClass(line, \"background\", `c-automator-editor__${lineType}-line`);\r\n          AutomatorTextUI.editor.removeLineClass(line, \"gutter\", `c-automator-editor__${lineType}-line-gutter`);\r\n        }\r\n      }\r\n      this.lines[lineType] = -1;\r\n    }\r\n  }\r\n};\r\n\r\n// Manages line highlighting in a way which is agnostic to the current editor mode (line or block)\r\nexport const AutomatorScroller = {\r\n  // Block editor counts lines differently due to modified loop structure; this method handles that internally\r\n  scrollToRawLine(line) {\r\n    const targetLine = player.reality.automator.type === AUTOMATOR_TYPE.TEXT\r\n      ? line\r\n      : AutomatorBackend.translateLineNumber(line);\r\n    this.scrollToLine(targetLine);\r\n  },\r\n\r\n  scrollToLine(line) {\r\n    let editor, textHeight, lineToScroll;\r\n    if (player.reality.automator.type === AUTOMATOR_TYPE.TEXT) {\r\n      // We can't use CodeMirror's scrollIntoView() method as that forces the entire viewport to keep the line in view.\r\n      // This can potentially cause a softlock with \"follow execution\" enabled on sufficiently short screens.\r\n      editor = document.querySelector(\".CodeMirror-scroll\");\r\n      textHeight = AutomatorTextUI.editor.defaultTextHeight();\r\n      lineToScroll = line + 1;\r\n    } else {\r\n      editor = BlockAutomator.editor;\r\n      textHeight = 34.5;\r\n      lineToScroll = line;\r\n    }\r\n\r\n    // In both cases we might potentially try to scroll before the editor has properly initialized (ie. the automator\r\n    // itself ends up loading up faster than the editor UI element)\r\n    if (!editor) return;\r\n\r\n    const paddedHeight = editor.clientHeight - 40;\r\n    const newScrollPos = textHeight * (lineToScroll - 1);\r\n    if (newScrollPos > editor.scrollTop + paddedHeight) editor.scrollTo(0, newScrollPos - paddedHeight);\r\n    if (newScrollPos < editor.scrollTop) editor.scrollTo(0, newScrollPos);\r\n    if (player.reality.automator.type === AUTOMATOR_TYPE.BLOCK) {\r\n      BlockAutomator.gutter.style.bottom = `${editor.scrollTop}px`;\r\n    }\r\n  }\r\n};\r\n\r\nexport const AutomatorBackend = {\r\n  MAX_COMMANDS_PER_UPDATE: 100,\r\n  hasJustCompleted: false,\r\n  _scripts: [],\r\n\r\n  get state() {\r\n    return player.reality.automator.state;\r\n  },\r\n\r\n  // The Automator may be paused at some instruction, but still be on.\r\n  get isOn() {\r\n    return !this.stack.isEmpty;\r\n  },\r\n\r\n  /**\r\n  * @returns {AUTOMATOR_MODE}\r\n  */\r\n  get mode() {\r\n    return this.state.mode;\r\n  },\r\n\r\n  set mode(value) {\r\n    this.state.mode = value;\r\n  },\r\n\r\n  get isRunning() {\r\n    return this.isOn && this.mode === AUTOMATOR_MODE.RUN;\r\n  },\r\n\r\n  findRawScriptObject(id) {\r\n    const scripts = player.reality.automator.scripts;\r\n    const index = Object.values(scripts).findIndex(s => s.id === id);\r\n    return scripts[parseInt(Object.keys(scripts)[index], 10)];\r\n  },\r\n\r\n  get currentRunningScript() {\r\n    return this.findRawScriptObject(this.state.topLevelScript);\r\n  },\r\n\r\n  get currentEditingScript() {\r\n    return this.findRawScriptObject(player.reality.automator.state.editorScript);\r\n  },\r\n\r\n  get scriptName() {\r\n    return this.currentRunningScript?.name ?? \"\";\r\n  },\r\n\r\n  hasDuplicateName(name) {\r\n    const nameArray = Object.values(player.reality.automator.scripts).map(s => s.name);\r\n    return nameArray.filter(n => n === name).length > 1;\r\n  },\r\n\r\n  // Scripts are internally stored and run as text, but block mode has a different layout for loops that\r\n  // shifts a lot of commands around. Therefore we need to conditionally change it based on mode in order\r\n  // to make sure the player is presented with the correct line number\r\n  translateLineNumber(num) {\r\n    if (player.reality.automator.type === AUTOMATOR_TYPE.TEXT) return num;\r\n    return BlockAutomator.lineNumber(num);\r\n  },\r\n\r\n  get currentLineNumber() {\r\n    if (!this.stack.top) return -1;\r\n    return this.translateLineNumber(this.stack.top.lineNumber);\r\n  },\r\n\r\n  get currentInterval() {\r\n    return Math.clampMin(Math.pow(0.994, Currency.realities.value) * 500, 1);\r\n  },\r\n\r\n  get currentRawText() {\r\n    return this.currentRunningScript?.content ?? \"\";\r\n  },\r\n\r\n  get currentScriptLength() {\r\n    return this.currentRawText.split(\"\\n\").length;\r\n  },\r\n\r\n  // Finds which study presets are referenced within the specified script\r\n  getUsedPresets(scriptID) {\r\n    const script = this.findRawScriptObject(scriptID);\r\n    if (!script) return null;\r\n\r\n    const foundPresets = new Set();\r\n    const lines = script.content.split(\"\\n\");\r\n    for (const rawLine of lines) {\r\n      const matchPresetID = rawLine.match(/studies( nowait)? load id ([1-6])/ui);\r\n      if (matchPresetID) foundPresets.add(Number(matchPresetID[2]) - 1);\r\n      const matchPresetName = rawLine.match(/studies( nowait)? load name (\\S+)/ui);\r\n      if (matchPresetName) {\r\n        // A script might pass the regex match, but actually be referencing a preset which doesn't exist by name\r\n        const presetID = player.timestudy.presets.findIndex(p => p.name === matchPresetName[2]);\r\n        if (presetID !== -1) foundPresets.add(presetID);\r\n      }\r\n    }\r\n    const presets = Array.from(foundPresets);\r\n    presets.sort();\r\n    return presets;\r\n  },\r\n\r\n  // Finds which constants are referenced within the specified script\r\n  getUsedConstants(scriptID) {\r\n    const script = this.findRawScriptObject(scriptID);\r\n    if (!script) return null;\r\n\r\n    const foundConstants = new Set();\r\n    const lines = script.content.split(\"\\n\");\r\n    for (const rawLine of lines) {\r\n      const availableConstants = Object.keys(player.reality.automator.constants);\r\n      // Needs a space-padded regex match so that (for example) a constant \"unl\" doesn't match to an unlock command\r\n      // Additionally we need a negative lookbehind in order to ignore matches with presets which have the same name\r\n      for (const key of availableConstants) {\r\n        if (rawLine.match(`(?<![Nn][Aa][Mm][Ee])\\\\s${key}(\\\\s|$)`)) foundConstants.add(key);\r\n      }\r\n    }\r\n    const constants = Array.from(foundConstants);\r\n    constants.sort();\r\n    return constants;\r\n  },\r\n\r\n  // All modifications to constants should go these four methods in order to properly update both the constant prop and\r\n  // the sorting order prop while keeping them consistent with each other\r\n  addConstant(constantName, value) {\r\n    if (Object.keys(player.reality.automator.constants).length >= AutomatorData.MAX_ALLOWED_CONSTANT_COUNT) return;\r\n    player.reality.automator.constants[constantName] = value;\r\n    player.reality.automator.constantSortOrder.push(constantName);\r\n    EventHub.dispatch(GAME_EVENT.AUTOMATOR_CONSTANT_CHANGED);\r\n  },\r\n  modifyConstant(constantName, newValue) {\r\n    if (Object.keys(player.reality.automator.constants).includes(constantName)) {\r\n      player.reality.automator.constants[constantName] = newValue;\r\n      EventHub.dispatch(GAME_EVENT.AUTOMATOR_CONSTANT_CHANGED);\r\n    } else {\r\n      this.addConstant(constantName, newValue);\r\n    }\r\n  },\r\n  renameConstant(oldName, newName) {\r\n    const data = player.reality.automator.constants[oldName];\r\n    player.reality.automator.constants[newName] = data;\r\n    delete player.reality.automator.constants[oldName];\r\n\r\n    const index = player.reality.automator.constantSortOrder.indexOf(oldName);\r\n    if (index !== -1) player.reality.automator.constantSortOrder[index] = newName;\r\n    EventHub.dispatch(GAME_EVENT.AUTOMATOR_CONSTANT_CHANGED);\r\n  },\r\n  deleteConstant(constantName) {\r\n    delete player.reality.automator.constants[constantName];\r\n    const index = player.reality.automator.constantSortOrder.indexOf(constantName);\r\n    if (index > -1) player.reality.automator.constantSortOrder.splice(index, 1);\r\n    EventHub.dispatch(GAME_EVENT.AUTOMATOR_CONSTANT_CHANGED);\r\n  },\r\n\r\n  // We can't just concatenate different parts of script data together or use some kind of delimiting character string\r\n  // due to the fact that comments can essentially contain character sequences with nearly arbitrary content and\r\n  // length. Instead, we take the approach of concatenating all data together with their lengths prepended at the start\r\n  // of each respective data string. For example:\r\n  //    [\"blob\", \"11,21,31\"] => \"00004blob0000811,21,31\"\r\n  // Note that the whole string can be unambiguously parsed from left-to-right regardless of the actual data contents.\r\n  // All numerical values are assumed to be exactly 5 characters long for consistency and since the script length limit\r\n  // is 5 digits long.\r\n  serializeAutomatorData(dataArray) {\r\n    const paddedNumber = num => `0000${num}`.slice(-5);\r\n    const segments = [];\r\n    for (const data of dataArray) {\r\n      segments.push(`${paddedNumber(data.length)}${data}`);\r\n    }\r\n    return segments.join(\"\");\r\n  },\r\n\r\n  // Inverse of the operation performed by serializeAutomatorData(). Can throw an error for malformed inputs, but this\r\n  // will always be caught farther up the call chain and interpreted properly as an invalid dataString.\r\n  deserializeAutomatorData(dataString) {\r\n    if (dataString === \"\") throw new Error(\"Attempted deserialization of empty string\");\r\n    const dataArray = [];\r\n    let remainingData = dataString;\r\n    while (remainingData.length > 0) {\r\n      const segmentLength = Number(remainingData.slice(0, 5));\r\n      remainingData = remainingData.substr(5);\r\n      if (Number.isNaN(segmentLength) || remainingData.length < segmentLength) {\r\n        throw new Error(\"Inconsistent or malformed serialized automator data\");\r\n      } else {\r\n        const segmentData = remainingData.slice(0, segmentLength);\r\n        remainingData = remainingData.substr(segmentLength);\r\n        dataArray.push(segmentData);\r\n      }\r\n    }\r\n    return dataArray;\r\n  },\r\n\r\n  // This exports only the text contents of the currently-visible script\r\n  exportCurrentScriptContents() {\r\n    // Cut off leading and trailing whitespace\r\n    const trimmed = AutomatorData.currentScriptText().replace(/^\\s*(.*?)\\s*$/u, \"$1\");\r\n    if (trimmed.length === 0) return null;\r\n    // Serialize the script name and content\r\n    const name = AutomatorData.currentScriptName();\r\n    return GameSaveSerializer.encodeText(this.serializeAutomatorData([name, trimmed]), \"automator script\");\r\n  },\r\n\r\n  // This parses script content from an encoded export string; does not actually import anything\r\n  parseScriptContents(rawInput) {\r\n    let decoded, parts;\r\n    try {\r\n      decoded = GameSaveSerializer.decodeText(rawInput, \"automator script\");\r\n      parts = this.deserializeAutomatorData(decoded);\r\n    } catch (e) {\r\n      return null;\r\n    }\r\n\r\n    return {\r\n      name: parts[0],\r\n      content: parts[1],\r\n    };\r\n  },\r\n\r\n  // Creates a new script from the supplied import string\r\n  importScriptContents(rawInput) {\r\n    const parsed = this.parseScriptContents(rawInput);\r\n    AutomatorData.createNewScript(parsed.content, parsed.name);\r\n    this.initializeFromSave();\r\n  },\r\n\r\n  // This exports the selected script along with any constants and study presets it uses or references\r\n  exportFullScriptData(scriptID) {\r\n    const script = this.findRawScriptObject(scriptID);\r\n    const trimmed = script.content.replace(/^\\s*(.*?)\\s*$/u, \"$1\");\r\n    if (trimmed.length === 0) return null;\r\n\r\n    const foundPresets = new Set();\r\n    const foundConstants = new Set();\r\n    const lines = trimmed.split(\"\\n\");\r\n    // We find just the keys first, the rest of the associated data is serialized later\r\n    for (const rawLine of lines) {\r\n      const matchPresetID = rawLine.match(/studies( nowait)? load id ([1-6])/ui);\r\n      if (matchPresetID) foundPresets.add(Number(matchPresetID[2]) - 1);\r\n      const matchPresetName = rawLine.match(/studies( nowait)? load name (\\S+)/ui);\r\n      if (matchPresetName) {\r\n        // A script might pass the regex match, but actually be referencing a preset which doesn't exist by name\r\n        const presetID = player.timestudy.presets.findIndex(p => p.name === matchPresetName[2]);\r\n        if (presetID !== -1) foundPresets.add(presetID);\r\n      }\r\n      const availableConstants = Object.keys(player.reality.automator.constants);\r\n      for (const key of availableConstants) if (rawLine.match(`\\\\s${key}(\\\\s|$)`)) foundConstants.add(key);\r\n    }\r\n\r\n    // Serialize presets\r\n    const presets = [];\r\n    for (const id of Array.from(foundPresets)) {\r\n      const preset = player.timestudy.presets[id];\r\n      presets.push(`${id}:${preset?.name ?? \"\"}:${preset?.studies ?? \"\"}`);\r\n    }\r\n\r\n    // Serialize constants\r\n    const constants = [];\r\n    for (const name of Array.from(foundConstants)) {\r\n      constants.push(`${name}:${player.reality.automator.constants[name]}`);\r\n    }\r\n\r\n    // Serialize all the variables for the full data export\r\n    const serialized = this.serializeAutomatorData([script.name, presets.join(\"*\"), constants.join(\"*\"), trimmed]);\r\n    return GameSaveSerializer.encodeText(serialized, \"automator data\");\r\n  },\r\n\r\n  // This parses scripts which also have attached information in the form of associated constants and study presets.\r\n  // Note that it doesn't actually import or assign the data to the save file at this point.\r\n  parseFullScriptData(rawInput) {\r\n    let decoded, parts;\r\n    try {\r\n      decoded = GameSaveSerializer.decodeText(rawInput, \"automator data\");\r\n      parts = this.deserializeAutomatorData(decoded);\r\n    } catch (e) {\r\n      return null;\r\n    }\r\n    if (parts.length !== 4) return null;\r\n\r\n    // Parse preset data (needs the conditional because otherwise it'll use the empty string to assign 0/undef/undef)\r\n    const presetData = parts[1];\r\n    const presets = [];\r\n    if (presetData) {\r\n      for (const preset of presetData.split(\"*\")) {\r\n        const props = preset.split(\":\");\r\n        presets.push({\r\n          id: Number(props[0]),\r\n          name: props[1],\r\n          studies: props[2],\r\n        });\r\n      }\r\n    }\r\n    presets.sort((a, b) => a.id - b.id);\r\n\r\n    // Parse constant data\r\n    const constantData = parts[2];\r\n    const constants = [];\r\n    for (const constant of constantData.split(\"*\")) {\r\n      if (constant === \"\") continue;\r\n      const props = constant.split(\":\");\r\n      constants.push({\r\n        key: props[0],\r\n        value: props[1],\r\n      });\r\n    }\r\n\r\n    return {\r\n      name: parts[0],\r\n      presets,\r\n      constants,\r\n      content: parts[3],\r\n    };\r\n  },\r\n\r\n  // This imports a given script, with options supplied for ignoring included presets and constants\r\n  // within the import data.\r\n  importFullScriptData(rawInput, ignore) {\r\n    const parsed = this.parseFullScriptData(rawInput);\r\n    AutomatorData.createNewScript(parsed.content, parsed.name);\r\n\r\n    if (!ignore.presets) {\r\n      for (const preset of parsed.presets) {\r\n        player.timestudy.presets[preset.id] = { name: preset.name, studies: preset.studies };\r\n      }\r\n    }\r\n\r\n    if (!ignore.constants) {\r\n      for (const constant of parsed.constants) {\r\n        this.modifyConstant(constant.key, constant.value);\r\n      }\r\n    }\r\n\r\n    this.initializeFromSave();\r\n  },\r\n\r\n  update(diff) {\r\n    if (!this.isOn) return;\r\n    let stack;\r\n    switch (this.mode) {\r\n      case AUTOMATOR_MODE.PAUSE:\r\n        return;\r\n      case AUTOMATOR_MODE.SINGLE_STEP:\r\n        this.singleStep();\r\n        stack = AutomatorBackend.stack.top;\r\n        // If single step completes the last line and repeat is off, the command stack will be empty and\r\n        // scrolling will cause an error\r\n        if (stack && this.state.followExecution) AutomatorScroller.scrollToRawLine(stack.lineNumber);\r\n        this.state.mode = AUTOMATOR_MODE.PAUSE;\r\n        return;\r\n      case AUTOMATOR_MODE.RUN:\r\n        break;\r\n      default:\r\n        this.stop();\r\n        return;\r\n    }\r\n\r\n    player.reality.automator.execTimer += diff;\r\n    const commandsThisUpdate = Math.min(\r\n      Math.floor(player.reality.automator.execTimer / this.currentInterval), this.MAX_COMMANDS_PER_UPDATE\r\n    );\r\n    player.reality.automator.execTimer -= commandsThisUpdate * this.currentInterval;\r\n\r\n    for (let count = 0; count < commandsThisUpdate && this.isRunning; ++count) {\r\n      if (!this.step()) break;\r\n    }\r\n  },\r\n\r\n  step() {\r\n    if (this.stack.isEmpty) return false;\r\n    for (let steps = 0; steps < 100 && !this.hasJustCompleted; steps++) {\r\n      switch (this.runCurrentCommand()) {\r\n        case AUTOMATOR_COMMAND_STATUS.SAME_INSTRUCTION:\r\n          return true;\r\n        case AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION:\r\n          return this.nextCommand();\r\n        case AUTOMATOR_COMMAND_STATUS.NEXT_TICK_SAME_INSTRUCTION:\r\n          return false;\r\n        case AUTOMATOR_COMMAND_STATUS.NEXT_TICK_NEXT_INSTRUCTION:\r\n          this.nextCommand();\r\n          return false;\r\n        case AUTOMATOR_COMMAND_STATUS.SKIP_INSTRUCTION:\r\n          this.nextCommand();\r\n          break;\r\n        case AUTOMATOR_COMMAND_STATUS.HALT:\r\n          this.stop();\r\n          return false;\r\n        case AUTOMATOR_COMMAND_STATUS.RESTART:\r\n          this.restart();\r\n          return false;\r\n      }\r\n\r\n      // We need to break out of the loop if the last commands are all SKIP_INSTRUCTION, or else it'll start\r\n      // trying to execute from an undefined stack if it isn't set to automatically repeat\r\n      if (!this.stack.top) this.hasJustCompleted = true;\r\n    }\r\n\r\n    // This should in practice never happen by accident due to it requiring 100 consecutive commands that don't do\r\n    // anything (looping a smaller group of no-ops will instead trigger the loop check every tick). Nevertheless,\r\n    // better to not have an explicit infinite loop so that the game doesn't hang if the player decides to be funny\r\n    // and input 3000 comments in a row. If hasJustCompleted is true, then we actually broke out because the end of\r\n    // the script has no-ops and we just looped through them, and therefore shouldn't show these messages\r\n    if (!this.hasJustCompleted) {\r\n      GameUI.notify.error(\"Automator halted - too many consecutive no-ops detected\");\r\n      AutomatorData.logCommandEvent(\"Automator halted due to excessive no-op commands\", this.currentLineNumber);\r\n    }\r\n\r\n    this.stop();\r\n    return false;\r\n  },\r\n\r\n  singleStep() {\r\n    if (this.stack.isEmpty) return;\r\n    // SAME_INSTRUCTION is used to enter blocks; this means we've successfully\r\n    // advanced a line. Otherwise, we always advance a line, regardless of return\r\n    // state.\r\n    // HALT and RESTART are exceptions, as these are called by commands which force\r\n    // program flow to do something else other than simply advancing to the next line\r\n    switch (this.runCurrentCommand()) {\r\n      case AUTOMATOR_COMMAND_STATUS.NEXT_TICK_SAME_INSTRUCTION:\r\n        break;\r\n      case AUTOMATOR_COMMAND_STATUS.HALT:\r\n        this.stop();\r\n        break;\r\n      case AUTOMATOR_COMMAND_STATUS.RESTART:\r\n        this.restart();\r\n        break;\r\n      default:\r\n        this.nextCommand();\r\n        break;\r\n    }\r\n  },\r\n\r\n  runCurrentCommand() {\r\n    const S = this.stack.top;\r\n    const cmdState = S.commands[S.commandIndex].run(S);\r\n    return cmdState;\r\n  },\r\n\r\n  nextCommand() {\r\n    const S = this.stack.top;\r\n    if (S.commandIndex >= S.commands.length - 1) {\r\n      this.stack.pop();\r\n      if (this.stack.isEmpty) {\r\n        // With the debug output on, running short scripts gets very spammy, working around that\r\n        // return false here makes sure that a single instruction script executes one tick at a time\r\n        if (this.state.repeat) {\r\n          this.start(this.state.topLevelScript, AUTOMATOR_MODE.RUN, false);\r\n          return false;\r\n        }\r\n        this.stop();\r\n      } else if (this.stack.top.commandState && this.stack.top.commandState.advanceOnPop) {\r\n        AutomatorData.logCommandEvent(`Exiting IF block`, this.stack.top.commandState.ifEndLine);\r\n        return this.nextCommand();\r\n      }\r\n    } else {\r\n      S.commandState = null;\r\n      ++S.commandIndex;\r\n    }\r\n    return true;\r\n  },\r\n\r\n  push(commands) {\r\n    // We do not allow empty scripts on the stack.\r\n    if (commands.length === 0) return;\r\n    this.stack.push(commands);\r\n  },\r\n\r\n  findScript(id) {\r\n    return this._scripts.find(e => e.id === id);\r\n  },\r\n\r\n  _createDefaultScript() {\r\n    const defaultScript = AutomatorScript.create(\"New Script\");\r\n    this._scripts = [defaultScript];\r\n    this.state.topLevelScript = defaultScript.id;\r\n    return defaultScript.id;\r\n  },\r\n\r\n  initializeFromSave() {\r\n    const scriptIds = Object.keys(player.reality.automator.scripts).map(id => parseInt(id, 10));\r\n    if (scriptIds.length === 0) {\r\n      scriptIds.push(this._createDefaultScript());\r\n    } else {\r\n      this._scripts = scriptIds.map(s => new AutomatorScript(s));\r\n    }\r\n    if (!scriptIds.includes(this.state.topLevelScript)) this.state.topLevelScript = scriptIds[0];\r\n    const currentScript = this.findScript(this.state.topLevelScript);\r\n    if (currentScript.commands) {\r\n      const commands = currentScript.commands;\r\n      if (!this.stack.initializeFromSave(commands)) this.reset(commands);\r\n    } else {\r\n      this.stack.clear();\r\n    }\r\n  },\r\n\r\n  // Note: This gets run every time any edit or mode conversion is done\r\n  saveScript(id, data) {\r\n    const script = this.findScript(id);\r\n    if (!script) return;\r\n\r\n    // Add the old data to the undo buffer; there are internal checks which prevent it from saving too often.\r\n    // For performance, the contents of the script aren't actually checked (this would be an unavoidable O(n) cost).\r\n    // Instead we naively assume length changes are pure insertions and deletions, which does mean we're ignoring\r\n    // a few edge cases when changes are really substitutions that massively change the content\r\n    const oldData = script.persistent.content;\r\n    const lenChange = Math.abs(oldData.length - data.length);\r\n    AutomatorData.pushUndoData(oldData, lenChange);\r\n\r\n    script.save(data);\r\n    if (id === this.state.topLevelScript) this.stop();\r\n  },\r\n\r\n  newScript() {\r\n    // Make sure the new script has a unique name\r\n    const scriptNames = AutomatorBackend._scripts.map(s => s.name);\r\n    let newScript;\r\n    if (scriptNames.includes(\"New Script\")) {\r\n      let newIndex = 2;\r\n      while (scriptNames.includes(`New Script (${newIndex})`)) newIndex++;\r\n      newScript = AutomatorScript.create(`New Script (${newIndex})`);\r\n    } else {\r\n      newScript = AutomatorScript.create(\"New Script\");\r\n    }\r\n\r\n    this._scripts.push(newScript);\r\n    return newScript;\r\n  },\r\n\r\n  // Note that deleting scripts leaves gaps in the automator script indexing since automator scripts can't be\r\n  // dynamically re-indexed while the automator is running without causing a stutter from recompiling scripts.\r\n  deleteScript(id) {\r\n    // We need to delete scripts from two places - in the savefile and compiled AutomatorScript Objects\r\n    const saveId = Object.values(player.reality.automator.scripts).findIndex(s => s.id === id);\r\n    delete player.reality.automator.scripts[parseInt(Object.keys(player.reality.automator.scripts)[saveId], 10)];\r\n    const idx = this._scripts.findIndex(e => e.id === id);\r\n    this._scripts.splice(idx, 1);\r\n    if (this._scripts.length === 0) {\r\n      this._createDefaultScript();\r\n      this.clearEditor();\r\n    }\r\n    if (id === this.state.topLevelScript) {\r\n      this.stop();\r\n      this.state.topLevelScript = this._scripts[0].id;\r\n    }\r\n    EventHub.dispatch(GAME_EVENT.AUTOMATOR_SAVE_CHANGED);\r\n  },\r\n\r\n  toggleRepeat() {\r\n    this.state.repeat = !this.state.repeat;\r\n  },\r\n\r\n  toggleForceRestart() {\r\n    this.state.forceRestart = !this.state.forceRestart;\r\n  },\r\n\r\n  toggleFollowExecution() {\r\n    this.state.followExecution = !this.state.followExecution;\r\n    this.jumpToActiveLine();\r\n  },\r\n\r\n  jumpToActiveLine() {\r\n    const state = this.state;\r\n    const focusedScript = state.topLevelScript === state.editorScript;\r\n    if (focusedScript && this.isRunning && state.followExecution) {\r\n      AutomatorScroller.scrollToRawLine(AutomatorBackend.stack.top.lineNumber);\r\n    }\r\n  },\r\n\r\n  reset(commands) {\r\n    this.stack.clear();\r\n    this.push(commands);\r\n  },\r\n\r\n  stop() {\r\n    this.stack.clear();\r\n    this.state.mode = AUTOMATOR_MODE.PAUSE;\r\n    this.hasJustCompleted = true;\r\n    AutomatorHighlighter.clearAllHighlightedLines();\r\n  },\r\n\r\n  pause() {\r\n    this.state.mode = AUTOMATOR_MODE.PAUSE;\r\n  },\r\n\r\n  start(scriptID = this.state.topLevelScript, initialMode = AUTOMATOR_MODE.RUN, compile = true) {\r\n    // Automator execution behaves oddly across new games, so we explicitly stop it from running if not unlocked\r\n    if (!Player.automatorUnlocked) return;\r\n    this.hasJustCompleted = false;\r\n    this.state.topLevelScript = scriptID;\r\n    player.reality.automator.execTimer = 0;\r\n    const scriptObject = this.findScript(scriptID);\r\n    if (!scriptObject) return;\r\n    if (compile) scriptObject.compile();\r\n    if (scriptObject.commands) {\r\n      this.reset(scriptObject.commands);\r\n      this.state.mode = initialMode;\r\n    }\r\n    AutomatorData.isWaiting = false;\r\n    if (player.options.automatorEvents.clearOnRestart) AutomatorData.clearEventLog();\r\n  },\r\n\r\n  restart() {\r\n    // Sometimes this leads to start getting called twice in quick succession but it's close enough\r\n    // that there's usually no command in between (possibly same tick).\r\n    this.start(this.state.topLevelScript, AUTOMATOR_MODE.RUN);\r\n    if (this.stack.isEmpty) return;\r\n    this.reset(this.stack._data[0].commands);\r\n  },\r\n\r\n  changeModes(scriptID) {\r\n    Tutorial.moveOn(TUTORIAL_STATE.AUTOMATOR);\r\n    if (player.reality.automator.type === AUTOMATOR_TYPE.BLOCK) {\r\n      // This saves the script after converting it.\r\n      BlockAutomator.parseTextFromBlocks();\r\n      player.reality.automator.type = AUTOMATOR_TYPE.TEXT;\r\n    } else {\r\n      const toConvert = AutomatorTextUI.editor.getDoc().getValue();\r\n      // Needs to be called to update the lines prop in the BlockAutomator object\r\n      BlockAutomator.updateEditor(toConvert);\r\n      AutomatorBackend.saveScript(scriptID, toConvert);\r\n      player.reality.automator.type = AUTOMATOR_TYPE.BLOCK;\r\n    }\r\n    AutomatorHighlighter.clearAllHighlightedLines();\r\n    EventHub.ui.dispatch(GAME_EVENT.AUTOMATOR_TYPE_CHANGED);\r\n  },\r\n\r\n  clearEditor() {\r\n    if (player.reality.automator.type === AUTOMATOR_TYPE.BLOCK) {\r\n      BlockAutomator.clearEditor();\r\n    } else {\r\n      AutomatorTextUI.clearEditor();\r\n    }\r\n  },\r\n\r\n  stack: {\r\n    _data: [],\r\n    push(commands) {\r\n      const newEntry = new AutomatorStackEntry(this.length);\r\n      newEntry.initializeNew(commands);\r\n      this._data.push(newEntry);\r\n    },\r\n    pop() {\r\n      if (this._data.length === 0) return;\r\n      player.reality.automator.state.stack.pop();\r\n      this._data.pop();\r\n    },\r\n    clear() {\r\n      this._data = [];\r\n      player.reality.automator.state.stack.length = 0;\r\n    },\r\n    initializeFromSave(commands) {\r\n      this._data = [];\r\n      const playerStack = player.reality.automator.state.stack;\r\n      let currentCommands = commands;\r\n      for (let depth = 0; depth < playerStack.length; ++depth) {\r\n        const playerEntry = playerStack[depth];\r\n        const newEntry = new AutomatorStackEntry(depth);\r\n        newEntry.commands = currentCommands;\r\n        const foundIndex = currentCommands.findIndex(e => e.lineNumber === playerEntry.lineNumber);\r\n        if (foundIndex === -1) {\r\n          // Could not match stack state to script, have to reset automato\r\n          return false;\r\n        }\r\n        newEntry.commandIndex = foundIndex;\r\n        this._data.push(newEntry);\r\n        // Are we inside a code block?\r\n        if (depth !== playerStack.length - 1) {\r\n          if (currentCommands[foundIndex].blockCommands === undefined) {\r\n            return false;\r\n          }\r\n          currentCommands = currentCommands[foundIndex].blockCommands;\r\n        }\r\n      }\r\n      return true;\r\n    },\r\n    get top() {\r\n      return this._data[this.length - 1];\r\n    },\r\n    get length() {\r\n      if (this._data.length !== player.reality.automator.state.stack.length) {\r\n        throw new Error(\"Inconsistent stack length\");\r\n      }\r\n      return this._data.length;\r\n    },\r\n    get isEmpty() {\r\n      return this._data.length === 0;\r\n    }\r\n  },\r\n};\r\n"]},"metadata":{},"sourceType":"module"}