{"ast":null,"code":"import \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.string.trim.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.string.replace-all.js\";\nimport \"core-js/modules/es.regexp.constructor.js\";\nimport \"core-js/modules/es.regexp.dot-all.js\";\n\n/**\r\n * Abstract representation of a full time study tree object. The intended usage is to supply the constructor with\r\n * an import string and a budget of time/space theorems, which it will use together to determine which studies can\r\n * actually be purchased in the specified order. All of the complex purchasing logic should be handled here, and not\r\n * in any TimeStudyState objects. During parsing, some minor additional info is stored in order to improve user\r\n * feedback when attempting to import other study trees.\r\n *\r\n * Usage notes:\r\n * - Unless commitToGameState() is called, this only ever creates a \"virtual\" tree object which does not change the\r\n *   overall game state. This class serves the purpose of having all the purchasing and locking logic in one place.\r\n *   Only upon calling commitToGameState() will the game actually try to get every study specified in tree.\r\n * - The general intent is that the logic in this class is meant to pull minimally from the extrenal game state; for\r\n *   example, how many dimension paths are allowed or which ECs are unlockable depend on only the data in the tree\r\n *   object itself and should not depend on the actual current game state\r\n * - All study entries must be Strings because numbers (normal TS) and EC# (ECs) need to be supported\r\n *\r\n * @member {Number[]} spentTheorems      Two-element array containing TT/ST totals for studies which were actually\r\n *  purchased after accounting for various conditions which would forbid some being bought (eg. cost or tree structure)\r\n * @member {String[]} invalidStudies     Array of studies from the initial string which are correctly formatted\r\n *  but don't actually exist; used for informational purposes elsewhere\r\n * @member {TimeStudyState[]} selectedStudies   Array of all given valid studies, whether or not they are actually\r\n *  accessible or purchasable in the given order\r\n * @member {TimeStudyState[]} purchasedStudies  Array of studies which were actually purchased, using the given amount\r\n *  of available theorems\r\n * @member {Boolean} startEC    Whether or not to start an EC within purchasedStudies when committing to game state\r\n */\nexport class TimeStudyTree {\n  // The first parameter will either be an import string or an array of studies (possibly with an EC at the end)\n  constructor(studies) {\n    this.spentTheorems = [0, 0];\n    this.invalidStudies = [];\n    this.purchasedStudies = [];\n    this.selectedStudies = [];\n    this.startEC = false;\n\n    switch (typeof studies) {\n      case \"string\":\n        // Input parameter is an unparsed study import string\n        if (TimeStudyTree.isValidImportString(studies)) {\n          this.attemptBuyArray(this.parseStudyImport(studies), false);\n        }\n\n        break;\n\n      case \"object\":\n        // Input parameter is an array of time study objects\n        this.attemptBuyArray([...studies], false);\n        this.selectedStudies = [...studies];\n        break;\n\n      case \"undefined\":\n        // If not supplied with anything, we leave everything at default values and don't attempt to buy anything\n        break;\n\n      default:\n        throw new Error(\"Unrecognized input parameter for TimeStudyTree constructor\");\n    }\n  } // Note that this only checks pure formatting, not whether or not a study/EC actually exists, but verifying correct\n  // formatting separately from verifying existence allows us to produce more useful in-game error messages for\n  // import strings which are formatted correctly but aren't entirely valid\n\n\n  static isValidImportString(input) {\n    if (input.trim() === \"\") {\n      return false;\n    }\n\n    let test = input.replaceAll(/ +/g, \"\");\n    TimeStudyTree.sets.forEach((_, x) => test = test.replaceAll(new RegExp(`${x},?`, \"gu\"), \"\"));\n    return /^,?(([0-9]{2,3}(\\x2D[0-9]{2,3})?)\\b,?)*(\\|[0-9]{1,2}!?)?$/i.test(test);\n  } // Getter for all the studies in the current game state\n\n\n  static get currentStudies() {\n    const currentStudies = player.timestudy.studies.map(s => TimeStudy(s));\n\n    if (player.challenge.eternity.unlocked !== 0) {\n      currentStudies.push(TimeStudy.eternityChallenge(player.challenge.eternity.unlocked));\n    }\n\n    return currentStudies;\n  } // Parses out the EC number from an import string (returns 0 for invalid or nonexistent EC ids)\n\n\n  static getECFromString(input) {\n    if (!this.isValidImportString(input)) return 0;\n    const parts = input.split(\"|\");\n    if (parts.length < 1) return 0; // Note: parseInt() seems to silently ignore the presence of \"!\"\n\n    return parseInt(parts[1], 10);\n  } // THIS METHOD HAS LASTING CONSEQUENCES ON THE GAME STATE. STUDIES WILL ACTUALLY BE PURCHASED IF POSSIBLE.\n  // This method attempts to take the parameter array and purchase all the studies specified, using the current game\n  // state to determine if they are affordable. Input array may be either an id array or a TimeStudyState array\n\n\n  static commitToGameState(studyArray, auto = true, startEC = false) {\n    for (const item of studyArray) {\n      const study = typeof item === \"number\" ? TimeStudy(item) : item;\n      if (study && !study.isBought) study.purchase(auto); // Note: This will automatically (silently) fail if we try to start an EC while we have a different one unlocked\n\n      if (startEC && study instanceof ECTimeStudyState) EternityChallenge(study.id).start(auto);\n    }\n\n    GameCache.currentStudyTree.invalidate();\n  }\n\n  static get sets() {\n    // Grouping of studies. The key followed by an array of the studies the key is a shorthand for.\n    return new Map([[\"antimatter\", [71, 81, 91, 101]], [\"infinity\", [72, 82, 92, 102]], [\"time\", [73, 83, 93, 103]], [\"active\", [121, 131, 141]], [\"passive\", [122, 132, 142]], [\"idle\", [123, 133, 143]], [\"light\", [221, 223, 225, 227, 231, 233]], [\"dark\", [222, 224, 226, 228, 232, 234]], ...(Ra.unlocks.unlockHardV.canBeApplied ? [[\"triad\", [301, 302, 303, 304].slice(0, Ra.unlocks.unlockHardV.effectOrDefault(0))]] : [])]);\n  }\n\n  static truncateInput(input) {\n    let internal = input.toLowerCase(); // Convert every name into the ids it is a shorthand for\n\n    this.sets.forEach((ids, name) => internal = internal.replace(name, ids.join()));\n    return internal.replace(/[,\\|]$/, \"\").replaceAll(\" \", \"\") // Allows 11,,21 to be parsed as 11,21 and 11,|1 to be parsed as 11|1\n    .replace(/,{2,}/g, \",\").replace(/,\\|/g, \"|\");\n  }\n\n  static formatStudyList(input) {\n    const internal = input.toLowerCase().replaceAll(\" \", \"\");\n    return internal.replaceAll(\",\", \", \").replace(\"|\", \" | \");\n  } // This reads off all the studies in the import string and splits them into invalid and valid study IDs. We hold on\n  // to invalid studies for additional information to present to the player\n\n\n  parseStudyImport(input) {\n    const studyDB = GameDatabase.eternity.timeStudies.normal.map(s => s.id);\n    const output = [];\n    const studiesString = TimeStudyTree.truncateInput(input).split(\"|\")[0];\n\n    if (studiesString.length) {\n      const studyCluster = studiesString.split(\",\");\n\n      for (const studyRange of studyCluster) {\n        const studyRangeSplit = studyRange.split(\"-\");\n        const studyArray = studyRangeSplit[1] ? this.studyRangeToArray(studyRangeSplit[0], studyRangeSplit[1]) : studyRangeSplit;\n\n        for (const study of studyArray) {\n          if (studyDB.includes(parseInt(study, 10))) {\n            const tsObject = TimeStudy(study);\n            this.selectedStudies.push(tsObject);\n            output.push(tsObject);\n          } else {\n            this.invalidStudies.push(study);\n          }\n        }\n      }\n    } // If the string has an EC indicated in it, append that to the end of the study array\n\n\n    const ecString = input.split(\"|\")[1];\n    this.startEC = input.endsWith(\"!\");\n\n    if (!ecString) {\n      // Study strings without an ending \"|##\" are still valid, but will result in ecString being undefined\n      return output;\n    } // Note: parseInt() seems to silently ignore the presence of \"!\"\n\n\n    const ecID = parseInt(ecString, 10);\n    const ecDB = GameDatabase.eternity.timeStudies.ec; // Specifically exclude 0 because saved presets will contain it by default\n\n    if (!ecDB.map(c => c.id).includes(ecID) && ecID !== 0) {\n      this.invalidStudies.push(`EC${ecID}`);\n      return output;\n    }\n\n    if (ecID !== 0) output.push(TimeStudy.eternityChallenge(ecID));\n    return output;\n  }\n\n  studyRangeToArray(firstNumber, lastNumber) {\n    const studiesArray = [];\n    const first = this.checkTimeStudyNumber(firstNumber);\n    const last = this.checkTimeStudyNumber(lastNumber);\n\n    if (first !== 0 && last !== 0) {\n      for (let id = first; id <= last; id++) {\n        if (TimeStudy(id)) {\n          studiesArray.push(id);\n        }\n      }\n    }\n\n    return studiesArray;\n  }\n\n  checkTimeStudyNumber(token) {\n    const tsNumber = parseFloat(token);\n\n    if (!TimeStudy(tsNumber) || TimeStudy(tsNumber).isTriad && !Ra.canBuyTriad) {\n      return 0;\n    }\n\n    return tsNumber;\n  } // Attempt to purchase all studies specified in the array which may be either study IDs (which get converted) or\n  // study objects. The method needs to support both because turning it entirely to studies causes circular references\n  // which make the game fail to load\n\n\n  attemptBuyArray(studyArray, checkCosts) {\n    for (const study of studyArray) {\n      const toBuy = typeof study === \"object\" ? study : TimeStudy(study);\n      if (this.hasRequirements(toBuy)) this.buySingleStudy(toBuy, checkCosts);\n    }\n  } // Tries to buy a single study, accounting for all various requirements and locking behavior in the game. Does not\n  // update anything cost-related, use buySingleStudy() to actually purchase. checkOnlyStructure is used to ignore\n  // EC secondary requirements\n\n\n  hasRequirements(study, checkOnlyStructure = false) {\n    // Import strings can contain repeated or undefined entries\n    if (!study || this.purchasedStudies.includes(study)) return false; // Because the player data may not reflect the state of the TimeStudyTree object's purchasedStudies,\n    // we have to do all the checks here with purchasedStudies. study.isBought and similar functions cannot be used.\n\n    const check = req => typeof req === \"number\" ? this.purchasedStudies.includes(TimeStudy(req)) : req();\n\n    const config = study.config;\n    let reqSatisfied;\n\n    switch (config.reqType) {\n      case TS_REQUIREMENT_TYPE.AT_LEAST_ONE:\n        reqSatisfied = config.requirement.some(r => check(r));\n        break;\n\n      case TS_REQUIREMENT_TYPE.ALL:\n        reqSatisfied = config.requirement.every(r => check(r));\n        break;\n\n      case TS_REQUIREMENT_TYPE.DIMENSION_PATH:\n        reqSatisfied = config.requirement.every(r => check(r)) && this.currDimPathCount < this.allowedDimPathCount;\n        break;\n\n      default:\n        throw Error(`Unrecognized TS requirement type: ${this.reqType}`);\n    }\n\n    if (study instanceof ECTimeStudyState) {\n      var _study$config$seconda;\n\n      if (this.purchasedStudies.some(s => s instanceof ECTimeStudyState)) return false;\n      const hasForbiddenStudies = !Perk.studyECRequirement.isBought && ((_study$config$seconda = study.config.secondary.forbiddenStudies) === null || _study$config$seconda === void 0 ? void 0 : _study$config$seconda.some(s => check(s))); // We want to only check the structure for script template error instructions\n\n      if (checkOnlyStructure) {\n        return reqSatisfied && !hasForbiddenStudies;\n      }\n\n      const totalTT = player.timestudy.theorem.plus(TimeTheorems.calculateTimeStudiesCost());\n      const hasEnoughTT = totalTT.subtract(this.spentTheorems[0]).gte(study.cost);\n      const secondaryGoal = Perk.studyECRequirement.isBought || study.isEntryGoalMet;\n      return reqSatisfied && !hasForbiddenStudies && (study.isBought || secondaryGoal && hasEnoughTT);\n    }\n\n    return reqSatisfied;\n  } // Buys the specified study; no requirement verification beyond cost, use hasRequirements() to verify proper structure\n\n\n  buySingleStudy(study, checkCosts) {\n    const config = study.config;\n    const stDiscount = VUnlocks.raUnlock.effectOrDefault(0);\n    const stNeeded = config.STCost && config.requiresST.some(s => this.purchasedStudies.includes(TimeStudy(s))) ? Math.clampMin(config.STCost - stDiscount, 0) : 0; // Took these out of the checkCosts check as these aren't available early game\n\n    const maxST = Pelle.isDoomed ? 0 : V.spaceTheorems;\n    const hasST = this.spentTheorems[1] + stNeeded <= maxST;\n\n    if (checkCosts) {\n      const maxTT = Currency.timeTheorems.value.add(GameCache.currentStudyTree.value.spentTheorems[0]).clampMax(Number.MAX_VALUE).toNumber();\n      const hasTT = this.spentTheorems[0] + config.cost <= maxTT;\n      if (!hasTT || !hasST) return;\n    } // Don't add the costs nor add the study if it is one using ST and there are none\n\n\n    if (maxST === 0 && stNeeded > 0) return;\n    this.spentTheorems[0] += config.cost;\n    this.spentTheorems[1] += stNeeded;\n    this.purchasedStudies.push(study);\n  }\n\n  get currDimPathCount() {\n    return [71, 72, 73].countWhere(x => this.purchasedStudies.includes(TimeStudy(x)));\n  }\n\n  get allowedDimPathCount() {\n    if (DilationUpgrade.timeStudySplit.isBought) return 3;\n    if (this.purchasedStudies.includes(TimeStudy(201))) return 2;\n    return 1;\n  }\n\n  get dimensionPaths() {\n    const pathSet = new Set();\n    const validPaths = [TIME_STUDY_PATH.ANTIMATTER_DIM, TIME_STUDY_PATH.INFINITY_DIM, TIME_STUDY_PATH.TIME_DIM];\n\n    for (const path of validPaths) {\n      const pathEntry = NormalTimeStudies.pathList.find(p => p.path === path);\n\n      for (const study of this.purchasedStudies) {\n        if (pathEntry.studies.includes(study.id)) {\n          pathSet.add(pathEntry.name);\n          break;\n        }\n      }\n    }\n\n    return Array.from(pathSet);\n  }\n\n  get pacePaths() {\n    const pathSet = new Set();\n    const validPaths = [TIME_STUDY_PATH.ACTIVE, TIME_STUDY_PATH.PASSIVE, TIME_STUDY_PATH.IDLE];\n\n    for (const path of validPaths) {\n      const pathEntry = NormalTimeStudies.pathList.find(p => p.path === path);\n\n      for (const study of this.purchasedStudies) {\n        if (pathEntry.studies.includes(study.id)) {\n          pathSet.add(pathEntry.name);\n          break;\n        }\n      }\n    }\n\n    return Array.from(pathSet);\n  }\n\n  get ec() {\n    // This technically takes the very first EC entry if there's more than one, but that shouldn't happen in practice\n    const ecStudies = this.purchasedStudies.find(s => s instanceof ECTimeStudyState);\n    return ecStudies ? ecStudies.id : 0;\n  } // Creates an export string based on all currently purchased studies; gives an ! at the end if currently in an EC\n\n\n  get exportString() {\n    return `${this.purchasedStudies.filter(s => s instanceof NormalTimeStudyState).map(s => s.id).join(\",\")}|${this.ec}${player.challenge.eternity.current === 0 ? \"\" : \"!\"}`;\n  }\n\n}","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/time-studies/time-study-tree.js"],"names":["TimeStudyTree","constructor","studies","spentTheorems","invalidStudies","purchasedStudies","selectedStudies","startEC","isValidImportString","attemptBuyArray","parseStudyImport","Error","input","trim","test","replaceAll","sets","forEach","_","x","RegExp","currentStudies","player","timestudy","map","s","TimeStudy","challenge","eternity","unlocked","push","eternityChallenge","getECFromString","parts","split","length","parseInt","commitToGameState","studyArray","auto","item","study","isBought","purchase","ECTimeStudyState","EternityChallenge","id","start","GameCache","currentStudyTree","invalidate","Map","Ra","unlocks","unlockHardV","canBeApplied","slice","effectOrDefault","truncateInput","internal","toLowerCase","ids","name","replace","join","formatStudyList","studyDB","GameDatabase","timeStudies","normal","output","studiesString","studyCluster","studyRange","studyRangeSplit","studyRangeToArray","includes","tsObject","ecString","endsWith","ecID","ecDB","ec","c","firstNumber","lastNumber","studiesArray","first","checkTimeStudyNumber","last","token","tsNumber","parseFloat","isTriad","canBuyTriad","checkCosts","toBuy","hasRequirements","buySingleStudy","checkOnlyStructure","check","req","config","reqSatisfied","reqType","TS_REQUIREMENT_TYPE","AT_LEAST_ONE","requirement","some","r","ALL","every","DIMENSION_PATH","currDimPathCount","allowedDimPathCount","hasForbiddenStudies","Perk","studyECRequirement","secondary","forbiddenStudies","totalTT","theorem","plus","TimeTheorems","calculateTimeStudiesCost","hasEnoughTT","subtract","gte","cost","secondaryGoal","isEntryGoalMet","stDiscount","VUnlocks","raUnlock","stNeeded","STCost","requiresST","Math","clampMin","maxST","Pelle","isDoomed","V","spaceTheorems","hasST","maxTT","Currency","timeTheorems","value","add","clampMax","Number","MAX_VALUE","toNumber","hasTT","countWhere","DilationUpgrade","timeStudySplit","dimensionPaths","pathSet","Set","validPaths","TIME_STUDY_PATH","ANTIMATTER_DIM","INFINITY_DIM","TIME_DIM","path","pathEntry","NormalTimeStudies","pathList","find","p","Array","from","pacePaths","ACTIVE","PASSIVE","IDLE","ecStudies","exportString","filter","NormalTimeStudyState","current"],"mappings":";;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMA,aAAN,CAAoB;AACzB;AACAC,EAAAA,WAAW,CAACC,OAAD,EAAU;AACnB,SAAKC,aAAL,GAAqB,CAAC,CAAD,EAAI,CAAJ,CAArB;AACA,SAAKC,cAAL,GAAsB,EAAtB;AACA,SAAKC,gBAAL,GAAwB,EAAxB;AACA,SAAKC,eAAL,GAAuB,EAAvB;AACA,SAAKC,OAAL,GAAe,KAAf;;AACA,YAAQ,OAAOL,OAAf;AACE,WAAK,QAAL;AACE;AACA,YAAIF,aAAa,CAACQ,mBAAd,CAAkCN,OAAlC,CAAJ,EAAgD;AAC9C,eAAKO,eAAL,CAAqB,KAAKC,gBAAL,CAAsBR,OAAtB,CAArB,EAAqD,KAArD;AACD;;AACD;;AACF,WAAK,QAAL;AACE;AACA,aAAKO,eAAL,CAAqB,CAAC,GAAGP,OAAJ,CAArB,EAAmC,KAAnC;AACA,aAAKI,eAAL,GAAuB,CAAC,GAAGJ,OAAJ,CAAvB;AACA;;AACF,WAAK,WAAL;AACE;AACA;;AACF;AACE,cAAM,IAAIS,KAAJ,CAAU,4DAAV,CAAN;AAhBJ;AAkBD,GA1BwB,CA4BzB;AACA;AACA;;;AAC0B,SAAnBH,mBAAmB,CAACI,KAAD,EAAQ;AAChC,QAAIA,KAAK,CAACC,IAAN,OAAiB,EAArB,EAAyB;AACvB,aAAO,KAAP;AACD;;AACD,QAAIC,IAAI,GAAGF,KAAK,CAACG,UAAN,CAAiB,KAAjB,EAAyB,EAAzB,CAAX;AACAf,IAAAA,aAAa,CAACgB,IAAd,CAAmBC,OAAnB,CAA2B,CAACC,CAAD,EAAIC,CAAJ,KAAUL,IAAI,GAAGA,IAAI,CAACC,UAAL,CAAgB,IAAIK,MAAJ,CAAY,GAAED,CAAE,IAAhB,EAAqB,IAArB,CAAhB,EAA4C,EAA5C,CAA5C;AACA,WAAO,6DAAkDL,IAAlD,CAAuDA,IAAvD,CAAP;AACD,GAtCwB,CAwCzB;;;AACyB,aAAdO,cAAc,GAAG;AAC1B,UAAMA,cAAc,GAAGC,MAAM,CAACC,SAAP,CAAiBrB,OAAjB,CAAyBsB,GAAzB,CAA6BC,CAAC,IAAIC,SAAS,CAACD,CAAD,CAA3C,CAAvB;;AACA,QAAIH,MAAM,CAACK,SAAP,CAAiBC,QAAjB,CAA0BC,QAA1B,KAAuC,CAA3C,EAA8C;AAC5CR,MAAAA,cAAc,CAACS,IAAf,CAAoBJ,SAAS,CAACK,iBAAV,CAA4BT,MAAM,CAACK,SAAP,CAAiBC,QAAjB,CAA0BC,QAAtD,CAApB;AACD;;AACD,WAAOR,cAAP;AACD,GA/CwB,CAiDzB;;;AACsB,SAAfW,eAAe,CAACpB,KAAD,EAAQ;AAC5B,QAAI,CAAC,KAAKJ,mBAAL,CAAyBI,KAAzB,CAAL,EAAsC,OAAO,CAAP;AACtC,UAAMqB,KAAK,GAAGrB,KAAK,CAACsB,KAAN,CAAY,GAAZ,CAAd;AACA,QAAID,KAAK,CAACE,MAAN,GAAe,CAAnB,EAAsB,OAAO,CAAP,CAHM,CAI5B;;AACA,WAAOC,QAAQ,CAACH,KAAK,CAAC,CAAD,CAAN,EAAW,EAAX,CAAf;AACD,GAxDwB,CA0DzB;AACA;AACA;;;AACwB,SAAjBI,iBAAiB,CAACC,UAAD,EAAaC,IAAI,GAAG,IAApB,EAA0BhC,OAAO,GAAG,KAApC,EAA2C;AACjE,SAAK,MAAMiC,IAAX,IAAmBF,UAAnB,EAA+B;AAC7B,YAAMG,KAAK,GAAG,OAAOD,IAAP,KAAgB,QAAhB,GAA2Bd,SAAS,CAACc,IAAD,CAApC,GAA6CA,IAA3D;AACA,UAAIC,KAAK,IAAI,CAACA,KAAK,CAACC,QAApB,EAA8BD,KAAK,CAACE,QAAN,CAAeJ,IAAf,EAFD,CAG7B;;AACA,UAAIhC,OAAO,IAAIkC,KAAK,YAAYG,gBAAhC,EAAkDC,iBAAiB,CAACJ,KAAK,CAACK,EAAP,CAAjB,CAA4BC,KAA5B,CAAkCR,IAAlC;AACnD;;AACDS,IAAAA,SAAS,CAACC,gBAAV,CAA2BC,UAA3B;AACD;;AAEc,aAAJlC,IAAI,GAAG;AAChB;AACA,WAAO,IAAImC,GAAJ,CAAQ,CACb,CAAC,YAAD,EAAe,CAAC,EAAD,EAAK,EAAL,EAAS,EAAT,EAAa,GAAb,CAAf,CADa,EAEb,CAAC,UAAD,EAAa,CAAC,EAAD,EAAK,EAAL,EAAS,EAAT,EAAa,GAAb,CAAb,CAFa,EAGb,CAAC,MAAD,EAAS,CAAC,EAAD,EAAK,EAAL,EAAS,EAAT,EAAa,GAAb,CAAT,CAHa,EAIb,CAAC,QAAD,EAAW,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,CAAX,CAJa,EAKb,CAAC,SAAD,EAAY,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,CAAZ,CALa,EAMb,CAAC,MAAD,EAAS,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,CAAT,CANa,EAOb,CAAC,OAAD,EAAU,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgB,GAAhB,EAAqB,GAArB,EAA0B,GAA1B,CAAV,CAPa,EAQb,CAAC,MAAD,EAAS,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgB,GAAhB,EAAqB,GAArB,EAA0B,GAA1B,CAAT,CARa,EASb,IAAIC,EAAE,CAACC,OAAH,CAAWC,WAAX,CAAuBC,YAAvB,GACA,CAAC,CAAC,OAAD,EAAU,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgB,GAAhB,EAAqBC,KAArB,CAA2B,CAA3B,EAA8BJ,EAAE,CAACC,OAAH,CAAWC,WAAX,CAAuBG,eAAvB,CAAuC,CAAvC,CAA9B,CAAV,CAAD,CADA,GAEA,EAFJ,CATa,CAAR,CAAP;AAaD;;AAEmB,SAAbC,aAAa,CAAC9C,KAAD,EAAQ;AAC1B,QAAI+C,QAAQ,GAAG/C,KAAK,CAACgD,WAAN,EAAf,CAD0B,CAE1B;;AACA,SAAK5C,IAAL,CAAUC,OAAV,CAAkB,CAAC4C,GAAD,EAAMC,IAAN,KAAgBH,QAAQ,GAAGA,QAAQ,CAACI,OAAT,CAAiBD,IAAjB,EAAuBD,GAAG,CAACG,IAAJ,EAAvB,CAA7C;AACA,WAAOL,QAAQ,CACZI,OADI,CACI,QADJ,EACc,EADd,EAEJhD,UAFI,CAEO,GAFP,EAEY,EAFZ,EAGL;AAHK,KAIJgD,OAJI,CAII,QAJJ,EAIe,GAJf,EAKJA,OALI,CAKI,MALJ,EAKa,GALb,CAAP;AAMD;;AAEqB,SAAfE,eAAe,CAACrD,KAAD,EAAQ;AAC5B,UAAM+C,QAAQ,GAAG/C,KAAK,CAACgD,WAAN,GAAoB7C,UAApB,CAA+B,GAA/B,EAAoC,EAApC,CAAjB;AACA,WAAO4C,QAAQ,CAAC5C,UAAT,CAAoB,GAApB,EAAyB,IAAzB,EAA+BgD,OAA/B,CAAuC,GAAvC,EAA4C,KAA5C,CAAP;AACD,GAvGwB,CAyGzB;AACA;;;AACArD,EAAAA,gBAAgB,CAACE,KAAD,EAAQ;AACtB,UAAMsD,OAAO,GAAGC,YAAY,CAACvC,QAAb,CAAsBwC,WAAtB,CAAkCC,MAAlC,CAAyC7C,GAAzC,CAA6CC,CAAC,IAAIA,CAAC,CAACqB,EAApD,CAAhB;AACA,UAAMwB,MAAM,GAAG,EAAf;AACA,UAAMC,aAAa,GAAGvE,aAAa,CAAC0D,aAAd,CAA4B9C,KAA5B,EAAmCsB,KAAnC,CAAyC,GAAzC,EAA8C,CAA9C,CAAtB;;AACA,QAAIqC,aAAa,CAACpC,MAAlB,EAA0B;AACxB,YAAMqC,YAAY,GAAGD,aAAa,CAACrC,KAAd,CAAoB,GAApB,CAArB;;AACA,WAAK,MAAMuC,UAAX,IAAyBD,YAAzB,EAAuC;AACrC,cAAME,eAAe,GAAGD,UAAU,CAACvC,KAAX,CAAiB,GAAjB,CAAxB;AACA,cAAMI,UAAU,GAAGoC,eAAe,CAAC,CAAD,CAAf,GACf,KAAKC,iBAAL,CAAuBD,eAAe,CAAC,CAAD,CAAtC,EAA2CA,eAAe,CAAC,CAAD,CAA1D,CADe,GAEfA,eAFJ;;AAGA,aAAK,MAAMjC,KAAX,IAAoBH,UAApB,EAAgC;AAC9B,cAAI4B,OAAO,CAACU,QAAR,CAAiBxC,QAAQ,CAACK,KAAD,EAAQ,EAAR,CAAzB,CAAJ,EAA2C;AACzC,kBAAMoC,QAAQ,GAAGnD,SAAS,CAACe,KAAD,CAA1B;AACA,iBAAKnC,eAAL,CAAqBwB,IAArB,CAA0B+C,QAA1B;AACAP,YAAAA,MAAM,CAACxC,IAAP,CAAY+C,QAAZ;AACD,WAJD,MAIO;AACL,iBAAKzE,cAAL,CAAoB0B,IAApB,CAAyBW,KAAzB;AACD;AACF;AACF;AACF,KArBqB,CAuBtB;;;AACA,UAAMqC,QAAQ,GAAGlE,KAAK,CAACsB,KAAN,CAAY,GAAZ,EAAiB,CAAjB,CAAjB;AACA,SAAK3B,OAAL,GAAeK,KAAK,CAACmE,QAAN,CAAe,GAAf,CAAf;;AACA,QAAI,CAACD,QAAL,EAAe;AACb;AACA,aAAOR,MAAP;AACD,KA7BqB,CA8BtB;;;AACA,UAAMU,IAAI,GAAG5C,QAAQ,CAAC0C,QAAD,EAAW,EAAX,CAArB;AACA,UAAMG,IAAI,GAAGd,YAAY,CAACvC,QAAb,CAAsBwC,WAAtB,CAAkCc,EAA/C,CAhCsB,CAiCtB;;AACA,QAAI,CAACD,IAAI,CAACzD,GAAL,CAAS2D,CAAC,IAAIA,CAAC,CAACrC,EAAhB,EAAoB8B,QAApB,CAA6BI,IAA7B,CAAD,IAAuCA,IAAI,KAAK,CAApD,EAAuD;AACrD,WAAK5E,cAAL,CAAoB0B,IAApB,CAA0B,KAAIkD,IAAK,EAAnC;AACA,aAAOV,MAAP;AACD;;AACD,QAAIU,IAAI,KAAK,CAAb,EAAgBV,MAAM,CAACxC,IAAP,CAAYJ,SAAS,CAACK,iBAAV,CAA4BiD,IAA5B,CAAZ;AAChB,WAAOV,MAAP;AACD;;AAEDK,EAAAA,iBAAiB,CAACS,WAAD,EAAcC,UAAd,EAA0B;AACzC,UAAMC,YAAY,GAAG,EAArB;AACA,UAAMC,KAAK,GAAG,KAAKC,oBAAL,CAA0BJ,WAA1B,CAAd;AACA,UAAMK,IAAI,GAAG,KAAKD,oBAAL,CAA0BH,UAA1B,CAAb;;AACA,QAAKE,KAAK,KAAK,CAAX,IAAkBE,IAAI,KAAK,CAA/B,EAAmC;AACjC,WAAK,IAAI3C,EAAE,GAAGyC,KAAd,EAAqBzC,EAAE,IAAI2C,IAA3B,EAAiC3C,EAAE,EAAnC,EAAuC;AACrC,YAAIpB,SAAS,CAACoB,EAAD,CAAb,EAAmB;AACjBwC,UAAAA,YAAY,CAACxD,IAAb,CAAkBgB,EAAlB;AACD;AACF;AACF;;AACD,WAAOwC,YAAP;AACD;;AAEDE,EAAAA,oBAAoB,CAACE,KAAD,EAAQ;AAC1B,UAAMC,QAAQ,GAAGC,UAAU,CAACF,KAAD,CAA3B;;AACA,QAAI,CAAChE,SAAS,CAACiE,QAAD,CAAV,IAAyBjE,SAAS,CAACiE,QAAD,CAAT,CAAoBE,OAApB,IAA+B,CAACzC,EAAE,CAAC0C,WAAhE,EAA8E;AAC5E,aAAO,CAAP;AACD;;AACD,WAAOH,QAAP;AACD,GAzKwB,CA2KzB;AACA;AACA;;;AACAlF,EAAAA,eAAe,CAAC6B,UAAD,EAAayD,UAAb,EAAyB;AACtC,SAAK,MAAMtD,KAAX,IAAoBH,UAApB,EAAgC;AAC9B,YAAM0D,KAAK,GAAG,OAAOvD,KAAP,KAAiB,QAAjB,GAA4BA,KAA5B,GAAoCf,SAAS,CAACe,KAAD,CAA3D;AACA,UAAI,KAAKwD,eAAL,CAAqBD,KAArB,CAAJ,EAAiC,KAAKE,cAAL,CAAoBF,KAApB,EAA2BD,UAA3B;AAClC;AACF,GAnLwB,CAqLzB;AACA;AACA;;;AACAE,EAAAA,eAAe,CAACxD,KAAD,EAAQ0D,kBAAkB,GAAG,KAA7B,EAAoC;AACjD;AACA,QAAI,CAAC1D,KAAD,IAAU,KAAKpC,gBAAL,CAAsBuE,QAAtB,CAA+BnC,KAA/B,CAAd,EAAqD,OAAO,KAAP,CAFJ,CAIjD;AACA;;AACA,UAAM2D,KAAK,GAAGC,GAAG,IAAK,OAAOA,GAAP,KAAe,QAAf,GAClB,KAAKhG,gBAAL,CAAsBuE,QAAtB,CAA+BlD,SAAS,CAAC2E,GAAD,CAAxC,CADkB,GAElBA,GAAG,EAFP;;AAGA,UAAMC,MAAM,GAAG7D,KAAK,CAAC6D,MAArB;AACA,QAAIC,YAAJ;;AACA,YAAQD,MAAM,CAACE,OAAf;AACE,WAAKC,mBAAmB,CAACC,YAAzB;AACEH,QAAAA,YAAY,GAAGD,MAAM,CAACK,WAAP,CAAmBC,IAAnB,CAAwBC,CAAC,IAAIT,KAAK,CAACS,CAAD,CAAlC,CAAf;AACA;;AACF,WAAKJ,mBAAmB,CAACK,GAAzB;AACEP,QAAAA,YAAY,GAAGD,MAAM,CAACK,WAAP,CAAmBI,KAAnB,CAAyBF,CAAC,IAAIT,KAAK,CAACS,CAAD,CAAnC,CAAf;AACA;;AACF,WAAKJ,mBAAmB,CAACO,cAAzB;AACET,QAAAA,YAAY,GAAGD,MAAM,CAACK,WAAP,CAAmBI,KAAnB,CAAyBF,CAAC,IAAIT,KAAK,CAACS,CAAD,CAAnC,KAA2C,KAAKI,gBAAL,GAAwB,KAAKC,mBAAvF;AACA;;AACF;AACE,cAAMvG,KAAK,CAAE,qCAAoC,KAAK6F,OAAQ,EAAnD,CAAX;AAXJ;;AAaA,QAAI/D,KAAK,YAAYG,gBAArB,EAAuC;AAAA;;AACrC,UAAI,KAAKvC,gBAAL,CAAsBuG,IAAtB,CAA2BnF,CAAC,IAAIA,CAAC,YAAYmB,gBAA7C,CAAJ,EAAoE,OAAO,KAAP;AACpE,YAAMuE,mBAAmB,GAAG,CAACC,IAAI,CAACC,kBAAL,CAAwB3E,QAAzB,8BAC1BD,KAAK,CAAC6D,MAAN,CAAagB,SAAb,CAAuBC,gBADG,0DAC1B,sBAAyCX,IAAzC,CAA8CnF,CAAC,IAAI2E,KAAK,CAAC3E,CAAD,CAAxD,CAD0B,CAA5B,CAFqC,CAIrC;;AACA,UAAI0E,kBAAJ,EAAwB;AACtB,eAAOI,YAAY,IAAI,CAACY,mBAAxB;AACD;;AACD,YAAMK,OAAO,GAAGlG,MAAM,CAACC,SAAP,CAAiBkG,OAAjB,CAAyBC,IAAzB,CAA8BC,YAAY,CAACC,wBAAb,EAA9B,CAAhB;AACA,YAAMC,WAAW,GAAGL,OAAO,CAACM,QAAR,CAAiB,KAAK3H,aAAL,CAAmB,CAAnB,CAAjB,EAAwC4H,GAAxC,CAA4CtF,KAAK,CAACuF,IAAlD,CAApB;AACA,YAAMC,aAAa,GAAGb,IAAI,CAACC,kBAAL,CAAwB3E,QAAxB,IAAoCD,KAAK,CAACyF,cAAhE;AACA,aAAO3B,YAAY,IAAI,CAACY,mBAAjB,KAAyC1E,KAAK,CAACC,QAAN,IAAmBuF,aAAa,IAAIJ,WAA7E,CAAP;AACD;;AACD,WAAOtB,YAAP;AACD,GA9NwB,CAgOzB;;;AACAL,EAAAA,cAAc,CAACzD,KAAD,EAAQsD,UAAR,EAAoB;AAChC,UAAMO,MAAM,GAAG7D,KAAK,CAAC6D,MAArB;AACA,UAAM6B,UAAU,GAAGC,QAAQ,CAACC,QAAT,CAAkB5E,eAAlB,CAAkC,CAAlC,CAAnB;AACA,UAAM6E,QAAQ,GAAGhC,MAAM,CAACiC,MAAP,IAAiBjC,MAAM,CAACkC,UAAP,CAAkB5B,IAAlB,CAAuBnF,CAAC,IAAI,KAAKpB,gBAAL,CAAsBuE,QAAtB,CAA+BlD,SAAS,CAACD,CAAD,CAAxC,CAA5B,CAAjB,GACbgH,IAAI,CAACC,QAAL,CAAcpC,MAAM,CAACiC,MAAP,GAAgBJ,UAA9B,EAA0C,CAA1C,CADa,GAEb,CAFJ,CAHgC,CAMhC;;AACA,UAAMQ,KAAK,GAAGC,KAAK,CAACC,QAAN,GAAiB,CAAjB,GAAqBC,CAAC,CAACC,aAArC;AACA,UAAMC,KAAK,GAAG,KAAK7I,aAAL,CAAmB,CAAnB,IAAwBmI,QAAxB,IAAoCK,KAAlD;;AACA,QAAI5C,UAAJ,EAAgB;AACd,YAAMkD,KAAK,GAAGC,QAAQ,CAACC,YAAT,CAAsBC,KAAtB,CAA4BC,GAA5B,CAAgCrG,SAAS,CAACC,gBAAV,CAA2BmG,KAA3B,CAAiCjJ,aAAjC,CAA+C,CAA/C,CAAhC,EACXmJ,QADW,CACFC,MAAM,CAACC,SADL,EACgBC,QADhB,EAAd;AAEA,YAAMC,KAAK,GAAG,KAAKvJ,aAAL,CAAmB,CAAnB,IAAwBmG,MAAM,CAAC0B,IAA/B,IAAuCiB,KAArD;AACA,UAAI,CAACS,KAAD,IAAU,CAACV,KAAf,EAAsB;AACvB,KAd+B,CAgBhC;;;AACA,QAAIL,KAAK,KAAK,CAAV,IAAeL,QAAQ,GAAG,CAA9B,EAAiC;AACjC,SAAKnI,aAAL,CAAmB,CAAnB,KAAyBmG,MAAM,CAAC0B,IAAhC;AACA,SAAK7H,aAAL,CAAmB,CAAnB,KAAyBmI,QAAzB;AAEA,SAAKjI,gBAAL,CAAsByB,IAAtB,CAA2BW,KAA3B;AACD;;AAEmB,MAAhBwE,gBAAgB,GAAG;AACrB,WAAO,CAAC,EAAD,EAAK,EAAL,EAAS,EAAT,EAAa0C,UAAb,CAAwBxI,CAAC,IAAI,KAAKd,gBAAL,CAAsBuE,QAAtB,CAA+BlD,SAAS,CAACP,CAAD,CAAxC,CAA7B,CAAP;AACD;;AAEsB,MAAnB+F,mBAAmB,GAAG;AACxB,QAAI0C,eAAe,CAACC,cAAhB,CAA+BnH,QAAnC,EAA6C,OAAO,CAAP;AAC7C,QAAI,KAAKrC,gBAAL,CAAsBuE,QAAtB,CAA+BlD,SAAS,CAAC,GAAD,CAAxC,CAAJ,EAAoD,OAAO,CAAP;AACpD,WAAO,CAAP;AACD;;AAEiB,MAAdoI,cAAc,GAAG;AACnB,UAAMC,OAAO,GAAG,IAAIC,GAAJ,EAAhB;AACA,UAAMC,UAAU,GAAG,CAACC,eAAe,CAACC,cAAjB,EAAiCD,eAAe,CAACE,YAAjD,EAA+DF,eAAe,CAACG,QAA/E,CAAnB;;AACA,SAAK,MAAMC,IAAX,IAAmBL,UAAnB,EAA+B;AAC7B,YAAMM,SAAS,GAAGC,iBAAiB,CAACC,QAAlB,CAA2BC,IAA3B,CAAgCC,CAAC,IAAIA,CAAC,CAACL,IAAF,KAAWA,IAAhD,CAAlB;;AACA,WAAK,MAAM7H,KAAX,IAAoB,KAAKpC,gBAAzB,EAA2C;AACzC,YAAIkK,SAAS,CAACrK,OAAV,CAAkB0E,QAAlB,CAA2BnC,KAAK,CAACK,EAAjC,CAAJ,EAA0C;AACxCiH,UAAAA,OAAO,CAACV,GAAR,CAAYkB,SAAS,CAACzG,IAAtB;AACA;AACD;AACF;AACF;;AACD,WAAO8G,KAAK,CAACC,IAAN,CAAWd,OAAX,CAAP;AACD;;AAEY,MAATe,SAAS,GAAG;AACd,UAAMf,OAAO,GAAG,IAAIC,GAAJ,EAAhB;AACA,UAAMC,UAAU,GAAG,CAACC,eAAe,CAACa,MAAjB,EAAyBb,eAAe,CAACc,OAAzC,EAAkDd,eAAe,CAACe,IAAlE,CAAnB;;AACA,SAAK,MAAMX,IAAX,IAAmBL,UAAnB,EAA+B;AAC7B,YAAMM,SAAS,GAAGC,iBAAiB,CAACC,QAAlB,CAA2BC,IAA3B,CAAgCC,CAAC,IAAIA,CAAC,CAACL,IAAF,KAAWA,IAAhD,CAAlB;;AACA,WAAK,MAAM7H,KAAX,IAAoB,KAAKpC,gBAAzB,EAA2C;AACzC,YAAIkK,SAAS,CAACrK,OAAV,CAAkB0E,QAAlB,CAA2BnC,KAAK,CAACK,EAAjC,CAAJ,EAA0C;AACxCiH,UAAAA,OAAO,CAACV,GAAR,CAAYkB,SAAS,CAACzG,IAAtB;AACA;AACD;AACF;AACF;;AACD,WAAO8G,KAAK,CAACC,IAAN,CAAWd,OAAX,CAAP;AACD;;AAEK,MAAF7E,EAAE,GAAG;AACP;AACA,UAAMgG,SAAS,GAAG,KAAK7K,gBAAL,CAAsBqK,IAAtB,CAA2BjJ,CAAC,IAAIA,CAAC,YAAYmB,gBAA7C,CAAlB;AACA,WAAOsI,SAAS,GAAGA,SAAS,CAACpI,EAAb,GAAkB,CAAlC;AACD,GArSwB,CAuSzB;;;AACgB,MAAZqI,YAAY,GAAG;AACjB,WAAQ,GAAE,KAAK9K,gBAAL,CACP+K,MADO,CACA3J,CAAC,IAAIA,CAAC,YAAY4J,oBADlB,EAEP7J,GAFO,CAEHC,CAAC,IAAIA,CAAC,CAACqB,EAFJ,EAGPkB,IAHO,CAGF,GAHE,CAGG,IAAG,KAAKkB,EAAG,GAAE5D,MAAM,CAACK,SAAP,CAAiBC,QAAjB,CAA0B0J,OAA1B,KAAsC,CAAtC,GAA0C,EAA1C,GAA+C,GAAI,EAH7E;AAID;;AA7SwB","sourcesContent":["/**\r\n * Abstract representation of a full time study tree object. The intended usage is to supply the constructor with\r\n * an import string and a budget of time/space theorems, which it will use together to determine which studies can\r\n * actually be purchased in the specified order. All of the complex purchasing logic should be handled here, and not\r\n * in any TimeStudyState objects. During parsing, some minor additional info is stored in order to improve user\r\n * feedback when attempting to import other study trees.\r\n *\r\n * Usage notes:\r\n * - Unless commitToGameState() is called, this only ever creates a \"virtual\" tree object which does not change the\r\n *   overall game state. This class serves the purpose of having all the purchasing and locking logic in one place.\r\n *   Only upon calling commitToGameState() will the game actually try to get every study specified in tree.\r\n * - The general intent is that the logic in this class is meant to pull minimally from the extrenal game state; for\r\n *   example, how many dimension paths are allowed or which ECs are unlockable depend on only the data in the tree\r\n *   object itself and should not depend on the actual current game state\r\n * - All study entries must be Strings because numbers (normal TS) and EC# (ECs) need to be supported\r\n *\r\n * @member {Number[]} spentTheorems      Two-element array containing TT/ST totals for studies which were actually\r\n *  purchased after accounting for various conditions which would forbid some being bought (eg. cost or tree structure)\r\n * @member {String[]} invalidStudies     Array of studies from the initial string which are correctly formatted\r\n *  but don't actually exist; used for informational purposes elsewhere\r\n * @member {TimeStudyState[]} selectedStudies   Array of all given valid studies, whether or not they are actually\r\n *  accessible or purchasable in the given order\r\n * @member {TimeStudyState[]} purchasedStudies  Array of studies which were actually purchased, using the given amount\r\n *  of available theorems\r\n * @member {Boolean} startEC    Whether or not to start an EC within purchasedStudies when committing to game state\r\n */\r\nexport class TimeStudyTree {\r\n  // The first parameter will either be an import string or an array of studies (possibly with an EC at the end)\r\n  constructor(studies) {\r\n    this.spentTheorems = [0, 0];\r\n    this.invalidStudies = [];\r\n    this.purchasedStudies = [];\r\n    this.selectedStudies = [];\r\n    this.startEC = false;\r\n    switch (typeof studies) {\r\n      case \"string\":\r\n        // Input parameter is an unparsed study import string\r\n        if (TimeStudyTree.isValidImportString(studies)) {\r\n          this.attemptBuyArray(this.parseStudyImport(studies), false);\r\n        }\r\n        break;\r\n      case \"object\":\r\n        // Input parameter is an array of time study objects\r\n        this.attemptBuyArray([...studies], false);\r\n        this.selectedStudies = [...studies];\r\n        break;\r\n      case \"undefined\":\r\n        // If not supplied with anything, we leave everything at default values and don't attempt to buy anything\r\n        break;\r\n      default:\r\n        throw new Error(\"Unrecognized input parameter for TimeStudyTree constructor\");\r\n    }\r\n  }\r\n\r\n  // Note that this only checks pure formatting, not whether or not a study/EC actually exists, but verifying correct\r\n  // formatting separately from verifying existence allows us to produce more useful in-game error messages for\r\n  // import strings which are formatted correctly but aren't entirely valid\r\n  static isValidImportString(input) {\r\n    if (input.trim() === \"\") {\r\n      return false;\r\n    }\r\n    let test = input.replaceAll(/ +/gu, \"\");\r\n    TimeStudyTree.sets.forEach((_, x) => test = test.replaceAll(new RegExp(`${x},?`, \"gu\"), \"\"));\r\n    return /^,?((\\d{2,3}(-\\d{2,3})?)\\b,?)*(\\|\\d{1,2}!?)?$/iu.test(test);\r\n  }\r\n\r\n  // Getter for all the studies in the current game state\r\n  static get currentStudies() {\r\n    const currentStudies = player.timestudy.studies.map(s => TimeStudy(s));\r\n    if (player.challenge.eternity.unlocked !== 0) {\r\n      currentStudies.push(TimeStudy.eternityChallenge(player.challenge.eternity.unlocked));\r\n    }\r\n    return currentStudies;\r\n  }\r\n\r\n  // Parses out the EC number from an import string (returns 0 for invalid or nonexistent EC ids)\r\n  static getECFromString(input) {\r\n    if (!this.isValidImportString(input)) return 0;\r\n    const parts = input.split(\"|\");\r\n    if (parts.length < 1) return 0;\r\n    // Note: parseInt() seems to silently ignore the presence of \"!\"\r\n    return parseInt(parts[1], 10);\r\n  }\r\n\r\n  // THIS METHOD HAS LASTING CONSEQUENCES ON THE GAME STATE. STUDIES WILL ACTUALLY BE PURCHASED IF POSSIBLE.\r\n  // This method attempts to take the parameter array and purchase all the studies specified, using the current game\r\n  // state to determine if they are affordable. Input array may be either an id array or a TimeStudyState array\r\n  static commitToGameState(studyArray, auto = true, startEC = false) {\r\n    for (const item of studyArray) {\r\n      const study = typeof item === \"number\" ? TimeStudy(item) : item;\r\n      if (study && !study.isBought) study.purchase(auto);\r\n      // Note: This will automatically (silently) fail if we try to start an EC while we have a different one unlocked\r\n      if (startEC && study instanceof ECTimeStudyState) EternityChallenge(study.id).start(auto);\r\n    }\r\n    GameCache.currentStudyTree.invalidate();\r\n  }\r\n\r\n  static get sets() {\r\n    // Grouping of studies. The key followed by an array of the studies the key is a shorthand for.\r\n    return new Map([\r\n      [\"antimatter\", [71, 81, 91, 101]],\r\n      [\"infinity\", [72, 82, 92, 102]],\r\n      [\"time\", [73, 83, 93, 103]],\r\n      [\"active\", [121, 131, 141]],\r\n      [\"passive\", [122, 132, 142]],\r\n      [\"idle\", [123, 133, 143]],\r\n      [\"light\", [221, 223, 225, 227, 231, 233]],\r\n      [\"dark\", [222, 224, 226, 228, 232, 234]],\r\n      ...(Ra.unlocks.unlockHardV.canBeApplied\r\n        ? [[\"triad\", [301, 302, 303, 304].slice(0, Ra.unlocks.unlockHardV.effectOrDefault(0))]]\r\n        : [])\r\n    ]);\r\n  }\r\n\r\n  static truncateInput(input) {\r\n    let internal = input.toLowerCase();\r\n    // Convert every name into the ids it is a shorthand for\r\n    this.sets.forEach((ids, name) => (internal = internal.replace(name, ids.join())));\r\n    return internal\r\n      .replace(/[|,]$/u, \"\")\r\n      .replaceAll(\" \", \"\")\r\n      // Allows 11,,21 to be parsed as 11,21 and 11,|1 to be parsed as 11|1\r\n      .replace(/,{2,}/gu, \",\")\r\n      .replace(/,\\|/gu, \"|\");\r\n  }\r\n\r\n  static formatStudyList(input) {\r\n    const internal = input.toLowerCase().replaceAll(\" \", \"\");\r\n    return internal.replaceAll(\",\", \", \").replace(\"|\", \" | \");\r\n  }\r\n\r\n  // This reads off all the studies in the import string and splits them into invalid and valid study IDs. We hold on\r\n  // to invalid studies for additional information to present to the player\r\n  parseStudyImport(input) {\r\n    const studyDB = GameDatabase.eternity.timeStudies.normal.map(s => s.id);\r\n    const output = [];\r\n    const studiesString = TimeStudyTree.truncateInput(input).split(\"|\")[0];\r\n    if (studiesString.length) {\r\n      const studyCluster = studiesString.split(\",\");\r\n      for (const studyRange of studyCluster) {\r\n        const studyRangeSplit = studyRange.split(\"-\");\r\n        const studyArray = studyRangeSplit[1]\r\n          ? this.studyRangeToArray(studyRangeSplit[0], studyRangeSplit[1])\r\n          : studyRangeSplit;\r\n        for (const study of studyArray) {\r\n          if (studyDB.includes(parseInt(study, 10))) {\r\n            const tsObject = TimeStudy(study);\r\n            this.selectedStudies.push(tsObject);\r\n            output.push(tsObject);\r\n          } else {\r\n            this.invalidStudies.push(study);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // If the string has an EC indicated in it, append that to the end of the study array\r\n    const ecString = input.split(\"|\")[1];\r\n    this.startEC = input.endsWith(\"!\");\r\n    if (!ecString) {\r\n      // Study strings without an ending \"|##\" are still valid, but will result in ecString being undefined\r\n      return output;\r\n    }\r\n    // Note: parseInt() seems to silently ignore the presence of \"!\"\r\n    const ecID = parseInt(ecString, 10);\r\n    const ecDB = GameDatabase.eternity.timeStudies.ec;\r\n    // Specifically exclude 0 because saved presets will contain it by default\r\n    if (!ecDB.map(c => c.id).includes(ecID) && ecID !== 0) {\r\n      this.invalidStudies.push(`EC${ecID}`);\r\n      return output;\r\n    }\r\n    if (ecID !== 0) output.push(TimeStudy.eternityChallenge(ecID));\r\n    return output;\r\n  }\r\n\r\n  studyRangeToArray(firstNumber, lastNumber) {\r\n    const studiesArray = [];\r\n    const first = this.checkTimeStudyNumber(firstNumber);\r\n    const last = this.checkTimeStudyNumber(lastNumber);\r\n    if ((first !== 0) && (last !== 0)) {\r\n      for (let id = first; id <= last; id++) {\r\n        if (TimeStudy(id)) {\r\n          studiesArray.push(id);\r\n        }\r\n      }\r\n    }\r\n    return studiesArray;\r\n  }\r\n\r\n  checkTimeStudyNumber(token) {\r\n    const tsNumber = parseFloat(token);\r\n    if (!TimeStudy(tsNumber) || (TimeStudy(tsNumber).isTriad && !Ra.canBuyTriad)) {\r\n      return 0;\r\n    }\r\n    return tsNumber;\r\n  }\r\n\r\n  // Attempt to purchase all studies specified in the array which may be either study IDs (which get converted) or\r\n  // study objects. The method needs to support both because turning it entirely to studies causes circular references\r\n  // which make the game fail to load\r\n  attemptBuyArray(studyArray, checkCosts) {\r\n    for (const study of studyArray) {\r\n      const toBuy = typeof study === \"object\" ? study : TimeStudy(study);\r\n      if (this.hasRequirements(toBuy)) this.buySingleStudy(toBuy, checkCosts);\r\n    }\r\n  }\r\n\r\n  // Tries to buy a single study, accounting for all various requirements and locking behavior in the game. Does not\r\n  // update anything cost-related, use buySingleStudy() to actually purchase. checkOnlyStructure is used to ignore\r\n  // EC secondary requirements\r\n  hasRequirements(study, checkOnlyStructure = false) {\r\n    // Import strings can contain repeated or undefined entries\r\n    if (!study || this.purchasedStudies.includes(study)) return false;\r\n\r\n    // Because the player data may not reflect the state of the TimeStudyTree object's purchasedStudies,\r\n    // we have to do all the checks here with purchasedStudies. study.isBought and similar functions cannot be used.\r\n    const check = req => (typeof req === \"number\"\r\n      ? this.purchasedStudies.includes(TimeStudy(req))\r\n      : req());\r\n    const config = study.config;\r\n    let reqSatisfied;\r\n    switch (config.reqType) {\r\n      case TS_REQUIREMENT_TYPE.AT_LEAST_ONE:\r\n        reqSatisfied = config.requirement.some(r => check(r));\r\n        break;\r\n      case TS_REQUIREMENT_TYPE.ALL:\r\n        reqSatisfied = config.requirement.every(r => check(r));\r\n        break;\r\n      case TS_REQUIREMENT_TYPE.DIMENSION_PATH:\r\n        reqSatisfied = config.requirement.every(r => check(r)) && this.currDimPathCount < this.allowedDimPathCount;\r\n        break;\r\n      default:\r\n        throw Error(`Unrecognized TS requirement type: ${this.reqType}`);\r\n    }\r\n    if (study instanceof ECTimeStudyState) {\r\n      if (this.purchasedStudies.some(s => s instanceof ECTimeStudyState)) return false;\r\n      const hasForbiddenStudies = !Perk.studyECRequirement.isBought &&\r\n        study.config.secondary.forbiddenStudies?.some(s => check(s));\r\n      // We want to only check the structure for script template error instructions\r\n      if (checkOnlyStructure) {\r\n        return reqSatisfied && !hasForbiddenStudies;\r\n      }\r\n      const totalTT = player.timestudy.theorem.plus(TimeTheorems.calculateTimeStudiesCost());\r\n      const hasEnoughTT = totalTT.subtract(this.spentTheorems[0]).gte(study.cost);\r\n      const secondaryGoal = Perk.studyECRequirement.isBought || study.isEntryGoalMet;\r\n      return reqSatisfied && !hasForbiddenStudies && (study.isBought || (secondaryGoal && hasEnoughTT));\r\n    }\r\n    return reqSatisfied;\r\n  }\r\n\r\n  // Buys the specified study; no requirement verification beyond cost, use hasRequirements() to verify proper structure\r\n  buySingleStudy(study, checkCosts) {\r\n    const config = study.config;\r\n    const stDiscount = VUnlocks.raUnlock.effectOrDefault(0);\r\n    const stNeeded = config.STCost && config.requiresST.some(s => this.purchasedStudies.includes(TimeStudy(s)))\r\n      ? Math.clampMin(config.STCost - stDiscount, 0)\r\n      : 0;\r\n    // Took these out of the checkCosts check as these aren't available early game\r\n    const maxST = Pelle.isDoomed ? 0 : V.spaceTheorems;\r\n    const hasST = this.spentTheorems[1] + stNeeded <= maxST;\r\n    if (checkCosts) {\r\n      const maxTT = Currency.timeTheorems.value.add(GameCache.currentStudyTree.value.spentTheorems[0])\r\n        .clampMax(Number.MAX_VALUE).toNumber();\r\n      const hasTT = this.spentTheorems[0] + config.cost <= maxTT;\r\n      if (!hasTT || !hasST) return;\r\n    }\r\n\r\n    // Don't add the costs nor add the study if it is one using ST and there are none\r\n    if (maxST === 0 && stNeeded > 0) return;\r\n    this.spentTheorems[0] += config.cost;\r\n    this.spentTheorems[1] += stNeeded;\r\n\r\n    this.purchasedStudies.push(study);\r\n  }\r\n\r\n  get currDimPathCount() {\r\n    return [71, 72, 73].countWhere(x => this.purchasedStudies.includes(TimeStudy(x)));\r\n  }\r\n\r\n  get allowedDimPathCount() {\r\n    if (DilationUpgrade.timeStudySplit.isBought) return 3;\r\n    if (this.purchasedStudies.includes(TimeStudy(201))) return 2;\r\n    return 1;\r\n  }\r\n\r\n  get dimensionPaths() {\r\n    const pathSet = new Set();\r\n    const validPaths = [TIME_STUDY_PATH.ANTIMATTER_DIM, TIME_STUDY_PATH.INFINITY_DIM, TIME_STUDY_PATH.TIME_DIM];\r\n    for (const path of validPaths) {\r\n      const pathEntry = NormalTimeStudies.pathList.find(p => p.path === path);\r\n      for (const study of this.purchasedStudies) {\r\n        if (pathEntry.studies.includes(study.id)) {\r\n          pathSet.add(pathEntry.name);\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    return Array.from(pathSet);\r\n  }\r\n\r\n  get pacePaths() {\r\n    const pathSet = new Set();\r\n    const validPaths = [TIME_STUDY_PATH.ACTIVE, TIME_STUDY_PATH.PASSIVE, TIME_STUDY_PATH.IDLE];\r\n    for (const path of validPaths) {\r\n      const pathEntry = NormalTimeStudies.pathList.find(p => p.path === path);\r\n      for (const study of this.purchasedStudies) {\r\n        if (pathEntry.studies.includes(study.id)) {\r\n          pathSet.add(pathEntry.name);\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    return Array.from(pathSet);\r\n  }\r\n\r\n  get ec() {\r\n    // This technically takes the very first EC entry if there's more than one, but that shouldn't happen in practice\r\n    const ecStudies = this.purchasedStudies.find(s => s instanceof ECTimeStudyState);\r\n    return ecStudies ? ecStudies.id : 0;\r\n  }\r\n\r\n  // Creates an export string based on all currently purchased studies; gives an ! at the end if currently in an EC\r\n  get exportString() {\r\n    return `${this.purchasedStudies\r\n      .filter(s => s instanceof NormalTimeStudyState)\r\n      .map(s => s.id)\r\n      .join(\",\")}|${this.ec}${player.challenge.eternity.current === 0 ? \"\" : \"!\"}`;\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}