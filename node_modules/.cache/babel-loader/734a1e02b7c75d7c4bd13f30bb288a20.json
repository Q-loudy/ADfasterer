{"ast":null,"code":"import \"core-js/modules/es.json.stringify.js\";\nconst Payments = {\n  interval: null,\n  windowReference: null,\n  // This is here to prevent notification spam; purchase canceling can be called multiple times before the first\n  // call's Promise is settled\n  hasCanceled: false,\n  init: () => {\n    // We have unfinished checkouts from when the page was last closed\n    if (player.IAP.checkoutSession.id) {\n      Payments.pollForPurchases();\n    }\n  },\n  // Only called from clicking the \"Buy More\" button in the Shop tab\n  buyMoreSTD: async STD => {\n    player.IAP.checkoutSession = {\n      id: true\n    };\n    let res;\n\n    try {\n      res = await fetch(`${STD_BACKEND_URL}/purchase`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          amount: STD,\n          cloudID: Cloud.user.id\n        })\n      });\n    } catch (e) {\n      GameUI.notify.error(\"Could not contact payment server!\", 10000);\n      return;\n    }\n\n    const data = await res.json();\n    Payments.windowReference = window.open(data.url, \"antimatterDimensionsPurchase\", \"popup,width=500,height=500,left=100,top=100\");\n    player.IAP.checkoutSession = {\n      id: data.id,\n      amount: STD\n    };\n    GameStorage.save();\n    Payments.pollForPurchases();\n  },\n  // Starts a purchase-checking loop and adds a listener which cancels any ongoing purchases if the page is closed.\n  // Any unresolved purchases will be reopened when the page is opened again in init()\n  pollForPurchases: () => {\n    const {\n      id,\n      amount\n    } = player.IAP.checkoutSession;\n    let pollAmount = 0;\n\n    window.onbeforeunload = async () => {\n      var _Payments$windowRefer;\n\n      if (!Payments.interval) return;\n      (_Payments$windowRefer = Payments.windowReference) === null || _Payments$windowRefer === void 0 ? void 0 : _Payments$windowRefer.close();\n      await Payments.cancelPurchase(false);\n    }; // This setInterval checks every 3 seconds for a response from the payment backend\n\n\n    Payments.interval = setInterval(async () => {\n      var _Payments$windowRefer4;\n\n      pollAmount++;\n      let statusRes;\n\n      try {\n        statusRes = await fetch(`${STD_BACKEND_URL}/validate?sessionId=${id}`);\n      } catch (e) {\n        // Note: Not redundant with notification in buyMoreSTD above; will not be reached if exception is thrown there\n        GameUI.notify.error(\"Could not contact payment server!\", 10000);\n        Payments.clearInterval();\n        return;\n      }\n\n      const {\n        completed,\n        failure\n      } = await statusRes.json();\n\n      if (completed) {\n        var _Payments$windowRefer2;\n\n        (_Payments$windowRefer2 = Payments.windowReference) === null || _Payments$windowRefer2 === void 0 ? void 0 : _Payments$windowRefer2.close();\n        await ShopPurchaseData.syncSTD();\n        GameUI.notify.success(`Purchase of ${amount} STDs was successful, thank you for your support! ❤️`, 10000);\n        Payments.clearInterval();\n        player.IAP.checkoutSession = {\n          id: false\n        };\n        GameStorage.save();\n        Modal.hide();\n      }\n\n      if (failure) {\n        var _Payments$windowRefer3;\n\n        (_Payments$windowRefer3 = Payments.windowReference) === null || _Payments$windowRefer3 === void 0 ? void 0 : _Payments$windowRefer3.close();\n        Payments.clearInterval();\n        GameUI.notify.error(`Purchase failed!`, 10000);\n        player.IAP.checkoutSession = {\n          id: false\n        };\n        GameStorage.save();\n        return;\n      } // 30 minutes of polling is the maximum\n\n\n      if (!completed && ((_Payments$windowRefer4 = Payments.windowReference) !== null && _Payments$windowRefer4 !== void 0 && _Payments$windowRefer4.closed || pollAmount >= 20 * 30)) {\n        await Payments.cancelPurchase(true);\n      }\n    }, 3000);\n  },\n\n  // Sends a request to purchase a STD upgrade, returning true if successful (and syncs data), false if not\n  async buyUpgrade(upgradeKey, cosmeticName) {\n    var _stdData$error;\n\n    if (!Cloud.loggedIn) return false;\n    let res;\n\n    try {\n      res = await fetch(`${STD_BACKEND_URL}/upgrade`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          user: Cloud.user.id,\n          upgrade: upgradeKey,\n          extraData: {\n            requestedSet: cosmeticName,\n            fullCompletions: player.records.fullGameCompletions\n          }\n        })\n      });\n    } catch (e) {\n      GameUI.notify.error(\"Unable to spend STD coins on upgrade!\", 10000);\n      return false;\n    }\n\n    const stdData = await res.json(); // The \"not enough STDs\" message should only show up if the player modifies costs on the frontend and forces the\n    // game to send a request despite not actually having enough STDs. The cost check is done again on the backend\n\n    if (stdData.success) GameUI.notify.info(`Successfully spent ${stdData.amountSpent} STD coins`, 10000);else GameUI.notify.error((_stdData$error = stdData.error) !== null && _stdData$error !== void 0 ? _stdData$error : \"Unable to purchase upgrade\", 10000);\n    ShopPurchaseData.syncSTD(false, stdData.data);\n    return stdData.success;\n  },\n\n  // Explicitly cancels purchases if the player chooses to, they take too long to resolve, or the page is closed\n  async cancelPurchase(isTimeout) {\n    var _Payments$windowRefer5;\n\n    if (this.hasCanceled) return;\n    (_Payments$windowRefer5 = Payments.windowReference) === null || _Payments$windowRefer5 === void 0 ? void 0 : _Payments$windowRefer5.close();\n    Payments.clearInterval();\n\n    try {\n      await fetch(`${STD_BACKEND_URL}/expire`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          sessionId: player.IAP.checkoutSession.id\n        })\n      });\n    } catch (e) {\n      GameUI.notify.error(\"Could not contact payment server!\", 10000);\n    }\n\n    if (isTimeout) GameUI.notify.error(\"Purchase took too long to resolve!\", 10000);\n    player.IAP.checkoutSession = {\n      id: false\n    };\n    GameStorage.save();\n    this.hasCanceled = false;\n  },\n\n  // Removes the repeating checker and page-close listener for if payments have been resolved\n  clearInterval() {\n    clearInterval(Payments.interval);\n    window.onbeforeunload = null;\n  }\n\n};\nexport default Payments;","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/payments.js"],"names":["Payments","interval","windowReference","hasCanceled","init","player","IAP","checkoutSession","id","pollForPurchases","buyMoreSTD","STD","res","fetch","STD_BACKEND_URL","method","headers","body","JSON","stringify","amount","cloudID","Cloud","user","e","GameUI","notify","error","data","json","window","open","url","GameStorage","save","pollAmount","onbeforeunload","close","cancelPurchase","setInterval","statusRes","clearInterval","completed","failure","ShopPurchaseData","syncSTD","success","Modal","hide","closed","buyUpgrade","upgradeKey","cosmeticName","loggedIn","upgrade","extraData","requestedSet","fullCompletions","records","fullGameCompletions","stdData","info","amountSpent","isTimeout","sessionId"],"mappings":"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","sourcesContent":["const Payments = {\r\n  interval: null,\r\n  windowReference: null,\r\n  // This is here to prevent notification spam; purchase canceling can be called multiple times before the first\r\n  // call's Promise is settled\r\n  hasCanceled: false,\r\n  init: () => {\r\n    // We have unfinished checkouts from when the page was last closed\r\n    if (player.IAP.checkoutSession.id) {\r\n      Payments.pollForPurchases();\r\n    }\r\n  },\r\n\r\n  // Only called from clicking the \"Buy More\" button in the Shop tab\r\n  buyMoreSTD: async STD => {\r\n    player.IAP.checkoutSession = { id: true };\r\n    let res;\r\n    try {\r\n      res = await fetch(`${STD_BACKEND_URL}/purchase`, {\r\n        method: \"POST\",\r\n        headers: {\r\n          \"Content-Type\": \"application/json\"\r\n        },\r\n        body: JSON.stringify({ amount: STD, cloudID: Cloud.user.id })\r\n      });\r\n    } catch (e) {\r\n      GameUI.notify.error(\"Could not contact payment server!\", 10000);\r\n      return;\r\n    }\r\n    const data = await res.json();\r\n    Payments.windowReference = window.open(\r\n      data.url,\r\n      \"antimatterDimensionsPurchase\",\r\n      \"popup,width=500,height=500,left=100,top=100\"\r\n    );\r\n    player.IAP.checkoutSession = { id: data.id, amount: STD };\r\n    GameStorage.save();\r\n    Payments.pollForPurchases();\r\n  },\r\n\r\n  // Starts a purchase-checking loop and adds a listener which cancels any ongoing purchases if the page is closed.\r\n  // Any unresolved purchases will be reopened when the page is opened again in init()\r\n  pollForPurchases: () => {\r\n    const { id, amount } = player.IAP.checkoutSession;\r\n    let pollAmount = 0;\r\n    window.onbeforeunload = async() => {\r\n      if (!Payments.interval) return;\r\n      Payments.windowReference?.close();\r\n      await Payments.cancelPurchase(false);\r\n    };\r\n\r\n    // This setInterval checks every 3 seconds for a response from the payment backend\r\n    Payments.interval = setInterval(async() => {\r\n      pollAmount++;\r\n      let statusRes;\r\n      try {\r\n        statusRes = await fetch(`${STD_BACKEND_URL}/validate?sessionId=${id}`);\r\n      } catch (e) {\r\n        // Note: Not redundant with notification in buyMoreSTD above; will not be reached if exception is thrown there\r\n        GameUI.notify.error(\"Could not contact payment server!\", 10000);\r\n        Payments.clearInterval();\r\n        return;\r\n      }\r\n      const { completed, failure } = await statusRes.json();\r\n\r\n      if (completed) {\r\n        Payments.windowReference?.close();\r\n        await ShopPurchaseData.syncSTD();\r\n        GameUI.notify.success(`Purchase of ${amount} STDs was successful, thank you for your support! ❤️`, 10000);\r\n        Payments.clearInterval();\r\n        player.IAP.checkoutSession = { id: false };\r\n        GameStorage.save();\r\n        Modal.hide();\r\n      }\r\n\r\n      if (failure) {\r\n        Payments.windowReference?.close();\r\n        Payments.clearInterval();\r\n        GameUI.notify.error(`Purchase failed!`, 10000);\r\n        player.IAP.checkoutSession = { id: false };\r\n        GameStorage.save();\r\n        return;\r\n      }\r\n\r\n      // 30 minutes of polling is the maximum\r\n      if (!completed && (Payments.windowReference?.closed || pollAmount >= 20 * 30)) {\r\n        await Payments.cancelPurchase(true);\r\n      }\r\n    }, 3000);\r\n  },\r\n\r\n  // Sends a request to purchase a STD upgrade, returning true if successful (and syncs data), false if not\r\n  async buyUpgrade(upgradeKey, cosmeticName) {\r\n    if (!Cloud.loggedIn) return false;\r\n    let res;\r\n    try {\r\n      res = await fetch(`${STD_BACKEND_URL}/upgrade`, {\r\n        method: \"POST\",\r\n        headers: {\r\n          \"Content-Type\": \"application/json\"\r\n        },\r\n        body: JSON.stringify({\r\n          user: Cloud.user.id,\r\n          upgrade: upgradeKey,\r\n          extraData: {\r\n            requestedSet: cosmeticName,\r\n            fullCompletions: player.records.fullGameCompletions\r\n          }\r\n        })\r\n      });\r\n    } catch (e) {\r\n      GameUI.notify.error(\"Unable to spend STD coins on upgrade!\", 10000);\r\n      return false;\r\n    }\r\n    const stdData = await res.json();\r\n    // The \"not enough STDs\" message should only show up if the player modifies costs on the frontend and forces the\r\n    // game to send a request despite not actually having enough STDs. The cost check is done again on the backend\r\n    if (stdData.success) GameUI.notify.info(`Successfully spent ${stdData.amountSpent} STD coins`, 10000);\r\n    else GameUI.notify.error(stdData.error ?? \"Unable to purchase upgrade\", 10000);\r\n    ShopPurchaseData.syncSTD(false, stdData.data);\r\n    return stdData.success;\r\n  },\r\n\r\n  // Explicitly cancels purchases if the player chooses to, they take too long to resolve, or the page is closed\r\n  async cancelPurchase(isTimeout) {\r\n    if (this.hasCanceled) return;\r\n    Payments.windowReference?.close();\r\n    Payments.clearInterval();\r\n    try {\r\n      await fetch(`${STD_BACKEND_URL}/expire`, {\r\n        method: \"POST\",\r\n        headers: {\r\n          \"Content-Type\": \"application/json\"\r\n        },\r\n        body: JSON.stringify({ sessionId: player.IAP.checkoutSession.id })\r\n      });\r\n    } catch (e) {\r\n      GameUI.notify.error(\"Could not contact payment server!\", 10000);\r\n    }\r\n    if (isTimeout) GameUI.notify.error(\"Purchase took too long to resolve!\", 10000);\r\n    player.IAP.checkoutSession = { id: false };\r\n    GameStorage.save();\r\n    this.hasCanceled = false;\r\n  },\r\n\r\n  // Removes the repeating checker and page-close listener for if payments have been resolved\r\n  clearInterval() {\r\n    clearInterval(Payments.interval);\r\n    window.onbeforeunload = null;\r\n  }\r\n};\r\n\r\nexport default Payments;\r\n"]},"metadata":{},"sourceType":"module"}