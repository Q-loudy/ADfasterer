{"ast":null,"code":"import \"core-js/modules/web.dom-collections.iterator.js\";\nimport { DC } from \"./constants\";\nimport { GameMechanicState } from \"./game-mechanics\";\nexport function updateNormalAndInfinityChallenges(diff) {\n  if (NormalChallenge(11).isRunning || InfinityChallenge(6).isRunning) {\n    if (AntimatterDimension(2).amount.neq(0)) {\n      Currency.matter.bumpTo(1); // These caps are values which occur at approximately e308 IP\n\n      const cappedBase = 1.03 + Math.clampMax(DimBoost.totalBoosts, 400) / 200 + Math.clampMax(player.galaxies, 100) / 100;\n      Currency.matter.multiply(Decimal.pow(cappedBase, diff / getGlobalSpeedFactor() / 20));\n    }\n\n    if (Currency.matter.gt(Currency.antimatter.value) && NormalChallenge(11).isRunning && !Player.canCrunch) {\n      const values = [Currency.antimatter.value, Currency.matter.value];\n      softReset(0, true, true);\n      Modal.message.show(`Your ${format(values[0], 2, 2)} antimatter was annihilated\n        by ${format(values[1], 2, 2)} matter.`, {\n        closeEvent: GAME_EVENT.BIG_CRUNCH_AFTER\n      }, 1);\n    }\n  }\n\n  if (NormalChallenge(3).isRunning) {\n    player.chall3Pow = player.chall3Pow.times(DC.D1_00038.pow(diff / 100)).clampMax(Decimal.NUMBER_MAX_VALUE);\n  }\n\n  if (NormalChallenge(2).isRunning) {\n    player.chall2Pow = Math.min(player.chall2Pow + diff / 100 / 1800, 1);\n  }\n\n  if (InfinityChallenge(2).isRunning) {\n    if (player.ic2Count >= 400) {\n      if (AntimatterDimension(8).amount.gt(0)) {\n        sacrificeReset();\n      }\n\n      player.ic2Count %= 400;\n    } else {\n      // Do not change to diff, as this may lead to a sacrifice softlock with high gamespeed\n      player.ic2Count += Math.clamp(Date.now() - player.lastUpdate, 1, 21600000);\n    }\n  }\n}\n\nclass NormalChallengeState extends GameMechanicState {\n  get isQuickResettable() {\n    return this.config.isQuickResettable;\n  }\n\n  get isRunning() {\n    const isPartOfIC1 = this.id !== 9 && this.id !== 12;\n    return player.challenge.normal.current === this.id || isPartOfIC1 && InfinityChallenge(1).isRunning;\n  }\n\n  get isOnlyActiveChallenge() {\n    return player.challenge.normal.current === this.id;\n  }\n\n  get isUnlocked() {\n    if (PlayerProgress.eternityUnlocked()) return true;\n    if (this.id === 0) return true;\n    const ip = GameDatabase.challenges.normal[this.id - 1].lockedAt;\n    return Currency.infinitiesTotal.gte(ip);\n  }\n\n  get isDisabled() {\n    return Pelle.isDoomed;\n  }\n\n  get lockedAt() {\n    return GameDatabase.challenges.normal[this.id].lockedAt;\n  }\n\n  requestStart() {\n    if (!Tab.challenges.isUnlocked) return;\n    if (GameEnd.creditsEverClosed) return;\n\n    if (!player.options.confirmations.challenges) {\n      this.start();\n      return;\n    }\n\n    Modal.startNormalChallenge.show(this.id);\n  }\n\n  start() {\n    if (this.id === 1 || this.isOnlyActiveChallenge) return;\n    if (!Tab.challenges.isUnlocked) return; // Forces big crunch reset but ensures IP gain, if any.\n\n    bigCrunchReset(true, true);\n    player.challenge.normal.current = this.id;\n    player.challenge.infinity.current = 0;\n\n    if (Enslaved.isRunning && EternityChallenge(6).isRunning && this.id === 10) {\n      EnslavedProgress.challengeCombo.giveProgress();\n      Enslaved.quotes.ec6C10.show();\n    }\n\n    if (!Enslaved.isRunning) Tab.dimensions.antimatter.show();\n  }\n\n  get isCompleted() {\n    return (player.challenge.normal.completedBits & 1 << this.id) !== 0;\n  }\n\n  complete() {\n    player.challenge.normal.completedBits |= 1 << this.id; // Since breaking infinity maxes even autobuyers that aren't unlocked,\n    // it's possible to get r52 or r53 from completing a challenge\n    // and thus unlocking an autobuyer.\n\n    Achievement(52).tryUnlock();\n    Achievement(53).tryUnlock(); // Completing a challenge unlocks an autobuyer even if not purchased with antimatter, but we still\n    // need to clear the notification because otherwise it sticks there forever. Any other methods of\n    // unlocking autobuyers (such as Existentially Prolong) should also go through this code path\n\n    TabNotification.newAutobuyer.clearTrigger();\n    GameCache.cheapestAntimatterAutobuyer.invalidate();\n  }\n\n  get goal() {\n    if (Enslaved.isRunning && Enslaved.BROKEN_CHALLENGES.includes(this.id)) {\n      return DC.E1E15;\n    }\n\n    return Decimal.NUMBER_MAX_VALUE;\n  }\n\n  updateChallengeTime() {\n    const bestTimes = player.challenge.normal.bestTimes;\n\n    if (bestTimes[this.id - 2] <= player.records.thisInfinity.time / getGlobalSpeedFactor()) {\n      return;\n    }\n\n    player.challenge.normal.bestTimes[this.id - 2] = player.records.thisInfinity.time / getGlobalSpeedFactor();\n    GameCache.challengeTimeSum.invalidate();\n    GameCache.worstChallengeTime.invalidate();\n  }\n\n  exit() {\n    player.challenge.normal.current = 0;\n    bigCrunchReset(true, false);\n    if (!Enslaved.isRunning) Tab.dimensions.antimatter.show();\n  }\n\n}\n/**\r\n * @param {number} id\r\n * @return {NormalChallengeState}\r\n */\n\n\nexport const NormalChallenge = NormalChallengeState.createAccessor(GameDatabase.challenges.normal);\n/**\r\n * @returns {NormalChallengeState}\r\n */\n\nObject.defineProperty(NormalChallenge, \"current\", {\n  get: () => player.challenge.normal.current > 0 ? NormalChallenge(player.challenge.normal.current) : undefined\n});\nObject.defineProperty(NormalChallenge, \"isRunning\", {\n  get: () => player.challenge.normal.current !== 0\n});\nexport const NormalChallenges = {\n  /**\r\n   * @type {NormalChallengeState[]}\r\n   */\n  all: NormalChallenge.index.compact(),\n\n  completeAll() {\n    for (const challenge of NormalChallenges.all) challenge.complete();\n  },\n\n  clearCompletions() {\n    player.challenge.normal.completedBits = 0;\n  }\n\n};","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/normal-challenges.js"],"names":["DC","GameMechanicState","updateNormalAndInfinityChallenges","diff","NormalChallenge","isRunning","InfinityChallenge","AntimatterDimension","amount","neq","Currency","matter","bumpTo","cappedBase","Math","clampMax","DimBoost","totalBoosts","player","galaxies","multiply","Decimal","pow","getGlobalSpeedFactor","gt","antimatter","value","Player","canCrunch","values","softReset","Modal","message","show","format","closeEvent","GAME_EVENT","BIG_CRUNCH_AFTER","chall3Pow","times","D1_00038","NUMBER_MAX_VALUE","chall2Pow","min","ic2Count","sacrificeReset","clamp","Date","now","lastUpdate","NormalChallengeState","isQuickResettable","config","isPartOfIC1","id","challenge","normal","current","isOnlyActiveChallenge","isUnlocked","PlayerProgress","eternityUnlocked","ip","GameDatabase","challenges","lockedAt","infinitiesTotal","gte","isDisabled","Pelle","isDoomed","requestStart","Tab","GameEnd","creditsEverClosed","options","confirmations","start","startNormalChallenge","bigCrunchReset","infinity","Enslaved","EternityChallenge","EnslavedProgress","challengeCombo","giveProgress","quotes","ec6C10","dimensions","isCompleted","completedBits","complete","Achievement","tryUnlock","TabNotification","newAutobuyer","clearTrigger","GameCache","cheapestAntimatterAutobuyer","invalidate","goal","BROKEN_CHALLENGES","includes","E1E15","updateChallengeTime","bestTimes","records","thisInfinity","time","challengeTimeSum","worstChallengeTime","exit","createAccessor","Object","defineProperty","get","undefined","NormalChallenges","all","index","compact","completeAll","clearCompletions"],"mappings":"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","sourcesContent":["import { DC } from \"./constants\";\r\nimport { GameMechanicState } from \"./game-mechanics\";\r\n\r\nexport function updateNormalAndInfinityChallenges(diff) {\r\n  if (NormalChallenge(11).isRunning || InfinityChallenge(6).isRunning) {\r\n    if (AntimatterDimension(2).amount.neq(0)) {\r\n      Currency.matter.bumpTo(1);\r\n      // These caps are values which occur at approximately e308 IP\r\n      const cappedBase = 1.03 + Math.clampMax(DimBoost.totalBoosts, 400) / 200 +\r\n        Math.clampMax(player.galaxies, 100) / 100;\r\n      Currency.matter.multiply(Decimal.pow(cappedBase, diff / getGlobalSpeedFactor() / 20));\r\n    }\r\n    if (Currency.matter.gt(Currency.antimatter.value) && NormalChallenge(11).isRunning && !Player.canCrunch) {\r\n      const values = [Currency.antimatter.value, Currency.matter.value];\r\n      softReset(0, true, true);\r\n      Modal.message.show(`Your ${format(values[0], 2, 2)} antimatter was annihilated\r\n        by ${format(values[1], 2, 2)} matter.`, { closeEvent: GAME_EVENT.BIG_CRUNCH_AFTER }, 1);\r\n    }\r\n  }\r\n\r\n  if (NormalChallenge(3).isRunning) {\r\n    player.chall3Pow = player.chall3Pow.times(DC.D1_00038.pow(diff / 100)).clampMax(Decimal.NUMBER_MAX_VALUE);\r\n  }\r\n\r\n  if (NormalChallenge(2).isRunning) {\r\n    player.chall2Pow = Math.min(player.chall2Pow + diff / 100 / 1800, 1);\r\n  }\r\n\r\n  if (InfinityChallenge(2).isRunning) {\r\n    if (player.ic2Count >= 400) {\r\n      if (AntimatterDimension(8).amount.gt(0)) {\r\n        sacrificeReset();\r\n      }\r\n      player.ic2Count %= 400;\r\n    } else {\r\n      // Do not change to diff, as this may lead to a sacrifice softlock with high gamespeed\r\n      player.ic2Count += Math.clamp(Date.now() - player.lastUpdate, 1, 21600000);\r\n    }\r\n  }\r\n}\r\n\r\nclass NormalChallengeState extends GameMechanicState {\r\n  get isQuickResettable() {\r\n    return this.config.isQuickResettable;\r\n  }\r\n\r\n  get isRunning() {\r\n    const isPartOfIC1 = this.id !== 9 && this.id !== 12;\r\n    return player.challenge.normal.current === this.id || (isPartOfIC1 && InfinityChallenge(1).isRunning);\r\n  }\r\n\r\n  get isOnlyActiveChallenge() {\r\n    return player.challenge.normal.current === this.id;\r\n  }\r\n\r\n  get isUnlocked() {\r\n    if (PlayerProgress.eternityUnlocked()) return true;\r\n    if (this.id === 0) return true;\r\n    const ip = GameDatabase.challenges.normal[this.id - 1].lockedAt;\r\n    return Currency.infinitiesTotal.gte(ip);\r\n  }\r\n\r\n  get isDisabled() {\r\n    return Pelle.isDoomed;\r\n  }\r\n\r\n  get lockedAt() {\r\n    return GameDatabase.challenges.normal[this.id].lockedAt;\r\n  }\r\n\r\n  requestStart() {\r\n    if (!Tab.challenges.isUnlocked) return;\r\n    if (GameEnd.creditsEverClosed) return;\r\n    if (!player.options.confirmations.challenges) {\r\n      this.start();\r\n      return;\r\n    }\r\n    Modal.startNormalChallenge.show(this.id);\r\n  }\r\n\r\n  start() {\r\n    if (this.id === 1 || this.isOnlyActiveChallenge) return;\r\n    if (!Tab.challenges.isUnlocked) return;\r\n    // Forces big crunch reset but ensures IP gain, if any.\r\n    bigCrunchReset(true, true);\r\n    player.challenge.normal.current = this.id;\r\n    player.challenge.infinity.current = 0;\r\n    if (Enslaved.isRunning && EternityChallenge(6).isRunning && this.id === 10) {\r\n      EnslavedProgress.challengeCombo.giveProgress();\r\n      Enslaved.quotes.ec6C10.show();\r\n    }\r\n    if (!Enslaved.isRunning) Tab.dimensions.antimatter.show();\r\n  }\r\n\r\n  get isCompleted() {\r\n    return (player.challenge.normal.completedBits & (1 << this.id)) !== 0;\r\n  }\r\n\r\n  complete() {\r\n    player.challenge.normal.completedBits |= 1 << this.id;\r\n    // Since breaking infinity maxes even autobuyers that aren't unlocked,\r\n    // it's possible to get r52 or r53 from completing a challenge\r\n    // and thus unlocking an autobuyer.\r\n    Achievement(52).tryUnlock();\r\n    Achievement(53).tryUnlock();\r\n\r\n    // Completing a challenge unlocks an autobuyer even if not purchased with antimatter, but we still\r\n    // need to clear the notification because otherwise it sticks there forever. Any other methods of\r\n    // unlocking autobuyers (such as Existentially Prolong) should also go through this code path\r\n    TabNotification.newAutobuyer.clearTrigger();\r\n    GameCache.cheapestAntimatterAutobuyer.invalidate();\r\n  }\r\n\r\n  get goal() {\r\n    if (Enslaved.isRunning && Enslaved.BROKEN_CHALLENGES.includes(this.id)) {\r\n      return DC.E1E15;\r\n    }\r\n    return Decimal.NUMBER_MAX_VALUE;\r\n  }\r\n\r\n  updateChallengeTime() {\r\n    const bestTimes = player.challenge.normal.bestTimes;\r\n    if (bestTimes[this.id - 2] <= player.records.thisInfinity.time / getGlobalSpeedFactor()) {\r\n      return;\r\n    }\r\n    player.challenge.normal.bestTimes[this.id - 2] = player.records.thisInfinity.time / getGlobalSpeedFactor();\r\n    GameCache.challengeTimeSum.invalidate();\r\n    GameCache.worstChallengeTime.invalidate();\r\n  }\r\n\r\n  exit() {\r\n    player.challenge.normal.current = 0;\r\n    bigCrunchReset(true, false);\r\n    if (!Enslaved.isRunning) Tab.dimensions.antimatter.show();\r\n  }\r\n}\r\n\r\n/**\r\n * @param {number} id\r\n * @return {NormalChallengeState}\r\n */\r\nexport const NormalChallenge = NormalChallengeState.createAccessor(GameDatabase.challenges.normal);\r\n\r\n/**\r\n * @returns {NormalChallengeState}\r\n */\r\nObject.defineProperty(NormalChallenge, \"current\", {\r\n  get: () => (player.challenge.normal.current > 0\r\n    ? NormalChallenge(player.challenge.normal.current)\r\n    : undefined),\r\n});\r\n\r\nObject.defineProperty(NormalChallenge, \"isRunning\", {\r\n  get: () => player.challenge.normal.current !== 0,\r\n});\r\n\r\nexport const NormalChallenges = {\r\n  /**\r\n   * @type {NormalChallengeState[]}\r\n   */\r\n  all: NormalChallenge.index.compact(),\r\n  completeAll() {\r\n    for (const challenge of NormalChallenges.all) challenge.complete();\r\n  },\r\n  clearCompletions() {\r\n    player.challenge.normal.completedBits = 0;\r\n  }\r\n};\r\n"]},"metadata":{},"sourceType":"module"}