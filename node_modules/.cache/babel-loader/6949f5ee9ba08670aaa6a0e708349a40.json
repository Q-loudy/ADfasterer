{"ast":null,"code":"import \"core-js/modules/web.dom-collections.iterator.js\";\nexport const GameIntervals = function () {\n  const interval = (handler, timeout) => {\n    let id = -1;\n    return {\n      start() {\n        // This starts the interval if it isn't already started,\n        // and throws an error if it is.\n        if (this.isStarted) {\n          throw new Error(\"An already started interval cannot be started again.\");\n        } else {\n          id = setInterval(handler, typeof timeout === \"function\" ? timeout() : timeout);\n        }\n      },\n\n      get isStarted() {\n        return id !== -1;\n      },\n\n      stop() {\n        // This stops the interval if it isn't already stopped,\n        // and does nothing if it is already stopped.\n        clearInterval(id);\n        id = -1;\n      },\n\n      restart() {\n        this.stop();\n        this.start();\n      }\n\n    };\n  };\n\n  return {\n    // Not a getter because getter will cause stack overflow\n    all() {\n      return Object.values(GameIntervals).filter(i => Object.prototype.hasOwnProperty.call(i, \"start\") && Object.prototype.hasOwnProperty.call(i, \"stop\"));\n    },\n\n    start() {\n      // eslint-disable-next-line no-shadow\n      for (const interval of this.all()) {\n        interval.start();\n      }\n    },\n\n    stop() {\n      // eslint-disable-next-line no-shadow\n      for (const interval of this.all()) {\n        interval.stop();\n      }\n    },\n\n    restart() {\n      // eslint-disable-next-line no-shadow\n      for (const interval of this.all()) {\n        interval.restart();\n      }\n    },\n\n    gameLoop: interval(() => gameLoop(), () => player.options.updateRate),\n    save: interval(() => GameStorage.save(), () => player.options.autosaveInterval - Math.clampMin(0, Date.now() - GameStorage.lastSaveTime)),\n    checkCloudSave: interval(() => {\n      if (player.options.cloudEnabled && Cloud.loggedIn) Cloud.saveCheck();\n    }, 600 * 1000),\n    // This simplifies auto-backup code to check every second instead of dynamically stopping and\n    // restarting the interval every save operation, and is how it's structured on Android as well\n    checkEverySecond: interval(() => {\n      if (Math.random() < 0.00001) SecretAchievement(18).unlock();\n      GameStorage.tryOnlineBackups();\n    }, 1000),\n    checkForUpdates: interval(() => {\n      if (isLocalEnvironment()) return;\n      fetch(\"version.txt\").then(response => response.json()).then(json => {\n        if (json.version > player.version) {\n          Modal.message.show(json.message, {\n            callback: updateRefresh\n          }, 3);\n        }\n      });\n    }, 60000)\n  };\n}();","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/intervals.js"],"names":["GameIntervals","interval","handler","timeout","id","start","isStarted","Error","setInterval","stop","clearInterval","restart","all","Object","values","filter","i","prototype","hasOwnProperty","call","gameLoop","player","options","updateRate","save","GameStorage","autosaveInterval","Math","clampMin","Date","now","lastSaveTime","checkCloudSave","cloudEnabled","Cloud","loggedIn","saveCheck","checkEverySecond","random","SecretAchievement","unlock","tryOnlineBackups","checkForUpdates","isLocalEnvironment","fetch","then","response","json","version","Modal","message","show","callback","updateRefresh"],"mappings":"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","sourcesContent":["export const GameIntervals = (function() {\r\n  const interval = (handler, timeout) => {\r\n    let id = -1;\r\n    return {\r\n      start() {\r\n        // This starts the interval if it isn't already started,\r\n        // and throws an error if it is.\r\n        if (this.isStarted) {\r\n          throw new Error(\"An already started interval cannot be started again.\");\r\n        } else {\r\n          id = setInterval(handler, typeof timeout === \"function\" ? timeout() : timeout);\r\n        }\r\n      },\r\n      get isStarted() {\r\n        return id !== -1;\r\n      },\r\n      stop() {\r\n        // This stops the interval if it isn't already stopped,\r\n        // and does nothing if it is already stopped.\r\n        clearInterval(id);\r\n        id = -1;\r\n      },\r\n      restart() {\r\n        this.stop();\r\n        this.start();\r\n      }\r\n    };\r\n  };\r\n  return {\r\n    // Not a getter because getter will cause stack overflow\r\n    all() {\r\n      return Object.values(GameIntervals)\r\n        .filter(i =>\r\n          Object.prototype.hasOwnProperty.call(i, \"start\") &&\r\n          Object.prototype.hasOwnProperty.call(i, \"stop\")\r\n        );\r\n    },\r\n    start() {\r\n      // eslint-disable-next-line no-shadow\r\n      for (const interval of this.all()) {\r\n        interval.start();\r\n      }\r\n    },\r\n    stop() {\r\n      // eslint-disable-next-line no-shadow\r\n      for (const interval of this.all()) {\r\n        interval.stop();\r\n      }\r\n    },\r\n    restart() {\r\n      // eslint-disable-next-line no-shadow\r\n      for (const interval of this.all()) {\r\n        interval.restart();\r\n      }\r\n    },\r\n    gameLoop: interval(() => gameLoop(), () => player.options.updateRate),\r\n    save: interval(() => GameStorage.save(), () =>\r\n      player.options.autosaveInterval - Math.clampMin(0, Date.now() - GameStorage.lastSaveTime)\r\n    ),\r\n    checkCloudSave: interval(() => {\r\n      if (player.options.cloudEnabled && Cloud.loggedIn) Cloud.saveCheck();\r\n    }, 600 * 1000),\r\n    // This simplifies auto-backup code to check every second instead of dynamically stopping and\r\n    // restarting the interval every save operation, and is how it's structured on Android as well\r\n    checkEverySecond: interval(() => {\r\n      if (Math.random() < 0.00001) SecretAchievement(18).unlock();\r\n      GameStorage.tryOnlineBackups();\r\n    }, 1000),\r\n    checkForUpdates: interval(() => {\r\n      if (isLocalEnvironment()) return;\r\n      fetch(\"version.txt\")\r\n        .then(response => response.json())\r\n        .then(json => {\r\n          if (json.version > player.version) {\r\n            Modal.message.show(json.message, { callback: updateRefresh }, 3);\r\n          }\r\n        });\r\n    }, 60000)\r\n  };\r\n}());\r\n"]},"metadata":{},"sourceType":"module"}