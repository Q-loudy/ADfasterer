{"ast":null,"code":"import \"core-js/modules/web.dom-collections.iterator.js\";\nimport { BitPurchasableMechanicState, RebuyableMechanicState } from \"./game-mechanics\";\nimport { DC } from \"./constants\";\n\nclass ImaginaryUpgradeState extends BitPurchasableMechanicState {\n  constructor(config) {\n    super(config);\n    this.registerEvents(config.checkEvent, () => this.tryUnlock());\n  }\n\n  get name() {\n    return this.config.name;\n  }\n\n  get requirement() {\n    return typeof this.config.requirement === \"function\" ? this.config.requirement() : this.config.requirement;\n  }\n\n  get lockEvent() {\n    return typeof this.config.lockEvent === \"function\" ? this.config.lockEvent() : this.config.lockEvent;\n  }\n\n  get currency() {\n    return Currency.imaginaryMachines;\n  }\n\n  get bitIndex() {\n    return this.id;\n  }\n\n  get bits() {\n    return player.reality.imaginaryUpgradeBits;\n  }\n\n  set bits(value) {\n    player.reality.imaginaryUpgradeBits = value;\n  }\n\n  get hasPlayerLock() {\n    return (player.reality.reqLock.imaginary & 1 << this.bitIndex) !== 0;\n  }\n\n  set hasPlayerLock(value) {\n    if (value) player.reality.reqLock.imaginary |= 1 << this.bitIndex;else player.reality.reqLock.imaginary &= ~(1 << this.bitIndex);\n  }\n\n  get isLockingMechanics() {\n    return this.hasPlayerLock && this.isPossible && !this.isAvailableForPurchase;\n  } // Required to be changed this way to avoid direct prop mutation in Vue components\n\n\n  setMechanicLock(value) {\n    this.hasPlayerLock = value;\n  }\n\n  toggleMechanicLock() {\n    this.hasPlayerLock = !this.hasPlayerLock;\n  } // Note we don't actually show the modal if we already failed or unlocked it\n\n\n  tryShowWarningModal(specialLockText) {\n    if (this.isPossible && !this.isAvailableForPurchase) {\n      Modal.upgradeLock.show({\n        upgrade: this,\n        isImaginary: true,\n        specialLockText\n      });\n    }\n  }\n\n  get isAvailableForPurchase() {\n    return (player.reality.imaginaryUpgReqs & 1 << this.id) !== 0;\n  }\n\n  get isPossible() {\n    return this.config.hasFailed ? !this.config.hasFailed() : true;\n  }\n\n  get canBeApplied() {\n    return super.canBeApplied && !this.pelleDisabled;\n  }\n\n  get pelleDisabled() {\n    return Pelle.isDoomed && this.config.isDisabledInDoomed;\n  }\n\n  tryUnlock() {\n    if (!MachineHandler.isIMUnlocked || this.isAvailableForPurchase || !this.config.checkRequirement()) return;\n    player.reality.imaginaryUpgReqs |= 1 << this.id;\n    GameUI.notify.reality(`You've unlocked an Imaginary Upgrade: ${this.config.name}`);\n    this.hasPlayerLock = false;\n  }\n\n  onPurchased() {\n    EventHub.dispatch(GAME_EVENT.REALITY_UPGRADE_BOUGHT);\n\n    if (this.id >= 15 && this.id <= 18) {\n      DarkMatterDimension(this.id - 14).amount = DC.D1;\n      if (this.id === 17) Laitela.quotes.thirdDMD.show();\n    }\n\n    if (this.id >= 15 && this.id <= 19) {\n      // Need to clear before retriggering, or else it won't actually show up on subsequent upgrades\n      TabNotification.laitelaUnlock.clearTrigger();\n      TabNotification.laitelaUnlock.tryTrigger();\n    }\n\n    if (this.id === 21) {\n      Laitela.quotes.finalRowIM.show();\n    }\n\n    if (this.id === 22) {\n      for (const key of Object.keys(player.reality.glyphs.sac)) {\n        player.reality.glyphs.sac[key] = ImaginaryUpgrade(22).effectValue;\n      }\n    }\n\n    if (this.id === 25) {\n      TabNotification.pelleUnlock.tryTrigger();\n    }\n  }\n\n}\n\nclass RebuyableImaginaryUpgradeState extends RebuyableMechanicState {\n  get currency() {\n    return Currency.imaginaryMachines;\n  }\n\n  get boughtAmount() {\n    return player.reality.imaginaryRebuyables[this.id];\n  }\n\n  get canBeApplied() {\n    return super.canBeApplied && !this.pelleDisabled;\n  }\n\n  get pelleDisabled() {\n    return Pelle.isDoomed;\n  }\n\n  set boughtAmount(value) {\n    player.reality.imaginaryRebuyables[this.id] = value;\n  }\n\n  onPurchased() {\n    if (this.id === 7) {\n      GameCache.staticGlyphWeights.invalidate();\n    }\n  }\n\n}\n\nImaginaryUpgradeState.index = mapGameData(GameDatabase.reality.imaginaryUpgrades, config => config.id <= 10 ? new RebuyableImaginaryUpgradeState(config) : new ImaginaryUpgradeState(config));\nexport const ImaginaryUpgrade = id => ImaginaryUpgradeState.index[id];\nexport const ImaginaryUpgrades = {\n  all: ImaginaryUpgradeState.index.compact(),\n\n  get totalRebuyables() {\n    const rebuyables = player.reality.imaginaryRebuyables;\n    let total = 0;\n\n    for (const i in rebuyables) total += rebuyables[i];\n\n    return total;\n  },\n\n  get totalSinglePurchase() {\n    return this.all.countWhere(u => u.isBought);\n  },\n\n  get allBought() {\n    return (player.reality.imaginaryUpgradeBits >> 6) + 1 === 1 << GameDatabase.reality.imaginaryUpgrades.length - 5;\n  }\n\n};","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/imaginary-upgrades.js"],"names":["BitPurchasableMechanicState","RebuyableMechanicState","DC","ImaginaryUpgradeState","constructor","config","registerEvents","checkEvent","tryUnlock","name","requirement","lockEvent","currency","Currency","imaginaryMachines","bitIndex","id","bits","player","reality","imaginaryUpgradeBits","value","hasPlayerLock","reqLock","imaginary","isLockingMechanics","isPossible","isAvailableForPurchase","setMechanicLock","toggleMechanicLock","tryShowWarningModal","specialLockText","Modal","upgradeLock","show","upgrade","isImaginary","imaginaryUpgReqs","hasFailed","canBeApplied","pelleDisabled","Pelle","isDoomed","isDisabledInDoomed","MachineHandler","isIMUnlocked","checkRequirement","GameUI","notify","onPurchased","EventHub","dispatch","GAME_EVENT","REALITY_UPGRADE_BOUGHT","DarkMatterDimension","amount","D1","Laitela","quotes","thirdDMD","TabNotification","laitelaUnlock","clearTrigger","tryTrigger","finalRowIM","key","Object","keys","glyphs","sac","ImaginaryUpgrade","effectValue","pelleUnlock","RebuyableImaginaryUpgradeState","boughtAmount","imaginaryRebuyables","GameCache","staticGlyphWeights","invalidate","index","mapGameData","GameDatabase","imaginaryUpgrades","ImaginaryUpgrades","all","compact","totalRebuyables","rebuyables","total","i","totalSinglePurchase","countWhere","u","isBought","allBought","length"],"mappings":"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","sourcesContent":["import { BitPurchasableMechanicState, RebuyableMechanicState } from \"./game-mechanics\";\r\nimport { DC } from \"./constants\";\r\n\r\nclass ImaginaryUpgradeState extends BitPurchasableMechanicState {\r\n  constructor(config) {\r\n    super(config);\r\n    this.registerEvents(config.checkEvent, () => this.tryUnlock());\r\n  }\r\n\r\n  get name() {\r\n    return this.config.name;\r\n  }\r\n\r\n  get requirement() {\r\n    return typeof this.config.requirement === \"function\" ? this.config.requirement() : this.config.requirement;\r\n  }\r\n\r\n  get lockEvent() {\r\n    return typeof this.config.lockEvent === \"function\" ? this.config.lockEvent() : this.config.lockEvent;\r\n  }\r\n\r\n  get currency() {\r\n    return Currency.imaginaryMachines;\r\n  }\r\n\r\n  get bitIndex() {\r\n    return this.id;\r\n  }\r\n\r\n  get bits() {\r\n    return player.reality.imaginaryUpgradeBits;\r\n  }\r\n\r\n  set bits(value) {\r\n    player.reality.imaginaryUpgradeBits = value;\r\n  }\r\n\r\n  get hasPlayerLock() {\r\n    return (player.reality.reqLock.imaginary & (1 << this.bitIndex)) !== 0;\r\n  }\r\n\r\n  set hasPlayerLock(value) {\r\n    if (value) player.reality.reqLock.imaginary |= 1 << this.bitIndex;\r\n    else player.reality.reqLock.imaginary &= ~(1 << this.bitIndex);\r\n  }\r\n\r\n  get isLockingMechanics() {\r\n    return this.hasPlayerLock && this.isPossible && !this.isAvailableForPurchase;\r\n  }\r\n\r\n  // Required to be changed this way to avoid direct prop mutation in Vue components\r\n  setMechanicLock(value) {\r\n    this.hasPlayerLock = value;\r\n  }\r\n\r\n  toggleMechanicLock() {\r\n    this.hasPlayerLock = !this.hasPlayerLock;\r\n  }\r\n\r\n  // Note we don't actually show the modal if we already failed or unlocked it\r\n  tryShowWarningModal(specialLockText) {\r\n    if (this.isPossible && !this.isAvailableForPurchase) {\r\n      Modal.upgradeLock.show({ upgrade: this, isImaginary: true, specialLockText });\r\n    }\r\n  }\r\n\r\n  get isAvailableForPurchase() {\r\n    return (player.reality.imaginaryUpgReqs & (1 << this.id)) !== 0;\r\n  }\r\n\r\n  get isPossible() {\r\n    return this.config.hasFailed ? !this.config.hasFailed() : true;\r\n  }\r\n\r\n  get canBeApplied() {\r\n    return super.canBeApplied && !this.pelleDisabled;\r\n  }\r\n\r\n  get pelleDisabled() {\r\n    return Pelle.isDoomed && this.config.isDisabledInDoomed;\r\n  }\r\n\r\n  tryUnlock() {\r\n    if (!MachineHandler.isIMUnlocked || this.isAvailableForPurchase || !this.config.checkRequirement()) return;\r\n    player.reality.imaginaryUpgReqs |= (1 << this.id);\r\n    GameUI.notify.reality(`You've unlocked an Imaginary Upgrade: ${this.config.name}`);\r\n    this.hasPlayerLock = false;\r\n  }\r\n\r\n  onPurchased() {\r\n    EventHub.dispatch(GAME_EVENT.REALITY_UPGRADE_BOUGHT);\r\n    if (this.id >= 15 && this.id <= 18) {\r\n      DarkMatterDimension(this.id - 14).amount = DC.D1;\r\n      if (this.id === 17) Laitela.quotes.thirdDMD.show();\r\n    }\r\n    if (this.id >= 15 && this.id <= 19) {\r\n      // Need to clear before retriggering, or else it won't actually show up on subsequent upgrades\r\n      TabNotification.laitelaUnlock.clearTrigger();\r\n      TabNotification.laitelaUnlock.tryTrigger();\r\n    }\r\n    if (this.id === 21) {\r\n      Laitela.quotes.finalRowIM.show();\r\n    }\r\n    if (this.id === 22) {\r\n      for (const key of Object.keys(player.reality.glyphs.sac)) {\r\n        player.reality.glyphs.sac[key] = ImaginaryUpgrade(22).effectValue;\r\n      }\r\n    }\r\n    if (this.id === 25) {\r\n      TabNotification.pelleUnlock.tryTrigger();\r\n    }\r\n  }\r\n}\r\n\r\nclass RebuyableImaginaryUpgradeState extends RebuyableMechanicState {\r\n  get currency() {\r\n    return Currency.imaginaryMachines;\r\n  }\r\n\r\n  get boughtAmount() {\r\n    return player.reality.imaginaryRebuyables[this.id];\r\n  }\r\n\r\n  get canBeApplied() {\r\n    return super.canBeApplied && !this.pelleDisabled;\r\n  }\r\n\r\n  get pelleDisabled() {\r\n    return Pelle.isDoomed;\r\n  }\r\n\r\n  set boughtAmount(value) {\r\n    player.reality.imaginaryRebuyables[this.id] = value;\r\n  }\r\n\r\n  onPurchased() {\r\n    if (this.id === 7) {\r\n      GameCache.staticGlyphWeights.invalidate();\r\n    }\r\n  }\r\n}\r\n\r\nImaginaryUpgradeState.index = mapGameData(\r\n  GameDatabase.reality.imaginaryUpgrades,\r\n  config => (config.id <= 10\r\n    ? new RebuyableImaginaryUpgradeState(config)\r\n    : new ImaginaryUpgradeState(config))\r\n);\r\n\r\nexport const ImaginaryUpgrade = id => ImaginaryUpgradeState.index[id];\r\n\r\nexport const ImaginaryUpgrades = {\r\n  all: ImaginaryUpgradeState.index.compact(),\r\n  get totalRebuyables() {\r\n    const rebuyables = player.reality.imaginaryRebuyables;\r\n    let total = 0;\r\n    for (const i in rebuyables) total += rebuyables[i];\r\n    return total;\r\n  },\r\n  get totalSinglePurchase() {\r\n    return this.all.countWhere(u => u.isBought);\r\n  },\r\n  get allBought() {\r\n    return (player.reality.imaginaryUpgradeBits >> 6) + 1 === 1 << (GameDatabase.reality.imaginaryUpgrades.length - 5);\r\n  }\r\n};\r\n"]},"metadata":{},"sourceType":"module"}