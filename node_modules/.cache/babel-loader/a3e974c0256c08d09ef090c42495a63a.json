{"ast":null,"code":"import \"core-js/modules/web.dom-collections.iterator.js\";\nimport ModalWrapper from \"@/components/modals/ModalWrapper\";\nimport PrimaryButton from \"@/components/PrimaryButton\";\nexport default {\n  name: \"EnslavedHintsModal\",\n  components: {\n    ModalWrapper,\n    PrimaryButton\n  },\n\n  data() {\n    return {\n      currentStored: 0,\n      nextHintCost: 0,\n      canGetHint: false,\n      shownEntries: [],\n      realityHintsLeft: 0,\n      glyphHintsLeft: 0,\n      hints: 0\n    };\n  },\n\n  computed: {\n    hintCost() {\n      return `${quantify(\"year\", TimeSpan.fromMilliseconds(this.nextHintCost).totalYears, 2)}`;\n    },\n\n    formattedStored() {\n      return `${quantify(\"year\", TimeSpan.fromMilliseconds(this.currentStored).totalYears, 2)}`;\n    },\n\n    hasProgress(id) {\n      return this.progressEntries.some(entry => entry.id === id);\n    },\n\n    // Note: This calculation seems to behave extremely poorly if the goal has been raised more than 12 hints worth\n    // of cost bumps and I'm not entirely sure why. There's probably a numerical issue I can't quite figure out, but\n    // considering that much cost raising can't happen in practice I think I'm just going to leave it be.\n    timeEstimate() {\n      if (this.currentStored >= this.nextHintCost) return \"\"; // Relevant values are stored as milliseconds, so multiply the rate by 1000 to get to seconds\n\n      const storeRate = 1000 * (Enslaved.isStoringGameTime ? Enslaved.currentBlackHoleStoreAmountPerMs : getGameSpeedupFactor());\n      const alreadyWaited = this.currentStored / storeRate;\n      const decaylessTime = this.nextHintCost / storeRate; // Check if decay is irrelevant and don't do the hard calculations if so\n\n      const minCostEstimate = (TimeSpan.fromYears(1e40).totalMilliseconds - this.currentStored) / storeRate;\n\n      if (TimeSpan.fromSeconds(minCostEstimate).totalDays > this.hints) {\n        return `${TimeSpan.fromSeconds(minCostEstimate).toStringShort(true)}`;\n      } // Decay is 3x per day, but the math needs decay per second\n\n\n      const K = Math.pow(3, 1 / 86400);\n      const x = decaylessTime * Math.log(K) * Math.pow(K, alreadyWaited);\n      const timeToGoal = productLog(x) / Math.log(K) - alreadyWaited;\n      return `${TimeSpan.fromSeconds(timeToGoal).toStringShort(true)}`;\n    }\n\n  },\n  methods: {\n    update() {\n      this.currentStored = player.celestials.enslaved.stored;\n      this.nextHintCost = Enslaved.nextHintCost;\n      this.canGetHint = this.currentStored >= this.nextHintCost;\n      this.shownEntries = [];\n      this.realityHintsLeft = EnslavedProgress.all.length;\n\n      for (const prog of EnslavedProgress.all) {\n        if (prog.hasHint) {\n          this.shownEntries.push([false, prog]);\n          this.realityHintsLeft--;\n        }\n      }\n\n      const glyphHintCount = player.celestials.enslaved.glyphHintsGiven;\n\n      for (let hintNum = 0; hintNum < glyphHintCount; hintNum++) {\n        this.shownEntries.push([true, GameDatabase.celestials.enslaved.glyphHints[hintNum]]);\n      }\n\n      this.glyphHintsLeft = GameDatabase.celestials.enslaved.glyphHints.length - glyphHintCount;\n      this.hints = Enslaved.hintCostIncreases;\n    },\n\n    giveRealityHint(available) {\n      if (available <= 0 || !Enslaved.spendTimeForHint()) return;\n      EnslavedProgress.all.filter(prog => !prog.hasHint).randomElement().unlock();\n    },\n\n    giveGlyphHint(available) {\n      if (available <= 0 || !Enslaved.spendTimeForHint()) return;\n      player.celestials.enslaved.glyphHintsGiven++;\n    }\n\n  }\n};","map":{"version":3,"sources":["EnslavedHintsModal.vue"],"names":[],"mappings":"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","sourcesContent":["<script>\r\nimport ModalWrapper from \"@/components/modals/ModalWrapper\";\r\nimport PrimaryButton from \"@/components/PrimaryButton\";\r\n\r\nexport default {\r\n  name: \"EnslavedHintsModal\",\r\n  components: {\r\n    ModalWrapper,\r\n    PrimaryButton\r\n  },\r\n  data() {\r\n    return {\r\n      currentStored: 0,\r\n      nextHintCost: 0,\r\n      canGetHint: false,\r\n      shownEntries: [],\r\n      realityHintsLeft: 0,\r\n      glyphHintsLeft: 0,\r\n      hints: 0,\r\n    };\r\n  },\r\n  computed: {\r\n    hintCost() {\r\n      return `${quantify(\"year\", TimeSpan.fromMilliseconds(this.nextHintCost).totalYears, 2)}`;\r\n    },\r\n    formattedStored() {\r\n      return `${quantify(\"year\", TimeSpan.fromMilliseconds(this.currentStored).totalYears, 2)}`;\r\n    },\r\n    hasProgress(id) {\r\n      return this.progressEntries.some(entry => entry.id === id);\r\n    },\r\n    // Note: This calculation seems to behave extremely poorly if the goal has been raised more than 12 hints worth\r\n    // of cost bumps and I'm not entirely sure why. There's probably a numerical issue I can't quite figure out, but\r\n    // considering that much cost raising can't happen in practice I think I'm just going to leave it be.\r\n    timeEstimate() {\r\n      if (this.currentStored >= this.nextHintCost) return \"\";\r\n\r\n      // Relevant values are stored as milliseconds, so multiply the rate by 1000 to get to seconds\r\n      const storeRate = 1000 * (Enslaved.isStoringGameTime\r\n        ? Enslaved.currentBlackHoleStoreAmountPerMs\r\n        : getGameSpeedupFactor());\r\n      const alreadyWaited = this.currentStored / storeRate;\r\n      const decaylessTime = this.nextHintCost / storeRate;\r\n\r\n      // Check if decay is irrelevant and don't do the hard calculations if so\r\n      const minCostEstimate = (TimeSpan.fromYears(1e40).totalMilliseconds - this.currentStored) / storeRate;\r\n      if (TimeSpan.fromSeconds(minCostEstimate).totalDays > this.hints) {\r\n        return `${TimeSpan.fromSeconds(minCostEstimate).toStringShort(true)}`;\r\n      }\r\n\r\n      // Decay is 3x per day, but the math needs decay per second\r\n      const K = Math.pow(3, 1 / 86400);\r\n      const x = decaylessTime * Math.log(K) * Math.pow(K, alreadyWaited);\r\n      const timeToGoal = productLog(x) / Math.log(K) - alreadyWaited;\r\n      return `${TimeSpan.fromSeconds(timeToGoal).toStringShort(true)}`;\r\n    }\r\n  },\r\n  methods: {\r\n    update() {\r\n      this.currentStored = player.celestials.enslaved.stored;\r\n      this.nextHintCost = Enslaved.nextHintCost;\r\n      this.canGetHint = this.currentStored >= this.nextHintCost;\r\n      this.shownEntries = [];\r\n\r\n      this.realityHintsLeft = EnslavedProgress.all.length;\r\n      for (const prog of EnslavedProgress.all) {\r\n        if (prog.hasHint) {\r\n          this.shownEntries.push([false, prog]);\r\n          this.realityHintsLeft--;\r\n        }\r\n      }\r\n\r\n      const glyphHintCount = player.celestials.enslaved.glyphHintsGiven;\r\n      for (let hintNum = 0; hintNum < glyphHintCount; hintNum++) {\r\n        this.shownEntries.push([true, GameDatabase.celestials.enslaved.glyphHints[hintNum]]);\r\n      }\r\n      this.glyphHintsLeft = GameDatabase.celestials.enslaved.glyphHints.length - glyphHintCount;\r\n\r\n      this.hints = Enslaved.hintCostIncreases;\r\n    },\r\n    giveRealityHint(available) {\r\n      if (available <= 0 || !Enslaved.spendTimeForHint()) return;\r\n      EnslavedProgress.all.filter(prog => !prog.hasHint).randomElement().unlock();\r\n    },\r\n    giveGlyphHint(available) {\r\n      if (available <= 0 || !Enslaved.spendTimeForHint()) return;\r\n      player.celestials.enslaved.glyphHintsGiven++;\r\n    }\r\n  },\r\n\r\n};\r\n</script>\r\n\r\n<template>\r\n  <ModalWrapper>\r\n    <template #header>\r\n      Cracks in The Nameless Ones' Reality\r\n    </template>\r\n    <div class=\"c-enslaved-hint-modal c-modal--short\">\r\n      <div>\r\n        This Reality seems to be resisting your efforts to complete it. So far you have done the following:\r\n      </div>\r\n      <br>\r\n      <div\r\n        v-for=\"(entry, index) in shownEntries\"\r\n        :key=\"index\"\r\n      >\r\n        <div v-if=\"!entry[0]\">\r\n          <span v-if=\"entry[1].hasHint && !entry[1].hasProgress\">\r\n            <i class=\"c-icon-wrapper fas fa-question-circle\" />\r\n            <b>You have not figured out what this hint means yet.</b>\r\n          </span>\r\n          <span v-else>\r\n            <i class=\"c-icon-wrapper fa-solid fa-house-crack\" />\r\n            <b>You have exposed a crack in the Reality:</b>\r\n          </span>\r\n          <br>\r\n          - {{ entry[1].hintInfo }}\r\n          <br>\r\n          - {{ entry[1].hasProgress ? entry[1].completedInfo : \"?????\" }}\r\n        </div>\r\n        <div v-else>\r\n          <i class=\"fa-solid fa-shapes\" /> <b>Glyph hint:</b>\r\n          <br>\r\n          {{ entry[1] }}\r\n        </div>\r\n        <br>\r\n      </div>\r\n      <div v-if=\"realityHintsLeft + glyphHintsLeft > 0\">\r\n        You can spend some time looking for some more cracks in the Reality, but every hint you spend Stored Time on\r\n        will increase the Stored Time needed for the next by a factor of {{ formatInt(3) }}. This cost bump will\r\n        gradually go away over {{ formatInt(24) }} hours and figuring out what the hint means will immediately\r\n        divide the cost by {{ formatInt(2) }}. The cost can't be reduced below {{ format(1e40) }} years.\r\n        <br><br>\r\n        The next hint will cost {{ hintCost }} of Stored Time. You currently have {{ formattedStored }}.\r\n        <span v-if=\"currentStored < nextHintCost\">\r\n          You will reach this if you charge your Black Hole for {{ timeEstimate }}.\r\n        </span>\r\n        <br><br>\r\n        <PrimaryButton\r\n          :enabled=\"realityHintsLeft > 0 && canGetHint\"\r\n          class=\"l-enslaved-hint-button\"\r\n          @click=\"giveRealityHint(realityHintsLeft)\"\r\n        >\r\n          Get a hint about the Reality itself ({{ formatInt(realityHintsLeft) }} left)\r\n        </PrimaryButton>\r\n        <br>\r\n        <PrimaryButton\r\n          :enabled=\"glyphHintsLeft > 0 && canGetHint\"\r\n          class=\"l-enslaved-hint-button\"\r\n          @click=\"giveGlyphHint(glyphHintsLeft)\"\r\n        >\r\n          Get a hint on what Glyphs to use ({{ formatInt(glyphHintsLeft) }} left)\r\n        </PrimaryButton>\r\n      </div>\r\n      <div v-else>\r\n        <b>There are no more hints left!</b>\r\n      </div>\r\n    </div>\r\n  </ModalWrapper>\r\n</template>\r\n\r\n<style scoped>\r\n.c-icon-wrapper {\r\n  margin-right: 1rem;\r\n}\r\n\r\n.l-enslaved-hint-button {\r\n  margin: 0.4rem 0;\r\n}\r\n</style>\r\n"],"sourceRoot":"src/components/modals"},"metadata":{},"sourceType":"module"}