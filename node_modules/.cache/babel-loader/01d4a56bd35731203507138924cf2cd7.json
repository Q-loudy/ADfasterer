{"ast":null,"code":"import \"core-js/modules/es.string.trim.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport { GameDatabase } from \"./secret-formula/game-database\";\nimport { GameMechanicState } from \"./game-mechanics\";\nexport const Speedrun = {\n  officialFixedSeed: 69420,\n\n  unlock() {\n    if (player.speedrun.isUnlocked) return;\n    Modal.message.show(`You have unlocked Speedrun Mode! This allows you to start a new save file with some slight\n      changes which can be helpful if you're trying to complete the game as quickly as possible. The option to\n      start a Speedrun Save is now available in the Options tab, under Saving. Choosing to start a Speedrun Save\n      will provide you with another modal with more in-depth information.`, {}, 3);\n    player.speedrun.isUnlocked = true;\n  },\n\n  // Used to block the seed-changing modal from opening (other functions assume this is checked beforehand)\n  canModifySeed() {\n    return player.realities < 1;\n  },\n\n  modifySeed(key, seed) {\n    player.speedrun.seedSelection = key;\n    let newSeed;\n\n    switch (key) {\n      case SPEEDRUN_SEED_STATE.FIXED:\n        player.reality.initialSeed = this.officialFixedSeed;\n        player.speedrun.initialSeed = this.officialFixedSeed;\n        return;\n\n      case SPEEDRUN_SEED_STATE.RANDOM:\n        // This gives seeds of roughly the same magnitude that the first-run Date.now() would give\n        newSeed = Math.floor(1e13 * Math.random());\n        player.reality.initialSeed = newSeed;\n        player.speedrun.initialSeed = newSeed;\n        return;\n\n      case SPEEDRUN_SEED_STATE.PLAYER:\n        player.reality.initialSeed = seed;\n        player.speedrun.initialSeed = seed;\n        return;\n\n      default:\n        throw new Error(\"Unrecognized speedrun seed setting option\");\n    }\n  },\n\n  seedModeText(rec) {\n    const record = rec !== null && rec !== void 0 ? rec : player.speedrun;\n\n    switch (record.seedSelection) {\n      case SPEEDRUN_SEED_STATE.UNKNOWN:\n        return `No seed data (old save)`;\n\n      case SPEEDRUN_SEED_STATE.FIXED:\n        return `Official fixed seed (${record.initialSeed})`;\n\n      case SPEEDRUN_SEED_STATE.RANDOM:\n        return `Random seed (${record.initialSeed})`;\n\n      case SPEEDRUN_SEED_STATE.PLAYER:\n        return `Player seed (${record.initialSeed})`;\n\n      default:\n        throw new Error(\"Unrecognized speedrun seed option in seedModeText\");\n    }\n  },\n\n  // If a name isn't given, choose a somewhat-likely-to-be-unique big number instead\n  generateName(name) {\n    if (name.trim() === \"\") {\n      const id = Math.floor((1e7 - 1) * Math.random()) + 1;\n      return `AD Player #${\"0\".repeat(6 - Math.floor(Math.log10(id)))}${id}`;\n    }\n\n    if (name.length > 40) return `${name.slice(0, 37)}...`;\n    return name;\n  },\n\n  // Hard-resets the current save and puts it in a state ready to be \"unpaused\" once resources start being generated\n  prepareSave(name) {\n    // Carry all relevant post-completion variables over too\n    NG.restartWithCarryover();\n    player.speedrun.isUnlocked = true;\n    player.speedrun.isActive = true;\n    this.modifySeed(SPEEDRUN_SEED_STATE.FIXED);\n    player.speedrun.name = name; // We make a few assumptions on settings which are likely to be changed for all speedrunners\n\n    for (const key of Object.keys(player.options.confirmations)) player.options.confirmations[key] = false;\n\n    player.options.confirmations.glyphSelection = true;\n\n    for (const key of Object.keys(player.options.animations)) {\n      if (typeof player.options.animations[key] === \"boolean\") player.options.animations[key] = false;\n    } // A few achievements are given for free to mitigate weird strategies at the beginning of runs or unavoidable\n    // timewalls for particularly fast/optimized runs\n\n\n    Achievement(22).unlock();\n    Achievement(35).unlock();\n    Achievement(76).unlock(); // Some time elapses after the reset and before the UI is actually ready, which ends up getting \"counted\" as offline\n\n    player.speedrun.offlineTimeUsed = 0;\n    GameStorage.save();\n  },\n\n  // Speedruns are initially paused until startTimer is called, which happens as soon as the player purchases a AD or\n  // uses the Konami code. Until then, they're free to do whatever they want with the UI\n  startTimer() {\n    if (player.speedrun.hasStarted) return;\n    player.speedrun.hasStarted = true;\n    player.speedrun.startDate = Date.now();\n    player.lastUpdate = Date.now(); // This needs to be calculated \"live\" because using spentSTD includes any offline progress purchases too\n\n    let currentSpent = 0;\n\n    for (const purchase of ShopPurchase.all) {\n      if (purchase.config.instantPurchase) continue;\n      currentSpent += purchase.purchases * purchase.cost;\n    }\n\n    this.setSTDUse(ShopPurchaseData.isIAPEnabled && currentSpent > 0);\n  },\n\n  isPausedAtStart() {\n    return player.speedrun.isActive && !player.speedrun.hasStarted;\n  },\n\n  // This needs to be here due to JS applying \"function scope\" to the player object within importing in storage.js,\n  // which causes any direct changes done in storage.js to fall out of scope afterwards. We also don't want to change\n  // this state at the beginning in case people want to share identical single-segment saves before starting the timer.\n  setSegmented(state) {\n    if (this.isPausedAtStart()) return;\n    player.speedrun.isSegmented = state;\n  },\n\n  setSTDUse(state) {\n    if (this.isPausedAtStart() || ShopPurchaseData.spentSTD === 0) return;\n    player.speedrun.usedSTD = state;\n  },\n\n  mostRecentMilestone() {\n    const newestTime = player.speedrun.records.max();\n    if (newestTime === 0) return 0;\n    return player.speedrun.records.indexOf(newestTime);\n  }\n\n};\n\nclass SpeedrunMilestone extends GameMechanicState {\n  constructor(config) {\n    super(config);\n    this.registerEvents(config.checkEvent, args => this.tryComplete(args));\n  }\n\n  get name() {\n    return this.config.name;\n  }\n\n  get isReached() {\n    return player.speedrun.records[this.config.id] !== 0;\n  }\n\n  tryComplete(args) {\n    if (!this.config.checkRequirement(args)) return;\n    this.complete();\n  }\n\n  complete() {\n    if (this.isReached || !player.speedrun.isActive) return; // Rounding slightly reduces filesize by removing weird float rounding\n\n    player.speedrun.records[this.config.id] = Math.round(player.records.realTimePlayed);\n    GameUI.notify.success(`Speedrun Milestone Reached: ${this.name}`);\n  }\n\n}\n\nexport const SpeedrunMilestones = SpeedrunMilestone.createAccessor(GameDatabase.speedrunMilestones);","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/speedrun.js"],"names":["GameDatabase","GameMechanicState","Speedrun","officialFixedSeed","unlock","player","speedrun","isUnlocked","Modal","message","show","canModifySeed","realities","modifySeed","key","seed","seedSelection","newSeed","SPEEDRUN_SEED_STATE","FIXED","reality","initialSeed","RANDOM","Math","floor","random","PLAYER","Error","seedModeText","rec","record","UNKNOWN","generateName","name","trim","id","repeat","log10","length","slice","prepareSave","NG","restartWithCarryover","isActive","Object","keys","options","confirmations","glyphSelection","animations","Achievement","offlineTimeUsed","GameStorage","save","startTimer","hasStarted","startDate","Date","now","lastUpdate","currentSpent","purchase","ShopPurchase","all","config","instantPurchase","purchases","cost","setSTDUse","ShopPurchaseData","isIAPEnabled","isPausedAtStart","setSegmented","state","isSegmented","spentSTD","usedSTD","mostRecentMilestone","newestTime","records","max","indexOf","SpeedrunMilestone","constructor","registerEvents","checkEvent","args","tryComplete","isReached","checkRequirement","complete","round","realTimePlayed","GameUI","notify","success","SpeedrunMilestones","createAccessor","speedrunMilestones"],"mappings":"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","sourcesContent":["import { GameDatabase } from \"./secret-formula/game-database\";\r\nimport { GameMechanicState } from \"./game-mechanics\";\r\n\r\nexport const Speedrun = {\r\n  officialFixedSeed: 69420,\r\n  unlock() {\r\n    if (player.speedrun.isUnlocked) return;\r\n    Modal.message.show(`You have unlocked Speedrun Mode! This allows you to start a new save file with some slight\r\n      changes which can be helpful if you're trying to complete the game as quickly as possible. The option to\r\n      start a Speedrun Save is now available in the Options tab, under Saving. Choosing to start a Speedrun Save\r\n      will provide you with another modal with more in-depth information.`, {}, 3);\r\n    player.speedrun.isUnlocked = true;\r\n  },\r\n  // Used to block the seed-changing modal from opening (other functions assume this is checked beforehand)\r\n  canModifySeed() {\r\n    return player.realities < 1;\r\n  },\r\n  modifySeed(key, seed) {\r\n    player.speedrun.seedSelection = key;\r\n    let newSeed;\r\n    switch (key) {\r\n      case SPEEDRUN_SEED_STATE.FIXED:\r\n        player.reality.initialSeed = this.officialFixedSeed;\r\n        player.speedrun.initialSeed = this.officialFixedSeed;\r\n        return;\r\n      case SPEEDRUN_SEED_STATE.RANDOM:\r\n        // This gives seeds of roughly the same magnitude that the first-run Date.now() would give\r\n        newSeed = Math.floor(1e13 * Math.random());\r\n        player.reality.initialSeed = newSeed;\r\n        player.speedrun.initialSeed = newSeed;\r\n        return;\r\n      case SPEEDRUN_SEED_STATE.PLAYER:\r\n        player.reality.initialSeed = seed;\r\n        player.speedrun.initialSeed = seed;\r\n        return;\r\n      default:\r\n        throw new Error(\"Unrecognized speedrun seed setting option\");\r\n    }\r\n  },\r\n  seedModeText(rec) {\r\n    const record = rec ?? player.speedrun;\r\n    switch (record.seedSelection) {\r\n      case SPEEDRUN_SEED_STATE.UNKNOWN:\r\n        return `No seed data (old save)`;\r\n      case SPEEDRUN_SEED_STATE.FIXED:\r\n        return `Official fixed seed (${record.initialSeed})`;\r\n      case SPEEDRUN_SEED_STATE.RANDOM:\r\n        return `Random seed (${record.initialSeed})`;\r\n      case SPEEDRUN_SEED_STATE.PLAYER:\r\n        return `Player seed (${record.initialSeed})`;\r\n      default:\r\n        throw new Error(\"Unrecognized speedrun seed option in seedModeText\");\r\n    }\r\n  },\r\n  // If a name isn't given, choose a somewhat-likely-to-be-unique big number instead\r\n  generateName(name) {\r\n    if (name.trim() === \"\") {\r\n      const id = Math.floor((1e7 - 1) * Math.random()) + 1;\r\n      return `AD Player #${\"0\".repeat(6 - Math.floor(Math.log10(id)))}${id}`;\r\n    }\r\n    if (name.length > 40) return `${name.slice(0, 37)}...`;\r\n    return name;\r\n  },\r\n  // Hard-resets the current save and puts it in a state ready to be \"unpaused\" once resources start being generated\r\n  prepareSave(name) {\r\n    // Carry all relevant post-completion variables over too\r\n    NG.restartWithCarryover();\r\n\r\n    player.speedrun.isUnlocked = true;\r\n    player.speedrun.isActive = true;\r\n    this.modifySeed(SPEEDRUN_SEED_STATE.FIXED);\r\n    player.speedrun.name = name;\r\n\r\n    // We make a few assumptions on settings which are likely to be changed for all speedrunners\r\n    for (const key of Object.keys(player.options.confirmations)) player.options.confirmations[key] = false;\r\n    player.options.confirmations.glyphSelection = true;\r\n    for (const key of Object.keys(player.options.animations)) {\r\n      if (typeof player.options.animations[key] === \"boolean\") player.options.animations[key] = false;\r\n    }\r\n\r\n    // A few achievements are given for free to mitigate weird strategies at the beginning of runs or unavoidable\r\n    // timewalls for particularly fast/optimized runs\r\n    Achievement(22).unlock();\r\n    Achievement(35).unlock();\r\n    Achievement(76).unlock();\r\n\r\n    // Some time elapses after the reset and before the UI is actually ready, which ends up getting \"counted\" as offline\r\n    player.speedrun.offlineTimeUsed = 0;\r\n    GameStorage.save();\r\n  },\r\n  // Speedruns are initially paused until startTimer is called, which happens as soon as the player purchases a AD or\r\n  // uses the Konami code. Until then, they're free to do whatever they want with the UI\r\n  startTimer() {\r\n    if (player.speedrun.hasStarted) return;\r\n    player.speedrun.hasStarted = true;\r\n    player.speedrun.startDate = Date.now();\r\n    player.lastUpdate = Date.now();\r\n\r\n    // This needs to be calculated \"live\" because using spentSTD includes any offline progress purchases too\r\n    let currentSpent = 0;\r\n    for (const purchase of ShopPurchase.all) {\r\n      if (purchase.config.instantPurchase) continue;\r\n      currentSpent += purchase.purchases * purchase.cost;\r\n    }\r\n    this.setSTDUse(ShopPurchaseData.isIAPEnabled && currentSpent > 0);\r\n  },\r\n  isPausedAtStart() {\r\n    return player.speedrun.isActive && !player.speedrun.hasStarted;\r\n  },\r\n  // This needs to be here due to JS applying \"function scope\" to the player object within importing in storage.js,\r\n  // which causes any direct changes done in storage.js to fall out of scope afterwards. We also don't want to change\r\n  // this state at the beginning in case people want to share identical single-segment saves before starting the timer.\r\n  setSegmented(state) {\r\n    if (this.isPausedAtStart()) return;\r\n    player.speedrun.isSegmented = state;\r\n  },\r\n  setSTDUse(state) {\r\n    if (this.isPausedAtStart() || ShopPurchaseData.spentSTD === 0) return;\r\n    player.speedrun.usedSTD = state;\r\n  },\r\n  mostRecentMilestone() {\r\n    const newestTime = player.speedrun.records.max();\r\n    if (newestTime === 0) return 0;\r\n    return player.speedrun.records.indexOf(newestTime);\r\n  }\r\n};\r\n\r\nclass SpeedrunMilestone extends GameMechanicState {\r\n  constructor(config) {\r\n    super(config);\r\n    this.registerEvents(config.checkEvent, args => this.tryComplete(args));\r\n  }\r\n\r\n  get name() {\r\n    return this.config.name;\r\n  }\r\n\r\n  get isReached() {\r\n    return player.speedrun.records[this.config.id] !== 0;\r\n  }\r\n\r\n  tryComplete(args) {\r\n    if (!this.config.checkRequirement(args)) return;\r\n    this.complete();\r\n  }\r\n\r\n  complete() {\r\n    if (this.isReached || !player.speedrun.isActive) return;\r\n    // Rounding slightly reduces filesize by removing weird float rounding\r\n    player.speedrun.records[this.config.id] = Math.round(player.records.realTimePlayed);\r\n    GameUI.notify.success(`Speedrun Milestone Reached: ${this.name}`);\r\n  }\r\n}\r\n\r\nexport const SpeedrunMilestones = SpeedrunMilestone.createAccessor(GameDatabase.speedrunMilestones);\r\n"]},"metadata":{},"sourceType":"module"}