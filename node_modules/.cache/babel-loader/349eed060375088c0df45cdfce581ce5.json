{"ast":null,"code":"import \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.sort.js\";\nconst GLYPH_NAMES = {\n  companion: {\n    adjective: \"Huggable\",\n    noun: \"Companion\"\n  },\n  reality: {\n    adjective: \"Real\",\n    noun: \"Reality\"\n  },\n  music: {\n    adjective: {\n      high: \"Melodic\",\n      mid: \"Chordal\",\n      low: \"Tuned\"\n    },\n    // This noun is only used in the case of a single companion reskinned as music (resulting in \"Huggable Music\");\n    // otherwise the set's noun will always come from an actual glyph type instead of music\n    noun: \"Music\"\n  },\n  effarig: {\n    adjective: {\n      both: \"Meta\",\n      glyph: \"Stable\",\n      rm: \"Mechanical\",\n      none: \"Fragmented\"\n    },\n    noun: {\n      both: \"Effarig\",\n      glyph: \"Stability\",\n      rm: \"Mechanism\",\n      none: \"Fragmentation\"\n    }\n  },\n  cursed: {\n    adjective: {\n      high: \"Cursed\",\n      mid: \"Hexed\",\n      low: \"Jinxed\"\n    },\n    noun: \"Curse\"\n  },\n  power: {\n    adjective: {\n      high: \"Powerful\",\n      mid: \"Mastered\",\n      low: \"Potential\"\n    },\n    noun: \"Power\"\n  },\n  infinity: {\n    adjective: {\n      high: \"Infinite\",\n      mid: \"Boundless\",\n      low: \"Immense\"\n    },\n    noun: \"Infinity\"\n  },\n  replication: {\n    adjective: {\n      high: \"Replicated\",\n      mid: \"Simulated\",\n      low: \"Duplicated\"\n    },\n    noun: \"Replication\"\n  },\n  time: {\n    adjective: {\n      high: \"Temporal\",\n      mid: \"Chronal\",\n      low: \"Transient\"\n    },\n    noun: \"Time\"\n  },\n  dilation: {\n    adjective: {\n      high: \"Dilated\",\n      mid: \"Attenuated\",\n      low: \"Diluted\"\n    },\n    noun: \"Dilation\"\n  }\n};\nexport default {\n  name: \"GlyphSetName\",\n  props: {\n    glyphSet: {\n      type: Array,\n      required: true\n    },\n    forceColor: {\n      type: Boolean,\n      required: false,\n      default: false\n    }\n  },\n\n  data() {\n    return {\n      isColored: true,\n      // Adjectives are added in descending order of adjOrder (basic glyphs are handled together)\n      glyphTypeList: [{\n        type: \"power\",\n        perc: 0,\n        adjOrder: 1\n      }, {\n        type: \"infinity\",\n        perc: 0,\n        adjOrder: 1\n      }, {\n        type: \"replication\",\n        perc: 0,\n        adjOrder: 1\n      }, {\n        type: \"time\",\n        perc: 0,\n        adjOrder: 1\n      }, {\n        type: \"dilation\",\n        perc: 0,\n        adjOrder: 1\n      }, {\n        type: \"effarig\",\n        perc: 0,\n        adjOrder: 2\n      }, {\n        type: \"music\",\n        perc: 0,\n        adjOrder: 3\n      }, {\n        type: \"reality\",\n        perc: 0,\n        adjOrder: 4\n      }, {\n        type: \"companion\",\n        perc: 0,\n        adjOrder: 5\n      }, {\n        type: \"cursed\",\n        perc: 0,\n        adjOrder: 6\n      }],\n      sortedGlyphs: [],\n      slotCount: 0\n    };\n  },\n\n  computed: {\n    isDoomed: () => Pelle.isDoomed,\n\n    setName() {\n      this.sortGlyphList();\n      if (this.sortedGlyphs.length === 0) return \"Void\";\n      if (this.sortedGlyphs.length === 1) return this.singletonName; // Figure out the noun part of the name first. If we have basic glyphs, this is generated through examining those\n      // specifically. Otherwise, we take the lowest-priority special glyph and turn it into its noun form\n\n      let adjList, nounPhrase;\n\n      if (this.sortedGlyphs.some(t => t.adjOrder === 1)) {\n        adjList = this.sortedGlyphs.filter(t => t.adjOrder !== 1);\n        nounPhrase = this.basicTypePhrase;\n      } else {\n        adjList = [...this.sortedGlyphs];\n        nounPhrase = this.getNoun(adjList.pop());\n      }\n\n      const adjectives = [];\n\n      for (const listEntry of adjList) adjectives.push(this.getAdjective(listEntry));\n\n      return `${adjectives.join(\" \")} ${nounPhrase}`;\n    },\n\n    basicTypePhrase() {\n      const basicGlyphList = this.sortedGlyphs.filter(t => BASIC_GLYPH_TYPES.includes(t.type) && t.perc !== 0);\n\n      switch (basicGlyphList.length) {\n        case 1:\n          return GLYPH_NAMES[basicGlyphList[0].type].noun;\n\n        case 2:\n          // Call it a mixture if they're equal and apply adjectives of appropriate magnitude\n          if (basicGlyphList[0].perc === basicGlyphList[1].perc) {\n            return [this.getAdjective(basicGlyphList[0]), this.getAdjective(basicGlyphList[1]), \"Mixture\"].join(\" \");\n          } // Otherwise, give it a noun from the largest component\n\n\n          return `${this.getAdjective(basicGlyphList[1])} ${this.getNoun(basicGlyphList[0])}`;\n\n        case 3:\n          // Give it a noun if there's a clear majority\n          if (basicGlyphList[0].perc > basicGlyphList[1].perc) {\n            return [this.getAdjective(basicGlyphList[1]), this.getAdjective(basicGlyphList[2]), this.getNoun(basicGlyphList[0])].join(\" \");\n          } // This is relatively rare; we have 1/1/1, which means that we may also already have 3 other adjectives.\n          // In this case we make an exception and shorten the name instead of providing another 4 words\n\n\n          if (basicGlyphList[0].perc === basicGlyphList[2].perc) return \"Mixed Irregularity\"; // The only case left is 2/2/1, where we have plenty of room for words\n\n          return [this.getAdjective(basicGlyphList[0]), this.getAdjective(basicGlyphList[1]), this.getAdjective(basicGlyphList[2]), \"Irregularity\"].join(\" \");\n\n        case 4:\n          // Don't bother filling the name with excessive adjectives if we have an equal proportion (1/1/1/1),\n          // otherwise we take the largest component and ignore all the others (2/1/1/1)\n          if (basicGlyphList[0].perc === basicGlyphList[1].perc) return \"Irregular Jumble\";\n          return `${this.getAdjective(basicGlyphList[0])} Jumble`;\n\n        case 5:\n          // This is in reference to the achievement name, and can only occur with exactly one of every basic glyph.\n          // Due to music glyphs doubling-up contributions, this may result in a \"Melodic Royal Flush\" or similar\n          return \"Royal Flush\";\n\n        default:\n          throw new Error(\"Unexpected glyph set configuration in GlyphSetName\");\n      }\n    },\n\n    // Check for single-type sets and give them a special name based on how much of the full equipped slots they take up\n    singletonName() {\n      if (this.sortedGlyphs[0].type === \"effarig\") return GLYPH_NAMES.effarig.noun[this.getEffarigProp()];\n      const singleGlyphTypes = [\"reality\", \"companion\"];\n\n      for (const key of singleGlyphTypes) {\n        if (this.sortedGlyphs[0].type === key) return GLYPH_NAMES[key].noun;\n      } // We want a bit of additional flavor for partially-filled sets\n\n\n      const word = GLYPH_NAMES[this.sortedGlyphs[0].type].noun;\n      const perc = this.sortedGlyphs[0].perc;\n      if (this.isDoomed) return `Doomed ${word}`;\n      if (perc === 100) return `Full ${word}`;\n      if (perc >= 75) return `Strengthened ${word}`;\n      if (perc >= 40) return `Partial ${word}`;\n      return `Weak ${word}`;\n    },\n\n    mainGlyphName() {\n      // This returns the type of Glyph that we want for color determinations.\n      // The priority is Empty > Cursed > Companion > Reality > 50% or more normal Glyphs > Effarig > any normal Glyph\n      if (this.sortedGlyphs.length === 0) return {\n        id: \"none\",\n        currentColor: {\n          border: \"#888888\"\n        }\n      };\n      if (this.calculateGlyphPercent(\"cursed\")) return CosmeticGlyphTypes.cursed;\n      if (this.calculateGlyphPercent(\"companion\")) return CosmeticGlyphTypes.companion;\n      if (this.calculateGlyphPercent(\"reality\")) return CosmeticGlyphTypes.reality;\n      if (this.calculateGlyphPercent(\"music\") >= 50) return CosmeticGlyphTypes.music;\n      const primaryType = this.sortedGlyphs.filter(t => t.adjOrder === 1)[0];\n      if ((primaryType === null || primaryType === void 0 ? void 0 : primaryType.perc) >= 50) return CosmeticGlyphTypes[primaryType.type];\n      if (this.calculateGlyphPercent(\"effarig\")) return CosmeticGlyphTypes.effarig;\n      return CosmeticGlyphTypes[primaryType.type];\n    },\n\n    textColor() {\n      // If it's the singular equipped glyph in Doomed, we color it crimson\n      // If its cursed, we give it the celestial color because the default (without cosmetics) black is often unreadable\n      // If we have 3 types of Glyphs, and none of them have more than 30% total, lets get a copper color.\n      // And if we have none of the above (which is most common), lets get the color of the main Glyph.\n      if (this.isDoomed && this.glyphSet.length === 1) return \"var(--color-pelle--base)\";\n      if (this.mainGlyphName.id === \"cursed\") return \"var(--color-celestials)\";\n      if (this.mainGlyphName.id === \"music\") return CosmeticGlyphTypes.music.currentColor.border;\n      if (this.sortedGlyphs.length >= 3 && this.sortedGlyphs[0].perc <= 30) return \"#C46200\";\n      return this.mainGlyphName.currentColor.border;\n    },\n\n    textStyle() {\n      this.$recompute(\"mainGlyphName\"); // If you have the player option to not show color enabled, and this isn't a special case forcing color, return {}\n\n      if (!this.isColored && !this.forceColor) return {}; // Otherwise, lets set the shadow to be 4, each offset to a different corner, and bluring by 1px,\n      // then bluring by 3px with no offset with the same color as the text.\n      // If its a Reality Glyph, assign it Reality Glyph's animation.\n\n      return {\n        color: this.textColor,\n        \"text-shadow\": `-1px 1px 1px var(--color-text-base), 1px 1px 1px var(--color-text-base),\n                        -1px -1px 1px var(--color-text-base), 1px -1px 1px var(--color-text-base),\n                        0 0 3px ${this.textColor}`,\n        animation: this.mainGlyphName.id === \"reality\" ? \"a-reality-glyph-description-cycle 10s infinite\" : undefined\n      };\n    }\n\n  },\n\n  created() {\n    this.on$(GAME_EVENT.GLYPHS_CHANGED, this.sortGlyphList);\n    this.sortGlyphList();\n  },\n\n  methods: {\n    update() {\n      this.isColored = player.options.glyphTextColors; // Without max, Doomed may retroactively zero the slot count of older sets in records and mess up their names\n      // This can retroactively change names on old sets when gaining new slots in reality upgrades, but this is\n      // probably acceptable since the old names may have become unattainable with the new slot count anyway\n\n      this.slotCount = Math.max(Glyphs.activeSlotCount, this.glyphSet.length);\n    },\n\n    getEffarigProp() {\n      const effarigRM = this.glyphSet.some(i => getSingleGlyphEffectFromBitmask(\"effarigrm\", i));\n      const effarigGlyph = this.glyphSet.some(i => getSingleGlyphEffectFromBitmask(\"effarigglyph\", i));\n      if (effarigRM && effarigGlyph) return \"both\";\n      if (effarigRM) return \"rm\";\n      if (effarigGlyph) return \"glyph\";\n      return \"none\";\n    },\n\n    calculateGlyphPercent(name) {\n      const percentPerGlyph = this.slotCount ? 100 / this.slotCount : 0;\n      if (name === \"music\") return this.glyphSet.filter(i => Glyphs.isMusicGlyph(i)).length * percentPerGlyph; // Take the amount of a type of glyph in the set, divide by the maximum number of glyphs, then * 100 to get %\n\n      return this.glyphSet.filter(i => i.type === name).length * percentPerGlyph;\n    },\n\n    sortGlyphList() {\n      this.$recompute(\"textColor\");\n      this.glyphTypeList.forEach(t => t.perc = this.calculateGlyphPercent(t.type));\n      this.sortedGlyphs = this.glyphTypeList.filter(t => t.perc !== 0); // This composite function is required in order to ensure consistent names with equal percentages, as JS doesn't\n      // guarantee .sort() operations are stable sorts. Sorts by adjOrder, followed by perc, followed by alphabetical.\n\n      const sortFn = t => 100 * t.adjOrder + t.perc + t.type.charCodeAt(0) / 1000;\n\n      this.sortedGlyphs.sort((a, b) => sortFn(b) - sortFn(a));\n    },\n\n    getAdjective(listEntry) {\n      if (listEntry.type === \"effarig\") return GLYPH_NAMES.effarig.adjective[this.getEffarigProp()];\n\n      const adjFn = val => {\n        if (val >= 60) return \"high\";\n        if (val >= 40) return \"mid\";\n        return \"low\";\n      };\n\n      const adj = GLYPH_NAMES[listEntry.type].adjective;\n      return typeof adj === \"string\" ? adj : adj[adjFn(listEntry.perc)];\n    },\n\n    getNoun(listEntry) {\n      if (listEntry.type === \"effarig\") return GLYPH_NAMES.effarig.noun[this.getEffarigProp()];\n      return GLYPH_NAMES[listEntry.type].noun;\n    }\n\n  }\n};","map":{"version":3,"sources":["GlyphSetName.vue"],"names":[],"mappings":"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","sourcesContent":["<script>\r\nconst GLYPH_NAMES = {\r\n  companion: {\r\n    adjective: \"Huggable\",\r\n    noun: \"Companion\"\r\n  },\r\n  reality: {\r\n    adjective: \"Real\",\r\n    noun: \"Reality\"\r\n  },\r\n  music: {\r\n    adjective: { high: \"Melodic\", mid: \"Chordal\", low: \"Tuned\" },\r\n    // This noun is only used in the case of a single companion reskinned as music (resulting in \"Huggable Music\");\r\n    // otherwise the set's noun will always come from an actual glyph type instead of music\r\n    noun: \"Music\"\r\n  },\r\n  effarig: {\r\n    adjective: { both: \"Meta\", glyph: \"Stable\", rm: \"Mechanical\", none: \"Fragmented\" },\r\n    noun: { both: \"Effarig\", glyph: \"Stability\", rm: \"Mechanism\", none: \"Fragmentation\" }\r\n  },\r\n  cursed: {\r\n    adjective: { high: \"Cursed\", mid: \"Hexed\", low: \"Jinxed\" },\r\n    noun: \"Curse\"\r\n  },\r\n  power: {\r\n    adjective: { high: \"Powerful\", mid: \"Mastered\", low: \"Potential\" },\r\n    noun: \"Power\"\r\n  },\r\n  infinity: {\r\n    adjective: { high: \"Infinite\", mid: \"Boundless\", low: \"Immense\" },\r\n    noun: \"Infinity\"\r\n  },\r\n  replication: {\r\n    adjective: { high: \"Replicated\", mid: \"Simulated\", low: \"Duplicated\" },\r\n    noun: \"Replication\"\r\n  },\r\n  time: {\r\n    adjective: { high: \"Temporal\", mid: \"Chronal\", low: \"Transient\" },\r\n    noun: \"Time\"\r\n  },\r\n  dilation: {\r\n    adjective: { high: \"Dilated\", mid: \"Attenuated\", low: \"Diluted\" },\r\n    noun: \"Dilation\"\r\n  },\r\n};\r\n\r\nexport default {\r\n  name: \"GlyphSetName\",\r\n  props: {\r\n    glyphSet: {\r\n      type: Array,\r\n      required: true\r\n    },\r\n    forceColor: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: false\r\n    }\r\n  },\r\n  data() {\r\n    return {\r\n      isColored: true,\r\n      // Adjectives are added in descending order of adjOrder (basic glyphs are handled together)\r\n      glyphTypeList: [\r\n        { type: \"power\", perc: 0, adjOrder: 1 },\r\n        { type: \"infinity\", perc: 0, adjOrder: 1 },\r\n        { type: \"replication\", perc: 0, adjOrder: 1 },\r\n        { type: \"time\", perc: 0, adjOrder: 1 },\r\n        { type: \"dilation\", perc: 0, adjOrder: 1 },\r\n        { type: \"effarig\", perc: 0, adjOrder: 2 },\r\n        { type: \"music\", perc: 0, adjOrder: 3 },\r\n        { type: \"reality\", perc: 0, adjOrder: 4 },\r\n        { type: \"companion\", perc: 0, adjOrder: 5 },\r\n        { type: \"cursed\", perc: 0, adjOrder: 6 },\r\n      ],\r\n      sortedGlyphs: [],\r\n      slotCount: 0\r\n    };\r\n  },\r\n  computed: {\r\n    isDoomed: () => Pelle.isDoomed,\r\n    setName() {\r\n      this.sortGlyphList();\r\n      if (this.sortedGlyphs.length === 0) return \"Void\";\r\n      if (this.sortedGlyphs.length === 1) return this.singletonName;\r\n\r\n      // Figure out the noun part of the name first. If we have basic glyphs, this is generated through examining those\r\n      // specifically. Otherwise, we take the lowest-priority special glyph and turn it into its noun form\r\n      let adjList, nounPhrase;\r\n      if (this.sortedGlyphs.some(t => t.adjOrder === 1)) {\r\n        adjList = this.sortedGlyphs.filter(t => t.adjOrder !== 1);\r\n        nounPhrase = this.basicTypePhrase;\r\n      } else {\r\n        adjList = [...this.sortedGlyphs];\r\n        nounPhrase = this.getNoun(adjList.pop());\r\n      }\r\n\r\n      const adjectives = [];\r\n      for (const listEntry of adjList) adjectives.push(this.getAdjective(listEntry));\r\n      return `${adjectives.join(\" \")} ${nounPhrase}`;\r\n    },\r\n    basicTypePhrase() {\r\n      const basicGlyphList = this.sortedGlyphs.filter(t => BASIC_GLYPH_TYPES.includes(t.type) && t.perc !== 0);\r\n      switch (basicGlyphList.length) {\r\n        case 1:\r\n          return GLYPH_NAMES[basicGlyphList[0].type].noun;\r\n        case 2:\r\n          // Call it a mixture if they're equal and apply adjectives of appropriate magnitude\r\n          if (basicGlyphList[0].perc === basicGlyphList[1].perc) {\r\n            return [this.getAdjective(basicGlyphList[0]),\r\n              this.getAdjective(basicGlyphList[1]),\r\n              \"Mixture\"\r\n            ].join(\" \");\r\n          }\r\n          // Otherwise, give it a noun from the largest component\r\n          return `${this.getAdjective(basicGlyphList[1])} ${this.getNoun(basicGlyphList[0])}`;\r\n        case 3:\r\n          // Give it a noun if there's a clear majority\r\n          if (basicGlyphList[0].perc > basicGlyphList[1].perc) {\r\n            return [this.getAdjective(basicGlyphList[1]),\r\n              this.getAdjective(basicGlyphList[2]),\r\n              this.getNoun(basicGlyphList[0]),\r\n            ].join(\" \");\r\n          }\r\n          // This is relatively rare; we have 1/1/1, which means that we may also already have 3 other adjectives.\r\n          // In this case we make an exception and shorten the name instead of providing another 4 words\r\n          if (basicGlyphList[0].perc === basicGlyphList[2].perc) return \"Mixed Irregularity\";\r\n          // The only case left is 2/2/1, where we have plenty of room for words\r\n          return [this.getAdjective(basicGlyphList[0]),\r\n            this.getAdjective(basicGlyphList[1]),\r\n            this.getAdjective(basicGlyphList[2]),\r\n            \"Irregularity\"\r\n          ].join(\" \");\r\n        case 4:\r\n          // Don't bother filling the name with excessive adjectives if we have an equal proportion (1/1/1/1),\r\n          // otherwise we take the largest component and ignore all the others (2/1/1/1)\r\n          if (basicGlyphList[0].perc === basicGlyphList[1].perc) return \"Irregular Jumble\";\r\n          return `${this.getAdjective(basicGlyphList[0])} Jumble`;\r\n        case 5:\r\n          // This is in reference to the achievement name, and can only occur with exactly one of every basic glyph.\r\n          // Due to music glyphs doubling-up contributions, this may result in a \"Melodic Royal Flush\" or similar\r\n          return \"Royal Flush\";\r\n        default:\r\n          throw new Error(\"Unexpected glyph set configuration in GlyphSetName\");\r\n      }\r\n    },\r\n    // Check for single-type sets and give them a special name based on how much of the full equipped slots they take up\r\n    singletonName() {\r\n      if (this.sortedGlyphs[0].type === \"effarig\") return GLYPH_NAMES.effarig.noun[this.getEffarigProp()];\r\n      const singleGlyphTypes = [\"reality\", \"companion\"];\r\n      for (const key of singleGlyphTypes) {\r\n        if (this.sortedGlyphs[0].type === key) return GLYPH_NAMES[key].noun;\r\n      }\r\n\r\n      // We want a bit of additional flavor for partially-filled sets\r\n      const word = GLYPH_NAMES[this.sortedGlyphs[0].type].noun;\r\n      const perc = this.sortedGlyphs[0].perc;\r\n      if (this.isDoomed) return `Doomed ${word}`;\r\n      if (perc === 100) return `Full ${word}`;\r\n      if (perc >= 75) return `Strengthened ${word}`;\r\n      if (perc >= 40) return `Partial ${word}`;\r\n      return `Weak ${word}`;\r\n    },\r\n    mainGlyphName() {\r\n      // This returns the type of Glyph that we want for color determinations.\r\n      // The priority is Empty > Cursed > Companion > Reality > 50% or more normal Glyphs > Effarig > any normal Glyph\r\n      if (this.sortedGlyphs.length === 0) return { id: \"none\", currentColor: { border: \"#888888\" } };\r\n      if (this.calculateGlyphPercent(\"cursed\")) return CosmeticGlyphTypes.cursed;\r\n      if (this.calculateGlyphPercent(\"companion\")) return CosmeticGlyphTypes.companion;\r\n      if (this.calculateGlyphPercent(\"reality\")) return CosmeticGlyphTypes.reality;\r\n      if (this.calculateGlyphPercent(\"music\") >= 50) return CosmeticGlyphTypes.music;\r\n      const primaryType = this.sortedGlyphs.filter(t => t.adjOrder === 1)[0];\r\n      if (primaryType?.perc >= 50) return CosmeticGlyphTypes[primaryType.type];\r\n      if (this.calculateGlyphPercent(\"effarig\")) return CosmeticGlyphTypes.effarig;\r\n      return CosmeticGlyphTypes[primaryType.type];\r\n    },\r\n    textColor() {\r\n      // If it's the singular equipped glyph in Doomed, we color it crimson\r\n      // If its cursed, we give it the celestial color because the default (without cosmetics) black is often unreadable\r\n      // If we have 3 types of Glyphs, and none of them have more than 30% total, lets get a copper color.\r\n      // And if we have none of the above (which is most common), lets get the color of the main Glyph.\r\n      if (this.isDoomed && this.glyphSet.length === 1) return \"var(--color-pelle--base)\";\r\n      if (this.mainGlyphName.id === \"cursed\") return \"var(--color-celestials)\";\r\n      if (this.mainGlyphName.id === \"music\") return CosmeticGlyphTypes.music.currentColor.border;\r\n      if (this.sortedGlyphs.length >= 3 && this.sortedGlyphs[0].perc <= 30) return \"#C46200\";\r\n      return this.mainGlyphName.currentColor.border;\r\n    },\r\n    textStyle() {\r\n      this.$recompute(\"mainGlyphName\");\r\n      // If you have the player option to not show color enabled, and this isn't a special case forcing color, return {}\r\n      if (!this.isColored && !this.forceColor) return {};\r\n      // Otherwise, lets set the shadow to be 4, each offset to a different corner, and bluring by 1px,\r\n      // then bluring by 3px with no offset with the same color as the text.\r\n      // If its a Reality Glyph, assign it Reality Glyph's animation.\r\n      return {\r\n        color: this.textColor,\r\n        \"text-shadow\": `-1px 1px 1px var(--color-text-base), 1px 1px 1px var(--color-text-base),\r\n                        -1px -1px 1px var(--color-text-base), 1px -1px 1px var(--color-text-base),\r\n                        0 0 3px ${this.textColor}`,\r\n        animation: this.mainGlyphName.id === \"reality\" ? \"a-reality-glyph-description-cycle 10s infinite\" : undefined,\r\n      };\r\n    }\r\n  },\r\n  created() {\r\n    this.on$(GAME_EVENT.GLYPHS_CHANGED, this.sortGlyphList);\r\n    this.sortGlyphList();\r\n  },\r\n  methods: {\r\n    update() {\r\n      this.isColored = player.options.glyphTextColors;\r\n      // Without max, Doomed may retroactively zero the slot count of older sets in records and mess up their names\r\n      // This can retroactively change names on old sets when gaining new slots in reality upgrades, but this is\r\n      // probably acceptable since the old names may have become unattainable with the new slot count anyway\r\n      this.slotCount = Math.max(Glyphs.activeSlotCount, this.glyphSet.length);\r\n    },\r\n    getEffarigProp() {\r\n      const effarigRM = this.glyphSet.some(i => getSingleGlyphEffectFromBitmask(\"effarigrm\", i));\r\n      const effarigGlyph = this.glyphSet.some(i => getSingleGlyphEffectFromBitmask(\"effarigglyph\", i));\r\n      if (effarigRM && effarigGlyph) return \"both\";\r\n      if (effarigRM) return \"rm\";\r\n      if (effarigGlyph) return \"glyph\";\r\n      return \"none\";\r\n    },\r\n    calculateGlyphPercent(name) {\r\n      const percentPerGlyph = this.slotCount ? 100 / this.slotCount : 0;\r\n      if (name === \"music\") return this.glyphSet.filter(i => Glyphs.isMusicGlyph(i)).length * percentPerGlyph;\r\n      // Take the amount of a type of glyph in the set, divide by the maximum number of glyphs, then * 100 to get %\r\n      return this.glyphSet.filter(i => i.type === name).length * percentPerGlyph;\r\n    },\r\n    sortGlyphList() {\r\n      this.$recompute(\"textColor\");\r\n      this.glyphTypeList.forEach(t => t.perc = this.calculateGlyphPercent(t.type));\r\n      this.sortedGlyphs = this.glyphTypeList.filter(t => t.perc !== 0);\r\n      // This composite function is required in order to ensure consistent names with equal percentages, as JS doesn't\r\n      // guarantee .sort() operations are stable sorts. Sorts by adjOrder, followed by perc, followed by alphabetical.\r\n      const sortFn = t => 100 * t.adjOrder + t.perc + t.type.charCodeAt(0) / 1000;\r\n      this.sortedGlyphs.sort((a, b) => sortFn(b) - sortFn(a));\r\n    },\r\n    getAdjective(listEntry) {\r\n      if (listEntry.type === \"effarig\") return GLYPH_NAMES.effarig.adjective[this.getEffarigProp()];\r\n      const adjFn = val => {\r\n        if (val >= 60) return \"high\";\r\n        if (val >= 40) return \"mid\";\r\n        return \"low\";\r\n      };\r\n      const adj = GLYPH_NAMES[listEntry.type].adjective;\r\n      return typeof adj === \"string\" ? adj : adj[adjFn(listEntry.perc)];\r\n    },\r\n    getNoun(listEntry) {\r\n      if (listEntry.type === \"effarig\") return GLYPH_NAMES.effarig.noun[this.getEffarigProp()];\r\n      return GLYPH_NAMES[listEntry.type].noun;\r\n    },\r\n  }\r\n};\r\n</script>\r\n\r\n<template>\r\n  <div>\r\n    <span\r\n      :style=\"textStyle\"\r\n      class=\"c-current-glyph-effects__header\"\r\n    >\r\n      {{ setName }}\r\n    </span>\r\n  </div>\r\n</template>\r\n"],"sourceRoot":"src/components"},"metadata":{},"sourceType":"module"}