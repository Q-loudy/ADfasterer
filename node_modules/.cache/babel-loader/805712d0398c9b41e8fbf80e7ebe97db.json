{"ast":null,"code":"import \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.json.stringify.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport { RebuyableMechanicState } from \"./game-mechanics\";\nimport { SteamRuntime } from \"@/steam\";\nimport Payments from \"./payments\";\nexport const shop = {};\nexport const ShopPurchaseData = {\n  totalSTD: 0,\n  spentSTD: 0,\n  respecAvailable: false,\n  lastRespec: \"\",\n  unlockedCosmetics: [],\n\n  get availableSTD() {\n    return this.totalSTD - this.spentSTD;\n  },\n\n  get isIAPEnabled() {\n    return Cloud.loggedIn && this.availableSTD >= 0 && player.IAP.enabled;\n  },\n\n  // We also allow for respecs if it's been at least 3 days since the last one\n  get timeUntilRespec() {\n    const msSinceLast = Date.now() - new Date(ShopPurchaseData.lastRespec).getTime();\n    return TimeSpan.fromMilliseconds(3 * 86400 * 1000 - msSinceLast);\n  },\n\n  get canRespec() {\n    return this.respecAvailable || this.timeUntilRespec.totalDays <= 0;\n  },\n\n  updateLocalSTD(newData) {\n    var _newData$lastRespec, _newData$unlockedCosm;\n\n    this.totalSTD = newData.totalSTD;\n    this.spentSTD = newData.spentSTD;\n    this.respecAvailable = newData.respecAvailable;\n    this.lastRespec = (_newData$lastRespec = newData.lastRespec) !== null && _newData$lastRespec !== void 0 ? _newData$lastRespec : 0;\n    this.unlockedCosmetics = [...((_newData$unlockedCosm = newData.unlockedCosmetics) !== null && _newData$unlockedCosm !== void 0 ? _newData$unlockedCosm : [])];\n\n    for (const key of Object.keys(GameDatabase.shopPurchases)) {\n      var _newData$key;\n\n      this[key] = (_newData$key = newData[key]) !== null && _newData$key !== void 0 ? _newData$key : 0;\n    }\n\n    if (this.allCosmeticSets > 0) this.unlockedCosmetics = Object.keys(GameDatabase.reality.glyphCosmeticSets);\n    if (ShopPurchaseData.isIAPEnabled) Speedrun.setSTDUse(true);\n    GameStorage.save();\n  },\n\n  clearLocalSTD() {\n    this.totalSTD = 0;\n    this.spentSTD = 0;\n    this.respecAvailable = false;\n    this.unlockedCosmetics = [];\n\n    for (const key of Object.keys(GameDatabase.shopPurchases)) this[key] = 0;\n  },\n\n  // Reads STD props from the cloud and sets local cached values with the result\n  async syncSTD(showNotification = true, fetchedData = undefined) {\n    if (!Cloud.loggedIn) return;\n    let newSTDData;\n\n    if (fetchedData) {\n      newSTDData = fetchedData;\n    } else {\n      try {\n        const statusRes = await fetch(`${STD_BACKEND_URL}/STDData?user=${Cloud.user.id}`);\n        newSTDData = await statusRes.json();\n      } catch (e) {\n        GameUI.notify.error(\"Could not sync STD purchases!\", 10000);\n        return;\n      }\n    }\n\n    if (showNotification && newSTDData.totalSTD > 0) GameUI.notify.info(\"STD purchases successfully loaded!\", 10000);\n    this.updateLocalSTD(newSTDData);\n  },\n\n  respecRequest() {\n    if (player.options.confirmations.respecIAP) {\n      Modal.respecIAP.show();\n    } else {\n      this.respecAll();\n    }\n  },\n\n  async respecAll() {\n    if (!this.canRespec) {\n      // This case only happens if the player is cheating and using the console to make the game think it has a respec\n      // when on the backend they don't. Nevertheless, responsive UI rarely hurts\n      GameUI.notify.error(\"You do not have a respec available\", 10000);\n      return;\n    }\n\n    let res;\n\n    try {\n      res = await fetch(`${STD_BACKEND_URL}/respec`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          user: Cloud.user.id\n        })\n      });\n    } catch (e) {\n      GameUI.notify.error(\"Unable to respec STD purchases!\", 10000);\n      return;\n    }\n\n    const stdData = await res.json();\n    if (stdData.success) GameUI.notify.info(\"STD respec successful!\", 10000);else GameUI.notify.error(\"No purchases to respec!\", 10000);\n    this.updateLocalSTD(stdData.data);\n  }\n\n}; // We track the local state of shop purchases here, so dynamically add all the keys which exist in the gameDB\n\nfor (const key of Object.keys(GameDatabase.shopPurchases)) ShopPurchaseData[key] = 0;\n\nclass ShopPurchaseState extends RebuyableMechanicState {\n  get currency() {\n    return ShopPurchaseData.availableSTD;\n  }\n\n  get isAffordable() {\n    return this.currency >= this.cost;\n  }\n\n  get description() {\n    const desc = this.config.description;\n    return typeof desc === \"function\" ? desc() : desc;\n  }\n\n  get cost() {\n    const cost = this.config.cost;\n    return typeof cost === \"function\" ? cost() : cost;\n  } // ShopPurchaseData for any particular key is undefined in between page load and STD load,\n  // so we need to guard against that causing NaNs to propagate through the save\n\n\n  get purchases() {\n    var _ShopPurchaseData$thi;\n\n    return (_ShopPurchaseData$thi = ShopPurchaseData[this.config.key]) !== null && _ShopPurchaseData$thi !== void 0 ? _ShopPurchaseData$thi : 0;\n  }\n\n  set purchases(value) {\n    if (!Number.isFinite(value)) return;\n    ShopPurchaseData[this.config.key] = value;\n  }\n\n  isUnlocked() {\n    var _this$config$isUnlock, _this$config$isUnlock2, _this$config;\n\n    return player.records.fullGameCompletions > 0 || ((_this$config$isUnlock = (_this$config$isUnlock2 = (_this$config = this.config).isUnlocked) === null || _this$config$isUnlock2 === void 0 ? void 0 : _this$config$isUnlock2.call(_this$config)) !== null && _this$config$isUnlock !== void 0 ? _this$config$isUnlock : true);\n  }\n\n  get lockText() {\n    return this.config.lockText;\n  }\n\n  get shouldDisplayMult() {\n    return Boolean(this.config.multiplier);\n  }\n\n  get currentMult() {\n    if (!this.shouldDisplayMult) return \"\";\n    return this.config.multiplier(ShopPurchaseData.isIAPEnabled ? this.purchases : 0);\n  }\n\n  get nextMult() {\n    if (!this.shouldDisplayMult) return \"\";\n    return this.config.multiplier(ShopPurchaseData.isIAPEnabled ? this.purchases + 1 : 0);\n  } // We want to still display the correct value in the button, so we need separate getters for it\n\n\n  get currentMultForDisplay() {\n    if (!this.shouldDisplayMult) return \"\";\n    return this.config.multiplier(this.purchases);\n  }\n\n  get nextMultForDisplay() {\n    if (!this.shouldDisplayMult) return \"\";\n    return this.config.multiplier(this.purchases + 1);\n  }\n\n  formatEffect(effect) {\n    var _this$config$formatEf, _this$config2;\n\n    return ((_this$config$formatEf = (_this$config2 = this.config).formatEffect) === null || _this$config$formatEf === void 0 ? void 0 : _this$config$formatEf.call(_this$config2, effect)) || formatX(effect, 2, 0);\n  }\n\n  async purchase() {\n    var _GlyphAppearanceHandl;\n\n    if (!this.canBeBought) return false;\n    if (GameEnd.creditsEverClosed) return false;\n    if (this.config.instantPurchase && ui.$viewModel.modal.progressBar) return false;\n    const cosmeticId = this.config.key === \"singleCosmeticSet\" ? (_GlyphAppearanceHandl = GlyphAppearanceHandler.chosenFromModal) === null || _GlyphAppearanceHandl === void 0 ? void 0 : _GlyphAppearanceHandl.id : undefined; // Contact the purchase provider to verify the purchase\n\n    const success = SteamRuntime.isActive ? await SteamRuntime.purchaseShopItem(this.config.key, this.cost, cosmeticId) : await Payments.buyUpgrade(this.config.key, cosmeticId);\n    if (!success) return false;\n    if (player.IAP.enabled) Speedrun.setSTDUse(true);\n    if (this.config.instantPurchase) this.config.onPurchase();\n    GameUI.update();\n    return true;\n  }\n\n}\n\nexport const ShopPurchase = mapGameDataToObject(GameDatabase.shopPurchases, config => new ShopPurchaseState(config));\n\nshop.purchaseTimeSkip = function () {\n  Speedrun.setSTDUse(true);\n  simulateTime(3600 * 6);\n};\n\nshop.purchaseLongerTimeSkip = function () {\n  Speedrun.setSTDUse(true);\n  simulateTime(3600 * 24);\n};","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/shop.js"],"names":["RebuyableMechanicState","SteamRuntime","Payments","shop","ShopPurchaseData","totalSTD","spentSTD","respecAvailable","lastRespec","unlockedCosmetics","availableSTD","isIAPEnabled","Cloud","loggedIn","player","IAP","enabled","timeUntilRespec","msSinceLast","Date","now","getTime","TimeSpan","fromMilliseconds","canRespec","totalDays","updateLocalSTD","newData","key","Object","keys","GameDatabase","shopPurchases","allCosmeticSets","reality","glyphCosmeticSets","Speedrun","setSTDUse","GameStorage","save","clearLocalSTD","syncSTD","showNotification","fetchedData","undefined","newSTDData","statusRes","fetch","STD_BACKEND_URL","user","id","json","e","GameUI","notify","error","info","respecRequest","options","confirmations","respecIAP","Modal","show","respecAll","res","method","headers","body","JSON","stringify","stdData","success","data","ShopPurchaseState","currency","isAffordable","cost","description","desc","config","purchases","value","Number","isFinite","isUnlocked","records","fullGameCompletions","lockText","shouldDisplayMult","Boolean","multiplier","currentMult","nextMult","currentMultForDisplay","nextMultForDisplay","formatEffect","effect","formatX","purchase","canBeBought","GameEnd","creditsEverClosed","instantPurchase","ui","$viewModel","modal","progressBar","cosmeticId","GlyphAppearanceHandler","chosenFromModal","isActive","purchaseShopItem","buyUpgrade","onPurchase","update","ShopPurchase","mapGameDataToObject","purchaseTimeSkip","simulateTime","purchaseLongerTimeSkip"],"mappings":"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","sourcesContent":["import { RebuyableMechanicState } from \"./game-mechanics\";\r\nimport { SteamRuntime } from \"@/steam\";\r\n\r\nimport Payments from \"./payments\";\r\n\r\nexport const shop = {};\r\n\r\nexport const ShopPurchaseData = {\r\n  totalSTD: 0,\r\n  spentSTD: 0,\r\n  respecAvailable: false,\r\n  lastRespec: \"\",\r\n  unlockedCosmetics: [],\r\n\r\n  get availableSTD() {\r\n    return this.totalSTD - this.spentSTD;\r\n  },\r\n\r\n  get isIAPEnabled() {\r\n    return Cloud.loggedIn && this.availableSTD >= 0 && player.IAP.enabled;\r\n  },\r\n\r\n  // We also allow for respecs if it's been at least 3 days since the last one\r\n  get timeUntilRespec() {\r\n    const msSinceLast = Date.now() - new Date(ShopPurchaseData.lastRespec).getTime();\r\n    return TimeSpan.fromMilliseconds(3 * 86400 * 1000 - msSinceLast);\r\n  },\r\n\r\n  get canRespec() {\r\n    return this.respecAvailable || this.timeUntilRespec.totalDays <= 0;\r\n  },\r\n\r\n  updateLocalSTD(newData) {\r\n    this.totalSTD = newData.totalSTD;\r\n    this.spentSTD = newData.spentSTD;\r\n    this.respecAvailable = newData.respecAvailable;\r\n    this.lastRespec = newData.lastRespec ?? 0;\r\n    this.unlockedCosmetics = [...(newData.unlockedCosmetics ?? [])];\r\n    for (const key of Object.keys(GameDatabase.shopPurchases)) this[key] = newData[key] ?? 0;\r\n    if (this.allCosmeticSets > 0) this.unlockedCosmetics = Object.keys(GameDatabase.reality.glyphCosmeticSets);\r\n    if (ShopPurchaseData.isIAPEnabled) Speedrun.setSTDUse(true);\r\n    GameStorage.save();\r\n  },\r\n\r\n  clearLocalSTD() {\r\n    this.totalSTD = 0;\r\n    this.spentSTD = 0;\r\n    this.respecAvailable = false;\r\n    this.unlockedCosmetics = [];\r\n    for (const key of Object.keys(GameDatabase.shopPurchases)) this[key] = 0;\r\n  },\r\n\r\n  // Reads STD props from the cloud and sets local cached values with the result\r\n  async syncSTD(showNotification = true, fetchedData = undefined) {\r\n    if (!Cloud.loggedIn) return;\r\n    let newSTDData;\r\n    if (fetchedData) {\r\n      newSTDData = fetchedData;\r\n    } else {\r\n      try {\r\n        const statusRes = await fetch(`${STD_BACKEND_URL}/STDData?user=${Cloud.user.id}`);\r\n        newSTDData = await statusRes.json();\r\n      } catch (e) {\r\n        GameUI.notify.error(\"Could not sync STD purchases!\", 10000);\r\n        return;\r\n      }\r\n    }\r\n    if (showNotification && newSTDData.totalSTD > 0) GameUI.notify.info(\"STD purchases successfully loaded!\", 10000);\r\n    this.updateLocalSTD(newSTDData);\r\n  },\r\n\r\n  respecRequest() {\r\n    if (player.options.confirmations.respecIAP) {\r\n      Modal.respecIAP.show();\r\n    } else {\r\n      this.respecAll();\r\n    }\r\n  },\r\n\r\n  async respecAll() {\r\n    if (!this.canRespec) {\r\n      // This case only happens if the player is cheating and using the console to make the game think it has a respec\r\n      // when on the backend they don't. Nevertheless, responsive UI rarely hurts\r\n      GameUI.notify.error(\"You do not have a respec available\", 10000);\r\n      return;\r\n    }\r\n    let res;\r\n    try {\r\n      res = await fetch(`${STD_BACKEND_URL}/respec`, {\r\n        method: \"POST\",\r\n        headers: {\r\n          \"Content-Type\": \"application/json\"\r\n        },\r\n        body: JSON.stringify({ user: Cloud.user.id })\r\n      });\r\n    } catch (e) {\r\n      GameUI.notify.error(\"Unable to respec STD purchases!\", 10000);\r\n      return;\r\n    }\r\n    const stdData = await res.json();\r\n    if (stdData.success) GameUI.notify.info(\"STD respec successful!\", 10000);\r\n    else GameUI.notify.error(\"No purchases to respec!\", 10000);\r\n    this.updateLocalSTD(stdData.data);\r\n  },\r\n};\r\n\r\n// We track the local state of shop purchases here, so dynamically add all the keys which exist in the gameDB\r\nfor (const key of Object.keys(GameDatabase.shopPurchases)) ShopPurchaseData[key] = 0;\r\n\r\nclass ShopPurchaseState extends RebuyableMechanicState {\r\n  get currency() {\r\n    return ShopPurchaseData.availableSTD;\r\n  }\r\n\r\n  get isAffordable() {\r\n    return this.currency >= this.cost;\r\n  }\r\n\r\n  get description() {\r\n    const desc = this.config.description;\r\n    return typeof desc === \"function\" ? desc() : desc;\r\n  }\r\n\r\n  get cost() {\r\n    const cost = this.config.cost;\r\n    return typeof cost === \"function\" ? cost() : cost;\r\n  }\r\n\r\n  // ShopPurchaseData for any particular key is undefined in between page load and STD load,\r\n  // so we need to guard against that causing NaNs to propagate through the save\r\n  get purchases() {\r\n    return ShopPurchaseData[this.config.key] ?? 0;\r\n  }\r\n\r\n  set purchases(value) {\r\n    if (!Number.isFinite(value)) return;\r\n    ShopPurchaseData[this.config.key] = value;\r\n  }\r\n\r\n  isUnlocked() {\r\n    return player.records.fullGameCompletions > 0 || (this.config.isUnlocked?.() ?? true);\r\n  }\r\n\r\n  get lockText() {\r\n    return this.config.lockText;\r\n  }\r\n\r\n  get shouldDisplayMult() {\r\n    return Boolean(this.config.multiplier);\r\n  }\r\n\r\n  get currentMult() {\r\n    if (!this.shouldDisplayMult) return \"\";\r\n    return this.config.multiplier(ShopPurchaseData.isIAPEnabled ? this.purchases : 0);\r\n  }\r\n\r\n  get nextMult() {\r\n    if (!this.shouldDisplayMult) return \"\";\r\n    return this.config.multiplier(ShopPurchaseData.isIAPEnabled ? this.purchases + 1 : 0);\r\n  }\r\n\r\n  // We want to still display the correct value in the button, so we need separate getters for it\r\n  get currentMultForDisplay() {\r\n    if (!this.shouldDisplayMult) return \"\";\r\n    return this.config.multiplier(this.purchases);\r\n  }\r\n\r\n  get nextMultForDisplay() {\r\n    if (!this.shouldDisplayMult) return \"\";\r\n    return this.config.multiplier(this.purchases + 1);\r\n  }\r\n\r\n  formatEffect(effect) {\r\n    return this.config.formatEffect?.(effect) || formatX(effect, 2, 0);\r\n  }\r\n\r\n  async purchase() {\r\n    if (!this.canBeBought) return false;\r\n    if (GameEnd.creditsEverClosed) return false;\r\n    if (this.config.instantPurchase && ui.$viewModel.modal.progressBar) return false;\r\n\r\n    const cosmeticId = this.config.key === \"singleCosmeticSet\"\r\n      ? GlyphAppearanceHandler.chosenFromModal?.id\r\n      : undefined;\r\n\r\n    // Contact the purchase provider to verify the purchase\r\n    const success = SteamRuntime.isActive\r\n      ? await SteamRuntime.purchaseShopItem(this.config.key, this.cost, cosmeticId)\r\n      : await Payments.buyUpgrade(this.config.key, cosmeticId);\r\n    if (!success) return false;\r\n\r\n    if (player.IAP.enabled) Speedrun.setSTDUse(true);\r\n    if (this.config.instantPurchase) this.config.onPurchase();\r\n    GameUI.update();\r\n    return true;\r\n  }\r\n}\r\n\r\nexport const ShopPurchase = mapGameDataToObject(\r\n  GameDatabase.shopPurchases,\r\n  config => new ShopPurchaseState(config)\r\n);\r\n\r\nshop.purchaseTimeSkip = function() {\r\n  Speedrun.setSTDUse(true);\r\n  simulateTime(3600 * 6);\r\n};\r\n\r\nshop.purchaseLongerTimeSkip = function() {\r\n  Speedrun.setSTDUse(true);\r\n  simulateTime(3600 * 24);\r\n};\r\n"]},"metadata":{},"sourceType":"module"}