{"ast":null,"code":"import { DC } from \"./constants\"; // Slowdown parameters for replicanti growth, interval will increase by scaleFactor for every scaleLog10\n// OoM past the cap (default is 308.25 (log10 of 1.8e308), 1.2, Number.MAX_VALUE)\n\nexport const ReplicantiGrowth = {\n  get scaleLog10() {\n    return Math.log10(Number.MAX_VALUE);\n  },\n\n  get scaleFactor() {\n    if (PelleStrikes.eternity.hasStrike && Replicanti.amount.gte(DC.E2000)) return 10;\n    if (Pelle.isDoomed) return 2;\n    return AlchemyResource.cardinality.effectValue;\n  }\n\n}; // Internal function to add RGs; called both from within the fast replicanti code and from the function\n// used externally. Only called in cases of automatic RG and does not actually modify replicanti amount\n\nfunction addReplicantiGalaxies(newGalaxies) {\n  if (newGalaxies > 0) {\n    player.replicanti.galaxies += newGalaxies;\n    player.requirementChecks.eternity.noRG = false;\n    const keepResources = Pelle.isDoomed ? PelleUpgrade.replicantiGalaxyEM40.canBeApplied : EternityMilestone.replicantiNoReset.isReached;\n\n    if (!keepResources) {\n      player.dimensionBoosts = 0;\n      softReset(0, true, true);\n    }\n  }\n} // Function called externally for gaining RGs, which adjusts replicanti amount before calling the function\n// which actually adds the RG. Called externally both automatically and manually\n\n\nexport function replicantiGalaxy(auto) {\n  if (RealityUpgrade(6).isLockingMechanics) {\n    if (!auto) RealityUpgrade(6).tryShowWarningModal();\n    return;\n  }\n\n  if (!Replicanti.galaxies.canBuyMore) return;\n  const galaxyGain = Replicanti.galaxies.gain;\n  if (galaxyGain < 1) return;\n  player.replicanti.timer = 0;\n  Replicanti.amount = Achievement(126).isUnlocked && !Pelle.isDoomed ? Decimal.pow10(Replicanti.amount.log10() - LOG10_MAX_VALUE * galaxyGain) : DC.D1;\n  addReplicantiGalaxies(galaxyGain);\n} // Only called on manual RG requests\n\nexport function replicantiGalaxyRequest() {\n  if (!Replicanti.galaxies.canBuyMore) return;\n  if (RealityUpgrade(6).isLockingMechanics) RealityUpgrade(6).tryShowWarningModal();else if (player.options.confirmations.replicantiGalaxy) Modal.replicantiGalaxy.show();else replicantiGalaxy(false);\n} // Produces replicanti quickly below e308, will auto-bulk-RG if production is fast enough\n// Returns the remaining unused gain factor\n\nfunction fastReplicantiBelow308(log10GainFactor, isAutobuyerActive) {\n  const shouldBuyRG = isAutobuyerActive && !RealityUpgrade(6).isLockingMechanics; // More than e308 galaxies per tick causes the game to die, and I don't think it's worth the performance hit of\n  // Decimalifying the entire calculation.  And yes, this can and does actually happen super-lategame.\n\n  const uncappedAmount = DC.E1.pow(log10GainFactor.plus(Replicanti.amount.log10())); // Checking for uncapped equaling zero is because Decimal.pow returns zero for overflow for some reason\n\n  if (log10GainFactor.gt(Number.MAX_VALUE) || uncappedAmount.eq(0)) {\n    if (shouldBuyRG) {\n      addReplicantiGalaxies(Replicanti.galaxies.max - player.replicanti.galaxies);\n    }\n\n    Replicanti.amount = replicantiCap(); // Basically we've used nothing.\n\n    return log10GainFactor;\n  }\n\n  if (!shouldBuyRG) {\n    const _remainingGain = log10GainFactor.minus(replicantiCap().log10() - Replicanti.amount.log10()).clampMin(0);\n\n    Replicanti.amount = Decimal.min(uncappedAmount, replicantiCap());\n    return _remainingGain;\n  }\n\n  const gainNeededPerRG = Decimal.NUMBER_MAX_VALUE.log10();\n  const replicantiExponent = log10GainFactor.toNumber() + Replicanti.amount.log10();\n  const toBuy = Math.floor(Math.min(replicantiExponent / gainNeededPerRG, Replicanti.galaxies.max - player.replicanti.galaxies));\n  const maxUsedGain = gainNeededPerRG * toBuy + replicantiCap().log10() - Replicanti.amount.log10();\n  const remainingGain = log10GainFactor.minus(maxUsedGain).clampMin(0);\n  Replicanti.amount = Decimal.pow10(replicantiExponent - gainNeededPerRG * toBuy).clampMax(replicantiCap());\n  addReplicantiGalaxies(toBuy);\n  return remainingGain;\n} // When the amount is exactly the cap, there are two cases: the player can go\n// over cap (in which case interval should be as if over cap) or the player\n// has just crunched and is still at cap due to \"Is this safe?\" reward\n// (in which case interval should be as if not over cap). This is why we have\n// the overCapOverride parameter, to tell us which case we are in.\n\n\nexport function getReplicantiInterval(overCapOverride, intervalIn) {\n  let interval = intervalIn || player.replicanti.interval;\n  const amount = Replicanti.amount;\n  const overCap = overCapOverride === undefined ? amount.gt(replicantiCap()) : overCapOverride;\n  interval = new Decimal(interval);\n\n  if (TimeStudy(133).isBought && !Achievement(138).isUnlocked || overCap) {\n    interval = interval.times(10);\n  }\n\n  if (overCap) {\n    let increases = (amount.log10() - replicantiCap().log10()) / ReplicantiGrowth.scaleLog10;\n\n    if (PelleStrikes.eternity.hasStrike && amount.gte(DC.E2000)) {\n      // The above code assumes in this case there's 10x scaling for every 1e308 increase;\n      // in fact, before e2000 it's only 2x.\n      increases -= Math.log10(5) * (2000 - replicantiCap().log10()) / ReplicantiGrowth.scaleLog10;\n    }\n\n    interval = interval.times(Decimal.pow(ReplicantiGrowth.scaleFactor, increases));\n  }\n\n  interval = interval.divide(totalReplicantiSpeedMult(overCap));\n\n  if (V.isRunning) {\n    // This is a boost if interval < 1, but that only happens in EC12\n    // and handling it would make the replicanti code a lot more complicated.\n    interval = interval.pow(2);\n  }\n\n  return interval;\n} // This only counts the \"external\" multipliers - that is, it doesn't count any speed changes due to being over the cap.\n// These multipliers are separated out largely for two reasons - more \"dynamic\" multipliers (such as overcap scaling\n// and celestial nerfs) interact very weirdly and the game balance relies on this behavior, and we also use this same\n// value in the multiplier tab too\n\nexport function totalReplicantiSpeedMult(overCap) {\n  let totalMult = DC.D1; // These are the only effects active in Pelle - the function shortcuts everything else if we're in Pelle\n\n  totalMult = totalMult.times(PelleRifts.decay.effectValue);\n  totalMult = totalMult.times(Pelle.specialGlyphEffect.replication);\n  totalMult = totalMult.times(ShopPurchase.replicantiPurchases.currentMult);\n  if (Pelle.isDisabled(\"replicantiIntervalMult\")) return totalMult;\n  const preCelestialEffects = Effects.product(TimeStudy(62), TimeStudy(213), RealityUpgrade(2), RealityUpgrade(6), RealityUpgrade(23));\n  totalMult = totalMult.times(preCelestialEffects);\n\n  if (TimeStudy(132).isBought) {\n    totalMult = totalMult.times(Perk.studyPassive.isBought ? 3 : 1.5);\n  }\n\n  if (!overCap && Achievement(134).isUnlocked) {\n    totalMult = totalMult.times(2);\n  }\n\n  totalMult = totalMult.times(getAdjustedGlyphEffect(\"replicationspeed\"));\n\n  if (GlyphAlteration.isAdded(\"replication\")) {\n    totalMult = totalMult.times(Math.clampMin(Decimal.log10(Replicanti.amount) * getSecondaryGlyphEffect(\"replicationdtgain\"), 1));\n  }\n\n  totalMult = totalMult.timesEffectsOf(AlchemyResource.replication, Ra.unlocks.continuousTTBoost.effects.replicanti);\n  return totalMult;\n}\nexport function replicantiCap() {\n  return EffarigUnlock.infinity.canBeApplied ? Currency.infinitiesTotal.value.pow(TimeStudy(31).isBought ? 120 : 30).clampMin(1).times(Decimal.NUMBER_MAX_VALUE) : Decimal.NUMBER_MAX_VALUE;\n} // eslint-disable-next-line complexity\n\nexport function replicantiLoop(diff) {\n  if (!player.replicanti.unl) return;\n  const replicantiBeforeLoop = Replicanti.amount;\n  PerformanceStats.start(\"Replicanti\");\n  EventHub.dispatch(GAME_EVENT.REPLICANTI_TICK_BEFORE); // This gets the pre-cap interval (above the cap we recalculate the interval).\n\n  const interval = getReplicantiInterval(false);\n  const isUncapped = Replicanti.isUncapped;\n  const areRGsBeingBought = Replicanti.galaxies.areBeingBought; // Figure out how many ticks to calculate for and roll over any leftover time to the next tick. The rollover\n  // calculation is skipped if there's more than 100 replicanti ticks per game tick to reduce round-off problems.\n\n  let tickCount = Decimal.divide(diff + player.replicanti.timer, interval);\n  if (tickCount.lt(100)) player.replicanti.timer = tickCount.minus(tickCount.floor()).times(interval).toNumber();else player.replicanti.timer = 0;\n  tickCount = tickCount.floor();\n  const singleTickAvg = Replicanti.amount.times(player.replicanti.chance); // Note that code inside this conditional won't necessarily run every game tick; when game ticks are slower than\n  // replicanti ticks, then tickCount will look like [0, 0, 0, 1, 0, 0, ...] on successive game ticks\n\n  if (tickCount.gte(100) || singleTickAvg.gte(10) && tickCount.gte(1)) {\n    // Fast gain: If we're doing a very large number of ticks or each tick produces a lot, then continuous growth\n    // every replicanti tick is a good approximation and less intensive than distribution samples. This path will\n    // always happen above 1000 replicanti due to how singleTickAvg is calculated, so the over-cap math is only\n    // present on this path\n    let postScale = Math.log10(ReplicantiGrowth.scaleFactor) / ReplicantiGrowth.scaleLog10;\n\n    if (V.isRunning) {\n      postScale *= 2;\n    } // Note that remainingGain is in log10 terms.\n\n\n    let remainingGain = tickCount.times(Math.log(player.replicanti.chance + 1)).times(LOG10_E); // It is intended to be possible for both of the below conditionals to trigger.\n\n    if (!isUncapped || Replicanti.amount.lte(replicantiCap())) {\n      // Some of the gain is \"used up\" below e308, but if replicanti are uncapped\n      // then some may be \"left over\" for increasing replicanti beyond their cap.\n      remainingGain = fastReplicantiBelow308(remainingGain, areRGsBeingBought);\n    }\n\n    if (isUncapped && Replicanti.amount.gte(replicantiCap()) && remainingGain.gt(0)) {\n      // Recalculate the interval (it may have increased due to additional replicanti, or,\n      // far less importantly, decreased due to Reality Upgrade 6 and additional RG).\n      // Don't worry here about the lack of e2000 scaling in Pelle on the first tick\n      // (with replicanti still under e2000) causing a huge replicanti jump;\n      // there's code later to stop replicanti from increasing by more than e308\n      // in a single tick in Pelle.\n      const intervalRatio = getReplicantiInterval(true).div(interval);\n      remainingGain = remainingGain.div(intervalRatio);\n      Replicanti.amount = Decimal.exp(remainingGain.div(LOG10_E).times(postScale).plus(1).ln() / postScale + Replicanti.amount.clampMin(1).ln());\n    }\n  } else if (tickCount.gt(1)) {\n    // Multiple ticks but \"slow\" gain: This happens at low replicanti chance and amount with a fast interval, which\n    // can happen often in early cel7. In this case we \"batch\" ticks together as full doubling events and then draw\n    // from a Poisson distribution for how many times to do that. Any leftover ticks are used as binomial samples\n    const batchTicks = Math.floor(tickCount.toNumber() * Math.log2(1 + player.replicanti.chance));\n    const binomialTicks = tickCount.toNumber() - batchTicks / Math.log2(1 + player.replicanti.chance);\n    Replicanti.amount = Replicanti.amount.times(DC.D2.pow(poissonDistribution(batchTicks)));\n\n    for (let t = 0; t < Math.floor(binomialTicks); t++) {\n      const reproduced = binomialDistribution(Replicanti.amount, player.replicanti.chance);\n      Replicanti.amount = Replicanti.amount.plus(reproduced);\n    } // The batching might use partial ticks; we add the rest back to the timer so it gets used next loop\n\n\n    const leftover = binomialTicks - Math.floor(binomialTicks);\n    player.replicanti.timer += interval.times(leftover).toNumber();\n  } else if (tickCount.eq(1)) {\n    // Single tick: Take a single binomial sample to properly simulate replicanti growth with randomness\n    const reproduced = binomialDistribution(Replicanti.amount, player.replicanti.chance);\n    Replicanti.amount = Replicanti.amount.plus(reproduced);\n  }\n\n  if (!isUncapped) Replicanti.amount = Decimal.min(replicantiCap(), Replicanti.amount);\n\n  if (Pelle.isDoomed && Replicanti.amount.log10() - replicantiBeforeLoop.log10() > 308) {\n    Replicanti.amount = replicantiBeforeLoop.times(1e308);\n  }\n\n  if (areRGsBeingBought && Replicanti.amount.gte(Decimal.NUMBER_MAX_VALUE)) {\n    const buyer = Autobuyer.replicantiGalaxy;\n    const isAuto = buyer.canTick && buyer.isEnabled; // There might be a manual and auto tick simultaneously; pass auto === true iff the autobuyer is ticking and\n    // we aren't attempting to manually buy RG, because this controls modals appearing or not\n\n    replicantiGalaxy(isAuto && !Replicanti.galaxies.isPlayerHoldingR);\n  }\n\n  player.records.thisReality.maxReplicanti = player.records.thisReality.maxReplicanti.clampMin(Replicanti.amount);\n  EventHub.dispatch(GAME_EVENT.REPLICANTI_TICK_AFTER);\n  PerformanceStats.end();\n}\nexport function replicantiMult() {\n  return Decimal.pow(Decimal.log2(Replicanti.amount.clampMin(1)), 2).plusEffectOf(TimeStudy(21)).timesEffectOf(TimeStudy(102)).clampMin(1).pow(getAdjustedGlyphEffect(\"replicationpow\"));\n}\n/** @abstract */\n\nclass ReplicantiUpgradeState {\n  /** @abstract */\n  get id() {\n    throw new NotImplementedError();\n  }\n  /** @abstract */\n\n\n  get value() {\n    throw new NotImplementedError();\n  }\n  /** @abstract */\n\n\n  set value(value) {\n    throw new NotImplementedError();\n  }\n  /** @abstract */\n\n\n  get nextValue() {\n    throw new NotImplementedError();\n  }\n  /** @abstract */\n\n\n  get cost() {\n    throw new NotImplementedError();\n  }\n  /** @abstract */\n\n\n  set cost(value) {\n    throw new Error(\"Use baseCost to set cost\");\n  }\n  /** @abstract */\n\n\n  get costIncrease() {\n    throw new NotImplementedError();\n  }\n\n  get baseCost() {\n    return this.cost;\n  }\n  /** @abstract */\n\n\n  set baseCost(value) {\n    throw new NotImplementedError();\n  }\n\n  get cap() {\n    return undefined;\n  }\n\n  get isCapped() {\n    return false;\n  }\n  /** @abstract */\n\n\n  get autobuyerMilestone() {\n    throw new NotImplementedError();\n  }\n\n  get canBeBought() {\n    return !this.isCapped && Currency.infinityPoints.gte(this.cost) && player.eterc8repl !== 0;\n  }\n\n  purchase() {\n    if (!this.canBeBought) return;\n    Currency.infinityPoints.subtract(this.cost);\n    this.baseCost = Decimal.times(this.baseCost, this.costIncrease);\n    this.value = this.nextValue;\n    if (EternityChallenge(8).isRunning) player.eterc8repl--;\n    GameUI.update();\n  }\n\n  autobuyerTick() {\n    while (this.canBeBought) {\n      this.purchase();\n    }\n  }\n\n}\n\nexport const ReplicantiUpgrade = {\n  chance: new class ReplicantiChanceUpgrade extends ReplicantiUpgradeState {\n    get id() {\n      return 1;\n    }\n\n    get value() {\n      return player.replicanti.chance;\n    }\n\n    set value(value) {\n      player.replicanti.chance = value;\n    }\n\n    get nextValue() {\n      return this.nearestPercent(this.value + 0.01);\n    }\n\n    get cost() {\n      return player.replicanti.chanceCost.dividedByEffectOf(PelleRifts.vacuum.milestones[1]);\n    }\n\n    get baseCost() {\n      return player.replicanti.chanceCost;\n    }\n\n    set baseCost(value) {\n      player.replicanti.chanceCost = value;\n    }\n\n    get costIncrease() {\n      return 1e15;\n    }\n\n    get cap() {\n      // Chance never goes over 100%.\n      return 1;\n    }\n\n    get isCapped() {\n      return this.nearestPercent(this.value) >= this.cap;\n    }\n\n    get autobuyerMilestone() {\n      return EternityMilestone.autobuyerReplicantiChance;\n    }\n\n    autobuyerTick() {\n      // Fixed price increase of 1e15; so total cost for N upgrades is:\n      // cost + cost * 1e15 + cost * 1e30 + ... + cost * 1e15^(N-1) == cost * (1e15^N - 1) / (1e15 - 1)\n      // N = log(IP * (1e15 - 1) / cost + 1) / log(1e15)\n      let N = Currency.infinityPoints.value.times(this.costIncrease - 1).dividedBy(this.cost).plus(1).log(this.costIncrease);\n      N = Math.round((Math.min(this.value + 0.01 * Math.floor(N), this.cap) - this.value) * 100);\n      if (N <= 0) return;\n      const totalCost = this.cost.times(Decimal.pow(this.costIncrease, N).minus(1).dividedBy(this.costIncrease - 1));\n      Currency.infinityPoints.subtract(totalCost);\n      this.baseCost = this.baseCost.times(Decimal.pow(this.costIncrease, N));\n      this.value = this.nearestPercent(this.value + 0.01 * N);\n    } // Rounding errors suck\n\n\n    nearestPercent(x) {\n      return Math.round(100 * x) / 100;\n    }\n\n  }(),\n  interval: new class ReplicantiIntervalUpgrade extends ReplicantiUpgradeState {\n    get id() {\n      return 2;\n    }\n\n    get value() {\n      return player.replicanti.interval;\n    }\n\n    set value(value) {\n      player.replicanti.interval = value;\n    }\n\n    get nextValue() {\n      return Math.max(this.value * 0.9, this.cap);\n    }\n\n    get cost() {\n      return player.replicanti.intervalCost.dividedByEffectOf(PelleRifts.vacuum.milestones[1]);\n    }\n\n    get baseCost() {\n      return player.replicanti.intervalCost;\n    }\n\n    set baseCost(value) {\n      player.replicanti.intervalCost = value;\n    }\n\n    get costIncrease() {\n      return 1e10;\n    }\n\n    get cap() {\n      return Effects.min(50, TimeStudy(22));\n    }\n\n    get isCapped() {\n      return this.value <= this.cap;\n    }\n\n    get autobuyerMilestone() {\n      return EternityMilestone.autobuyerReplicantiInterval;\n    }\n\n    applyModifiers(value) {\n      return getReplicantiInterval(undefined, value);\n    }\n\n  }(),\n  galaxies: new class ReplicantiGalaxiesUpgrade extends ReplicantiUpgradeState {\n    get id() {\n      return 3;\n    }\n\n    get value() {\n      return player.replicanti.boughtGalaxyCap;\n    }\n\n    set value(value) {\n      player.replicanti.boughtGalaxyCap = value;\n    }\n\n    get nextValue() {\n      return this.value + 1;\n    }\n\n    get cost() {\n      return this.baseCost.dividedByEffectsOf(TimeStudy(233), PelleRifts.vacuum.milestones[1]);\n    }\n\n    get baseCost() {\n      return player.replicanti.galCost;\n    }\n\n    set baseCost(value) {\n      player.replicanti.galCost = value;\n    }\n\n    get distantRGStart() {\n      return 100 + Effects.sum(GlyphSacrifice.replication);\n    }\n\n    get remoteRGStart() {\n      return 1000 + Effects.sum(GlyphSacrifice.replication);\n    }\n\n    get costIncrease() {\n      const galaxies = this.value;\n      let increase = EternityChallenge(6).isRunning ? DC.E2.pow(galaxies).times(DC.E2) : DC.E5.pow(galaxies).times(DC.E25);\n\n      if (galaxies >= this.distantRGStart) {\n        increase = increase.times(DC.E50.pow(galaxies - this.distantRGStart + 5));\n      }\n\n      if (galaxies >= this.remoteRGStart) {\n        increase = increase.times(DC.E5.pow(Math.pow(galaxies - this.remoteRGStart + 1, 2)));\n      }\n\n      return increase;\n    }\n\n    get autobuyerMilestone() {\n      return EternityMilestone.autobuyerReplicantiMaxGalaxies;\n    }\n\n    get extra() {\n      return Effects.max(0, TimeStudy(131)) + PelleRifts.decay.milestones[2].effectOrDefault(0);\n    }\n\n    autobuyerTick() {\n      // This isn't a hot enough autobuyer to worry about doing an actual inverse.\n      const bulk = bulkBuyBinarySearch(Currency.infinityPoints.value, {\n        costFunction: x => this.baseCostAfterCount(x).dividedByEffectOf(TimeStudy(233)),\n        firstCost: this.cost,\n        cumulative: true\n      }, this.value);\n      if (!bulk) return;\n      Currency.infinityPoints.subtract(bulk.purchasePrice);\n      this.value += bulk.quantity;\n      this.baseCost = this.baseCostAfterCount(this.value);\n    }\n\n    baseCostAfterCount(count) {\n      const logBase = 170;\n      const logBaseIncrease = EternityChallenge(6).isRunning ? 2 : 25;\n      const logCostScaling = EternityChallenge(6).isRunning ? 2 : 5;\n      const distantReplicatedGalaxyStart = 100 + Effects.sum(GlyphSacrifice.replication);\n      const remoteReplicatedGalaxyStart = 1000 + Effects.sum(GlyphSacrifice.replication);\n      let logCost = logBase + count * logBaseIncrease + count * (count - 1) / 2 * logCostScaling;\n\n      if (count > distantReplicatedGalaxyStart) {\n        const logDistantScaling = 50; // When distant scaling kicks in, the price increase jumps by a few extra steps.\n        // So, the difference between successive scales goes 5, 5, 5, 255, 55, 55, ...\n\n        const extraIncrements = 5;\n        const numDistant = count - distantReplicatedGalaxyStart;\n        logCost += logDistantScaling * numDistant * (numDistant + 2 * extraIncrements - 1) / 2;\n      }\n\n      if (count > remoteReplicatedGalaxyStart) {\n        const logRemoteScaling = 5;\n        const numRemote = count - remoteReplicatedGalaxyStart; // The formula x * (x + 1) * (2 * x + 1) / 6 is the sum of the first n squares.\n\n        logCost += logRemoteScaling * numRemote * (numRemote + 1) * (2 * numRemote + 1) / 6;\n      }\n\n      return Decimal.pow10(logCost);\n    }\n\n  }()\n};\nexport const Replicanti = {\n  get areUnlocked() {\n    return player.replicanti.unl;\n  },\n\n  reset(force = false) {\n    const unlocked = force ? false : EternityMilestone.unlockReplicanti.isReached;\n    player.replicanti = {\n      unl: unlocked,\n      amount: unlocked ? DC.D1 : DC.D0,\n      timer: 0,\n      chance: 0.01,\n      chanceCost: DC.E150,\n      interval: 1000,\n      intervalCost: DC.E140,\n      boughtGalaxyCap: 0,\n      galaxies: 0,\n      galCost: DC.E170\n    };\n  },\n\n  unlock(freeUnlock = false) {\n    const cost = DC.E140.dividedByEffectOf(PelleRifts.vacuum.milestones[1]);\n    if (player.replicanti.unl) return;\n\n    if (freeUnlock || Currency.infinityPoints.gte(cost)) {\n      if (!freeUnlock) Currency.infinityPoints.subtract(cost);\n      player.replicanti.unl = true;\n      player.replicanti.timer = 0;\n      Replicanti.amount = DC.D1;\n    }\n  },\n\n  get amount() {\n    return player.replicanti.amount;\n  },\n\n  set amount(value) {\n    player.replicanti.amount = value;\n  },\n\n  get chance() {\n    return ReplicantiUpgrade.chance.value;\n  },\n\n  galaxies: {\n    isPlayerHoldingR: false,\n\n    get bought() {\n      return player.replicanti.galaxies;\n    },\n\n    get extra() {\n      return Math.floor((Effects.sum(TimeStudy(225), TimeStudy(226)) + Effarig.bonusRG) * TimeStudy(303).effectOrDefault(1));\n    },\n\n    get total() {\n      return this.bought + this.extra;\n    },\n\n    get max() {\n      return ReplicantiUpgrade.galaxies.value + ReplicantiUpgrade.galaxies.extra;\n    },\n\n    get canBuyMore() {\n      if (!Replicanti.amount.gte(Decimal.NUMBER_MAX_VALUE)) return false;\n      return this.bought < this.max;\n    },\n\n    get areBeingBought() {\n      const buyer = Autobuyer.replicantiGalaxy; // If the confirmation is enabled, we presume the player wants to confirm each Replicanti Galaxy purchase\n\n      return buyer.canTick && buyer.isEnabled || !player.options.confirmations.replicantiGalaxy && this.isPlayerHoldingR;\n    },\n\n    get gain() {\n      if (!this.canBuyMore) return 0;\n\n      if (Achievement(126).isUnlocked) {\n        const maxGain = Replicanti.galaxies.max - player.replicanti.galaxies;\n        const logReplicanti = Replicanti.amount.log10();\n        return Math.min(maxGain, Math.floor(logReplicanti / LOG10_MAX_VALUE));\n      }\n\n      return 1;\n    }\n\n  },\n\n  get isUncapped() {\n    return TimeStudy(192).isBought || PelleRifts.vacuum.milestones[1].canBeApplied;\n  }\n\n};","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/replicanti.js"],"names":["DC","ReplicantiGrowth","scaleLog10","Math","log10","Number","MAX_VALUE","scaleFactor","PelleStrikes","eternity","hasStrike","Replicanti","amount","gte","E2000","Pelle","isDoomed","AlchemyResource","cardinality","effectValue","addReplicantiGalaxies","newGalaxies","player","replicanti","galaxies","requirementChecks","noRG","keepResources","PelleUpgrade","replicantiGalaxyEM40","canBeApplied","EternityMilestone","replicantiNoReset","isReached","dimensionBoosts","softReset","replicantiGalaxy","auto","RealityUpgrade","isLockingMechanics","tryShowWarningModal","canBuyMore","galaxyGain","gain","timer","Achievement","isUnlocked","Decimal","pow10","LOG10_MAX_VALUE","D1","replicantiGalaxyRequest","options","confirmations","Modal","show","fastReplicantiBelow308","log10GainFactor","isAutobuyerActive","shouldBuyRG","uncappedAmount","E1","pow","plus","gt","eq","max","replicantiCap","remainingGain","minus","clampMin","min","gainNeededPerRG","NUMBER_MAX_VALUE","replicantiExponent","toNumber","toBuy","floor","maxUsedGain","clampMax","getReplicantiInterval","overCapOverride","intervalIn","interval","overCap","undefined","TimeStudy","isBought","times","increases","divide","totalReplicantiSpeedMult","V","isRunning","totalMult","PelleRifts","decay","specialGlyphEffect","replication","ShopPurchase","replicantiPurchases","currentMult","isDisabled","preCelestialEffects","Effects","product","Perk","studyPassive","getAdjustedGlyphEffect","GlyphAlteration","isAdded","getSecondaryGlyphEffect","timesEffectsOf","Ra","unlocks","continuousTTBoost","effects","EffarigUnlock","infinity","Currency","infinitiesTotal","value","replicantiLoop","diff","unl","replicantiBeforeLoop","PerformanceStats","start","EventHub","dispatch","GAME_EVENT","REPLICANTI_TICK_BEFORE","isUncapped","areRGsBeingBought","areBeingBought","tickCount","lt","singleTickAvg","chance","postScale","log","LOG10_E","lte","intervalRatio","div","exp","ln","batchTicks","log2","binomialTicks","D2","poissonDistribution","t","reproduced","binomialDistribution","leftover","buyer","Autobuyer","isAuto","canTick","isEnabled","isPlayerHoldingR","records","thisReality","maxReplicanti","REPLICANTI_TICK_AFTER","end","replicantiMult","plusEffectOf","timesEffectOf","ReplicantiUpgradeState","id","NotImplementedError","nextValue","cost","Error","costIncrease","baseCost","cap","isCapped","autobuyerMilestone","canBeBought","infinityPoints","eterc8repl","purchase","subtract","EternityChallenge","GameUI","update","autobuyerTick","ReplicantiUpgrade","ReplicantiChanceUpgrade","nearestPercent","chanceCost","dividedByEffectOf","vacuum","milestones","autobuyerReplicantiChance","N","dividedBy","round","totalCost","x","ReplicantiIntervalUpgrade","intervalCost","autobuyerReplicantiInterval","applyModifiers","ReplicantiGalaxiesUpgrade","boughtGalaxyCap","dividedByEffectsOf","galCost","distantRGStart","sum","GlyphSacrifice","remoteRGStart","increase","E2","E5","E25","E50","autobuyerReplicantiMaxGalaxies","extra","effectOrDefault","bulk","bulkBuyBinarySearch","costFunction","baseCostAfterCount","firstCost","cumulative","purchasePrice","quantity","count","logBase","logBaseIncrease","logCostScaling","distantReplicatedGalaxyStart","remoteReplicatedGalaxyStart","logCost","logDistantScaling","extraIncrements","numDistant","logRemoteScaling","numRemote","areUnlocked","reset","force","unlocked","unlockReplicanti","D0","E150","E140","E170","unlock","freeUnlock","bought","Effarig","bonusRG","total","maxGain","logReplicanti"],"mappings":"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","sourcesContent":["import { DC } from \"./constants\";\r\n\r\n// Slowdown parameters for replicanti growth, interval will increase by scaleFactor for every scaleLog10\r\n// OoM past the cap (default is 308.25 (log10 of 1.8e308), 1.2, Number.MAX_VALUE)\r\nexport const ReplicantiGrowth = {\r\n  get scaleLog10() {\r\n    return Math.log10(Number.MAX_VALUE);\r\n  },\r\n  get scaleFactor() {\r\n    if (PelleStrikes.eternity.hasStrike && Replicanti.amount.gte(DC.E2000)) return 10;\r\n    if (Pelle.isDoomed) return 2;\r\n    return AlchemyResource.cardinality.effectValue;\r\n  }\r\n};\r\n\r\n// Internal function to add RGs; called both from within the fast replicanti code and from the function\r\n// used externally. Only called in cases of automatic RG and does not actually modify replicanti amount\r\nfunction addReplicantiGalaxies(newGalaxies) {\r\n  if (newGalaxies > 0) {\r\n    player.replicanti.galaxies += newGalaxies;\r\n    player.requirementChecks.eternity.noRG = false;\r\n    const keepResources = Pelle.isDoomed\r\n      ? PelleUpgrade.replicantiGalaxyEM40.canBeApplied\r\n      : EternityMilestone.replicantiNoReset.isReached;\r\n    if (!keepResources) {\r\n      player.dimensionBoosts = 0;\r\n      softReset(0, true, true);\r\n    }\r\n  }\r\n}\r\n\r\n// Function called externally for gaining RGs, which adjusts replicanti amount before calling the function\r\n// which actually adds the RG. Called externally both automatically and manually\r\nexport function replicantiGalaxy(auto) {\r\n  if (RealityUpgrade(6).isLockingMechanics) {\r\n    if (!auto) RealityUpgrade(6).tryShowWarningModal();\r\n    return;\r\n  }\r\n  if (!Replicanti.galaxies.canBuyMore) return;\r\n  const galaxyGain = Replicanti.galaxies.gain;\r\n  if (galaxyGain < 1) return;\r\n  player.replicanti.timer = 0;\r\n  Replicanti.amount = Achievement(126).isUnlocked && !Pelle.isDoomed\r\n    ? Decimal.pow10(Replicanti.amount.log10() - LOG10_MAX_VALUE * galaxyGain)\r\n    : DC.D1;\r\n  addReplicantiGalaxies(galaxyGain);\r\n}\r\n\r\n// Only called on manual RG requests\r\nexport function replicantiGalaxyRequest() {\r\n  if (!Replicanti.galaxies.canBuyMore) return;\r\n  if (RealityUpgrade(6).isLockingMechanics) RealityUpgrade(6).tryShowWarningModal();\r\n  else if (player.options.confirmations.replicantiGalaxy) Modal.replicantiGalaxy.show();\r\n  else replicantiGalaxy(false);\r\n}\r\n\r\n// Produces replicanti quickly below e308, will auto-bulk-RG if production is fast enough\r\n// Returns the remaining unused gain factor\r\nfunction fastReplicantiBelow308(log10GainFactor, isAutobuyerActive) {\r\n  const shouldBuyRG = isAutobuyerActive && !RealityUpgrade(6).isLockingMechanics;\r\n  // More than e308 galaxies per tick causes the game to die, and I don't think it's worth the performance hit of\r\n  // Decimalifying the entire calculation.  And yes, this can and does actually happen super-lategame.\r\n  const uncappedAmount = DC.E1.pow(log10GainFactor.plus(Replicanti.amount.log10()));\r\n  // Checking for uncapped equaling zero is because Decimal.pow returns zero for overflow for some reason\r\n  if (log10GainFactor.gt(Number.MAX_VALUE) || uncappedAmount.eq(0)) {\r\n    if (shouldBuyRG) {\r\n      addReplicantiGalaxies(Replicanti.galaxies.max - player.replicanti.galaxies);\r\n    }\r\n    Replicanti.amount = replicantiCap();\r\n    // Basically we've used nothing.\r\n    return log10GainFactor;\r\n  }\r\n\r\n  if (!shouldBuyRG) {\r\n    const remainingGain = log10GainFactor.minus(replicantiCap().log10() - Replicanti.amount.log10()).clampMin(0);\r\n    Replicanti.amount = Decimal.min(uncappedAmount, replicantiCap());\r\n    return remainingGain;\r\n  }\r\n\r\n  const gainNeededPerRG = Decimal.NUMBER_MAX_VALUE.log10();\r\n  const replicantiExponent = log10GainFactor.toNumber() + Replicanti.amount.log10();\r\n  const toBuy = Math.floor(Math.min(replicantiExponent / gainNeededPerRG,\r\n    Replicanti.galaxies.max - player.replicanti.galaxies));\r\n  const maxUsedGain = gainNeededPerRG * toBuy + replicantiCap().log10() - Replicanti.amount.log10();\r\n  const remainingGain = log10GainFactor.minus(maxUsedGain).clampMin(0);\r\n  Replicanti.amount = Decimal.pow10(replicantiExponent - gainNeededPerRG * toBuy)\r\n    .clampMax(replicantiCap());\r\n  addReplicantiGalaxies(toBuy);\r\n  return remainingGain;\r\n}\r\n\r\n// When the amount is exactly the cap, there are two cases: the player can go\r\n// over cap (in which case interval should be as if over cap) or the player\r\n// has just crunched and is still at cap due to \"Is this safe?\" reward\r\n// (in which case interval should be as if not over cap). This is why we have\r\n// the overCapOverride parameter, to tell us which case we are in.\r\nexport function getReplicantiInterval(overCapOverride, intervalIn) {\r\n  let interval = intervalIn || player.replicanti.interval;\r\n  const amount = Replicanti.amount;\r\n  const overCap = overCapOverride === undefined ? amount.gt(replicantiCap()) : overCapOverride;\r\n  interval = new Decimal(interval);\r\n  if ((TimeStudy(133).isBought && !Achievement(138).isUnlocked) || overCap) {\r\n    interval = interval.times(10);\r\n  }\r\n\r\n  if (overCap) {\r\n    let increases = (amount.log10() - replicantiCap().log10()) / ReplicantiGrowth.scaleLog10;\r\n    if (PelleStrikes.eternity.hasStrike && amount.gte(DC.E2000)) {\r\n      // The above code assumes in this case there's 10x scaling for every 1e308 increase;\r\n      // in fact, before e2000 it's only 2x.\r\n      increases -= Math.log10(5) * (2000 - replicantiCap().log10()) / ReplicantiGrowth.scaleLog10;\r\n    }\r\n    interval = interval.times(Decimal.pow(ReplicantiGrowth.scaleFactor, increases));\r\n  }\r\n\r\n  interval = interval.divide(totalReplicantiSpeedMult(overCap));\r\n\r\n  if (V.isRunning) {\r\n    // This is a boost if interval < 1, but that only happens in EC12\r\n    // and handling it would make the replicanti code a lot more complicated.\r\n    interval = interval.pow(2);\r\n  }\r\n  return interval;\r\n}\r\n\r\n// This only counts the \"external\" multipliers - that is, it doesn't count any speed changes due to being over the cap.\r\n// These multipliers are separated out largely for two reasons - more \"dynamic\" multipliers (such as overcap scaling\r\n// and celestial nerfs) interact very weirdly and the game balance relies on this behavior, and we also use this same\r\n// value in the multiplier tab too\r\nexport function totalReplicantiSpeedMult(overCap) {\r\n  let totalMult = DC.D1;\r\n\r\n  // These are the only effects active in Pelle - the function shortcuts everything else if we're in Pelle\r\n  totalMult = totalMult.times(PelleRifts.decay.effectValue);\r\n  totalMult = totalMult.times(Pelle.specialGlyphEffect.replication);\r\n  totalMult = totalMult.times(ShopPurchase.replicantiPurchases.currentMult);\r\n  if (Pelle.isDisabled(\"replicantiIntervalMult\")) return totalMult;\r\n\r\n  const preCelestialEffects = Effects.product(\r\n    TimeStudy(62),\r\n    TimeStudy(213),\r\n    RealityUpgrade(2),\r\n    RealityUpgrade(6),\r\n    RealityUpgrade(23),\r\n  );\r\n  totalMult = totalMult.times(preCelestialEffects);\r\n  if (TimeStudy(132).isBought) {\r\n    totalMult = totalMult.times(Perk.studyPassive.isBought ? 3 : 1.5);\r\n  }\r\n\r\n  if (!overCap && Achievement(134).isUnlocked) {\r\n    totalMult = totalMult.times(2);\r\n  }\r\n  totalMult = totalMult.times(getAdjustedGlyphEffect(\"replicationspeed\"));\r\n  if (GlyphAlteration.isAdded(\"replication\")) {\r\n    totalMult = totalMult.times(\r\n      Math.clampMin(Decimal.log10(Replicanti.amount) * getSecondaryGlyphEffect(\"replicationdtgain\"), 1));\r\n  }\r\n  totalMult = totalMult.timesEffectsOf(AlchemyResource.replication, Ra.unlocks.continuousTTBoost.effects.replicanti);\r\n\r\n  return totalMult;\r\n}\r\n\r\nexport function replicantiCap() {\r\n  return EffarigUnlock.infinity.canBeApplied\r\n    ? Currency.infinitiesTotal.value\r\n      .pow(TimeStudy(31).isBought ? 120 : 30)\r\n      .clampMin(1)\r\n      .times(Decimal.NUMBER_MAX_VALUE)\r\n    : Decimal.NUMBER_MAX_VALUE;\r\n}\r\n\r\n// eslint-disable-next-line complexity\r\nexport function replicantiLoop(diff) {\r\n  if (!player.replicanti.unl) return;\r\n  const replicantiBeforeLoop = Replicanti.amount;\r\n  PerformanceStats.start(\"Replicanti\");\r\n  EventHub.dispatch(GAME_EVENT.REPLICANTI_TICK_BEFORE);\r\n  // This gets the pre-cap interval (above the cap we recalculate the interval).\r\n  const interval = getReplicantiInterval(false);\r\n  const isUncapped = Replicanti.isUncapped;\r\n  const areRGsBeingBought = Replicanti.galaxies.areBeingBought;\r\n\r\n  // Figure out how many ticks to calculate for and roll over any leftover time to the next tick. The rollover\r\n  // calculation is skipped if there's more than 100 replicanti ticks per game tick to reduce round-off problems.\r\n  let tickCount = Decimal.divide(diff + player.replicanti.timer, interval);\r\n  if (tickCount.lt(100)) player.replicanti.timer = tickCount.minus(tickCount.floor()).times(interval).toNumber();\r\n  else player.replicanti.timer = 0;\r\n  tickCount = tickCount.floor();\r\n\r\n  const singleTickAvg = Replicanti.amount.times(player.replicanti.chance);\r\n  // Note that code inside this conditional won't necessarily run every game tick; when game ticks are slower than\r\n  // replicanti ticks, then tickCount will look like [0, 0, 0, 1, 0, 0, ...] on successive game ticks\r\n  if (tickCount.gte(100) || (singleTickAvg.gte(10) && tickCount.gte(1))) {\r\n    // Fast gain: If we're doing a very large number of ticks or each tick produces a lot, then continuous growth\r\n    // every replicanti tick is a good approximation and less intensive than distribution samples. This path will\r\n    // always happen above 1000 replicanti due to how singleTickAvg is calculated, so the over-cap math is only\r\n    // present on this path\r\n    let postScale = Math.log10(ReplicantiGrowth.scaleFactor) / ReplicantiGrowth.scaleLog10;\r\n    if (V.isRunning) {\r\n      postScale *= 2;\r\n    }\r\n\r\n    // Note that remainingGain is in log10 terms.\r\n    let remainingGain = tickCount.times(Math.log(player.replicanti.chance + 1)).times(LOG10_E);\r\n    // It is intended to be possible for both of the below conditionals to trigger.\r\n    if (!isUncapped || Replicanti.amount.lte(replicantiCap())) {\r\n      // Some of the gain is \"used up\" below e308, but if replicanti are uncapped\r\n      // then some may be \"left over\" for increasing replicanti beyond their cap.\r\n      remainingGain = fastReplicantiBelow308(remainingGain, areRGsBeingBought);\r\n    }\r\n    if (isUncapped && Replicanti.amount.gte(replicantiCap()) && remainingGain.gt(0)) {\r\n      // Recalculate the interval (it may have increased due to additional replicanti, or,\r\n      // far less importantly, decreased due to Reality Upgrade 6 and additional RG).\r\n      // Don't worry here about the lack of e2000 scaling in Pelle on the first tick\r\n      // (with replicanti still under e2000) causing a huge replicanti jump;\r\n      // there's code later to stop replicanti from increasing by more than e308\r\n      // in a single tick in Pelle.\r\n      const intervalRatio = getReplicantiInterval(true).div(interval);\r\n      remainingGain = remainingGain.div(intervalRatio);\r\n      Replicanti.amount =\r\n        Decimal.exp(remainingGain.div(LOG10_E).times(postScale).plus(1).ln() / postScale +\r\n        Replicanti.amount.clampMin(1).ln());\r\n    }\r\n  } else if (tickCount.gt(1)) {\r\n    // Multiple ticks but \"slow\" gain: This happens at low replicanti chance and amount with a fast interval, which\r\n    // can happen often in early cel7. In this case we \"batch\" ticks together as full doubling events and then draw\r\n    // from a Poisson distribution for how many times to do that. Any leftover ticks are used as binomial samples\r\n    const batchTicks = Math.floor(tickCount.toNumber() * Math.log2(1 + player.replicanti.chance));\r\n    const binomialTicks = tickCount.toNumber() - batchTicks / Math.log2(1 + player.replicanti.chance);\r\n\r\n    Replicanti.amount = Replicanti.amount.times(DC.D2.pow(poissonDistribution(batchTicks)));\r\n    for (let t = 0; t < Math.floor(binomialTicks); t++) {\r\n      const reproduced = binomialDistribution(Replicanti.amount, player.replicanti.chance);\r\n      Replicanti.amount = Replicanti.amount.plus(reproduced);\r\n    }\r\n\r\n    // The batching might use partial ticks; we add the rest back to the timer so it gets used next loop\r\n    const leftover = binomialTicks - Math.floor(binomialTicks);\r\n    player.replicanti.timer += interval.times(leftover).toNumber();\r\n  } else if (tickCount.eq(1)) {\r\n    // Single tick: Take a single binomial sample to properly simulate replicanti growth with randomness\r\n    const reproduced = binomialDistribution(Replicanti.amount, player.replicanti.chance);\r\n    Replicanti.amount = Replicanti.amount.plus(reproduced);\r\n  }\r\n\r\n  if (!isUncapped) Replicanti.amount = Decimal.min(replicantiCap(), Replicanti.amount);\r\n\r\n  if (Pelle.isDoomed && Replicanti.amount.log10() - replicantiBeforeLoop.log10() > 308) {\r\n    Replicanti.amount = replicantiBeforeLoop.times(1e308);\r\n  }\r\n\r\n  if (areRGsBeingBought && Replicanti.amount.gte(Decimal.NUMBER_MAX_VALUE)) {\r\n    const buyer = Autobuyer.replicantiGalaxy;\r\n    const isAuto = buyer.canTick && buyer.isEnabled;\r\n    // There might be a manual and auto tick simultaneously; pass auto === true iff the autobuyer is ticking and\r\n    // we aren't attempting to manually buy RG, because this controls modals appearing or not\r\n    replicantiGalaxy(isAuto && !Replicanti.galaxies.isPlayerHoldingR);\r\n  }\r\n  player.records.thisReality.maxReplicanti = player.records.thisReality.maxReplicanti\r\n    .clampMin(Replicanti.amount);\r\n  EventHub.dispatch(GAME_EVENT.REPLICANTI_TICK_AFTER);\r\n  PerformanceStats.end();\r\n}\r\n\r\nexport function replicantiMult() {\r\n  return Decimal.pow(Decimal.log2(Replicanti.amount.clampMin(1)), 2)\r\n    .plusEffectOf(TimeStudy(21))\r\n    .timesEffectOf(TimeStudy(102))\r\n    .clampMin(1)\r\n    .pow(getAdjustedGlyphEffect(\"replicationpow\"));\r\n}\r\n\r\n/** @abstract */\r\nclass ReplicantiUpgradeState {\r\n  /** @abstract */\r\n  get id() { throw new NotImplementedError(); }\r\n  /** @abstract */\r\n  get value() { throw new NotImplementedError(); }\r\n\r\n  /** @abstract */\r\n  set value(value) { throw new NotImplementedError(); }\r\n\r\n  /** @abstract */\r\n  get nextValue() { throw new NotImplementedError(); }\r\n\r\n  /** @abstract */\r\n  get cost() { throw new NotImplementedError(); }\r\n  /** @abstract */\r\n  set cost(value) { throw new Error(\"Use baseCost to set cost\"); }\r\n\r\n  /** @abstract */\r\n  get costIncrease() { throw new NotImplementedError(); }\r\n\r\n  get baseCost() { return this.cost; }\r\n  /** @abstract */\r\n  set baseCost(value) { throw new NotImplementedError(); }\r\n\r\n  get cap() { return undefined; }\r\n  get isCapped() { return false; }\r\n\r\n  /** @abstract */\r\n  get autobuyerMilestone() { throw new NotImplementedError(); }\r\n\r\n  get canBeBought() {\r\n    return !this.isCapped && Currency.infinityPoints.gte(this.cost) && player.eterc8repl !== 0;\r\n  }\r\n\r\n  purchase() {\r\n    if (!this.canBeBought) return;\r\n    Currency.infinityPoints.subtract(this.cost);\r\n    this.baseCost = Decimal.times(this.baseCost, this.costIncrease);\r\n    this.value = this.nextValue;\r\n    if (EternityChallenge(8).isRunning) player.eterc8repl--;\r\n    GameUI.update();\r\n  }\r\n\r\n  autobuyerTick() {\r\n    while (this.canBeBought) {\r\n      this.purchase();\r\n    }\r\n  }\r\n}\r\n\r\nexport const ReplicantiUpgrade = {\r\n  chance: new class ReplicantiChanceUpgrade extends ReplicantiUpgradeState {\r\n    get id() { return 1; }\r\n\r\n    get value() { return player.replicanti.chance; }\r\n    set value(value) { player.replicanti.chance = value; }\r\n\r\n    get nextValue() {\r\n      return this.nearestPercent(this.value + 0.01);\r\n    }\r\n\r\n    get cost() {\r\n      return player.replicanti.chanceCost.dividedByEffectOf(PelleRifts.vacuum.milestones[1]);\r\n    }\r\n\r\n    get baseCost() { return player.replicanti.chanceCost; }\r\n    set baseCost(value) { player.replicanti.chanceCost = value; }\r\n\r\n    get costIncrease() { return 1e15; }\r\n\r\n    get cap() {\r\n      // Chance never goes over 100%.\r\n      return 1;\r\n    }\r\n\r\n    get isCapped() {\r\n      return this.nearestPercent(this.value) >= this.cap;\r\n    }\r\n\r\n    get autobuyerMilestone() {\r\n      return EternityMilestone.autobuyerReplicantiChance;\r\n    }\r\n\r\n    autobuyerTick() {\r\n      // Fixed price increase of 1e15; so total cost for N upgrades is:\r\n      // cost + cost * 1e15 + cost * 1e30 + ... + cost * 1e15^(N-1) == cost * (1e15^N - 1) / (1e15 - 1)\r\n      // N = log(IP * (1e15 - 1) / cost + 1) / log(1e15)\r\n      let N = Currency.infinityPoints.value.times(this.costIncrease - 1)\r\n        .dividedBy(this.cost).plus(1).log(this.costIncrease);\r\n      N = Math.round((Math.min(this.value + 0.01 * Math.floor(N), this.cap) - this.value) * 100);\r\n      if (N <= 0) return;\r\n      const totalCost = this.cost.times(Decimal.pow(this.costIncrease, N).minus(1).dividedBy(this.costIncrease - 1));\r\n      Currency.infinityPoints.subtract(totalCost);\r\n      this.baseCost = this.baseCost.times(Decimal.pow(this.costIncrease, N));\r\n      this.value = this.nearestPercent(this.value + 0.01 * N);\r\n    }\r\n\r\n    // Rounding errors suck\r\n    nearestPercent(x) {\r\n      return Math.round(100 * x) / 100;\r\n    }\r\n  }(),\r\n  interval: new class ReplicantiIntervalUpgrade extends ReplicantiUpgradeState {\r\n    get id() { return 2; }\r\n\r\n    get value() { return player.replicanti.interval; }\r\n    set value(value) { player.replicanti.interval = value; }\r\n\r\n    get nextValue() {\r\n      return Math.max(this.value * 0.9, this.cap);\r\n    }\r\n\r\n    get cost() {\r\n      return player.replicanti.intervalCost.dividedByEffectOf(PelleRifts.vacuum.milestones[1]);\r\n    }\r\n\r\n    get baseCost() { return player.replicanti.intervalCost; }\r\n    set baseCost(value) { player.replicanti.intervalCost = value; }\r\n\r\n    get costIncrease() { return 1e10; }\r\n\r\n    get cap() {\r\n      return Effects.min(50, TimeStudy(22));\r\n    }\r\n\r\n    get isCapped() {\r\n      return this.value <= this.cap;\r\n    }\r\n\r\n    get autobuyerMilestone() {\r\n      return EternityMilestone.autobuyerReplicantiInterval;\r\n    }\r\n\r\n    applyModifiers(value) {\r\n      return getReplicantiInterval(undefined, value);\r\n    }\r\n  }(),\r\n  galaxies: new class ReplicantiGalaxiesUpgrade extends ReplicantiUpgradeState {\r\n    get id() { return 3; }\r\n\r\n    get value() { return player.replicanti.boughtGalaxyCap; }\r\n    set value(value) { player.replicanti.boughtGalaxyCap = value; }\r\n\r\n    get nextValue() {\r\n      return this.value + 1;\r\n    }\r\n\r\n    get cost() {\r\n      return this.baseCost.dividedByEffectsOf(TimeStudy(233), PelleRifts.vacuum.milestones[1]);\r\n    }\r\n\r\n    get baseCost() { return player.replicanti.galCost; }\r\n    set baseCost(value) { player.replicanti.galCost = value; }\r\n\r\n    get distantRGStart() {\r\n      return 100 + Effects.sum(GlyphSacrifice.replication);\r\n    }\r\n\r\n    get remoteRGStart() {\r\n      return 1000 + Effects.sum(GlyphSacrifice.replication);\r\n    }\r\n\r\n    get costIncrease() {\r\n      const galaxies = this.value;\r\n      let increase = EternityChallenge(6).isRunning\r\n        ? DC.E2.pow(galaxies).times(DC.E2)\r\n        : DC.E5.pow(galaxies).times(DC.E25);\r\n      if (galaxies >= this.distantRGStart) {\r\n        increase = increase.times(DC.E50.pow(galaxies - this.distantRGStart + 5));\r\n      }\r\n      if (galaxies >= this.remoteRGStart) {\r\n        increase = increase.times(DC.E5.pow(Math.pow(galaxies - this.remoteRGStart + 1, 2)));\r\n      }\r\n      return increase;\r\n    }\r\n\r\n    get autobuyerMilestone() {\r\n      return EternityMilestone.autobuyerReplicantiMaxGalaxies;\r\n    }\r\n\r\n    get extra() {\r\n      return Effects.max(0, TimeStudy(131)) + PelleRifts.decay.milestones[2].effectOrDefault(0);\r\n    }\r\n\r\n    autobuyerTick() {\r\n      // This isn't a hot enough autobuyer to worry about doing an actual inverse.\r\n      const bulk = bulkBuyBinarySearch(Currency.infinityPoints.value, {\r\n        costFunction: x => this.baseCostAfterCount(x).dividedByEffectOf(TimeStudy(233)),\r\n        firstCost: this.cost,\r\n        cumulative: true,\r\n      }, this.value);\r\n      if (!bulk) return;\r\n      Currency.infinityPoints.subtract(bulk.purchasePrice);\r\n      this.value += bulk.quantity;\r\n      this.baseCost = this.baseCostAfterCount(this.value);\r\n    }\r\n\r\n    baseCostAfterCount(count) {\r\n      const logBase = 170;\r\n      const logBaseIncrease = EternityChallenge(6).isRunning ? 2 : 25;\r\n      const logCostScaling = EternityChallenge(6).isRunning ? 2 : 5;\r\n      const distantReplicatedGalaxyStart = 100 + Effects.sum(GlyphSacrifice.replication);\r\n      const remoteReplicatedGalaxyStart = 1000 + Effects.sum(GlyphSacrifice.replication);\r\n      let logCost = logBase + count * logBaseIncrease + (count * (count - 1) / 2) * logCostScaling;\r\n      if (count > distantReplicatedGalaxyStart) {\r\n        const logDistantScaling = 50;\r\n        // When distant scaling kicks in, the price increase jumps by a few extra steps.\r\n        // So, the difference between successive scales goes 5, 5, 5, 255, 55, 55, ...\r\n        const extraIncrements = 5;\r\n        const numDistant = count - distantReplicatedGalaxyStart;\r\n        logCost += logDistantScaling * numDistant * (numDistant + 2 * extraIncrements - 1) / 2;\r\n      }\r\n      if (count > remoteReplicatedGalaxyStart) {\r\n        const logRemoteScaling = 5;\r\n        const numRemote = count - remoteReplicatedGalaxyStart;\r\n        // The formula x * (x + 1) * (2 * x + 1) / 6 is the sum of the first n squares.\r\n        logCost += logRemoteScaling * numRemote * (numRemote + 1) * (2 * numRemote + 1) / 6;\r\n      }\r\n      return Decimal.pow10(logCost);\r\n    }\r\n  }(),\r\n};\r\n\r\nexport const Replicanti = {\r\n  get areUnlocked() {\r\n    return player.replicanti.unl;\r\n  },\r\n  reset(force = false) {\r\n    const unlocked = force ? false : EternityMilestone.unlockReplicanti.isReached;\r\n    player.replicanti = {\r\n      unl: unlocked,\r\n      amount: unlocked ? DC.D1 : DC.D0,\r\n      timer: 0,\r\n      chance: 0.01,\r\n      chanceCost: DC.E150,\r\n      interval: 1000,\r\n      intervalCost: DC.E140,\r\n      boughtGalaxyCap: 0,\r\n      galaxies: 0,\r\n      galCost: DC.E170,\r\n    };\r\n  },\r\n  unlock(freeUnlock = false) {\r\n    const cost = DC.E140.dividedByEffectOf(PelleRifts.vacuum.milestones[1]);\r\n    if (player.replicanti.unl) return;\r\n    if (freeUnlock || Currency.infinityPoints.gte(cost)) {\r\n      if (!freeUnlock) Currency.infinityPoints.subtract(cost);\r\n      player.replicanti.unl = true;\r\n      player.replicanti.timer = 0;\r\n      Replicanti.amount = DC.D1;\r\n    }\r\n  },\r\n  get amount() {\r\n    return player.replicanti.amount;\r\n  },\r\n  set amount(value) {\r\n    player.replicanti.amount = value;\r\n  },\r\n  get chance() {\r\n    return ReplicantiUpgrade.chance.value;\r\n  },\r\n  galaxies: {\r\n    isPlayerHoldingR: false,\r\n    get bought() {\r\n      return player.replicanti.galaxies;\r\n    },\r\n    get extra() {\r\n      return Math.floor((Effects.sum(\r\n        TimeStudy(225),\r\n        TimeStudy(226)\r\n      ) + Effarig.bonusRG) * TimeStudy(303).effectOrDefault(1));\r\n    },\r\n    get total() {\r\n      return this.bought + this.extra;\r\n    },\r\n    get max() {\r\n      return ReplicantiUpgrade.galaxies.value + ReplicantiUpgrade.galaxies.extra;\r\n    },\r\n    get canBuyMore() {\r\n      if (!Replicanti.amount.gte(Decimal.NUMBER_MAX_VALUE)) return false;\r\n      return this.bought < this.max;\r\n    },\r\n    get areBeingBought() {\r\n      const buyer = Autobuyer.replicantiGalaxy;\r\n      // If the confirmation is enabled, we presume the player wants to confirm each Replicanti Galaxy purchase\r\n      return (buyer.canTick && buyer.isEnabled) ||\r\n        (!player.options.confirmations.replicantiGalaxy && this.isPlayerHoldingR);\r\n    },\r\n    get gain() {\r\n      if (!this.canBuyMore) return 0;\r\n      if (Achievement(126).isUnlocked) {\r\n        const maxGain = Replicanti.galaxies.max - player.replicanti.galaxies;\r\n        const logReplicanti = Replicanti.amount.log10();\r\n        return Math.min(maxGain, Math.floor(logReplicanti / LOG10_MAX_VALUE));\r\n      }\r\n      return 1;\r\n    },\r\n  },\r\n  get isUncapped() {\r\n    return TimeStudy(192).isBought || PelleRifts.vacuum.milestones[1].canBeApplied;\r\n  }\r\n};\r\n"]},"metadata":{},"sourceType":"module"}