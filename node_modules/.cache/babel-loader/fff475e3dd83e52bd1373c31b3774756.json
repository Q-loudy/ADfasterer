{"ast":null,"code":"/**\r\n * Async is used for making a big pile of computation into a manageable\r\n * set of batches that don't lock up the UI.\r\n * run() is the nominal entry point.\r\n */\nwindow.Async = {\n  _enabled: true,\n\n  get enabled() {\n    return this._enabled;\n  },\n\n  set enabled(val) {\n    this._enabled = val;\n  },\n\n  runForTime(fun, maxIter, config) {\n    const batchSize = config.batchSize || 1;\n    const maxTime = config.maxTime;\n    const t0 = Date.now();\n\n    for (let remaining = maxIter; remaining > 0;) {\n      for (let j = 0; j < Math.min(remaining, batchSize); ++j) {\n        fun(remaining);\n        --remaining;\n      }\n\n      if (Date.now() - t0 >= maxTime) return remaining;\n    }\n\n    return 0;\n  },\n\n  sleepPromise: ms => new Promise(resolve => setTimeout(resolve, ms)),\n\n  /**\r\n   * Asynchronously run the specified function maxIter times, letting the event\r\n   * loop run periodically. The function is run in chunks of config.batchSize;\r\n   * when the elapsed time reaches a specified amount, execution will pause for\r\n   * config.sleepTime\r\n   * @param {function} fun Function to run (e.g. do some computation)\r\n   * @param {number} maxIter Total number of times to run the function\r\n   * @param {Object} config Options for how to do the calculation\r\n   * @param {Number} config.maxTime Max time, ms, over which to run continuously\r\n   * @param {Number} [config.batchSize] Number of times to run fun between time checks. Since Date.now() takes\r\n   *    non-zero time to execute, you don't necessarily want to check every iteration\r\n   * @param {Number} [config.sleepTime] Amount of time to suspend between computing\r\n   * @param {function(Number)} [config.asyncEntry] IF CALCULATION ISN'T DONE IN ONE BATCH, then this\r\n   *    gets called before the first sleep. Use this to set up a progress bar, for example. The function will\r\n   *    get passed the number of iterations run so far.\r\n   * @param {function(Number)} [config.asyncProgress] Called after the second and subsequent batches, with the\r\n   *    total number of iterations done thus far\r\n   * @param {function} [config.asyncExit] If more than one batch was done, this will be called. For example, can\r\n   *    be used to hide a progress bar.\r\n   * @param {function} [config.then] Run after everything is done\r\n   * @returns {Promise|undefined}\r\n   */\n  run(fun, maxIter, config) {\n    if (this.enabled) {\n      // Disable async if we're already doing async\n      this.enabled = false;\n\n      const runResult = this._run(fun, maxIter, config);\n\n      return config.then ? runResult.then(() => {\n        config.then();\n        this.enabled = true;\n      }) : runResult;\n    }\n\n    for (let i = 0; i < maxIter; ++i) {\n      fun(i);\n    }\n\n    if (config.then) config.then();\n  },\n\n  /**\r\n   * @private\r\n   */\n  async _run(fun, maxIter, config) {\n    if (!config.progress) config.progress = {}; // We need to use config.progress variables because something else could change them\n    // (e.g. someone speeding up offline progress)\n\n    config.progress.maxIter = maxIter;\n    config.progress.remaining = this.runForTime(fun, config.progress.maxIter, config);\n    const sleepTime = config.sleepTime || 1;\n    if (!config.progress.remaining) return;\n    if (config.asyncEntry) config.asyncEntry(config.progress.maxIter - config.progress.remaining);\n\n    do {\n      await this.sleepPromise(sleepTime);\n      config.progress.remaining = this.runForTime(fun, config.progress.remaining, config);\n      if (config.asyncProgress) config.asyncProgress(config.progress.maxIter - config.progress.remaining);\n    } while (config.progress.remaining > 0);\n\n    if (config.asyncExit) config.asyncExit();\n  }\n\n};","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/async-utils.js"],"names":["window","Async","_enabled","enabled","val","runForTime","fun","maxIter","config","batchSize","maxTime","t0","Date","now","remaining","j","Math","min","sleepPromise","ms","Promise","resolve","setTimeout","run","runResult","_run","then","i","progress","sleepTime","asyncEntry","asyncProgress","asyncExit"],"mappings":"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","sourcesContent":["/**\r\n * Async is used for making a big pile of computation into a manageable\r\n * set of batches that don't lock up the UI.\r\n * run() is the nominal entry point.\r\n */\r\nwindow.Async = {\r\n  _enabled: true,\r\n  get enabled() {\r\n    return this._enabled;\r\n  },\r\n  set enabled(val) {\r\n    this._enabled = val;\r\n  },\r\n  runForTime(fun, maxIter, config) {\r\n    const batchSize = config.batchSize || 1;\r\n    const maxTime = config.maxTime;\r\n    const t0 = Date.now();\r\n    for (let remaining = maxIter; remaining > 0;) {\r\n      for (let j = 0; j < Math.min(remaining, batchSize); ++j) {\r\n        fun(remaining);\r\n        --remaining;\r\n      }\r\n      if (Date.now() - t0 >= maxTime) return remaining;\r\n    }\r\n    return 0;\r\n  },\r\n  sleepPromise: ms => new Promise(resolve => setTimeout(resolve, ms)),\r\n  /**\r\n   * Asynchronously run the specified function maxIter times, letting the event\r\n   * loop run periodically. The function is run in chunks of config.batchSize;\r\n   * when the elapsed time reaches a specified amount, execution will pause for\r\n   * config.sleepTime\r\n   * @param {function} fun Function to run (e.g. do some computation)\r\n   * @param {number} maxIter Total number of times to run the function\r\n   * @param {Object} config Options for how to do the calculation\r\n   * @param {Number} config.maxTime Max time, ms, over which to run continuously\r\n   * @param {Number} [config.batchSize] Number of times to run fun between time checks. Since Date.now() takes\r\n   *    non-zero time to execute, you don't necessarily want to check every iteration\r\n   * @param {Number} [config.sleepTime] Amount of time to suspend between computing\r\n   * @param {function(Number)} [config.asyncEntry] IF CALCULATION ISN'T DONE IN ONE BATCH, then this\r\n   *    gets called before the first sleep. Use this to set up a progress bar, for example. The function will\r\n   *    get passed the number of iterations run so far.\r\n   * @param {function(Number)} [config.asyncProgress] Called after the second and subsequent batches, with the\r\n   *    total number of iterations done thus far\r\n   * @param {function} [config.asyncExit] If more than one batch was done, this will be called. For example, can\r\n   *    be used to hide a progress bar.\r\n   * @param {function} [config.then] Run after everything is done\r\n   * @returns {Promise|undefined}\r\n   */\r\n  run(fun, maxIter, config) {\r\n    if (this.enabled) {\r\n      // Disable async if we're already doing async\r\n      this.enabled = false;\r\n      const runResult = this._run(fun, maxIter, config);\r\n      return config.then ? runResult.then(() => {\r\n        config.then();\r\n        this.enabled = true;\r\n      }) : runResult;\r\n    }\r\n    for (let i = 0; i < maxIter; ++i) {\r\n      fun(i);\r\n    }\r\n    if (config.then) config.then();\r\n  },\r\n  /**\r\n   * @private\r\n   */\r\n  async _run(fun, maxIter, config) {\r\n    if (!config.progress) config.progress = {};\r\n    // We need to use config.progress variables because something else could change them\r\n    // (e.g. someone speeding up offline progress)\r\n    config.progress.maxIter = maxIter;\r\n    config.progress.remaining = this.runForTime(fun, config.progress.maxIter, config);\r\n    const sleepTime = config.sleepTime || 1;\r\n    if (!config.progress.remaining) return;\r\n    if (config.asyncEntry) config.asyncEntry(config.progress.maxIter - config.progress.remaining);\r\n    do {\r\n      await this.sleepPromise(sleepTime);\r\n      config.progress.remaining = this.runForTime(fun, config.progress.remaining, config);\r\n      if (config.asyncProgress) config.asyncProgress(config.progress.maxIter - config.progress.remaining);\r\n    } while (config.progress.remaining > 0);\r\n    if (config.asyncExit) config.asyncExit();\r\n  }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}