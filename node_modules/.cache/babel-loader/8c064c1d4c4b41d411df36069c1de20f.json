{"ast":null,"code":"import \"core-js/modules/web.dom-collections.iterator.js\";\nimport { CELESTIAL_NAV_DRAW_ORDER } from \"../navigation\";\n\nfunction sigilProgress() {\n  const riftProgress = PelleRifts.all.map(r => Math.clamp(r.realPercentage, 0, 1)).min();\n  const generatorProgress = Math.log10(1 + GalaxyGenerator.generatedGalaxies) / 11;\n  return Math.clampMax(0.2 * riftProgress + 0.8 * generatorProgress, 1);\n} // Determines styling, overall visibility, and placement/scaling of the sigil. Center and size are defined such that\n// keeping the sigil within internal coordinates of ±1 will keep the sigil within a ±size box of the center coordinates\n\n\nconst SigilAttributes = {\n  visible: () => PelleRifts.all.map(r => Math.clamp(r.realPercentage, 0, 1)).min() > 0,\n  center: new Vector(400, 300),\n  size: 400,\n  color: \"#00ffff\",\n  canvasLayer: CELESTIAL_NAV_DRAW_ORDER.NODE_BG - 500\n};\n\nfunction scaledPos(x, y) {\n  const att = SigilAttributes;\n  return new Vector(att.center.x + att.size * x, att.center.y + att.size * y);\n} // Reflects a vector across the vertical line down the center of the sigil bounding box. Used to take advantage of the\n// sigil having vertical symmetry, allowing us to cut down on hardcoded specifications by half\n\n\nfunction reflectAcrossVertical(vec) {\n  return new Vector(2 * SigilAttributes.center.x - vec.x, vec.y);\n}\n/**\r\n * Method to make an appropriately-formatted entry to be fed into the navigation code\r\n *\r\n * @member {String} type  String specifying the actual shape of the element to be drawn; must be \"line\" or \"circle\"\r\n * @member {Object} att   Object whose props list out attributes of the shape to be drawn:\r\n *  Line  : start and end, specifying the two endpoints to draw between.\r\n *  Circle: center and radius to specify the circle path, initAngle and finalAngle to specify an arc segment to draw.\r\n *    0 is rightward and positive angles draw clockwise. Note that making finalAngle-initialAngle a multiple of 2pi\r\n *    will cause curve decomposition errors in the curve-drawing code.\r\n * @member {Object} fill  Object specifying a segment for the fill as a fraction of the total sigil filling progress.\r\n *  Each particular segment will fill from 0% to 100% within the range init to init+weight, without over/underfilling.\r\n * @member {String} colorOverride Color to use for rendering the element, used instead of SigilAttributes.color\r\n */\n// eslint-disable-next-line max-params\n\n\nfunction sigilShape(type, att, fill, colorOverride) {\n  let pos, path, pathStart, pathEnd;\n\n  switch (type) {\n    case \"edge\":\n      pos = att.start;\n      path = new LinearPath(att.start, att.end);\n      pathStart = 0;\n      pathEnd = 1;\n      break;\n\n    case \"circle\":\n      pos = att.center;\n      path = LogarithmicSpiral.fromPolarEndpoints(att.center, 0, att.radius * SigilAttributes.size, 1, att.radius * SigilAttributes.size);\n      pathStart = att.initAngle;\n      pathEnd = att.finalAngle;\n      break;\n\n    default:\n      throw Error(\"Unrecognized shape in sigil specification\");\n  }\n\n  return {\n    visible: () => SigilAttributes.visible() && sigilProgress() >= fill.init,\n    complete: () => Math.clamp((sigilProgress() - fill.init) / fill.weight, 0, 1),\n    // Note that att and fill aren't used in navigation rendering, but including them here massively simplifies the\n    // sigil reflection logic\n    att,\n    fill,\n    node: {\n      position: pos,\n      ring: {\n        rMajor: 0\n      }\n    },\n    connector: {\n      pathStart,\n      pathEnd,\n      drawOrder: SigilAttributes.canvasLayer,\n      path,\n      fill: colorOverride !== null && colorOverride !== void 0 ? colorOverride : SigilAttributes.color,\n      completeWidth: SigilAttributes.size / 20,\n      noBG: true\n    }\n  };\n} // These coordinates should generally be kept within ±1; if the sigil needs to be larger then that should be changed in\n// the SigilAttribute object instead. Naming conventions for this sigil use smaller numbers to denote nodes generally\n// closer to the center line (whether by distance or path length), whereas abbreviated words are used to describe\n// vertical position. C denotes horizontal center points.\n\n\nconst Positions = Object.freeze({\n  circTop: scaledPos(0.333, -0.41),\n  circMid: scaledPos(0.5, 0.22),\n  circBot: scaledPos(0, 0.43),\n  topC: scaledPos(0, -0.4),\n  top1: scaledPos(0.08, -0.27),\n  top2: scaledPos(0.18, -0.35),\n  top3: scaledPos(0.28, -0.35),\n  mid: scaledPos(0.08, 0.05),\n  arm1: scaledPos(0.5, 0.05),\n  arm2: scaledPos(0.5, -0.15),\n  arm3: scaledPos(0.4, -0.15),\n  lowC: scaledPos(0, 0.22),\n  low1: scaledPos(0.42, 0.22),\n  botC: scaledPos(0, 0.31),\n  bot1: scaledPos(0.12, 0.43),\n  bot2: scaledPos(0.28, 0.43)\n}); // List of specified primitive graphics elements with which to construct the sigil; see docstring of sigilShape\n// for description of proper attribute specifications\n\nconst Shapes = {\n  botCircR: sigilShape(\"circle\", {\n    center: Positions.circBot,\n    radius: 0.12,\n    initAngle: 0.5 * Math.PI,\n    finalAngle: -0.5 * Math.PI\n  }, {\n    init: 0,\n    weight: 0.2\n  }),\n  botH: sigilShape(\"edge\", {\n    start: Positions.bot1,\n    end: Positions.bot2\n  }, {\n    init: 0.1,\n    weight: 0.1\n  }),\n  lowH: sigilShape(\"edge\", {\n    start: Positions.lowC,\n    end: Positions.low1\n  }, {\n    init: 0.3,\n    weight: 0.3\n  }),\n  circUp: sigilShape(\"circle\", {\n    center: Positions.circMid,\n    radius: 0.08,\n    initAngle: Math.PI,\n    finalAngle: 0\n  }, {\n    init: 0.6,\n    weight: 0.1\n  }),\n  circDown: sigilShape(\"circle\", {\n    center: Positions.circMid,\n    radius: 0.08,\n    initAngle: Math.PI,\n    finalAngle: 2 * Math.PI\n  }, {\n    init: 0.6,\n    weight: 0.1\n  }),\n  vert2: sigilShape(\"edge\", {\n    start: Positions.bot2,\n    end: Positions.top3\n  }, {\n    init: 0.2,\n    weight: 0.7\n  }),\n  vertC: sigilShape(\"edge\", {\n    start: Positions.botC,\n    end: Positions.lowC\n  }, {\n    init: 0.2,\n    weight: 0.1\n  }),\n  vertDiag1: sigilShape(\"edge\", {\n    start: Positions.lowC,\n    end: Positions.mid\n  }, {\n    init: 0.3,\n    weight: 0.1\n  }),\n  arm1: sigilShape(\"edge\", {\n    start: Positions.mid,\n    end: Positions.arm1\n  }, {\n    init: 0.4,\n    weight: 0.2\n  }),\n  arm2: sigilShape(\"edge\", {\n    start: Positions.arm1,\n    end: Positions.arm2\n  }, {\n    init: 0.6,\n    weight: 0.1\n  }),\n  arm3: sigilShape(\"edge\", {\n    start: Positions.arm2,\n    end: Positions.arm3\n  }, {\n    init: 0.7,\n    weight: 0.1\n  }),\n  vert1: sigilShape(\"edge\", {\n    start: Positions.mid,\n    end: Positions.top1\n  }, {\n    init: 0.4,\n    weight: 0.3\n  }),\n  vertDiag2: sigilShape(\"edge\", {\n    start: Positions.top1,\n    end: Positions.topC\n  }, {\n    init: 0.7,\n    weight: 0.1\n  }),\n  vertDiag3: sigilShape(\"edge\", {\n    start: Positions.top1,\n    end: Positions.top2\n  }, {\n    init: 0.7,\n    weight: 0.1\n  }),\n  topH: sigilShape(\"edge\", {\n    start: Positions.top2,\n    end: Positions.top3\n  }, {\n    init: 0.8,\n    weight: 0.1\n  }),\n  circTopUp: sigilShape(\"circle\", {\n    center: Positions.circTop,\n    radius: 0.08,\n    initAngle: 0.75 * Math.PI,\n    finalAngle: 1.75 * Math.PI\n  }, {\n    init: 0.9,\n    weight: 0.1\n  }),\n  circTopDown: sigilShape(\"circle\", {\n    center: Positions.circTop,\n    radius: 0.08,\n    initAngle: 0.75 * Math.PI,\n    finalAngle: -0.25 * Math.PI\n  }, {\n    init: 0.9,\n    weight: 0.1\n  })\n}; // The hardcoded elements in Shapes above only specify roughly half of the sigil; here we take all the existing entries\n// and reflect them across the center line. Note that this technically duplicates one of the elements on top of itself\n\nfor (const key of Object.keys(Shapes)) {\n  const toReflect = Shapes[key];\n\n  if (toReflect.connector.path instanceof LinearPath) {\n    Shapes[`${key}Ref`] = sigilShape(\"edge\", {\n      start: reflectAcrossVertical(toReflect.att.start),\n      end: reflectAcrossVertical(toReflect.att.end)\n    }, toReflect.fill);\n  } else if (toReflect.connector.path instanceof LogarithmicSpiral) {\n    Shapes[`${key}Ref`] = sigilShape(\"circle\", {\n      center: reflectAcrossVertical(toReflect.att.center),\n      radius: toReflect.att.radius,\n      initAngle: Math.PI - toReflect.att.initAngle,\n      finalAngle: Math.PI - toReflect.att.finalAngle\n    }, toReflect.fill);\n  }\n} // This segment adds multiple circular arcs around the entire sigil, which all fill simultaneously\n\n\nconst arcSegments = 16;\n\nfor (let arcIndex = 0; arcIndex < arcSegments; arcIndex++) {\n  const len = 2 * Math.PI / arcSegments;\n  const init = arcIndex * len;\n  Shapes[`arcInner${arcIndex}`] = sigilShape(\"circle\", {\n    center: SigilAttributes.center,\n    radius: 0.75,\n    initAngle: init,\n    finalAngle: init + len\n  }, {\n    init: 0.1,\n    weight: 0.4\n  }, \"crimson\");\n  Shapes[`arcOuter${arcIndex}`] = sigilShape(\"circle\", {\n    center: SigilAttributes.center,\n    radius: 0.95,\n    initAngle: init,\n    finalAngle: init - len\n  }, {\n    init: 0.5,\n    weight: 0.4\n  }, \"crimson\");\n}\n\nexport const finalSigil = Object.values(Shapes).mapToObject((key, idx) => `final-sigil-${idx}`, val => val);","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/secret-formula/celestials/navigation-sigils/final-sigil.js"],"names":["CELESTIAL_NAV_DRAW_ORDER","sigilProgress","riftProgress","PelleRifts","all","map","r","Math","clamp","realPercentage","min","generatorProgress","log10","GalaxyGenerator","generatedGalaxies","clampMax","SigilAttributes","visible","center","Vector","size","color","canvasLayer","NODE_BG","scaledPos","x","y","att","reflectAcrossVertical","vec","sigilShape","type","fill","colorOverride","pos","path","pathStart","pathEnd","start","LinearPath","end","LogarithmicSpiral","fromPolarEndpoints","radius","initAngle","finalAngle","Error","init","complete","weight","node","position","ring","rMajor","connector","drawOrder","completeWidth","noBG","Positions","Object","freeze","circTop","circMid","circBot","topC","top1","top2","top3","mid","arm1","arm2","arm3","lowC","low1","botC","bot1","bot2","Shapes","botCircR","PI","botH","lowH","circUp","circDown","vert2","vertC","vertDiag1","vert1","vertDiag2","vertDiag3","topH","circTopUp","circTopDown","key","keys","toReflect","arcSegments","arcIndex","len","finalSigil","values","mapToObject","idx","val"],"mappings":"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","sourcesContent":["import { CELESTIAL_NAV_DRAW_ORDER } from \"../navigation\";\r\n\r\nfunction sigilProgress() {\r\n  const riftProgress = PelleRifts.all.map(r => Math.clamp(r.realPercentage, 0, 1)).min();\r\n  const generatorProgress = Math.log10(1 + GalaxyGenerator.generatedGalaxies) / 11;\r\n  return Math.clampMax(0.2 * riftProgress + 0.8 * generatorProgress, 1);\r\n}\r\n\r\n// Determines styling, overall visibility, and placement/scaling of the sigil. Center and size are defined such that\r\n// keeping the sigil within internal coordinates of ±1 will keep the sigil within a ±size box of the center coordinates\r\nconst SigilAttributes = {\r\n  visible: () => PelleRifts.all.map(r => Math.clamp(r.realPercentage, 0, 1)).min() > 0,\r\n  center: new Vector(400, 300),\r\n  size: 400,\r\n  color: \"#00ffff\",\r\n  canvasLayer: CELESTIAL_NAV_DRAW_ORDER.NODE_BG - 500,\r\n};\r\n\r\nfunction scaledPos(x, y) {\r\n  const att = SigilAttributes;\r\n  return new Vector(att.center.x + att.size * x, att.center.y + att.size * y);\r\n}\r\n\r\n// Reflects a vector across the vertical line down the center of the sigil bounding box. Used to take advantage of the\r\n// sigil having vertical symmetry, allowing us to cut down on hardcoded specifications by half\r\nfunction reflectAcrossVertical(vec) {\r\n  return new Vector(2 * SigilAttributes.center.x - vec.x, vec.y);\r\n}\r\n\r\n/**\r\n * Method to make an appropriately-formatted entry to be fed into the navigation code\r\n *\r\n * @member {String} type  String specifying the actual shape of the element to be drawn; must be \"line\" or \"circle\"\r\n * @member {Object} att   Object whose props list out attributes of the shape to be drawn:\r\n *  Line  : start and end, specifying the two endpoints to draw between.\r\n *  Circle: center and radius to specify the circle path, initAngle and finalAngle to specify an arc segment to draw.\r\n *    0 is rightward and positive angles draw clockwise. Note that making finalAngle-initialAngle a multiple of 2pi\r\n *    will cause curve decomposition errors in the curve-drawing code.\r\n * @member {Object} fill  Object specifying a segment for the fill as a fraction of the total sigil filling progress.\r\n *  Each particular segment will fill from 0% to 100% within the range init to init+weight, without over/underfilling.\r\n * @member {String} colorOverride Color to use for rendering the element, used instead of SigilAttributes.color\r\n */\r\n// eslint-disable-next-line max-params\r\nfunction sigilShape(type, att, fill, colorOverride) {\r\n  let pos, path, pathStart, pathEnd;\r\n  switch (type) {\r\n    case \"edge\":\r\n      pos = att.start;\r\n      path = new LinearPath(att.start, att.end);\r\n      pathStart = 0;\r\n      pathEnd = 1;\r\n      break;\r\n    case \"circle\":\r\n      pos = att.center;\r\n      path = LogarithmicSpiral.fromPolarEndpoints(att.center, 0, att.radius * SigilAttributes.size,\r\n        1, att.radius * SigilAttributes.size);\r\n      pathStart = att.initAngle;\r\n      pathEnd = att.finalAngle;\r\n      break;\r\n    default:\r\n      throw Error(\"Unrecognized shape in sigil specification\");\r\n  }\r\n\r\n  return {\r\n    visible: () => SigilAttributes.visible() && sigilProgress() >= fill.init,\r\n    complete: () => Math.clamp((sigilProgress() - fill.init) / fill.weight, 0, 1),\r\n    // Note that att and fill aren't used in navigation rendering, but including them here massively simplifies the\r\n    // sigil reflection logic\r\n    att,\r\n    fill,\r\n    node: {\r\n      position: pos,\r\n      ring: {\r\n        rMajor: 0,\r\n      },\r\n    },\r\n    connector: {\r\n      pathStart,\r\n      pathEnd,\r\n      drawOrder: SigilAttributes.canvasLayer,\r\n      path,\r\n      fill: colorOverride ?? SigilAttributes.color,\r\n      completeWidth: SigilAttributes.size / 20,\r\n      noBG: true,\r\n    },\r\n  };\r\n}\r\n\r\n// These coordinates should generally be kept within ±1; if the sigil needs to be larger then that should be changed in\r\n// the SigilAttribute object instead. Naming conventions for this sigil use smaller numbers to denote nodes generally\r\n// closer to the center line (whether by distance or path length), whereas abbreviated words are used to describe\r\n// vertical position. C denotes horizontal center points.\r\nconst Positions = Object.freeze({\r\n  circTop: scaledPos(0.333, -0.41),\r\n  circMid: scaledPos(0.5, 0.22),\r\n  circBot: scaledPos(0, 0.43),\r\n  topC: scaledPos(0, -0.4),\r\n  top1: scaledPos(0.08, -0.27),\r\n  top2: scaledPos(0.18, -0.35),\r\n  top3: scaledPos(0.28, -0.35),\r\n  mid: scaledPos(0.08, 0.05),\r\n  arm1: scaledPos(0.5, 0.05),\r\n  arm2: scaledPos(0.5, -0.15),\r\n  arm3: scaledPos(0.4, -0.15),\r\n  lowC: scaledPos(0, 0.22),\r\n  low1: scaledPos(0.42, 0.22),\r\n  botC: scaledPos(0, 0.31),\r\n  bot1: scaledPos(0.12, 0.43),\r\n  bot2: scaledPos(0.28, 0.43),\r\n});\r\n\r\n// List of specified primitive graphics elements with which to construct the sigil; see docstring of sigilShape\r\n// for description of proper attribute specifications\r\nconst Shapes = {\r\n  botCircR: sigilShape(\"circle\",\r\n    { center: Positions.circBot, radius: 0.12, initAngle: 0.5 * Math.PI, finalAngle: -0.5 * Math.PI },\r\n    { init: 0, weight: 0.2 }),\r\n  botH: sigilShape(\"edge\",\r\n    { start: Positions.bot1, end: Positions.bot2 },\r\n    { init: 0.1, weight: 0.1 }),\r\n  lowH: sigilShape(\"edge\",\r\n    { start: Positions.lowC, end: Positions.low1 },\r\n    { init: 0.3, weight: 0.3 }),\r\n  circUp: sigilShape(\"circle\",\r\n    { center: Positions.circMid, radius: 0.08, initAngle: Math.PI, finalAngle: 0 },\r\n    { init: 0.6, weight: 0.1 }),\r\n  circDown: sigilShape(\"circle\",\r\n    { center: Positions.circMid, radius: 0.08, initAngle: Math.PI, finalAngle: 2 * Math.PI },\r\n    { init: 0.6, weight: 0.1 }),\r\n  vert2: sigilShape(\"edge\",\r\n    { start: Positions.bot2, end: Positions.top3 },\r\n    { init: 0.2, weight: 0.7 }),\r\n  vertC: sigilShape(\"edge\",\r\n    { start: Positions.botC, end: Positions.lowC },\r\n    { init: 0.2, weight: 0.1 }),\r\n  vertDiag1: sigilShape(\"edge\",\r\n    { start: Positions.lowC, end: Positions.mid },\r\n    { init: 0.3, weight: 0.1 }),\r\n  arm1: sigilShape(\"edge\",\r\n    { start: Positions.mid, end: Positions.arm1 },\r\n    { init: 0.4, weight: 0.2 }),\r\n  arm2: sigilShape(\"edge\",\r\n    { start: Positions.arm1, end: Positions.arm2 },\r\n    { init: 0.6, weight: 0.1 }),\r\n  arm3: sigilShape(\"edge\",\r\n    { start: Positions.arm2, end: Positions.arm3 },\r\n    { init: 0.7, weight: 0.1 }),\r\n  vert1: sigilShape(\"edge\",\r\n    { start: Positions.mid, end: Positions.top1 },\r\n    { init: 0.4, weight: 0.3 }),\r\n  vertDiag2: sigilShape(\"edge\",\r\n    { start: Positions.top1, end: Positions.topC },\r\n    { init: 0.7, weight: 0.1 }),\r\n  vertDiag3: sigilShape(\"edge\",\r\n    { start: Positions.top1, end: Positions.top2 },\r\n    { init: 0.7, weight: 0.1 }),\r\n  topH: sigilShape(\"edge\",\r\n    { start: Positions.top2, end: Positions.top3 },\r\n    { init: 0.8, weight: 0.1 }),\r\n  circTopUp: sigilShape(\"circle\",\r\n    { center: Positions.circTop, radius: 0.08, initAngle: 0.75 * Math.PI, finalAngle: 1.75 * Math.PI },\r\n    { init: 0.9, weight: 0.1 }),\r\n  circTopDown: sigilShape(\"circle\",\r\n    { center: Positions.circTop, radius: 0.08, initAngle: 0.75 * Math.PI, finalAngle: -0.25 * Math.PI },\r\n    { init: 0.9, weight: 0.1 }),\r\n};\r\n\r\n// The hardcoded elements in Shapes above only specify roughly half of the sigil; here we take all the existing entries\r\n// and reflect them across the center line. Note that this technically duplicates one of the elements on top of itself\r\nfor (const key of Object.keys(Shapes)) {\r\n  const toReflect = Shapes[key];\r\n  if (toReflect.connector.path instanceof LinearPath) {\r\n    Shapes[`${key}Ref`] = sigilShape(\"edge\",\r\n      { start: reflectAcrossVertical(toReflect.att.start), end: reflectAcrossVertical(toReflect.att.end) },\r\n      toReflect.fill);\r\n  } else if (toReflect.connector.path instanceof LogarithmicSpiral) {\r\n    Shapes[`${key}Ref`] = sigilShape(\"circle\",\r\n      { center: reflectAcrossVertical(toReflect.att.center), radius: toReflect.att.radius,\r\n        initAngle: Math.PI - toReflect.att.initAngle, finalAngle: Math.PI - toReflect.att.finalAngle },\r\n      toReflect.fill);\r\n  }\r\n}\r\n\r\n// This segment adds multiple circular arcs around the entire sigil, which all fill simultaneously\r\nconst arcSegments = 16;\r\nfor (let arcIndex = 0; arcIndex < arcSegments; arcIndex++) {\r\n  const len = 2 * Math.PI / arcSegments;\r\n  const init = arcIndex * len;\r\n  Shapes[`arcInner${arcIndex}`] = sigilShape(\"circle\",\r\n    { center: SigilAttributes.center, radius: 0.75,\r\n      initAngle: init, finalAngle: init + len },\r\n    { init: 0.1, weight: 0.4 },\r\n    \"crimson\");\r\n  Shapes[`arcOuter${arcIndex}`] = sigilShape(\"circle\",\r\n    { center: SigilAttributes.center, radius: 0.95,\r\n      initAngle: init, finalAngle: init - len },\r\n    { init: 0.5, weight: 0.4 },\r\n    \"crimson\");\r\n}\r\n\r\nexport const finalSigil = Object.values(Shapes)\r\n  .mapToObject((key, idx) => `final-sigil-${idx}`, val => val);\r\n"]},"metadata":{},"sourceType":"module"}