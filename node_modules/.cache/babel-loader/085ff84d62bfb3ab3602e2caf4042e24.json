{"ast":null,"code":"import \"core-js/modules/web.dom-collections.iterator.js\";\nimport { log as lngamma } from \"gamma\";\nimport { DC } from \"./constants\";\n/* eslint-disable no-use-before-define */\n\n/* eslint-disable max-params */\n\nwindow.LOG10_MAX_VALUE = Math.log10(Number.MAX_VALUE);\nwindow.LN_SQRT_2_PI = 0.5 * Math.log(2 * Math.PI);\nwindow.LOG10_2 = Math.log10(2);\nwindow.LOG10_E = Math.log10(Math.E);\nMath.PI_2 = Math.PI * 2;\n/**\r\n * This is a file for general math utilities that can be used by many mechanics\r\n */\n\n/**\r\n * @typedef {Object} bulkBuyBinarySearch_result\r\n * @property {number} quantity amount purchased (relative)\r\n * @property {Decimal} purchasePrice amount that needs to be paid to get that\r\n */\n\n/**\r\n * bulkBuyBinarySearch is a helper for bulk buyers of non-linear prices. If the price of\r\n * a thing is f(n), it's hard to figure out how much of it can be bought without an inverse\r\n * of f. This helper starts at some n0, and then searches forward in powers of 2 until it\r\n * finds a value that is not affordable. After that, it performs a binary search to figure\r\n * out how much can actually be bought. Returns an object with a quantity and price, or\r\n * null if nothing can be bought\r\n * NOTE: this will not work with slowly increasing prices. This makes the assumption that\r\n * if you can afford purchase N, you can afford the combined cost of everything before N\r\n * (it does check and make sure you can afford all of that put together. See below in code\r\n * for details)\r\n * @param {Decimal} money Amount of currency available\r\n * @param {Object} costInfo cost parameters:\r\n * @param {function(number): Decimal} costInfo.costFunction price of the n'th purchase (starting from 0)\r\n * @param {Decimal} [costInfo.firstCost] Cost of the next purchase; this is usually available/cached. Will\r\n *   be calculated from costFunction if not provided.\r\n * @param {boolean} [costInfo.cumulative] (Defaults to true) specifies whether one must pay a cumulative\r\n *   cost or just the highest cost.\r\n * @param {number} alreadyBought amount already purchased\r\n * @returns {bulkBuyBinarySearch_result | null}\r\n */\n\nwindow.bulkBuyBinarySearch = function bulkBuyBinarySearch(money, costInfo, alreadyBought) {\n  const costFunction = costInfo.costFunction;\n  const firstCost = costInfo.firstCost === undefined ? costFunction(alreadyBought) : costInfo.firstCost;\n  const isCumulative = costInfo.cumulative === undefined ? true : costInfo.cumulative;\n  if (money.lt(firstCost)) return null; // Attempt to find the max we can purchase. We know we can buy 1, so we try 2, 4, 8, etc\n  // to figure out the upper limit\n\n  let cantBuy = 1;\n  let nextCost;\n\n  do {\n    cantBuy *= 2;\n    nextCost = costFunction(alreadyBought + cantBuy - 1);\n  } while (money.gte(nextCost)); // Deal with the simple case of buying just one\n\n\n  if (cantBuy === 2) {\n    return {\n      quantity: 1,\n      purchasePrice: firstCost\n    };\n  } // The amount we can actually buy is in the interval [canBuy/2, canBuy), we do a binary search\n  // to find the exact value:\n\n\n  let canBuy = cantBuy / 2;\n  if (cantBuy > Number.MAX_SAFE_INTEGER) throw new Error(\"Overflow in binary search\");\n\n  while (cantBuy - canBuy > 1) {\n    const middle = Math.floor((canBuy + cantBuy) / 2);\n\n    if (money.gte(costFunction(alreadyBought + middle - 1))) {\n      canBuy = middle;\n    } else {\n      cantBuy = middle;\n    }\n  }\n\n  const baseCost = costFunction(alreadyBought + canBuy - 1);\n\n  if (!isCumulative) {\n    return {\n      quantity: canBuy,\n      purchasePrice: baseCost\n    };\n  }\n\n  let otherCost = DC.D0; // Account for costs leading up to that purchase; we are basically adding things\n  // up until they are insignificant\n\n  let count = 0;\n\n  for (let i = canBuy - 1; i > 0; --i) {\n    const newCost = otherCost.plus(costFunction(alreadyBought + i - 1));\n    if (newCost.eq(otherCost)) break;\n    otherCost = newCost;\n    if (++count > 1000) throw new Error(\"unexpected long loop (buggy cost function?)\");\n  }\n\n  let totalCost = baseCost.plus(otherCost); // Check the purchase price again\n\n  if (money.lt(totalCost)) {\n    --canBuy; // Since prices grow rather steeply, we can safely assume that we can, indeed, buy\n    // one less (e.g. if prices were A, B, C, D, we could afford D, but not A+B+C+D; we\n    // assume we can afford A+B+C because A+B+C < D)\n\n    totalCost = otherCost;\n  }\n\n  return {\n    quantity: canBuy,\n    purchasePrice: totalCost\n  };\n};\n/**\r\n * LinearMultiplierScaling performs calculations for multipliers that scale up\r\n * linearly. The simplest case you might consider could be a factorial -- or something\r\n * much slower, like 2 * 2.01 * 2.02 * 2.03 * ...\r\n * In terms of accuracy, it's better for slower growing multipliers than fast. For\r\n * example, with a factorial setup, it evaluates 11! as 39826281.18738219 rather than 39916800\r\n * The ratio between the estimated 10! and 11! is 10.99999474474497 which is pretty good.\r\n * For base = 2, growth = 0.1, after 10 purchases, the result is 7268.488254368145, rather\r\n * than 7268.490028799995. After 100 purchases, it's 4.582662e+79 rather than\r\n * 4.582664e+79.\r\n * Note: this doesn't do well with small initial multipliers (close to 1). 1.01 is about low\r\n * as it's reasonable to go.\r\n */\n\n\nwindow.LinearMultiplierScaling = class LinearMultiplierScaling {\n  /**\r\n   * Construct the helper object, which can be invoked for various calculations\r\n   * @param {number} baseRatio The first multiplier\r\n   * @param {number} growth The growth rate; multiplier after purchase N, starting at 0, is baseRatio + N * growth\r\n   */\n  constructor(baseRatio, growth) {\n    this.baseRatio = baseRatio;\n    this.growth = growth;\n  }\n  /**\r\n   * Multiply both the base ratio and the growth rate by the specified factor\r\n   * @param {number} ratio\r\n   * @returns this object for easy chaining\r\n   */\n\n\n  scale(ratio) {\n    this.baseRatio *= ratio;\n    this.growth *= ratio;\n    return this;\n  }\n  /**\r\n   * Shift by the specified number of purchases. For example, if you set up 2, 0.1, but you\r\n   * want the first scale factor to be 2.1, you could shift by 1\r\n   * @param {number} count number of purchases to shift by\r\n   * @returns this\r\n   */\n\n\n  shift(count) {\n    this.baseRatio += this.growth * count;\n    return this;\n  }\n  /**\r\n   * Find the combined multiplier after N purchases. N = 0 means a multiplier of 1 -- since no\r\n   * purchases have been made, no scaling has been applied. N = 1 is baseRatio, N=2 gives\r\n   * baseRatio * (baseRatio + growth), and so on. This is done using a corrected integral\r\n   * approximation\r\n   * @param {number} count number of purchases that have happened\r\n   * @returns {number} the natural log of the combined multiplier\r\n   */\n\n\n  logTotalMultiplierAfterPurchases(count) {\n    if (count === 0) return 0;\n    const k = this.growth / this.baseRatio;\n    const u = k * count;\n    return (1 / k + count - 0.5) * Math.log1p(u) + count * (Math.log(this.baseRatio) - 1) - k * u / (12 * (1 + u));\n  }\n  /**\r\n   * Invert the function given a combined multiplier. This doesn't do any rounding (so you\r\n   * can choose how to handle that).\r\n   * @param {number} logMult natural logarithm of combined multiplier\r\n   */\n\n\n  purchasesForLogTotalMultiplier(logMult) {\n    if (this.baseRatio < 1.01) throw new Error(\"Ratio is too small for good calculations\");\n    const Lb = Math.log(this.baseRatio);\n    const k = this.growth / this.baseRatio; // Final refinement step, applying 2nd order iteration directly to the formula of\n    // logTotalMultiplierAfterPurchases\n\n    const refineFinal = g => {\n      const u = k * g;\n      const Lg = Math.log1p(u);\n      const v = 0.5 * k / (1 + u);\n      const fVal = (1 / k + g - 0.5) * Lg + g * (Lb - 1) - (logMult + v * u / 6);\n      const fDeriv = Lg + Lb - v * (v / 3 + 1);\n      const fD2 = v * (2 + v * (2 + v / 3));\n      const delta1 = fVal / fDeriv;\n      return g - 2 * delta1 / (1 + Math.sqrt(1 - 2 * delta1 * fD2 / fDeriv));\n    }; // We calculate an initial estimate, assuming that the price doesn't increase:\n\n\n    const g0 = logMult / Lb; // If the growth rate is really slow and there's not many steps, this is great guess\n    // the other method (below) doesn't do well in that case.\n\n    if (k * g0 < 0.01) return refineFinal(refineFinal(g0));\n    const rhs = this.growth * logMult + this.baseRatio * (Lb - 1); // First, we make a good guess at a solution, based on an approximation of the sum sas an\n    // uncorrected integral; these parameters came from an optimization. We are solving for\n    // the value of base + x * growth - 1 here\n\n    const K1 = 0.183709519164226;\n    const K2 = 0.693791942633232;\n    const K3 = 0.049293492810849;\n    const y = Math.sqrt(2 * (rhs + 1));\n    const h0 = y * (1 + K1 * y) / (1 + K2 * Math.log1p(K3 * y)); // Apply a refinement step; this also shifts the answer by 1\n\n    const h1 = (1 + h0 + rhs) / Math.log1p(h0); // At this point we should have a pretty solid guess -- enough that this calcuolation\n    // should be pretty accurate; the final refinement\n\n    const g1 = (h1 - this.baseRatio) / this.growth;\n    return refineFinal(refineFinal(g1));\n  }\n  /**\r\n   * Manual calculation, for testing purposes\r\n   * @param {number} count\r\n   */\n\n\n  logTotalMultiplierAfterPurchasesBaseline(count) {\n    let logMult = 0;\n    const k = this.growth / this.baseRatio;\n\n    for (let x = 0; x < count; ++x) logMult += Math.log1p(k * x);\n\n    return logMult + count * Math.log(this.baseRatio);\n  }\n\n};\n\nwindow.getCostWithLinearCostScaling = function getCostWithLinearCostScaling(amountOfPurchases, costScalingStart, initialCost, costMult, costMultGrowth) {\n  const preScalingPurchases = Math.max(0, Math.floor(Math.log(costScalingStart / initialCost) / Math.log(costMult)));\n  const preScalingCost = Math.ceil(Math.pow(costMult, Math.min(preScalingPurchases, amountOfPurchases)) * initialCost);\n  const scaling = new LinearMultiplierScaling(costMult, costMultGrowth);\n  const postScalingCost = Math.exp(scaling.logTotalMultiplierAfterPurchases(Math.max(0, amountOfPurchases - preScalingPurchases)));\n  return preScalingCost * postScalingCost;\n}; // Using the same arguments as getCostWithLinearCostScaling() above, do a binary search for the first purchase with a\n// cost of Infinity.\n\n\nwindow.findFirstInfiniteCostPurchase = function findFirstInfiniteCostPurchase(costScalingStart, initialCost, costMult, costMultGrowth) {\n  let upper = 1;\n\n  while (Number.isFinite(getCostWithLinearCostScaling(upper, costScalingStart, initialCost, costMult, costMultGrowth))) {\n    upper *= 2;\n  }\n\n  let lower = upper / 2;\n\n  while (lower < upper) {\n    const mid = Math.floor((lower + upper) / 2);\n    const value = getCostWithLinearCostScaling(mid, costScalingStart, initialCost, costMult, costMultGrowth);\n\n    if (Number.isFinite(value)) {\n      lower = mid + 1;\n    } else {\n      upper = mid;\n    }\n  }\n\n  return lower;\n};\n/**\r\n * LinearCostScaling is a helper class for costs that scale linearly. If we\r\n * know the available resources, initial cost, and cost multiplier, we can\r\n * figure out the maximum amount of purchases, and also the resulting total\r\n * cost and cost multiplier.\r\n *\r\n * i = initial cost\r\n * m = cost multiplier\r\n * p = purchases\r\n * t = total cost\r\n *\r\n * t = i * (1 - m^p) / (1 - m)\r\n * p = floor(log(1 + t * (m - 1) / i) / log(m))\r\n */\n\n\nwindow.LinearCostScaling = class LinearCostScaling {\n  /**\r\n   * @param {Decimal} resourcesAvailable amount of available resources\r\n   * @param {Decimal} initialCost current cost\r\n   * @param {Number} costMultiplier current cost multiplier\r\n   * @param {Number} maxPurchases max amount of purchases\r\n   * @param {Boolean} free signifies if the purchase is free -> if we only need to consider the last cost\r\n   */\n  constructor(resourcesAvailable, initialCost, costMultiplier, maxPurchases = Number.MAX_SAFE_INTEGER, free = false) {\n    if (free) {\n      this._purchases = Math.clampMax(Math.floor(resourcesAvailable.div(initialCost).log10() / Math.log10(costMultiplier) + 1), maxPurchases);\n    } else {\n      this._purchases = Math.clampMax(Math.floor(resourcesAvailable.mul(costMultiplier - 1).div(initialCost).add(1).log10() / Math.log10(costMultiplier)), maxPurchases);\n    }\n\n    this._totalCostMultiplier = Decimal.pow(costMultiplier, this._purchases);\n\n    if (free) {\n      this._totalCost = initialCost.mul(Decimal.pow(costMultiplier, this._purchases - 1));\n    } else {\n      this._totalCost = initialCost.mul(Decimal.sub(1, this._totalCostMultiplier)).div(1 - costMultiplier);\n    }\n  }\n\n  get purchases() {\n    return this._purchases;\n  }\n\n  get totalCostMultiplier() {\n    return this._totalCostMultiplier;\n  }\n\n  get totalCost() {\n    return this._totalCost;\n  }\n\n};\n/**\r\n * ExponentialCostScaling provides both a max quantity and a price\r\n * @typedef {Object} QuantityAndPrice\r\n * @property {number} quantity The new amount that can be bought\r\n * @property {number} logPrice The logarithm (base 10) of the price\r\n */\n\n/**\r\n * This is a a helper class to deal with the more common case of a cost that\r\n * grows exponentially (past some threshold). NOTE: this assumes that you only\r\n * have to pay for the highest tier when buying in bulk. That's a little bit cheaper,\r\n * but for the use cases this encounters, it's not a big deal.\r\n */\n\nwindow.ExponentialCostScaling = class ExponentialCostScaling {\n  /**\r\n   * @param {Object} param configuration object with the following fields\r\n   * @param {number|Decimal} param.baseCost the cost of the first purchase\r\n   * @param {number} param.baseIncrease the baseline increase in price\r\n   * @param {number} param.costScale the amount by which the cost scaling increases;\r\n   *  e.g. if it is 10, then the ratio between successive prices goes up by 10\r\n   * @param {number} [param.purchasesBeforeScaling] the number of purchases that can\r\n   *  be made before scaling begins. If baseCost is B, baseIncrease is C, and costScale is S,\r\n   *  and purchasesBeforeScaling is 0, the prices will go: B, B C, B C^2 S, B C^3 S^3, etc.\r\n   * @param {number|Decimal} [param.scalingCostThreshold] an alternative way of specifying\r\n   *  when scaling begins; once the cost is >= this threshold, scaling applies. Using the same\r\n   *  notation: B BC BC^2 .... BC^n <threshold> BC^(n+1) BC^(n+2)S BC^(n+3)S^3 etc. So, the first\r\n   *  price past the threshold has no costScale in it, but everything past that does.\r\n   */\n  constructor(param) {\n    this._baseCost = new Decimal(param.baseCost);\n    this._baseIncrease = param.baseIncrease;\n    if (typeof this._baseIncrease !== \"number\") throw new Error(\"baseIncrease must be a number\");\n    this._costScale = param.costScale;\n    if (typeof this._costScale !== \"number\") throw new Error(\"costScale must be a number\");\n    this._logBaseCost = ExponentialCostScaling.log10(param.baseCost);\n    this._logBaseIncrease = ExponentialCostScaling.log10(param.baseIncrease);\n    this._logCostScale = ExponentialCostScaling.log10(param.costScale);\n\n    if (param.purchasesBeforeScaling !== undefined) {\n      this._purchasesBeforeScaling = param.purchasesBeforeScaling; // eslint-disable-next-line no-negated-condition\n    } else if (param.scalingCostThreshold !== undefined) {\n      this._purchasesBeforeScaling = Math.ceil((ExponentialCostScaling.log10(param.scalingCostThreshold) - this._logBaseCost) / this._logBaseIncrease);\n    } else throw new Error(\"Must specify either scalingCostThreshold or purchasesBeforeScaling\");\n\n    this.updateCostScale();\n  }\n\n  get costScale() {\n    return this._costScale;\n  }\n  /**\r\n   * @param {number} value\r\n   */\n\n\n  set costScale(value) {\n    this._logCostScale = ExponentialCostScaling.log10(value);\n    this._costScale = value;\n    this.updateCostScale();\n  }\n\n  updateCostScale() {\n    this._precalcDiscriminant = Math.pow(2 * this._logBaseIncrease + this._logCostScale, 2) - 8 * this._logCostScale * (this._purchasesBeforeScaling * this._logBaseIncrease + this._logBaseCost);\n    this._precalcCenter = -this._logBaseIncrease / this._logCostScale + this._purchasesBeforeScaling + 0.5;\n  }\n  /**\r\n   * Calculates the cost of the next purchase\r\n   * @param {number} currentPurchases\r\n   */\n\n\n  calculateCost(currentPurchases) {\n    const logMult = this._logBaseIncrease;\n    const logBase = this._logBaseCost;\n    const excess = currentPurchases - this._purchasesBeforeScaling;\n    const logCost = excess > 0 ? currentPurchases * logMult + logBase + 0.5 * excess * (excess + 1) * this._logCostScale : currentPurchases * logMult + logBase;\n    return DC.E1.pow(logCost);\n  }\n  /**\r\n   * Figure out how much of this can be bought.\r\n   * This returns the maximum new number of this thing; If you have 51 and can\r\n   * afford to buy 10 more, this will return 61. NOTE! this assumes you only\r\n   * have to pay for the most expensive thing you get when you buy in bulk. This\r\n   * means it's not suitable for accurate caclulation of cumulative prices if the\r\n   * multiplier is small.\r\n   * @param {number} currentPurchases amount already possessed\r\n   * @param {Decimal} money\r\n   * @returns {QuantityAndPrice|null} maximum value of bought that money can buy up to\r\n   */\n\n\n  getMaxBought(currentPurchases, rawMoney, numberPerSet) {\n    // We need to divide money by the number of things we need to buy per set\n    // so that we don't, for example, buy all of a set of 10 dimensions\n    // when we can only afford 1.\n    const money = rawMoney.div(numberPerSet);\n    const logMoney = money.log10();\n    const logMult = this._logBaseIncrease;\n    const logBase = this._logBaseCost; // The 1 + is because the multiplier isn't applied to the first purchase\n\n    let newPurchases = Math.floor(1 + (logMoney - logBase) / logMult); // We can use the linear method up to one purchase past the threshold, because the first purchase\n    // past the threshold doesn't have cost scaling in it yet.\n\n    if (newPurchases > this._purchasesBeforeScaling) {\n      const discrim = this._precalcDiscriminant + 8 * this._logCostScale * logMoney;\n\n      if (discrim < 0) {\n        return null;\n      }\n\n      newPurchases = Math.floor(this._precalcCenter + Math.sqrt(discrim) / (2 * this._logCostScale));\n    }\n\n    if (newPurchases <= currentPurchases) return null; // There's a narrow edge case where the linear method returns > this._purchasesBeforeScaling + 1\n    // but the quadratic method returns less than that. Having this be a separate check covers that\n    // case:\n\n    let logPrice;\n\n    if (newPurchases <= this._purchasesBeforeScaling + 1) {\n      logPrice = (newPurchases - 1) * logMult + logBase;\n    } else {\n      const pExcess = newPurchases - this._purchasesBeforeScaling;\n      logPrice = (newPurchases - 1) * logMult + logBase + 0.5 * pExcess * (pExcess - 1) * this._logCostScale;\n    }\n\n    return {\n      quantity: newPurchases - currentPurchases,\n      logPrice: logPrice + Math.log10(numberPerSet)\n    };\n  }\n  /**\r\n   * Determines the number of purchases that would be possible, if purchase count was continuous. Might\r\n   * have some odd behavior right at e308, but otherwise should work. It's mostly a copy-paste from\r\n   * getMaxBought() above but with unnecessary extra code removed.\r\n   * @param {Decimal} money\r\n   * @returns {number} maximum value of bought that money can buy up to\r\n   */\n\n\n  getContinuumValue(rawMoney, numberPerSet) {\n    // We need to divide money by the number of things we need to buy per set\n    // so that we don't, for example, buy all of a set of 10 dimensions\n    // when we can only afford 1. In the specific case of continuum this means,\n    // for example, that 10 AM buys 2/3 of a set of 10 first dimensions rather than\n    // buying the whole set of 10, which at least feels more correct.\n    const money = rawMoney.div(numberPerSet);\n    const logMoney = money.log10();\n    const logMult = this._logBaseIncrease;\n    const logBase = this._logBaseCost; // The 1 + is because the multiplier isn't applied to the first purchase\n\n    let contValue = 1 + (logMoney - logBase) / logMult; // We can use the linear method up to one purchase past the threshold, because the first purchase\n    // past the threshold doesn't have cost scaling in it yet.\n\n    if (contValue > this._purchasesBeforeScaling) {\n      const discrim = this._precalcDiscriminant + 8 * this._logCostScale * logMoney;\n\n      if (discrim < 0) {\n        return 0;\n      }\n\n      contValue = this._precalcCenter + Math.sqrt(discrim) / (2 * this._logCostScale);\n    }\n\n    return Math.clampMin(contValue, 0);\n  }\n\n  static log10(value) {\n    if (value instanceof Decimal) return value.log10();\n    return Math.log10(value);\n  }\n\n}; // Numerical approximation for values from the Lambert W function, using Newton's method with some algebraic\n// changes to make it less likely to overflow. Relative precision of 1e-6 should be good enough for most purposes;\n// this should never be turned down to 0 as there can be oscillatory behavior due to floating point quantization\n// that never converges to a fixed point. It also seems to take much longer to converge at higher values.\n\nwindow.productLog = function productLog(x) {\n  let curr = x,\n      prev = 0;\n\n  do {\n    prev = curr;\n    curr -= 1 - (1 + x * Math.exp(-curr)) / (1 + curr);\n  } while (Math.abs(curr - prev) > 1e-6 * curr);\n\n  return curr;\n}; // Implementation of \"Lehmer code\" decoding to produce a specific permutation, given a permutation length and a\n// lexicographic index for the specified permutation. Calling with a lexicographic index that is too large will\n// not throw an error, but will use lexIndex % len! as an index instead.\n// This may behave incorrectly if len! > 9e15, which occurs when len > 18.\n\n\nwindow.permutationIndex = function permutationIndex(len, lexIndex) {\n  let numPerm = 1;\n\n  for (let n = 1; n <= len; n++) numPerm *= n;\n\n  let index = lexIndex % numPerm;\n  let remOrder = numPerm / len;\n  const ordered = Array.range(0, len);\n  const perm = [];\n\n  while (ordered.length > 0) {\n    const div = Math.floor(index / remOrder);\n    const rem = index % remOrder;\n    perm.push(ordered.splice(div, 1)[0]);\n    index = rem;\n    remOrder /= ordered.length;\n  }\n\n  return perm;\n}; // Calculate cost scaling for something that follows getCostWithLinearCostScaling() under Infinity and immediately\n// starts accelerated ExponentialCostScaling above Infinity.  Yes this is a fuckton of arguments, sorry.  It sort of\n// needs to inherit all arguments from both cost scaling functions.\n\n\nwindow.getHybridCostScaling = function getHybridCostScaling(amountOfPurchases, linCostScalingStart, linInitialCost, linCostMult, linCostMultGrowth, expInitialCost, expCostMult, expCostMultGrowth) {\n  const normalCost = getCostWithLinearCostScaling(amountOfPurchases, linCostScalingStart, linInitialCost, linCostMult, linCostMultGrowth);\n\n  if (Number.isFinite(normalCost)) {\n    return new Decimal(normalCost);\n  }\n\n  const postInfinityAmount = amountOfPurchases - findFirstInfiniteCostPurchase(linCostScalingStart, linInitialCost, linCostMult, linCostMultGrowth);\n  const costScale = new ExponentialCostScaling({\n    baseCost: expInitialCost,\n    baseIncrease: expCostMult,\n    costScale: expCostMultGrowth,\n    scalingCostThreshold: Number.MAX_VALUE\n  });\n  return costScale.calculateCost(postInfinityAmount);\n};\n\nwindow.logFactorial = function () {\n  const LOGS = Array.range(1, 11).map(Math.log);\n  const TABLE = [0];\n\n  for (const x of LOGS) {\n    TABLE.push(TABLE[TABLE.length - 1] + x);\n  }\n\n  return x => {\n    if (typeof x !== \"number\" || x < 0) return NaN;\n    if (x < TABLE.length) return TABLE[x];\n    return lngamma(x + 1);\n  };\n}();\n\nwindow.exp1m = function (x) {\n  if (x.abs().gte(0.001)) {\n    return x.exp().minus(1);\n  } // This sum contains all the terms that are relevant for |x| < 0.001. We could do some sort of loop\n  // (add terms as long as they matter) but that probably has a greater fixed overhead, and we don't\n  // call this enough for efficiency to be very worrying anyway.\n\n\n  return x.plus(x.pow(2).div(2)).plus(x.pow(3).div(6)).plus(x.pow(4).div(24)).plus(x.pow(5).div(120));\n};\n/** 32 bit XORSHIFT generator */\n\n\nwindow.xorshift32Update = function xorshift32Update(state) {\n  /* eslint-disable no-param-reassign */\n  state ^= state << 13;\n  state ^= state >>> 17;\n  state ^= state << 5;\n  /* eslint-enable no-param-reassign */\n\n  return state;\n};\n\nwindow.fastRandom = function () {\n  let state = Math.floor(Date.now()) % Math.pow(2, 32);\n  const scale = 1 / Math.pow(2, 32);\n  return () => {\n    state = xorshift32Update(state);\n    return state * scale + 0.5;\n  };\n}(); // Normal distribution with specified mean and standard deviation\n\n\nwindow.normalDistribution = function () {\n  let haveSpare = false;\n  let spare = 0;\n  return (mean, stdDev) => {\n    if (typeof mean !== \"number\" || typeof stdDev !== \"number\") return NaN;\n\n    if (haveSpare) {\n      haveSpare = false;\n      return mean + stdDev * spare;\n    }\n\n    let mag, u, v;\n\n    do {\n      u = fastRandom() * 2 - 1;\n      v = fastRandom() * 2 - 1;\n      mag = u * u + v * v;\n    } while (mag >= 1 || mag === 0);\n\n    const t = Math.sqrt(-2 * Math.log(mag) / mag);\n    haveSpare = true;\n    spare = v * t;\n    return mean + stdDev * u * t;\n  };\n}(); // Helper function for BTRD\n\n\nwindow.binomialGeneratorFC = function () {\n  const stirlingBase = x => -8.10614667953272582e-2 + (x + 0.5) * Math.log1p(x) - x;\n\n  const TABLE = Array.range(0, 20).map(x => logFactorial(x) - stirlingBase(x));\n  return x => {\n    if (typeof x !== \"number\" || x < 0) return NaN;\n    if (x < TABLE.length) return TABLE[x];\n    const xr = 1 / (x + 1);\n    return (1 / 12 - (1 / 360 - xr * xr / 1260) * (xr * xr)) * xr;\n  };\n}();\n/**\r\n * This manually inverts the cumulative probability distribution\r\n * @param {number} numSamples number of drawn samples\r\n * @param {number} p probability\r\n * @returns {number} number of samples that satisfied p\r\n */\n\n\nwindow.binomialDistributionSmallExpected = function binomialDistributionSmallExpected(numSamples, p) {\n  const R = p / (1 - p);\n  const NxR = (numSamples + 1) * R; // Calculate (1-p)^n without rounding error at 1 - p\n\n  let pdf = Math.exp(Math.log1p(-p) * numSamples);\n  const u = fastRandom();\n  let cdf = pdf;\n  let output = 0;\n\n  while (u > cdf) {\n    ++output;\n    pdf *= NxR / output - R;\n    if (cdf + pdf === cdf) break;\n    cdf += pdf;\n  }\n\n  return output;\n};\n\nwindow.binomialDistribution = function binomialDistribution(numSamples, p) {\n  if (p === 0) return 0;\n\n  if (numSamples instanceof Decimal) {\n    if (numSamples.e < 308) {\n      const pNumber = typeof p === \"number\" ? p : p.toNumber();\n      return new Decimal(binomialDistribution(numSamples.toNumber(), pNumber));\n    }\n\n    const _expected = numSamples.times(p);\n\n    if (_expected.e > 32) return _expected;\n    return new Decimal(poissonDistribution(numSamples.times(p)));\n  }\n\n  const expected = numSamples * p; // BTRD is good past 10, but the inversion method we use is faster up to 15 and is exact\n\n  if (expected < 15) return binomialDistributionSmallExpected(numSamples, p);\n  if (p > 0.5) return numSamples - binomialDistribution(numSamples, 1 - p); // At some point, the variance is so small relative to the expected value that\n  // all samples are within eps of the mean\n\n  if (expected > 1e32) return expected;\n  const approximateVariance = expected * (1 - p); // Normal approximation is good enough for larger distributions\n\n  if (approximateVariance > 1e4) return Math.round(normalDistribution(expected, Math.sqrt(approximateVariance)));\n  return binomialDistributionBTRD(numSamples, p);\n};\n/**\r\n * Chooses the method of generation based on the input\r\n * @param {number|Decimal} expected expected value of distribution\r\n * @returns {number|Decimal} number of poisson process events\r\n */\n\n\nwindow.poissonDistribution = function poissonDistribution(expected) {\n  if (expected === 0) return 0;\n\n  if (expected instanceof Decimal) {\n    if (expected.e > 32) return expected;\n    return new Decimal(poissonDistribution(expected.toNumber()));\n  }\n\n  if (expected > 1e32) return expected;\n  if (expected > 1e4) return poissonDistributionViaNormal(expected);\n  if (expected < 20) return poissonDistributionSmallExpected(expected);\n  return poissonDistributionPTRD(expected);\n};\n/**\r\n * Uses a normal approximation to sqrt(x)\r\n */\n\n\nwindow.poissonDistributionViaNormal = function poissonDistributionViaNormal(expected) {\n  const x = normalDistribution(Math.sqrt(expected), 0.5);\n  return Math.floor(x * x);\n};\n/**\r\n * This manually inverts the cumulative probability distribution\r\n */\n\n\nwindow.poissonDistributionSmallExpected = function poissonDistributionSmallExpected(expected) {\n  let pdf = Math.exp(-expected);\n  let cdf = pdf;\n  const u = fastRandom();\n  let output = 0;\n\n  while (u > cdf) {\n    ++output;\n    pdf *= expected / output;\n    if (cdf + pdf === cdf) break;\n    cdf += pdf;\n  }\n\n  return output;\n};\n/**\r\n * Algorithm from https://core.ac.uk/download/pdf/11007254.pdf\r\n */\n\n\nwindow.binomialDistributionBTRD = function binomialDistributionBTRD(numSamples, p) {\n  const expected = numSamples * p;\n  const approximateVariance = expected * (1 - p);\n  const approxStdev = Math.sqrt(approximateVariance);\n  const m = Math.floor(expected + p);\n  const R = p / (1 - p);\n  const NxR = (numSamples + 1) * R;\n  const b = 1.15 + 2.53 * approxStdev;\n  const a = -0.0873 + 0.0248 * b + 0.01 * p;\n  const c = expected + 0.5;\n  const alpha = (2.83 + 5.1 / b) * approxStdev;\n  const kU = 0.43;\n  const kV = 0.92 - 4.2 / b; // eslint-disable-next-line no-constant-condition\n\n  while (true) {\n    let v = fastRandom();\n\n    if (v <= 2 * kU * kV) {\n      const _u = v / kV - kU;\n\n      return Math.floor((2 * a / (0.5 - Math.abs(_u)) + b) * _u + c);\n    }\n\n    let u;\n\n    if (v >= kV) {\n      u = fastRandom() - 0.5;\n    } else {\n      const w = v / kV - 0.93;\n      v = fastRandom() * kV;\n      u = (w > 0 ? 0.5 : -0.5) - w;\n    }\n\n    const us = 0.5 - Math.abs(u);\n    const k = Math.floor((2 * a / us + b) * u + c);\n    if (k < 0 || k > numSamples) continue;\n    v *= alpha / (a / (us * us) + b);\n    const km = Math.abs(k - m); // These loops are very fast, compared to calculating all the logs and stuff below; the\n    // original paper has 15 here but 40 seems to be closer to optimal.\n\n    if (km <= 40) {\n      let f = 1;\n\n      if (m < k) {\n        for (let i = m + 1; i <= k; ++i) f *= NxR / i - R;\n      } else if (m > k) {\n        for (let i = k + 1; i <= m; ++i) v *= NxR / i - R;\n      }\n\n      if (v <= f) return k;\n      continue;\n    }\n\n    const rho = km / approximateVariance * (((km / 3 + 0.625) * km + 1 / 6) / approximateVariance + 0.5);\n    const t = -km * km / (2 * approximateVariance);\n    const logV = Math.log(v);\n    if (logV < t - rho) return k;\n    if (logV > t + rho) continue;\n\n    const _nm = numSamples - m + 1;\n\n    const _nk = numSamples - k + 1;\n\n    const h = (m + 0.5) * Math.log((m + 1) / (R * _nm)) + binomialGeneratorFC(m) + binomialGeneratorFC(numSamples - m);\n    const j = (numSamples + 1) * Math.log(_nm / _nk) + (k + 0.5) * Math.log(_nk * R / (k + 1)) - binomialGeneratorFC(k) - binomialGeneratorFC(numSamples - k);\n    if (logV <= h + j) return k;\n  }\n};\n/**\r\n * \"The transformed rejection method for generating Poisson random variables\"\r\n * http://epub.wu.ac.at/352/1/document.pdf\r\n * @param {number} mu expected value of distribution\r\n * @returns {number} (integer) number of events in poisson process\r\n */\n\n\nwindow.poissonDistributionPTRD = function poissonDistributionPTRD(mu) {\n  const sMu = Math.sqrt(mu);\n  const b = 0.931 + 2.53 * sMu;\n  const a = -0.059 + 0.02483 * b;\n  const iAlpha = 1.1239 + 1.328 / (b - 3.4);\n  const vR = 0.9277 - 3.6224 / (b - 2); // eslint-disable-next-line no-constant-condition\n\n  while (true) {\n    let v = Math.random();\n\n    if (v < 0.86 * vR) {\n      const _u2 = v / vR - 0.43;\n\n      return Math.floor((2 * a / (0.5 - Math.abs(_u2)) + b) * _u2 + mu + 0.445);\n    }\n\n    let u;\n\n    if (v >= vR) {\n      u = fastRandom() - 0.5;\n    } else {\n      const w = v / vR - 0.93;\n      u = (w > 0 ? 0.5 : -0.5) - w;\n      v = fastRandom() * vR;\n    }\n\n    const us = 0.5 - Math.abs(u);\n    if (us < 0.013 && us < v) continue;\n    const k = Math.floor((2 * a / us + b) * u + mu + 0.445);\n    v *= iAlpha / (a / us / us + b);\n    const ik = 1 / k;\n\n    if (k >= 10) {\n      const t = (k + 0.5) * Math.log(mu * ik) - mu - LN_SQRT_2_PI + k - (1 / 12 - ik * ik / 360) * ik;\n      if (Math.log(v * sMu) <= t) return k;\n    } else if (Math.log(v) <= k * Math.log(mu) - mu - logFactorial(k)) return k;\n  }\n};\n\nwindow.depressedCubicRealRoots = function depressedCubicRealRoots(k3, k1, k0) {\n  if (k3 === 0) {\n    if (k1 === 0) return [];\n    return [-k0 / k1];\n  }\n  /* eslint-disable no-param-reassign */\n\n\n  k1 /= k3;\n  k0 /= k3;\n  /* eslint-enable no-param-reassign */\n\n  if (k0 === 0) {\n    if (k1 === 0) return [0];\n    if (k1 > 0) return [];\n    const r = Math.sqrt(-k1);\n    return [r, -r];\n  }\n\n  if (k1 === 0) {\n    return [Math.cbrt(-k0)];\n  }\n\n  let innerDisc = 0.25 * k0 * k0 + k1 * k1 * k1 / 27;\n\n  if (innerDisc >= 0) {\n    innerDisc = Math.sqrt(innerDisc);\n    return [Math.cbrt(-0.5 * k0 + innerDisc) + Math.cbrt(-0.5 * k0 - innerDisc)];\n  }\n\n  const po3 = 2 * Math.sqrt(-k1 / 3);\n  const theta = Math.acos(3 * k0 / (k1 * po3)) / 3;\n  return [po3 * Math.cos(theta), po3 * Math.cos(theta - 2 * Math.PI / 3), po3 * Math.cos(theta - 4 * Math.PI / 3)];\n};\n\nwindow.quadraticRealRoots = function quadraticRealRoots(k2, k1, k0) {\n  if (k2 === 0) {\n    if (k1 === 0) return [];\n    return [-k0 / k1];\n  }\n\n  if (k1 === 0) {\n    const ktmp = k0 / k2;\n    if (ktmp > 0) return [];\n    return [Math.sqrt(-ktmp), -Math.sqrt(-ktmp)];\n  }\n\n  const disc = k1 * k1 - 4 * k2 * k0;\n  if (disc < 0) return [];\n  if (disc === 0) return [-k1 / (2 * k2)];\n  const bdsc = -k1 - Math.sign(k1) * Math.sqrt(disc);\n  return [bdsc / (2 * k2), 2 * k0 / bdsc];\n};\n\nwindow.cubicRealRoots = function cubicRealRoots(k3, k2, k1, k0) {\n  if (k3 === 0) {\n    return quadraticRealRoots(k2, k1, k0);\n  }\n\n  if (k2 === 0) return depressedCubicRealRoots(k3, k1, k0);\n  const bo3a = k2 / (3 * k3);\n  const bo3a2 = bo3a * bo3a;\n  const coa = k1 / k3;\n  const p = coa - 3 * bo3a2;\n  const q = 2 * bo3a * bo3a2 - bo3a * coa + k0 / k3;\n  const dcrr = depressedCubicRealRoots(1, p, q);\n  return dcrr.map(t => t - bo3a);\n};\n\nwindow.testCRR = function testCRR(k3, k2, k1, k0) {\n  const r = cubicRealRoots(k3, k2, k1, k0); // eslint-disable-next-line no-console\n\n  console.log(r); // eslint-disable-next-line no-console\n\n  console.log(r.map(x => k0 + x * (k1 + x * (k2 + x * k3))));\n};\n\nwindow.depressedQuarticRealRoots = function depressedQuarticRealRoots(k4, k2, k1, k0) {\n  if (k4 === 0) return quadraticRealRoots(k2, k1, k0);\n\n  if (k0 === 0) {\n    const reducedSol = depressedCubicRealRoots(k4, k2, k1);\n    if (!reducedSol.includes(0)) reducedSol.push(0);\n    return reducedSol;\n  }\n\n  if (k1 === 0) {\n    const squareSol = quadraticRealRoots(k4, k2, k0);\n    const _solution = [];\n\n    for (const sr of squareSol) {\n      if (sr < 0) continue;\n      if (sr === 0) _solution.push(0);else _solution.push(Math.sqrt(sr), -Math.sqrt(sr));\n    }\n\n    return _solution;\n  }\n  /* eslint-disable no-param-reassign */\n\n\n  k2 /= k4;\n  k1 /= k4;\n  k0 /= k4;\n  /* eslint-enable no-param-reassign */\n\n  const mSol = cubicRealRoots(8, 8 * k2, 2 * k2 * k2 - 8 * k0, -k1 * k1);\n  const m = mSol.max(); // I don't think this can happen, but I haven't double checked the math\n\n  if (m <= 0) return [];\n  const sqrt2m = Math.sqrt(2 * m);\n  const dInner = 2 * k1 / sqrt2m;\n  const d1 = -(2 * k2 + 2 * m + dInner);\n  const solution = [];\n\n  if (d1 > 0) {\n    solution.push(0.5 * (sqrt2m + Math.sqrt(d1)), 0.5 * (sqrt2m - Math.sqrt(d1)));\n  } else if (d1 === 0) {\n    solution.push(0.5 * sqrt2m);\n  }\n\n  const d2 = -(2 * k2 + 2 * m - dInner);\n\n  if (d2 > 0) {\n    solution.push(0.5 * (-sqrt2m + Math.sqrt(d2)), 0.5 * (-sqrt2m - Math.sqrt(d2)));\n  } else if (d2 === 0) {\n    solution.push(-0.5 * sqrt2m);\n  }\n\n  return solution;\n};\n\nwindow.testDQRR = function testDQRR(k4, k2, k1, k0) {\n  const r = depressedQuarticRealRoots(k4, k2, k1, k0); // eslint-disable-next-line no-console\n\n  console.log(r); // eslint-disable-next-line no-console\n\n  console.log(r.map(x => k0 + x * (k1 + x * (k2 + x * x * k4))));\n};\n\nwindow.solveSimpleBiquadratic = function solveSimpleBiquadratic(A, B, C, D, E, F) {\n  const solutions = [];\n\n  if (A === 0) {\n    if (B === 0 || E === 0) return [];\n    const y = -C / B;\n    if (D === 0) return [{\n      x: -F / E,\n      y\n    }];\n    return [{\n      x: (-F - D * y * y) / E,\n      y\n    }];\n  }\n\n  if (D === 0) {\n    if (B === 0 || E === 0) return [];\n    const x = -F / E;\n    return [{\n      x,\n      y: (-C - A * x * x) / B\n    }];\n  }\n\n  if (B === 0) {\n    const _xSol = quadraticRealRoots(A, 0, C);\n\n    for (const x of _xSol) {\n      const yTmp = F + E * x;\n      const ySol = quadraticRealRoots(D, 0, yTmp);\n\n      for (const y of ySol) solutions.push({\n        x,\n        y\n      });\n    }\n\n    return solutions;\n  }\n\n  if (E === 0) {\n    const ySol = quadraticRealRoots(D, 0, F);\n\n    for (const y of ySol) {\n      const xTmp = C + B * y;\n\n      const _xSol2 = quadraticRealRoots(A, 0, xTmp);\n\n      for (const x of _xSol2) solutions.push({\n        x,\n        y\n      });\n    }\n\n    return solutions;\n  }\n\n  const AoB = A / B;\n  const CoB = C / B;\n  const xSol = depressedQuarticRealRoots(D * AoB * AoB, 2 * D * AoB * CoB, E, F + D * CoB * CoB);\n\n  for (const x of xSol) solutions.push({\n    x,\n    y: -(AoB * x * x + CoB)\n  });\n\n  return solutions;\n};\n\nwindow.testSSBQ = function testSSBQ(A, B, C, D, E, F) {\n  // eslint-disable-next-line no-console\n  console.log({\n    A,\n    B,\n    C,\n    D,\n    E,\n    F\n  });\n  const sols = solveSimpleBiquadratic(A, B, C, D, E, F);\n\n  for (const s of sols) {\n    const e1 = A * s.x * s.x + B * s.y + C;\n    const e2 = D * s.y * s.y + E * s.x + F; // eslint-disable-next-line no-console\n\n    console.log(`${s.x} ${s.y} ${e1} ${e2}`);\n  }\n};\n\nwindow.AffineTransform = class AffineTransform {\n  constructor(a00 = 1, a01 = 0, a10 = 0, a11 = 1, o0 = 0, o1 = 0) {\n    this.a00 = a00;\n    this.a01 = a01;\n    this.a10 = a10;\n    this.a11 = a11;\n    this.o0 = o0;\n    this.o1 = o1;\n  }\n\n  times(ot) {\n    if (ot instanceof AffineTransform) {\n      return new AffineTransform(this.a00 * ot.a00 + this.a01 * ot.a10, this.a00 * ot.a01 + this.a01 * ot.a11, this.a10 * ot.a00 + this.a11 * ot.a10, this.a10 * ot.a01 + this.a11 * ot.a11, this.a00 * ot.o0 + this.a01 * ot.o1 + this.o0, this.a10 * ot.o0 + this.a11 * ot.o1 + this.o1);\n    }\n\n    if (ot instanceof Vector) return ot.transformedBy(this);\n    throw new Error(\"unsupported operation\");\n  }\n\n  translated(offX, offY = undefined) {\n    if (offX instanceof Vector) {\n      return new AffineTransform(this.a00, this.a01, this.a10, this.a11, this.o0 + offX.x, this.o1 + offX.y);\n    }\n\n    return new AffineTransform(this.a00, this.a01, this.a10, this.a11, this.o0 + offX, this.o1 + offY);\n  }\n\n  rotated(angle) {\n    return AffineTransform.rotation(angle).times(this);\n  }\n\n  scaled(scale) {\n    return AffineTransform.scale(scale).times(this);\n  }\n\n  get withoutTranslation() {\n    return new AffineTransform(this.a00, this.a01, this.a10, this.a11);\n  }\n\n  static translation(offX, offY) {\n    if (offX instanceof Vector) {\n      return new AffineTransform(1, 0, 0, 1, offX.x, offX.y);\n    }\n\n    return new AffineTransform(1, 0, 0, 1, offX, offY);\n  }\n\n  static rotation(angle) {\n    const c = Math.cos(angle),\n          s = Math.sin(angle);\n    return new AffineTransform(c, -s, s, c);\n  }\n\n  static scale(sc) {\n    return new AffineTransform(sc, 0, 0, sc);\n  }\n\n  static identity() {\n    return new AffineTransform();\n  }\n\n};\nwindow.Vector = class Vector {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  get length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  }\n\n  plus(v) {\n    return new Vector(this.x + v.x, this.y + v.y);\n  }\n\n  dot(v) {\n    return this.x * v.x + this.y * v.y;\n  }\n\n  cross(v) {\n    // Produces scalar, z term of 3D vectors\n    return this.x * v.y - this.y * v.x;\n  }\n\n  minus(v) {\n    return new Vector(this.x - v.x, this.y - v.y);\n  }\n\n  times(s) {\n    return new Vector(this.x * s, this.y * s);\n  }\n\n  asTranslate() {\n    return `translate(${this.x}, ${this.y})`;\n  }\n\n  asRotate() {\n    return `rotate(${180 / Math.PI * Math.atan2(this.y, this.x)})`;\n  }\n\n  toString() {\n    return `${this.x}, ${this.y}`;\n  }\n\n  round(factor) {\n    return new Vector(Math.round(this.x * factor) / factor, Math.round(this.y * factor) / factor);\n  }\n\n  get copy() {\n    return new Vector(this.x, this.y);\n  }\n\n  matrixTransform(a00, a01, a10, a11) {\n    return new Vector(a00 * this.x + a01 * this.y, a10 * this.x + a11 * this.y);\n  }\n\n  transformedBy(tform) {\n    return new Vector(tform.a00 * this.x + tform.a01 * this.y + tform.o0, tform.a10 * this.x + tform.a11 * this.y + tform.o1);\n  }\n\n  get negative() {\n    return new Vector(-this.x, -this.y);\n  }\n\n  get normalized() {\n    return this.times(1 / this.length);\n  }\n\n  get right90() {\n    return new Vector(this.y, -this.x);\n  }\n\n  get left90() {\n    return new Vector(-this.y, this.x);\n  }\n\n  get angle() {\n    return Math.atan2(this.y, this.x);\n  }\n\n  static horiz(x) {\n    return new Vector(x, 0);\n  }\n\n  static unitFromRadians(rad) {\n    return new Vector(Math.cos(rad), Math.sin(rad));\n  }\n\n  static unitFromDegrees(deg) {\n    return Vector.unitFromRadians(deg * Math.PI / 180);\n  }\n\n};\nwindow.Curve = class Curve {\n  /**\r\n   * @abstract\r\n   * @param {number} t\r\n   * @returns {Vector}\r\n  */\n  position() {\n    throw new NotImplementedError();\n  }\n  /**\r\n   * @abstract\r\n   * @param {number} t\r\n   * @returns {Vector}\r\n  */\n\n\n  derivative() {\n    throw new NotImplementedError();\n  }\n  /**\r\n   * @abstract\r\n   * @param {number} t\r\n   * @returns {Vector}\r\n  */\n\n\n  secondDerivative() {\n    throw new NotImplementedError();\n  }\n  /**\r\n   * @param {number} t\r\n   * @returns {number}\r\n   */\n\n\n  curvature(t) {\n    const d = this.derivative(t);\n    const dd = this.secondDerivative(t);\n    const dMag = d.length;\n    return d.cross(dd) / (dMag * dMag * dMag);\n  }\n\n  shapeAt(t) {\n    const d = this.derivative(t);\n    return {\n      t,\n      position: this.position(t),\n      derivative: d,\n      direction: d.normalized,\n      curvature: this.curvature(t)\n    };\n  }\n\n  minimumDistanceTo(pDes, tMin, tMax) {\n    let tGuess = 0.5 * (tMin + tMax);\n    const tTol = Math.max(Math.abs(tMax), Math.abs(tMin)) * Number.EPSILON * 16;\n\n    for (let iter = 0;; ++iter) {\n      const p = this.position(tGuess);\n      const d = this.derivative(tGuess);\n      const dd = this.secondDerivative(tGuess);\n      const offset = p.minus(pDes);\n      const dist = offset.length;\n      const distDeriv = offset.dot(d) * 2;\n      /* eslint-disable no-param-reassign */\n\n      if (distDeriv > 0) tMax = tGuess;else tMin = tGuess;\n      /* eslint-enable no-param-reassign */\n\n      const distSecondDeriv = (offset.dot(dd) + d.dot(d)) * 2;\n      const tStep = distSecondDeriv < 0 ? -dist / distDeriv : -distDeriv / distSecondDeriv;\n      if (Math.abs(tStep) < tTol || iter >= 16) return dist;\n      tGuess = Math.clamp(tGuess + tStep, tMin, tMax);\n    }\n  }\n\n};\nwindow.LinearPath = class LinearPath extends Curve {\n  constructor(p0, p1) {\n    super();\n    this.p0 = p0.copy;\n    this.p1 = p1.copy;\n  }\n\n  position(t) {\n    return this.p0.times(1 - t).plus(this.p1.times(t));\n  }\n\n  derivative() {\n    return this.p1.minus(this.p0);\n  }\n\n  secondDerivative() {\n    return new Vector(0, 0);\n  } // eslint-disable-next-line no-unused-vars\n\n\n  curvature(t) {\n    return 0;\n  }\n\n  trimStart(len) {\n    const dir = this.p1.minus(this.p0).normalized;\n    return new LinearPath(this.p0.plus(dir.times(len)), this.p1);\n  }\n\n  trimEnd(len) {\n    const dir = this.p1.minus(this.p0).normalized;\n    return new LinearPath(this.p0, this.p1.minus(dir.times(len)));\n  }\n\n  transformed(tform) {\n    return new LinearPath(this.p0.transformedBy(tform), this.p1.transformedBy(tform));\n  }\n\n  get relativeSVG() {\n    const d1 = this.p1.minus(this.p0);\n    return `l ${d1.x} ${d1.y}\\n`;\n  }\n\n  createOffsetLine(offset, t0 = 0, t1 = 1) {\n    const off = this.p1.minus(this.p0).normalized.right90.times(offset);\n    return new LinearPath(this.position(t0).plus(off), this.position(t1).plus(off));\n  }\n\n  static connectCircles(p0, r0, p1, r1) {\n    const dir = p1.minus(p0).normalized;\n    return new LinearPath(p0.plus(dir.times(r0)), p1.minus(dir.times(r1)));\n  }\n\n};\n\nclass CubicBezier extends Curve {\n  constructor(p0, p1, p2, p3) {\n    super();\n    this.p0 = p0.copy;\n    this.p1 = p1.copy;\n    this.p2 = p2.copy;\n    this.p3 = p3.copy;\n  }\n\n  position(t) {\n    const nt2 = (1 - t) * (1 - t);\n    const t2 = t * t;\n    return this.p0.times((1 - t) * nt2).plus(this.p1.times(3 * t * nt2)).plus(this.p2.times(3 * t2 * (1 - t))).plus(this.p3.times(t2 * t));\n  }\n\n  derivative(t) {\n    return this.p1.minus(this.p0).times(3 * (1 - t) * (1 - t)).plus(this.p2.minus(this.p1).times(6 * t * (1 - t))).plus(this.p3.minus(this.p2).times(3 * t * t));\n  }\n\n  secondDerivative(t) {\n    return this.p2.minus(this.p1.times(2)).plus(this.p0).times(6 * (1 - t)).plus(this.p3.minus(this.p2.times(2)).plus(this.p1).times(6 * t));\n  }\n\n  transformed(tform) {\n    return new CubicBezier(this.p0.transformedBy(tform), this.p1.transformedBy(tform), this.p2.transformedBy(tform), this.p3.transformedBy(tform));\n  }\n\n  get relativeSVG() {\n    const d1 = this.p1.minus(this.p0);\n    const d2 = this.p2.minus(this.p0);\n    const d3 = this.p3.minus(this.p0);\n    return `c ${d1.x} ${d1.y} ${d2.x} ${d2.y} ${d3.x} ${d3.y}\\n`;\n  }\n\n  get reverse() {\n    return new CubicBezier(this.p3, this.p2, this.p1, this.p0);\n  }\n\n  static fitCurveSection(shape0, shape1) {\n    const dP = shape1.position.minus(shape0.position);\n    const reversed = shape0.t > shape1.t;\n    const pathRotation = shape0.direction.cross(shape1.direction);\n    let magSol = solveSimpleBiquadratic(1.5 * shape0.curvature, pathRotation, -shape0.direction.cross(dP), 1.5 * shape1.curvature, pathRotation, shape1.direction.cross(dP));\n    magSol = reversed ? magSol.filter(o => o.x <= 0 && o.y <= 0) : magSol.filter(o => o.x >= 0 && o.y >= 0);\n    if (magSol.length === 0) return null;\n    return new CubicBezier(shape0.position, shape0.position.plus(shape0.direction.times(magSol[0].x)), shape1.position.minus(shape1.direction.times(magSol[0].y)), shape1.position);\n  }\n\n} // This is an \"inset/outset\" kind of transform\n\n\nwindow.OffsetCurve = class OffsetCurve extends Curve {\n  constructor(baseCurve, offset) {\n    super();\n    this.base = baseCurve;\n    this.offset = offset;\n  }\n\n  position(t) {\n    const p = this.base.position(t);\n    const d = this.base.derivative(t);\n    return p.plus(d.normalized.right90.times(this.offset));\n  }\n\n  derivative(t) {\n    return this.base.derivative(t);\n  } // 2nd derivative not implemented as only curvature is used atm\n\n\n  curvature(t) {\n    const c = this.base.curvature(t);\n    return 1 / (1 / c + this.offset);\n  }\n\n  shapeAt(t) {\n    const shape = this.base.shapeAt(t);\n    return {\n      t: shape.t,\n      position: shape.position.plus(shape.direction.right90.times(this.offset)),\n      derivative: shape.derivative,\n      direction: shape.direction,\n      curvature: shape.curvature / (1 + this.offset * shape.curvature)\n    };\n  }\n\n};\nwindow.LogarithmicSpiral = class LogarithmicSpiral extends Curve {\n  constructor(center, scale, rate) {\n    super();\n    this.center = center;\n    this.scale = scale;\n    this.rate = rate;\n  }\n\n  position(t) {\n    return Vector.unitFromRadians(t).times(this.scale * Math.exp(this.rate * t)).plus(this.center);\n  }\n\n  derivative(t) {\n    const unit = Vector.unitFromRadians(t);\n    const radius = this.scale * Math.exp(this.rate * t);\n    return unit.times(radius * this.rate).plus(unit.left90.times(radius));\n  }\n\n  secondDerivative(t) {\n    const unit = Vector.unitFromRadians(t);\n    const radius = this.scale * Math.exp(this.rate * t);\n    return unit.times(radius * (this.rate * this.rate - 1)).plus(unit.left90.times(2 * radius * this.rate));\n  }\n\n  shapeAt(t) {\n    const unit = Vector.unitFromRadians(t);\n    const radius = this.scale * Math.exp(this.rate * t);\n    const ur = unit.times(radius);\n    const d = ur.times(this.rate).plus(ur.left90);\n    return {\n      t,\n      position: ur.plus(this.center),\n      derivative: d,\n      direction: d.normalized,\n      curvature: 1 / (Math.abs(radius) * Math.sqrt(1 + this.rate * this.rate))\n    };\n  }\n\n  angleFromRadius(r) {\n    return Math.log(r / this.scale) / this.rate;\n  }\n\n  static fromPolarEndpoints(center, theta0, r0, theta1, r1) {\n    const rate = Math.log(r1 / r0) / (theta1 - theta0);\n    return new LogarithmicSpiral(center, r0 / Math.exp(rate * theta0), rate);\n  }\n\n};\nwindow.PiecewisePath = class PiecewisePath {\n  constructor(data = undefined) {\n    this.path = data ? data : [];\n  }\n\n  push(element) {\n    this.path.push(element);\n  }\n\n  transformedBy(tform) {\n    return new PiecewisePath(this.path.map(x => x.transformed(tform)));\n  }\n\n  toSVG(initialPrefix) {\n    const p0 = this.path[0].position(0);\n    const lines = [`${initialPrefix} ${p0.x} ${p0.y}\\n`];\n\n    for (const part of this.path) lines.push(part.relativeSVG);\n\n    return lines.join(\"\");\n  }\n\n  static cubicBezierFitToCurveSection(curve, t0, t1, tol = 1, minPieces = 1) {\n    const output = new PiecewisePath();\n    const shape0 = curve.shapeAt(t0);\n    const shape1 = curve.shapeAt(t1);\n\n    function subdivide(shapeStart, shapeEnd, maxDepth = 8) {\n      const shapeMid = curve.shapeAt(0.5 * (shapeStart.t + shapeEnd.t));\n      return single(shapeStart, shapeMid, maxDepth - 1) && single(shapeMid, shapeEnd, maxDepth - 1);\n    }\n\n    function single(shapeStart, shapeEnd, maxDepth = 8) {\n      const singleFit = CubicBezier.fitCurveSection(shapeStart, shapeEnd);\n\n      if (singleFit === null) {\n        if (maxDepth <= 0) throw new Error(\"coulnd't decompose curve\");\n        return subdivide(shapeStart, shapeEnd, maxDepth);\n      }\n\n      const tMid = 0.5 * (shapeStart.t + shapeEnd.t);\n      const err = singleFit.minimumDistanceTo(curve.position(tMid), 0, 1);\n\n      if (err > tol) {\n        return subdivide(shapeStart, shapeEnd, maxDepth);\n      }\n\n      output.push(singleFit);\n      return true;\n    }\n\n    if (minPieces > 1) subdivide(shape0, shape1);else single(shape0, shape1);\n    return output;\n  }\n\n}; // https://stackoverflow.com/a/9201081\n\nwindow.ExponentialMovingAverage = class ExponentialMovingAverage {\n  constructor(alpha = 0.02, maxOutliers = 5, highOutlierThreshold = 3, lowOutlierThreshold = 0.4) {\n    this.alpha = alpha;\n    this.maxOutliers = maxOutliers;\n    this.highOutlierThreshold = highOutlierThreshold;\n    this.lowOutlierThreshold = lowOutlierThreshold;\n    this.outliers = 0;\n    this._average = undefined;\n  }\n\n  get average() {\n    if (this._average === undefined) {\n      return 0;\n    }\n\n    return this._average;\n  }\n\n  addValue(value) {\n    if (this._average === undefined) {\n      this._average = value;\n    } else {\n      this._average += this.alpha * (value - this._average);\n      const absValue = Math.abs(value);\n      const absAverage = Math.abs(this._average);\n      const highOutlier = absValue > absAverage * this.highOutlierThreshold;\n      const lowOutlier = absValue < absAverage * this.lowOutlierThreshold;\n      const outlier = highOutlier || lowOutlier;\n\n      if (outlier) {\n        this.outliers++;\n\n        if (this.outliers >= this.maxOutliers) {\n          this._average = value;\n          this.outliers = 0;\n        }\n      } else {\n        this.outliers = 0;\n      }\n    }\n  }\n\n};","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/math.js"],"names":["log","lngamma","DC","window","LOG10_MAX_VALUE","Math","log10","Number","MAX_VALUE","LN_SQRT_2_PI","PI","LOG10_2","LOG10_E","E","PI_2","bulkBuyBinarySearch","money","costInfo","alreadyBought","costFunction","firstCost","undefined","isCumulative","cumulative","lt","cantBuy","nextCost","gte","quantity","purchasePrice","canBuy","MAX_SAFE_INTEGER","Error","middle","floor","baseCost","otherCost","D0","count","i","newCost","plus","eq","totalCost","LinearMultiplierScaling","constructor","baseRatio","growth","scale","ratio","shift","logTotalMultiplierAfterPurchases","k","u","log1p","purchasesForLogTotalMultiplier","logMult","Lb","refineFinal","g","Lg","v","fVal","fDeriv","fD2","delta1","sqrt","g0","rhs","K1","K2","K3","y","h0","h1","g1","logTotalMultiplierAfterPurchasesBaseline","x","getCostWithLinearCostScaling","amountOfPurchases","costScalingStart","initialCost","costMult","costMultGrowth","preScalingPurchases","max","preScalingCost","ceil","pow","min","scaling","postScalingCost","exp","findFirstInfiniteCostPurchase","upper","isFinite","lower","mid","value","LinearCostScaling","resourcesAvailable","costMultiplier","maxPurchases","free","_purchases","clampMax","div","mul","add","_totalCostMultiplier","Decimal","_totalCost","sub","purchases","totalCostMultiplier","ExponentialCostScaling","param","_baseCost","_baseIncrease","baseIncrease","_costScale","costScale","_logBaseCost","_logBaseIncrease","_logCostScale","purchasesBeforeScaling","_purchasesBeforeScaling","scalingCostThreshold","updateCostScale","_precalcDiscriminant","_precalcCenter","calculateCost","currentPurchases","logBase","excess","logCost","E1","getMaxBought","rawMoney","numberPerSet","logMoney","newPurchases","discrim","logPrice","pExcess","getContinuumValue","contValue","clampMin","productLog","curr","prev","abs","permutationIndex","len","lexIndex","numPerm","n","index","remOrder","ordered","Array","range","perm","length","rem","push","splice","getHybridCostScaling","linCostScalingStart","linInitialCost","linCostMult","linCostMultGrowth","expInitialCost","expCostMult","expCostMultGrowth","normalCost","postInfinityAmount","logFactorial","LOGS","map","TABLE","NaN","exp1m","minus","xorshift32Update","state","fastRandom","Date","now","normalDistribution","haveSpare","spare","mean","stdDev","mag","t","binomialGeneratorFC","stirlingBase","xr","binomialDistributionSmallExpected","numSamples","p","R","NxR","pdf","cdf","output","binomialDistribution","e","pNumber","toNumber","expected","times","poissonDistribution","approximateVariance","round","binomialDistributionBTRD","poissonDistributionViaNormal","poissonDistributionSmallExpected","poissonDistributionPTRD","approxStdev","m","b","a","c","alpha","kU","kV","w","us","km","f","rho","logV","_nm","_nk","h","j","mu","sMu","iAlpha","vR","random","ik","depressedCubicRealRoots","k3","k1","k0","r","cbrt","innerDisc","po3","theta","acos","cos","quadraticRealRoots","k2","ktmp","disc","bdsc","sign","cubicRealRoots","bo3a","bo3a2","coa","q","dcrr","testCRR","console","depressedQuarticRealRoots","k4","reducedSol","includes","squareSol","solution","sr","mSol","sqrt2m","dInner","d1","d2","testDQRR","solveSimpleBiquadratic","A","B","C","D","F","solutions","xSol","yTmp","ySol","xTmp","AoB","CoB","testSSBQ","sols","s","e1","e2","AffineTransform","a00","a01","a10","a11","o0","o1","ot","Vector","transformedBy","translated","offX","offY","rotated","angle","rotation","scaled","withoutTranslation","translation","sin","sc","identity","dot","cross","asTranslate","asRotate","atan2","toString","factor","copy","matrixTransform","tform","negative","normalized","right90","left90","horiz","unitFromRadians","rad","unitFromDegrees","deg","Curve","position","NotImplementedError","derivative","secondDerivative","curvature","d","dd","dMag","shapeAt","direction","minimumDistanceTo","pDes","tMin","tMax","tGuess","tTol","EPSILON","iter","offset","dist","distDeriv","distSecondDeriv","tStep","clamp","LinearPath","p0","p1","trimStart","dir","trimEnd","transformed","relativeSVG","createOffsetLine","t0","t1","off","connectCircles","r0","r1","CubicBezier","p2","p3","nt2","t2","d3","reverse","fitCurveSection","shape0","shape1","dP","reversed","pathRotation","magSol","filter","o","OffsetCurve","baseCurve","base","shape","LogarithmicSpiral","center","rate","unit","radius","ur","angleFromRadius","fromPolarEndpoints","theta0","theta1","PiecewisePath","data","path","element","toSVG","initialPrefix","lines","part","join","cubicBezierFitToCurveSection","curve","tol","minPieces","subdivide","shapeStart","shapeEnd","maxDepth","shapeMid","single","singleFit","tMid","err","ExponentialMovingAverage","maxOutliers","highOutlierThreshold","lowOutlierThreshold","outliers","_average","average","addValue","absValue","absAverage","highOutlier","lowOutlier","outlier"],"mappings":"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","sourcesContent":["import { log as lngamma } from \"gamma\";\r\n\r\nimport { DC } from \"./constants\";\r\n\r\n/* eslint-disable no-use-before-define */\r\n/* eslint-disable max-params */\r\n\r\nwindow.LOG10_MAX_VALUE = Math.log10(Number.MAX_VALUE);\r\nwindow.LN_SQRT_2_PI = 0.5 * Math.log(2 * Math.PI);\r\nwindow.LOG10_2 = Math.log10(2);\r\nwindow.LOG10_E = Math.log10(Math.E);\r\n\r\nMath.PI_2 = Math.PI * 2;\r\n\r\n/**\r\n * This is a file for general math utilities that can be used by many mechanics\r\n */\r\n\r\n/**\r\n * @typedef {Object} bulkBuyBinarySearch_result\r\n * @property {number} quantity amount purchased (relative)\r\n * @property {Decimal} purchasePrice amount that needs to be paid to get that\r\n */\r\n\r\n/**\r\n * bulkBuyBinarySearch is a helper for bulk buyers of non-linear prices. If the price of\r\n * a thing is f(n), it's hard to figure out how much of it can be bought without an inverse\r\n * of f. This helper starts at some n0, and then searches forward in powers of 2 until it\r\n * finds a value that is not affordable. After that, it performs a binary search to figure\r\n * out how much can actually be bought. Returns an object with a quantity and price, or\r\n * null if nothing can be bought\r\n * NOTE: this will not work with slowly increasing prices. This makes the assumption that\r\n * if you can afford purchase N, you can afford the combined cost of everything before N\r\n * (it does check and make sure you can afford all of that put together. See below in code\r\n * for details)\r\n * @param {Decimal} money Amount of currency available\r\n * @param {Object} costInfo cost parameters:\r\n * @param {function(number): Decimal} costInfo.costFunction price of the n'th purchase (starting from 0)\r\n * @param {Decimal} [costInfo.firstCost] Cost of the next purchase; this is usually available/cached. Will\r\n *   be calculated from costFunction if not provided.\r\n * @param {boolean} [costInfo.cumulative] (Defaults to true) specifies whether one must pay a cumulative\r\n *   cost or just the highest cost.\r\n * @param {number} alreadyBought amount already purchased\r\n * @returns {bulkBuyBinarySearch_result | null}\r\n */\r\nwindow.bulkBuyBinarySearch = function bulkBuyBinarySearch(money, costInfo, alreadyBought) {\r\n  const costFunction = costInfo.costFunction;\r\n  const firstCost = costInfo.firstCost === undefined ? costFunction(alreadyBought) : costInfo.firstCost;\r\n  const isCumulative = costInfo.cumulative === undefined ? true : costInfo.cumulative;\r\n  if (money.lt(firstCost)) return null;\r\n  // Attempt to find the max we can purchase. We know we can buy 1, so we try 2, 4, 8, etc\r\n  // to figure out the upper limit\r\n  let cantBuy = 1;\r\n  let nextCost;\r\n  do {\r\n    cantBuy *= 2;\r\n    nextCost = costFunction(alreadyBought + cantBuy - 1);\r\n  } while (money.gte(nextCost));\r\n  // Deal with the simple case of buying just one\r\n  if (cantBuy === 2) {\r\n    return { quantity: 1, purchasePrice: firstCost };\r\n  }\r\n  // The amount we can actually buy is in the interval [canBuy/2, canBuy), we do a binary search\r\n  // to find the exact value:\r\n  let canBuy = cantBuy / 2;\r\n  if (cantBuy > Number.MAX_SAFE_INTEGER) throw new Error(\"Overflow in binary search\");\r\n  while (cantBuy - canBuy > 1) {\r\n    const middle = Math.floor((canBuy + cantBuy) / 2);\r\n    if (money.gte(costFunction(alreadyBought + middle - 1))) {\r\n      canBuy = middle;\r\n    } else {\r\n      cantBuy = middle;\r\n    }\r\n  }\r\n  const baseCost = costFunction(alreadyBought + canBuy - 1);\r\n  if (!isCumulative) {\r\n    return { quantity: canBuy, purchasePrice: baseCost };\r\n  }\r\n  let otherCost = DC.D0;\r\n  // Account for costs leading up to that purchase; we are basically adding things\r\n  // up until they are insignificant\r\n  let count = 0;\r\n  for (let i = canBuy - 1; i > 0; --i) {\r\n    const newCost = otherCost.plus(costFunction(alreadyBought + i - 1));\r\n    if (newCost.eq(otherCost)) break;\r\n    otherCost = newCost;\r\n    if (++count > 1000) throw new Error(\"unexpected long loop (buggy cost function?)\");\r\n  }\r\n  let totalCost = baseCost.plus(otherCost);\r\n  // Check the purchase price again\r\n  if (money.lt(totalCost)) {\r\n    --canBuy;\r\n    // Since prices grow rather steeply, we can safely assume that we can, indeed, buy\r\n    // one less (e.g. if prices were A, B, C, D, we could afford D, but not A+B+C+D; we\r\n    // assume we can afford A+B+C because A+B+C < D)\r\n    totalCost = otherCost;\r\n  }\r\n  return { quantity: canBuy, purchasePrice: totalCost };\r\n};\r\n\r\n/**\r\n * LinearMultiplierScaling performs calculations for multipliers that scale up\r\n * linearly. The simplest case you might consider could be a factorial -- or something\r\n * much slower, like 2 * 2.01 * 2.02 * 2.03 * ...\r\n * In terms of accuracy, it's better for slower growing multipliers than fast. For\r\n * example, with a factorial setup, it evaluates 11! as 39826281.18738219 rather than 39916800\r\n * The ratio between the estimated 10! and 11! is 10.99999474474497 which is pretty good.\r\n * For base = 2, growth = 0.1, after 10 purchases, the result is 7268.488254368145, rather\r\n * than 7268.490028799995. After 100 purchases, it's 4.582662e+79 rather than\r\n * 4.582664e+79.\r\n * Note: this doesn't do well with small initial multipliers (close to 1). 1.01 is about low\r\n * as it's reasonable to go.\r\n */\r\nwindow.LinearMultiplierScaling = class LinearMultiplierScaling {\r\n  /**\r\n   * Construct the helper object, which can be invoked for various calculations\r\n   * @param {number} baseRatio The first multiplier\r\n   * @param {number} growth The growth rate; multiplier after purchase N, starting at 0, is baseRatio + N * growth\r\n   */\r\n  constructor(baseRatio, growth) {\r\n    this.baseRatio = baseRatio;\r\n    this.growth = growth;\r\n  }\r\n\r\n  /**\r\n   * Multiply both the base ratio and the growth rate by the specified factor\r\n   * @param {number} ratio\r\n   * @returns this object for easy chaining\r\n   */\r\n  scale(ratio) {\r\n    this.baseRatio *= ratio;\r\n    this.growth *= ratio;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Shift by the specified number of purchases. For example, if you set up 2, 0.1, but you\r\n   * want the first scale factor to be 2.1, you could shift by 1\r\n   * @param {number} count number of purchases to shift by\r\n   * @returns this\r\n   */\r\n  shift(count) {\r\n    this.baseRatio += this.growth * count;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Find the combined multiplier after N purchases. N = 0 means a multiplier of 1 -- since no\r\n   * purchases have been made, no scaling has been applied. N = 1 is baseRatio, N=2 gives\r\n   * baseRatio * (baseRatio + growth), and so on. This is done using a corrected integral\r\n   * approximation\r\n   * @param {number} count number of purchases that have happened\r\n   * @returns {number} the natural log of the combined multiplier\r\n   */\r\n  logTotalMultiplierAfterPurchases(count) {\r\n    if (count === 0) return 0;\r\n    const k = this.growth / this.baseRatio;\r\n    const u = k * count;\r\n    return (1 / k + count - 0.5) * Math.log1p(u) + count * (Math.log(this.baseRatio) - 1) - k * u / (12 * (1 + u));\r\n  }\r\n\r\n  /**\r\n   * Invert the function given a combined multiplier. This doesn't do any rounding (so you\r\n   * can choose how to handle that).\r\n   * @param {number} logMult natural logarithm of combined multiplier\r\n   */\r\n  purchasesForLogTotalMultiplier(logMult) {\r\n    if (this.baseRatio < 1.01) throw new Error(\"Ratio is too small for good calculations\");\r\n    const Lb = Math.log(this.baseRatio);\r\n    const k = this.growth / this.baseRatio;\r\n    // Final refinement step, applying 2nd order iteration directly to the formula of\r\n    // logTotalMultiplierAfterPurchases\r\n    const refineFinal = g => {\r\n      const u = k * g;\r\n      const Lg = Math.log1p(u);\r\n      const v = 0.5 * k / (1 + u);\r\n      const fVal = (1 / k + g - 0.5) * Lg + g * (Lb - 1) - (logMult + v * u / 6);\r\n      const fDeriv = Lg + Lb - v * (v / 3 + 1);\r\n      const fD2 = v * (2 + v * (2 + v / 3));\r\n      const delta1 = fVal / fDeriv;\r\n      return g - 2 * delta1 / (1 + Math.sqrt(1 - 2 * delta1 * fD2 / fDeriv));\r\n    };\r\n    // We calculate an initial estimate, assuming that the price doesn't increase:\r\n    const g0 = logMult / Lb;\r\n    // If the growth rate is really slow and there's not many steps, this is great guess\r\n    // the other method (below) doesn't do well in that case.\r\n    if (k * g0 < 0.01) return refineFinal(refineFinal(g0));\r\n    const rhs = this.growth * logMult + this.baseRatio * (Lb - 1);\r\n\r\n    // First, we make a good guess at a solution, based on an approximation of the sum sas an\r\n    // uncorrected integral; these parameters came from an optimization. We are solving for\r\n    // the value of base + x * growth - 1 here\r\n    const K1 = 0.183709519164226;\r\n    const K2 = 0.693791942633232;\r\n    const K3 = 0.049293492810849;\r\n    const y = Math.sqrt(2 * (rhs + 1));\r\n    const h0 = y * (1 + K1 * y) / (1 + K2 * Math.log1p(K3 * y));\r\n\r\n    // Apply a refinement step; this also shifts the answer by 1\r\n    const h1 = (1 + h0 + rhs) / Math.log1p(h0);\r\n\r\n    // At this point we should have a pretty solid guess -- enough that this calcuolation\r\n    // should be pretty accurate; the final refinement\r\n    const g1 = (h1 - this.baseRatio) / this.growth;\r\n    return refineFinal(refineFinal(g1));\r\n  }\r\n\r\n  /**\r\n   * Manual calculation, for testing purposes\r\n   * @param {number} count\r\n   */\r\n  logTotalMultiplierAfterPurchasesBaseline(count) {\r\n    let logMult = 0;\r\n    const k = this.growth / this.baseRatio;\r\n    for (let x = 0; x < count; ++x) logMult += Math.log1p(k * x);\r\n    return logMult + count * Math.log(this.baseRatio);\r\n  }\r\n};\r\n\r\nwindow.getCostWithLinearCostScaling = function getCostWithLinearCostScaling(\r\n  amountOfPurchases, costScalingStart, initialCost, costMult, costMultGrowth\r\n) {\r\n  const preScalingPurchases = Math.max(0, Math.floor(Math.log(costScalingStart / initialCost) / Math.log(costMult)));\r\n  const preScalingCost = Math.ceil(Math.pow(costMult, Math.min(preScalingPurchases, amountOfPurchases)) * initialCost);\r\n  const scaling = new LinearMultiplierScaling(costMult, costMultGrowth);\r\n  const postScalingCost = Math.exp(scaling.logTotalMultiplierAfterPurchases(\r\n    Math.max(0, amountOfPurchases - preScalingPurchases)));\r\n  return preScalingCost * postScalingCost;\r\n};\r\n\r\n// Using the same arguments as getCostWithLinearCostScaling() above, do a binary search for the first purchase with a\r\n// cost of Infinity.\r\nwindow.findFirstInfiniteCostPurchase = function findFirstInfiniteCostPurchase(\r\n  costScalingStart, initialCost, costMult, costMultGrowth\r\n) {\r\n  let upper = 1;\r\n  while (Number.isFinite(getCostWithLinearCostScaling(upper,\r\n    costScalingStart, initialCost, costMult, costMultGrowth))) {\r\n    upper *= 2;\r\n  }\r\n  let lower = upper / 2;\r\n  while (lower < upper) {\r\n    const mid = Math.floor((lower + upper) / 2);\r\n    const value = getCostWithLinearCostScaling(mid, costScalingStart, initialCost, costMult, costMultGrowth);\r\n    if (Number.isFinite(value)) {\r\n      lower = mid + 1;\r\n    } else {\r\n      upper = mid;\r\n    }\r\n  }\r\n  return lower;\r\n};\r\n\r\n/**\r\n * LinearCostScaling is a helper class for costs that scale linearly. If we\r\n * know the available resources, initial cost, and cost multiplier, we can\r\n * figure out the maximum amount of purchases, and also the resulting total\r\n * cost and cost multiplier.\r\n *\r\n * i = initial cost\r\n * m = cost multiplier\r\n * p = purchases\r\n * t = total cost\r\n *\r\n * t = i * (1 - m^p) / (1 - m)\r\n * p = floor(log(1 + t * (m - 1) / i) / log(m))\r\n */\r\nwindow.LinearCostScaling = class LinearCostScaling {\r\n  /**\r\n   * @param {Decimal} resourcesAvailable amount of available resources\r\n   * @param {Decimal} initialCost current cost\r\n   * @param {Number} costMultiplier current cost multiplier\r\n   * @param {Number} maxPurchases max amount of purchases\r\n   * @param {Boolean} free signifies if the purchase is free -> if we only need to consider the last cost\r\n   */\r\n  constructor(resourcesAvailable, initialCost, costMultiplier, maxPurchases = Number.MAX_SAFE_INTEGER, free = false) {\r\n    if (free) {\r\n      this._purchases = Math.clampMax(Math.floor(\r\n        resourcesAvailable.div(initialCost).log10() /\r\n        Math.log10(costMultiplier) + 1), maxPurchases);\r\n    } else {\r\n      this._purchases = Math.clampMax(Math.floor(\r\n        resourcesAvailable.mul(costMultiplier - 1).div(initialCost).add(1).log10() /\r\n        Math.log10(costMultiplier)), maxPurchases);\r\n    }\r\n    this._totalCostMultiplier = Decimal.pow(costMultiplier, this._purchases);\r\n    if (free) {\r\n      this._totalCost = initialCost.mul(Decimal.pow(costMultiplier, this._purchases - 1));\r\n    } else {\r\n      this._totalCost = initialCost.mul(Decimal.sub(1, this._totalCostMultiplier)).div(1 - costMultiplier);\r\n    }\r\n  }\r\n\r\n  get purchases() {\r\n    return this._purchases;\r\n  }\r\n\r\n  get totalCostMultiplier() {\r\n    return this._totalCostMultiplier;\r\n  }\r\n\r\n  get totalCost() {\r\n    return this._totalCost;\r\n  }\r\n};\r\n\r\n/**\r\n * ExponentialCostScaling provides both a max quantity and a price\r\n * @typedef {Object} QuantityAndPrice\r\n * @property {number} quantity The new amount that can be bought\r\n * @property {number} logPrice The logarithm (base 10) of the price\r\n */\r\n\r\n/**\r\n * This is a a helper class to deal with the more common case of a cost that\r\n * grows exponentially (past some threshold). NOTE: this assumes that you only\r\n * have to pay for the highest tier when buying in bulk. That's a little bit cheaper,\r\n * but for the use cases this encounters, it's not a big deal.\r\n */\r\nwindow.ExponentialCostScaling = class ExponentialCostScaling {\r\n  /**\r\n   * @param {Object} param configuration object with the following fields\r\n   * @param {number|Decimal} param.baseCost the cost of the first purchase\r\n   * @param {number} param.baseIncrease the baseline increase in price\r\n   * @param {number} param.costScale the amount by which the cost scaling increases;\r\n   *  e.g. if it is 10, then the ratio between successive prices goes up by 10\r\n   * @param {number} [param.purchasesBeforeScaling] the number of purchases that can\r\n   *  be made before scaling begins. If baseCost is B, baseIncrease is C, and costScale is S,\r\n   *  and purchasesBeforeScaling is 0, the prices will go: B, B C, B C^2 S, B C^3 S^3, etc.\r\n   * @param {number|Decimal} [param.scalingCostThreshold] an alternative way of specifying\r\n   *  when scaling begins; once the cost is >= this threshold, scaling applies. Using the same\r\n   *  notation: B BC BC^2 .... BC^n <threshold> BC^(n+1) BC^(n+2)S BC^(n+3)S^3 etc. So, the first\r\n   *  price past the threshold has no costScale in it, but everything past that does.\r\n   */\r\n  constructor(param) {\r\n    this._baseCost = new Decimal(param.baseCost);\r\n    this._baseIncrease = param.baseIncrease;\r\n    if (typeof this._baseIncrease !== \"number\") throw new Error(\"baseIncrease must be a number\");\r\n    this._costScale = param.costScale;\r\n    if (typeof this._costScale !== \"number\") throw new Error(\"costScale must be a number\");\r\n    this._logBaseCost = ExponentialCostScaling.log10(param.baseCost);\r\n    this._logBaseIncrease = ExponentialCostScaling.log10(param.baseIncrease);\r\n    this._logCostScale = ExponentialCostScaling.log10(param.costScale);\r\n    if (param.purchasesBeforeScaling !== undefined) {\r\n      this._purchasesBeforeScaling = param.purchasesBeforeScaling;\r\n    // eslint-disable-next-line no-negated-condition\r\n    } else if (param.scalingCostThreshold !== undefined) {\r\n      this._purchasesBeforeScaling = Math.ceil(\r\n        (ExponentialCostScaling.log10(param.scalingCostThreshold) - this._logBaseCost) / this._logBaseIncrease);\r\n    } else throw new Error(\"Must specify either scalingCostThreshold or purchasesBeforeScaling\");\r\n    this.updateCostScale();\r\n  }\r\n\r\n  get costScale() {\r\n    return this._costScale;\r\n  }\r\n\r\n  /**\r\n   * @param {number} value\r\n   */\r\n  set costScale(value) {\r\n    this._logCostScale = ExponentialCostScaling.log10(value);\r\n    this._costScale = value;\r\n    this.updateCostScale();\r\n  }\r\n\r\n  updateCostScale() {\r\n    this._precalcDiscriminant = Math.pow((2 * this._logBaseIncrease + this._logCostScale), 2) -\r\n      8 * this._logCostScale * (this._purchasesBeforeScaling * this._logBaseIncrease + this._logBaseCost);\r\n    this._precalcCenter = -this._logBaseIncrease / this._logCostScale + this._purchasesBeforeScaling + 0.5;\r\n  }\r\n\r\n  /**\r\n   * Calculates the cost of the next purchase\r\n   * @param {number} currentPurchases\r\n   */\r\n  calculateCost(currentPurchases) {\r\n    const logMult = this._logBaseIncrease;\r\n    const logBase = this._logBaseCost;\r\n    const excess = currentPurchases - this._purchasesBeforeScaling;\r\n    const logCost = excess > 0\r\n      ? currentPurchases * logMult + logBase + 0.5 * excess * (excess + 1) * this._logCostScale\r\n      : currentPurchases * logMult + logBase;\r\n    return DC.E1.pow(logCost);\r\n  }\r\n\r\n  /**\r\n   * Figure out how much of this can be bought.\r\n   * This returns the maximum new number of this thing; If you have 51 and can\r\n   * afford to buy 10 more, this will return 61. NOTE! this assumes you only\r\n   * have to pay for the most expensive thing you get when you buy in bulk. This\r\n   * means it's not suitable for accurate caclulation of cumulative prices if the\r\n   * multiplier is small.\r\n   * @param {number} currentPurchases amount already possessed\r\n   * @param {Decimal} money\r\n   * @returns {QuantityAndPrice|null} maximum value of bought that money can buy up to\r\n   */\r\n  getMaxBought(currentPurchases, rawMoney, numberPerSet) {\r\n    // We need to divide money by the number of things we need to buy per set\r\n    // so that we don't, for example, buy all of a set of 10 dimensions\r\n    // when we can only afford 1.\r\n    const money = rawMoney.div(numberPerSet);\r\n    const logMoney = money.log10();\r\n    const logMult = this._logBaseIncrease;\r\n    const logBase = this._logBaseCost;\r\n    // The 1 + is because the multiplier isn't applied to the first purchase\r\n    let newPurchases = Math.floor(1 + (logMoney - logBase) / logMult);\r\n    // We can use the linear method up to one purchase past the threshold, because the first purchase\r\n    // past the threshold doesn't have cost scaling in it yet.\r\n    if (newPurchases > this._purchasesBeforeScaling) {\r\n      const discrim = this._precalcDiscriminant + 8 * this._logCostScale * logMoney;\r\n      if (discrim < 0) {\r\n        return null;\r\n      }\r\n      newPurchases = Math.floor(this._precalcCenter + Math.sqrt(discrim) / (2 * this._logCostScale));\r\n    }\r\n    if (newPurchases <= currentPurchases) return null;\r\n    // There's a narrow edge case where the linear method returns > this._purchasesBeforeScaling + 1\r\n    // but the quadratic method returns less than that. Having this be a separate check covers that\r\n    // case:\r\n    let logPrice;\r\n    if (newPurchases <= this._purchasesBeforeScaling + 1) {\r\n      logPrice = (newPurchases - 1) * logMult + logBase;\r\n    } else {\r\n      const pExcess = newPurchases - this._purchasesBeforeScaling;\r\n      logPrice = (newPurchases - 1) * logMult + logBase + 0.5 * pExcess * (pExcess - 1) * this._logCostScale;\r\n    }\r\n    return { quantity: newPurchases - currentPurchases, logPrice: logPrice + Math.log10(numberPerSet) };\r\n  }\r\n\r\n  /**\r\n   * Determines the number of purchases that would be possible, if purchase count was continuous. Might\r\n   * have some odd behavior right at e308, but otherwise should work. It's mostly a copy-paste from\r\n   * getMaxBought() above but with unnecessary extra code removed.\r\n   * @param {Decimal} money\r\n   * @returns {number} maximum value of bought that money can buy up to\r\n   */\r\n  getContinuumValue(rawMoney, numberPerSet) {\r\n    // We need to divide money by the number of things we need to buy per set\r\n    // so that we don't, for example, buy all of a set of 10 dimensions\r\n    // when we can only afford 1. In the specific case of continuum this means,\r\n    // for example, that 10 AM buys 2/3 of a set of 10 first dimensions rather than\r\n    // buying the whole set of 10, which at least feels more correct.\r\n    const money = rawMoney.div(numberPerSet);\r\n    const logMoney = money.log10();\r\n    const logMult = this._logBaseIncrease;\r\n    const logBase = this._logBaseCost;\r\n    // The 1 + is because the multiplier isn't applied to the first purchase\r\n    let contValue = 1 + (logMoney - logBase) / logMult;\r\n    // We can use the linear method up to one purchase past the threshold, because the first purchase\r\n    // past the threshold doesn't have cost scaling in it yet.\r\n    if (contValue > this._purchasesBeforeScaling) {\r\n      const discrim = this._precalcDiscriminant + 8 * this._logCostScale * logMoney;\r\n      if (discrim < 0) {\r\n        return 0;\r\n      }\r\n      contValue = this._precalcCenter + Math.sqrt(discrim) / (2 * this._logCostScale);\r\n    }\r\n    return Math.clampMin(contValue, 0);\r\n  }\r\n\r\n  static log10(value) {\r\n    if (value instanceof Decimal) return value.log10();\r\n    return Math.log10(value);\r\n  }\r\n};\r\n\r\n// Numerical approximation for values from the Lambert W function, using Newton's method with some algebraic\r\n// changes to make it less likely to overflow. Relative precision of 1e-6 should be good enough for most purposes;\r\n// this should never be turned down to 0 as there can be oscillatory behavior due to floating point quantization\r\n// that never converges to a fixed point. It also seems to take much longer to converge at higher values.\r\nwindow.productLog = function productLog(x) {\r\n  let curr = x, prev = 0;\r\n  do {\r\n    prev = curr;\r\n    curr -= 1 - (1 + x * Math.exp(-curr)) / (1 + curr);\r\n  } while (Math.abs(curr - prev) > 1e-6 * curr);\r\n  return curr;\r\n};\r\n\r\n// Implementation of \"Lehmer code\" decoding to produce a specific permutation, given a permutation length and a\r\n// lexicographic index for the specified permutation. Calling with a lexicographic index that is too large will\r\n// not throw an error, but will use lexIndex % len! as an index instead.\r\n// This may behave incorrectly if len! > 9e15, which occurs when len > 18.\r\nwindow.permutationIndex = function permutationIndex(len, lexIndex) {\r\n  let numPerm = 1;\r\n  for (let n = 1; n <= len; n++) numPerm *= n;\r\n  let index = lexIndex % numPerm;\r\n  let remOrder = numPerm / len;\r\n  const ordered = Array.range(0, len);\r\n  const perm = [];\r\n  while (ordered.length > 0) {\r\n    const div = Math.floor(index / remOrder);\r\n    const rem = index % remOrder;\r\n    perm.push(ordered.splice(div, 1)[0]);\r\n    index = rem;\r\n    remOrder /= ordered.length;\r\n  }\r\n  return perm;\r\n};\r\n\r\n// Calculate cost scaling for something that follows getCostWithLinearCostScaling() under Infinity and immediately\r\n// starts accelerated ExponentialCostScaling above Infinity.  Yes this is a fuckton of arguments, sorry.  It sort of\r\n// needs to inherit all arguments from both cost scaling functions.\r\nwindow.getHybridCostScaling = function getHybridCostScaling(\r\n  amountOfPurchases, linCostScalingStart, linInitialCost, linCostMult, linCostMultGrowth,\r\n  expInitialCost, expCostMult, expCostMultGrowth\r\n) {\r\n  const normalCost = getCostWithLinearCostScaling(amountOfPurchases, linCostScalingStart, linInitialCost,\r\n    linCostMult, linCostMultGrowth);\r\n  if (Number.isFinite(normalCost)) {\r\n    return new Decimal(normalCost);\r\n  }\r\n  const postInfinityAmount = amountOfPurchases - findFirstInfiniteCostPurchase(linCostScalingStart, linInitialCost,\r\n    linCostMult, linCostMultGrowth);\r\n  const costScale = new ExponentialCostScaling({\r\n    baseCost: expInitialCost,\r\n    baseIncrease: expCostMult,\r\n    costScale: expCostMultGrowth,\r\n    scalingCostThreshold: Number.MAX_VALUE\r\n  });\r\n  return costScale.calculateCost(postInfinityAmount);\r\n};\r\n\r\nwindow.logFactorial = (function() {\r\n  const LOGS = Array.range(1, 11).map(Math.log);\r\n  const TABLE = [0];\r\n  for (const x of LOGS) {\r\n    TABLE.push(TABLE[TABLE.length - 1] + x);\r\n  }\r\n  return x => {\r\n    if (typeof x !== \"number\" || x < 0) return NaN;\r\n    if (x < TABLE.length) return TABLE[x];\r\n    return lngamma(x + 1);\r\n  };\r\n}());\r\n\r\nwindow.exp1m = function(x) {\r\n  if (x.abs().gte(0.001)) {\r\n    return x.exp().minus(1);\r\n  }\r\n  // This sum contains all the terms that are relevant for |x| < 0.001. We could do some sort of loop\r\n  // (add terms as long as they matter) but that probably has a greater fixed overhead, and we don't\r\n  // call this enough for efficiency to be very worrying anyway.\r\n  return x.plus(x.pow(2).div(2)).plus(x.pow(3).div(6)).plus(x.pow(4).div(24)).plus(x.pow(5).div(120));\r\n};\r\n\r\n/** 32 bit XORSHIFT generator */\r\nwindow.xorshift32Update = function xorshift32Update(state) {\r\n  /* eslint-disable no-param-reassign */\r\n  state ^= state << 13;\r\n  state ^= state >>> 17;\r\n  state ^= state << 5;\r\n  /* eslint-enable no-param-reassign */\r\n  return state;\r\n};\r\n\r\nwindow.fastRandom = (function() {\r\n  let state = Math.floor(Date.now()) % Math.pow(2, 32);\r\n  const scale = 1 / (Math.pow(2, 32));\r\n  return () => {\r\n    state = xorshift32Update(state);\r\n    return state * scale + 0.5;\r\n  };\r\n}());\r\n\r\n// Normal distribution with specified mean and standard deviation\r\nwindow.normalDistribution = (function() {\r\n  let haveSpare = false;\r\n  let spare = 0;\r\n  return (mean, stdDev) => {\r\n    if (typeof mean !== \"number\" || typeof stdDev !== \"number\") return NaN;\r\n    if (haveSpare) {\r\n      haveSpare = false;\r\n      return mean + stdDev * spare;\r\n    }\r\n    let mag, u, v;\r\n    do {\r\n      u = fastRandom() * 2 - 1;\r\n      v = fastRandom() * 2 - 1;\r\n      mag = u * u + v * v;\r\n    } while (mag >= 1 || mag === 0);\r\n    const t = Math.sqrt(-2 * Math.log(mag) / mag);\r\n    haveSpare = true;\r\n    spare = v * t;\r\n    return mean + stdDev * u * t;\r\n  };\r\n}());\r\n\r\n// Helper function for BTRD\r\nwindow.binomialGeneratorFC = (function() {\r\n  const stirlingBase = x => -8.10614667953272582e-2 + (x + 0.5) * Math.log1p(x) - x;\r\n  const TABLE = Array.range(0, 20).map(x => logFactorial(x) - stirlingBase(x));\r\n  return x => {\r\n    if (typeof x !== \"number\" || x < 0) return NaN;\r\n    if (x < TABLE.length) return TABLE[x];\r\n    const xr = 1 / (x + 1);\r\n    return (1 / 12 - (1 / 360 - (xr * xr) / 1260) * (xr * xr)) * xr;\r\n  };\r\n}());\r\n\r\n/**\r\n * This manually inverts the cumulative probability distribution\r\n * @param {number} numSamples number of drawn samples\r\n * @param {number} p probability\r\n * @returns {number} number of samples that satisfied p\r\n */\r\nwindow.binomialDistributionSmallExpected = function binomialDistributionSmallExpected(numSamples, p) {\r\n  const R = p / (1 - p);\r\n  const NxR = (numSamples + 1) * R;\r\n  // Calculate (1-p)^n without rounding error at 1 - p\r\n  let pdf = Math.exp(Math.log1p(-p) * numSamples);\r\n  const u = fastRandom();\r\n  let cdf = pdf;\r\n  let output = 0;\r\n  while (u > cdf) {\r\n    ++output;\r\n    pdf *= (NxR / output - R);\r\n    if (cdf + pdf === cdf) break;\r\n    cdf += pdf;\r\n  }\r\n  return output;\r\n};\r\n\r\nwindow.binomialDistribution = function binomialDistribution(numSamples, p) {\r\n  if (p === 0) return 0;\r\n  if (numSamples instanceof Decimal) {\r\n    if (numSamples.e < 308) {\r\n      const pNumber = typeof p === \"number\" ? p : p.toNumber();\r\n      return new Decimal(binomialDistribution(numSamples.toNumber(), pNumber));\r\n    }\r\n    const expected = numSamples.times(p);\r\n    if (expected.e > 32) return expected;\r\n    return new Decimal(poissonDistribution(numSamples.times(p)));\r\n  }\r\n  const expected = numSamples * p;\r\n  // BTRD is good past 10, but the inversion method we use is faster up to 15 and is exact\r\n  if (expected < 15) return binomialDistributionSmallExpected(numSamples, p);\r\n  if (p > 0.5) return numSamples - binomialDistribution(numSamples, 1 - p);\r\n  // At some point, the variance is so small relative to the expected value that\r\n  // all samples are within eps of the mean\r\n  if (expected > 1e32) return expected;\r\n  const approximateVariance = expected * (1 - p);\r\n  // Normal approximation is good enough for larger distributions\r\n  if (approximateVariance > 1e4) return Math.round(normalDistribution(expected, Math.sqrt(approximateVariance)));\r\n  return binomialDistributionBTRD(numSamples, p);\r\n};\r\n\r\n/**\r\n * Chooses the method of generation based on the input\r\n * @param {number|Decimal} expected expected value of distribution\r\n * @returns {number|Decimal} number of poisson process events\r\n */\r\nwindow.poissonDistribution = function poissonDistribution(expected) {\r\n  if (expected === 0) return 0;\r\n  if (expected instanceof Decimal) {\r\n    if (expected.e > 32) return expected;\r\n    return new Decimal(poissonDistribution(expected.toNumber()));\r\n  }\r\n  if (expected > 1e32) return expected;\r\n  if (expected > 1e4) return poissonDistributionViaNormal(expected);\r\n  if (expected < 20) return poissonDistributionSmallExpected(expected);\r\n  return poissonDistributionPTRD(expected);\r\n};\r\n\r\n/**\r\n * Uses a normal approximation to sqrt(x)\r\n */\r\nwindow.poissonDistributionViaNormal = function poissonDistributionViaNormal(expected) {\r\n  const x = normalDistribution(Math.sqrt(expected), 0.5);\r\n  return Math.floor(x * x);\r\n};\r\n\r\n/**\r\n * This manually inverts the cumulative probability distribution\r\n */\r\nwindow.poissonDistributionSmallExpected = function poissonDistributionSmallExpected(expected) {\r\n  let pdf = Math.exp(-expected);\r\n  let cdf = pdf;\r\n  const u = fastRandom();\r\n  let output = 0;\r\n  while (u > cdf) {\r\n    ++output;\r\n    pdf *= expected / output;\r\n    if (cdf + pdf === cdf) break;\r\n    cdf += pdf;\r\n  }\r\n  return output;\r\n};\r\n\r\n/**\r\n * Algorithm from https://core.ac.uk/download/pdf/11007254.pdf\r\n */\r\nwindow.binomialDistributionBTRD = function binomialDistributionBTRD(numSamples, p) {\r\n  const expected = numSamples * p;\r\n  const approximateVariance = expected * (1 - p);\r\n  const approxStdev = Math.sqrt(approximateVariance);\r\n  const m = Math.floor(expected + p);\r\n  const R = p / (1 - p);\r\n  const NxR = (numSamples + 1) * R;\r\n  const b = 1.15 + 2.53 * approxStdev;\r\n  const a = -0.0873 + 0.0248 * b + 0.01 * p;\r\n  const c = expected + 0.5;\r\n  const alpha = (2.83 + 5.1 / b) * approxStdev;\r\n  const kU = 0.43;\r\n  const kV = 0.92 - 4.2 / b;\r\n  // eslint-disable-next-line no-constant-condition\r\n  while (true) {\r\n    let v = fastRandom();\r\n    if (v <= 2 * kU * kV) {\r\n      const u = v / kV - kU;\r\n      return Math.floor((2 * a / (0.5 - Math.abs(u)) + b) * u + c);\r\n    }\r\n    let u;\r\n    if (v >= kV) {\r\n      u = fastRandom() - 0.5;\r\n    } else {\r\n      const w = v / kV - 0.93;\r\n      v = fastRandom() * kV;\r\n      u = (w > 0 ? 0.5 : -0.5) - w;\r\n    }\r\n    const us = 0.5 - Math.abs(u);\r\n    const k = Math.floor((2 * a / us + b) * u + c);\r\n    if (k < 0 || k > numSamples) continue;\r\n    v *= alpha / (a / (us * us) + b);\r\n    const km = Math.abs(k - m);\r\n    // These loops are very fast, compared to calculating all the logs and stuff below; the\r\n    // original paper has 15 here but 40 seems to be closer to optimal.\r\n    if (km <= 40) {\r\n      let f = 1;\r\n      if (m < k) {\r\n        for (let i = m + 1; i <= k; ++i) f *= (NxR / i - R);\r\n      } else if (m > k) {\r\n        for (let i = k + 1; i <= m; ++i) v *= (NxR / i - R);\r\n      }\r\n      if (v <= f) return k;\r\n      continue;\r\n    }\r\n    const rho = (km / approximateVariance) * (((km / 3 + 0.625) * km + 1 / 6) / approximateVariance + 0.5);\r\n    const t = -km * km / (2 * approximateVariance);\r\n    const logV = Math.log(v);\r\n    if (logV < t - rho) return k;\r\n    if (logV > t + rho) continue;\r\n    const _nm = numSamples - m + 1;\r\n    const _nk = numSamples - k + 1;\r\n    const h = (m + 0.5) * Math.log((m + 1) / (R * _nm)) +\r\n      binomialGeneratorFC(m) + binomialGeneratorFC(numSamples - m);\r\n    const j = (numSamples + 1) * Math.log(_nm / _nk) + (k + 0.5) * Math.log(_nk * R / (k + 1)) -\r\n      binomialGeneratorFC(k) - binomialGeneratorFC(numSamples - k);\r\n    if (logV <= h + j) return k;\r\n  }\r\n};\r\n\r\n/**\r\n * \"The transformed rejection method for generating Poisson random variables\"\r\n * http://epub.wu.ac.at/352/1/document.pdf\r\n * @param {number} mu expected value of distribution\r\n * @returns {number} (integer) number of events in poisson process\r\n */\r\nwindow.poissonDistributionPTRD = function poissonDistributionPTRD(mu) {\r\n  const sMu = Math.sqrt(mu);\r\n  const b = 0.931 + 2.53 * sMu;\r\n  const a = -0.059 + 0.02483 * b;\r\n  const iAlpha = 1.1239 + 1.328 / (b - 3.4);\r\n  const vR = 0.9277 - 3.6224 / (b - 2);\r\n  // eslint-disable-next-line no-constant-condition\r\n  while (true) {\r\n    let v = Math.random();\r\n    if (v < 0.86 * vR) {\r\n      const u = v / vR - 0.43;\r\n      return Math.floor((2 * a / (0.5 - Math.abs(u)) + b) * u + mu + 0.445);\r\n    }\r\n    let u;\r\n    if (v >= vR) {\r\n      u = fastRandom() - 0.5;\r\n    } else {\r\n      const w = v / vR - 0.93;\r\n      u = (w > 0 ? 0.5 : -0.5) - w;\r\n      v = fastRandom() * vR;\r\n    }\r\n    const us = 0.5 - Math.abs(u);\r\n    if (us < 0.013 && us < v) continue;\r\n    const k = Math.floor((2 * a / us + b) * u + mu + 0.445);\r\n    v *= iAlpha / (a / us / us + b);\r\n    const ik = 1 / k;\r\n    if (k >= 10) {\r\n      const t = (k + 0.5) * Math.log(mu * ik) - mu - LN_SQRT_2_PI + k - (1 / 12 - ik * ik / 360) * ik;\r\n      if (Math.log(v * sMu) <= t) return k;\r\n    } else if (Math.log(v) <= k * Math.log(mu) - mu - logFactorial(k)) return k;\r\n  }\r\n};\r\n\r\nwindow.depressedCubicRealRoots = function depressedCubicRealRoots(k3, k1, k0) {\r\n  if (k3 === 0) {\r\n    if (k1 === 0) return [];\r\n    return [-k0 / k1];\r\n  }\r\n  /* eslint-disable no-param-reassign */\r\n  k1 /= k3;\r\n  k0 /= k3;\r\n  /* eslint-enable no-param-reassign */\r\n  if (k0 === 0) {\r\n    if (k1 === 0) return [0];\r\n    if (k1 > 0) return [];\r\n    const r = Math.sqrt(-k1);\r\n    return [r, -r];\r\n  }\r\n  if (k1 === 0) {\r\n    return [Math.cbrt(-k0)];\r\n  }\r\n  let innerDisc = 0.25 * k0 * k0 + k1 * k1 * k1 / 27;\r\n  if (innerDisc >= 0) {\r\n    innerDisc = Math.sqrt(innerDisc);\r\n    return [Math.cbrt(-0.5 * k0 + innerDisc) + Math.cbrt(-0.5 * k0 - innerDisc)];\r\n  }\r\n  const po3 = 2 * Math.sqrt(-k1 / 3);\r\n  const theta = Math.acos(3 * k0 / (k1 * po3)) / 3;\r\n  return [\r\n    po3 * Math.cos(theta),\r\n    po3 * Math.cos(theta - 2 * Math.PI / 3),\r\n    po3 * Math.cos(theta - 4 * Math.PI / 3),\r\n  ];\r\n};\r\n\r\nwindow.quadraticRealRoots = function quadraticRealRoots(k2, k1, k0) {\r\n  if (k2 === 0) {\r\n    if (k1 === 0) return [];\r\n    return [-k0 / k1];\r\n  }\r\n  if (k1 === 0) {\r\n    const ktmp = k0 / k2;\r\n    if (ktmp > 0) return [];\r\n    return [Math.sqrt(-ktmp), -Math.sqrt(-ktmp)];\r\n  }\r\n  const disc = k1 * k1 - 4 * k2 * k0;\r\n  if (disc < 0) return [];\r\n  if (disc === 0) return [-k1 / (2 * k2)];\r\n  const bdsc = -k1 - Math.sign(k1) * Math.sqrt(disc);\r\n  return [\r\n    bdsc / (2 * k2),\r\n    2 * k0 / bdsc\r\n  ];\r\n};\r\n\r\nwindow.cubicRealRoots = function cubicRealRoots(k3, k2, k1, k0) {\r\n  if (k3 === 0) {\r\n    return quadraticRealRoots(k2, k1, k0);\r\n  }\r\n  if (k2 === 0) return depressedCubicRealRoots(k3, k1, k0);\r\n  const bo3a = k2 / (3 * k3);\r\n  const bo3a2 = bo3a * bo3a;\r\n  const coa = k1 / k3;\r\n  const p = coa - 3 * bo3a2;\r\n  const q = 2 * bo3a * bo3a2 - bo3a * coa + k0 / k3;\r\n  const dcrr = depressedCubicRealRoots(1, p, q);\r\n  return dcrr.map(t => t - bo3a);\r\n};\r\n\r\nwindow.testCRR = function testCRR(k3, k2, k1, k0) {\r\n  const r = cubicRealRoots(k3, k2, k1, k0);\r\n  // eslint-disable-next-line no-console\r\n  console.log(r);\r\n  // eslint-disable-next-line no-console\r\n  console.log(r.map(x => k0 + x * (k1 + x * (k2 + x * k3))));\r\n};\r\n\r\nwindow.depressedQuarticRealRoots = function depressedQuarticRealRoots(k4, k2, k1, k0) {\r\n  if (k4 === 0) return quadraticRealRoots(k2, k1, k0);\r\n  if (k0 === 0) {\r\n    const reducedSol = depressedCubicRealRoots(k4, k2, k1);\r\n    if (!reducedSol.includes(0)) reducedSol.push(0);\r\n    return reducedSol;\r\n  }\r\n  if (k1 === 0) {\r\n    const squareSol = quadraticRealRoots(k4, k2, k0);\r\n    const solution = [];\r\n    for (const sr of squareSol) {\r\n      if (sr < 0) continue;\r\n      if (sr === 0) solution.push(0);\r\n      else solution.push(Math.sqrt(sr), -Math.sqrt(sr));\r\n    }\r\n    return solution;\r\n  }\r\n  /* eslint-disable no-param-reassign */\r\n  k2 /= k4;\r\n  k1 /= k4;\r\n  k0 /= k4;\r\n  /* eslint-enable no-param-reassign */\r\n  const mSol = cubicRealRoots(8, 8 * k2, 2 * k2 * k2 - 8 * k0, -k1 * k1);\r\n  const m = mSol.max();\r\n  // I don't think this can happen, but I haven't double checked the math\r\n  if (m <= 0) return [];\r\n  const sqrt2m = Math.sqrt(2 * m);\r\n  const dInner = 2 * k1 / sqrt2m;\r\n  const d1 = -(2 * k2 + 2 * m + dInner);\r\n  const solution = [];\r\n  if (d1 > 0) {\r\n    solution.push(0.5 * (sqrt2m + Math.sqrt(d1)), 0.5 * (sqrt2m - Math.sqrt(d1)));\r\n  } else if (d1 === 0) {\r\n    solution.push(0.5 * sqrt2m);\r\n  }\r\n  const d2 = -(2 * k2 + 2 * m - dInner);\r\n  if (d2 > 0) {\r\n    solution.push(0.5 * (-sqrt2m + Math.sqrt(d2)), 0.5 * (-sqrt2m - Math.sqrt(d2)));\r\n  } else if (d2 === 0) {\r\n    solution.push(-0.5 * sqrt2m);\r\n  }\r\n  return solution;\r\n};\r\n\r\nwindow.testDQRR = function testDQRR(k4, k2, k1, k0) {\r\n  const r = depressedQuarticRealRoots(k4, k2, k1, k0);\r\n  // eslint-disable-next-line no-console\r\n  console.log(r);\r\n  // eslint-disable-next-line no-console\r\n  console.log(r.map(x => k0 + x * (k1 + x * (k2 + x * x * k4))));\r\n};\r\n\r\nwindow.solveSimpleBiquadratic = function solveSimpleBiquadratic(A, B, C, D, E, F) {\r\n  const solutions = [];\r\n  if (A === 0) {\r\n    if (B === 0 || E === 0) return [];\r\n    const y = -C / B;\r\n    if (D === 0) return [{ x: -F / E, y }];\r\n    return [{ x: (-F - D * y * y) / E, y }];\r\n  }\r\n  if (D === 0) {\r\n    if (B === 0 || E === 0) return [];\r\n    const x = -F / E;\r\n    return [{ x, y: (-C - A * x * x) / B }];\r\n  }\r\n  if (B === 0) {\r\n    const xSol = quadraticRealRoots(A, 0, C);\r\n    for (const x of xSol) {\r\n      const yTmp = F + E * x;\r\n      const ySol = quadraticRealRoots(D, 0, yTmp);\r\n      for (const y of ySol) solutions.push({ x, y });\r\n    }\r\n    return solutions;\r\n  }\r\n  if (E === 0) {\r\n    const ySol = quadraticRealRoots(D, 0, F);\r\n    for (const y of ySol) {\r\n      const xTmp = C + B * y;\r\n      const xSol = quadraticRealRoots(A, 0, xTmp);\r\n      for (const x of xSol) solutions.push({ x, y });\r\n    }\r\n    return solutions;\r\n  }\r\n  const AoB = A / B;\r\n  const CoB = C / B;\r\n  const xSol = depressedQuarticRealRoots(D * AoB * AoB, 2 * D * AoB * CoB, E, F + D * CoB * CoB);\r\n  for (const x of xSol) solutions.push({ x, y: -(AoB * x * x + CoB) });\r\n  return solutions;\r\n};\r\n\r\nwindow.testSSBQ = function testSSBQ(A, B, C, D, E, F) {\r\n  // eslint-disable-next-line no-console\r\n  console.log({ A, B, C, D, E, F });\r\n  const sols = solveSimpleBiquadratic(A, B, C, D, E, F);\r\n  for (const s of sols) {\r\n    const e1 = A * s.x * s.x + B * s.y + C;\r\n    const e2 = D * s.y * s.y + E * s.x + F;\r\n    // eslint-disable-next-line no-console\r\n    console.log(`${s.x} ${s.y} ${e1} ${e2}`);\r\n  }\r\n};\r\n\r\nwindow.AffineTransform = class AffineTransform {\r\n  constructor(a00 = 1, a01 = 0, a10 = 0, a11 = 1, o0 = 0, o1 = 0) {\r\n    this.a00 = a00;\r\n    this.a01 = a01;\r\n    this.a10 = a10;\r\n    this.a11 = a11;\r\n    this.o0 = o0;\r\n    this.o1 = o1;\r\n  }\r\n\r\n  times(ot) {\r\n    if (ot instanceof AffineTransform) {\r\n      return new AffineTransform(\r\n        this.a00 * ot.a00 + this.a01 * ot.a10, this.a00 * ot.a01 + this.a01 * ot.a11,\r\n        this.a10 * ot.a00 + this.a11 * ot.a10, this.a10 * ot.a01 + this.a11 * ot.a11,\r\n        this.a00 * ot.o0 + this.a01 * ot.o1 + this.o0,\r\n        this.a10 * ot.o0 + this.a11 * ot.o1 + this.o1\r\n      );\r\n    }\r\n    if (ot instanceof Vector) return ot.transformedBy(this);\r\n    throw new Error(\"unsupported operation\");\r\n  }\r\n\r\n  translated(offX, offY = undefined) {\r\n    if (offX instanceof Vector) {\r\n      return new AffineTransform(this.a00, this.a01, this.a10, this.a11, this.o0 + offX.x, this.o1 + offX.y);\r\n    }\r\n    return new AffineTransform(this.a00, this.a01, this.a10, this.a11, this.o0 + offX, this.o1 + offY);\r\n  }\r\n\r\n  rotated(angle) {\r\n    return AffineTransform.rotation(angle).times(this);\r\n  }\r\n\r\n  scaled(scale) {\r\n    return AffineTransform.scale(scale).times(this);\r\n  }\r\n\r\n  get withoutTranslation() {\r\n    return new AffineTransform(this.a00, this.a01, this.a10, this.a11);\r\n  }\r\n\r\n  static translation(offX, offY) {\r\n    if (offX instanceof Vector) {\r\n      return new AffineTransform(1, 0, 0, 1, offX.x, offX.y);\r\n    }\r\n    return new AffineTransform(1, 0, 0, 1, offX, offY);\r\n  }\r\n\r\n  static rotation(angle) {\r\n    const c = Math.cos(angle), s = Math.sin(angle);\r\n    return new AffineTransform(c, -s, s, c);\r\n  }\r\n\r\n  static scale(sc) {\r\n    return new AffineTransform(sc, 0, 0, sc);\r\n  }\r\n\r\n  static identity() {\r\n    return new AffineTransform();\r\n  }\r\n};\r\n\r\nwindow.Vector = class Vector {\r\n  constructor(x, y) {\r\n    this.x = x;\r\n    this.y = y;\r\n  }\r\n\r\n  get length() {\r\n    return Math.sqrt(this.x * this.x + this.y * this.y);\r\n  }\r\n\r\n  plus(v) {\r\n    return new Vector(this.x + v.x, this.y + v.y);\r\n  }\r\n\r\n  dot(v) {\r\n    return this.x * v.x + this.y * v.y;\r\n  }\r\n\r\n  cross(v) {\r\n    // Produces scalar, z term of 3D vectors\r\n    return this.x * v.y - this.y * v.x;\r\n  }\r\n\r\n  minus(v) {\r\n    return new Vector(this.x - v.x, this.y - v.y);\r\n  }\r\n\r\n  times(s) {\r\n    return new Vector(this.x * s, this.y * s);\r\n  }\r\n\r\n  asTranslate() {\r\n    return `translate(${this.x}, ${this.y})`;\r\n  }\r\n\r\n  asRotate() {\r\n    return `rotate(${180 / Math.PI * Math.atan2(this.y, this.x)})`;\r\n  }\r\n\r\n  toString() {\r\n    return `${this.x}, ${this.y}`;\r\n  }\r\n\r\n  round(factor) {\r\n    return new Vector(Math.round(this.x * factor) / factor, Math.round(this.y * factor) / factor);\r\n  }\r\n\r\n  get copy() {\r\n    return new Vector(this.x, this.y);\r\n  }\r\n\r\n  matrixTransform(a00, a01, a10, a11) {\r\n    return new Vector(a00 * this.x + a01 * this.y, a10 * this.x + a11 * this.y);\r\n  }\r\n\r\n  transformedBy(tform) {\r\n    return new Vector(tform.a00 * this.x + tform.a01 * this.y + tform.o0,\r\n      tform.a10 * this.x + tform.a11 * this.y + tform.o1);\r\n  }\r\n\r\n  get negative() {\r\n    return new Vector(-this.x, -this.y);\r\n  }\r\n\r\n  get normalized() {\r\n    return this.times(1 / this.length);\r\n  }\r\n\r\n  get right90() {\r\n    return new Vector(this.y, -this.x);\r\n  }\r\n\r\n  get left90() {\r\n    return new Vector(-this.y, this.x);\r\n  }\r\n\r\n  get angle() {\r\n    return Math.atan2(this.y, this.x);\r\n  }\r\n\r\n  static horiz(x) {\r\n    return new Vector(x, 0);\r\n  }\r\n\r\n  static unitFromRadians(rad) {\r\n    return new Vector(Math.cos(rad), Math.sin(rad));\r\n  }\r\n\r\n  static unitFromDegrees(deg) {\r\n    return Vector.unitFromRadians(deg * Math.PI / 180);\r\n  }\r\n};\r\n\r\n\r\nwindow.Curve = class Curve {\r\n  /**\r\n   * @abstract\r\n   * @param {number} t\r\n   * @returns {Vector}\r\n  */\r\n  position() {\r\n    throw new NotImplementedError();\r\n  }\r\n\r\n  /**\r\n   * @abstract\r\n   * @param {number} t\r\n   * @returns {Vector}\r\n  */\r\n  derivative() {\r\n    throw new NotImplementedError();\r\n  }\r\n\r\n  /**\r\n   * @abstract\r\n   * @param {number} t\r\n   * @returns {Vector}\r\n  */\r\n  secondDerivative() {\r\n    throw new NotImplementedError();\r\n  }\r\n\r\n  /**\r\n   * @param {number} t\r\n   * @returns {number}\r\n   */\r\n  curvature(t) {\r\n    const d = this.derivative(t);\r\n    const dd = this.secondDerivative(t);\r\n    const dMag = d.length;\r\n    return d.cross(dd) / (dMag * dMag * dMag);\r\n  }\r\n\r\n  shapeAt(t) {\r\n    const d = this.derivative(t);\r\n    return {\r\n      t,\r\n      position: this.position(t),\r\n      derivative: d,\r\n      direction: d.normalized,\r\n      curvature: this.curvature(t),\r\n    };\r\n  }\r\n\r\n  minimumDistanceTo(pDes, tMin, tMax) {\r\n    let tGuess = 0.5 * (tMin + tMax);\r\n    const tTol = Math.max(Math.abs(tMax), Math.abs(tMin)) * Number.EPSILON * 16;\r\n    for (let iter = 0; ; ++iter) {\r\n      const p = this.position(tGuess);\r\n      const d = this.derivative(tGuess);\r\n      const dd = this.secondDerivative(tGuess);\r\n      const offset = p.minus(pDes);\r\n      const dist = offset.length;\r\n      const distDeriv = offset.dot(d) * 2;\r\n      /* eslint-disable no-param-reassign */\r\n      if (distDeriv > 0) tMax = tGuess;\r\n      else tMin = tGuess;\r\n      /* eslint-enable no-param-reassign */\r\n      const distSecondDeriv = (offset.dot(dd) + d.dot(d)) * 2;\r\n      const tStep = distSecondDeriv < 0 ? -dist / distDeriv : -distDeriv / distSecondDeriv;\r\n      if (Math.abs(tStep) < tTol || iter >= 16) return dist;\r\n      tGuess = Math.clamp(tGuess + tStep, tMin, tMax);\r\n    }\r\n  }\r\n};\r\n\r\nwindow.LinearPath = class LinearPath extends Curve {\r\n  constructor(p0, p1) {\r\n    super();\r\n    this.p0 = p0.copy;\r\n    this.p1 = p1.copy;\r\n  }\r\n\r\n  position(t) {\r\n    return this.p0.times(1 - t).plus(this.p1.times(t));\r\n  }\r\n\r\n  derivative() {\r\n    return this.p1.minus(this.p0);\r\n  }\r\n\r\n  secondDerivative() {\r\n    return new Vector(0, 0);\r\n  }\r\n\r\n  // eslint-disable-next-line no-unused-vars\r\n  curvature(t) {\r\n    return 0;\r\n  }\r\n\r\n  trimStart(len) {\r\n    const dir = this.p1.minus(this.p0).normalized;\r\n    return new LinearPath(this.p0.plus(dir.times(len)), this.p1);\r\n  }\r\n\r\n  trimEnd(len) {\r\n    const dir = this.p1.minus(this.p0).normalized;\r\n    return new LinearPath(this.p0, this.p1.minus(dir.times(len)));\r\n  }\r\n\r\n  transformed(tform) {\r\n    return new LinearPath(this.p0.transformedBy(tform), this.p1.transformedBy(tform));\r\n  }\r\n\r\n  get relativeSVG() {\r\n    const d1 = this.p1.minus(this.p0);\r\n    return `l ${d1.x} ${d1.y}\\n`;\r\n  }\r\n\r\n  createOffsetLine(offset, t0 = 0, t1 = 1) {\r\n    const off = this.p1.minus(this.p0).normalized.right90.times(offset);\r\n    return new LinearPath(this.position(t0).plus(off), this.position(t1).plus(off));\r\n  }\r\n\r\n  static connectCircles(p0, r0, p1, r1) {\r\n    const dir = p1.minus(p0).normalized;\r\n    return new LinearPath(p0.plus(dir.times(r0)), p1.minus(dir.times(r1)));\r\n  }\r\n};\r\n\r\nclass CubicBezier extends Curve {\r\n  constructor(p0, p1, p2, p3) {\r\n    super();\r\n    this.p0 = p0.copy;\r\n    this.p1 = p1.copy;\r\n    this.p2 = p2.copy;\r\n    this.p3 = p3.copy;\r\n  }\r\n\r\n  position(t) {\r\n    const nt2 = (1 - t) * (1 - t);\r\n    const t2 = t * t;\r\n    return this.p0.times((1 - t) * nt2)\r\n      .plus(this.p1.times(3 * t * nt2))\r\n      .plus(this.p2.times(3 * t2 * (1 - t)))\r\n      .plus(this.p3.times(t2 * t));\r\n  }\r\n\r\n  derivative(t) {\r\n    return this.p1.minus(this.p0).times(3 * (1 - t) * (1 - t))\r\n      .plus(this.p2.minus(this.p1).times(6 * t * (1 - t)))\r\n      .plus(this.p3.minus(this.p2).times(3 * t * t));\r\n  }\r\n\r\n  secondDerivative(t) {\r\n    return this.p2.minus(this.p1.times(2)).plus(this.p0).times(6 * (1 - t))\r\n      .plus(this.p3.minus(this.p2.times(2)).plus(this.p1).times(6 * t));\r\n  }\r\n\r\n  transformed(tform) {\r\n    return new CubicBezier(this.p0.transformedBy(tform), this.p1.transformedBy(tform),\r\n      this.p2.transformedBy(tform), this.p3.transformedBy(tform));\r\n  }\r\n\r\n  get relativeSVG() {\r\n    const d1 = this.p1.minus(this.p0);\r\n    const d2 = this.p2.minus(this.p0);\r\n    const d3 = this.p3.minus(this.p0);\r\n    return `c ${d1.x} ${d1.y} ${d2.x} ${d2.y} ${d3.x} ${d3.y}\\n`;\r\n  }\r\n\r\n  get reverse() {\r\n    return new CubicBezier(this.p3, this.p2, this.p1, this.p0);\r\n  }\r\n\r\n  static fitCurveSection(shape0, shape1) {\r\n    const dP = shape1.position.minus(shape0.position);\r\n    const reversed = shape0.t > shape1.t;\r\n    const pathRotation = shape0.direction.cross(shape1.direction);\r\n    let magSol = solveSimpleBiquadratic(\r\n      1.5 * shape0.curvature, pathRotation, -shape0.direction.cross(dP),\r\n      1.5 * shape1.curvature, pathRotation, shape1.direction.cross(dP));\r\n    magSol = reversed ? magSol.filter(o => o.x <= 0 && o.y <= 0) : magSol.filter(o => o.x >= 0 && o.y >= 0);\r\n    if (magSol.length === 0) return null;\r\n    return new CubicBezier(\r\n      shape0.position, shape0.position.plus(shape0.direction.times(magSol[0].x)),\r\n      shape1.position.minus(shape1.direction.times(magSol[0].y)), shape1.position);\r\n  }\r\n}\r\n\r\n// This is an \"inset/outset\" kind of transform\r\nwindow.OffsetCurve = class OffsetCurve extends Curve {\r\n  constructor(baseCurve, offset) {\r\n    super();\r\n    this.base = baseCurve;\r\n    this.offset = offset;\r\n  }\r\n\r\n  position(t) {\r\n    const p = this.base.position(t);\r\n    const d = this.base.derivative(t);\r\n    return p.plus(d.normalized.right90.times(this.offset));\r\n  }\r\n\r\n  derivative(t) {\r\n    return this.base.derivative(t);\r\n  }\r\n\r\n  // 2nd derivative not implemented as only curvature is used atm\r\n  curvature(t) {\r\n    const c = this.base.curvature(t);\r\n    return 1 / (1 / c + this.offset);\r\n  }\r\n\r\n  shapeAt(t) {\r\n    const shape = this.base.shapeAt(t);\r\n    return {\r\n      t: shape.t,\r\n      position: shape.position.plus(shape.direction.right90.times(this.offset)),\r\n      derivative: shape.derivative,\r\n      direction: shape.direction,\r\n      curvature: shape.curvature / (1 + this.offset * shape.curvature),\r\n    };\r\n  }\r\n};\r\n\r\nwindow.LogarithmicSpiral = class LogarithmicSpiral extends Curve {\r\n  constructor(center, scale, rate) {\r\n    super();\r\n    this.center = center;\r\n    this.scale = scale;\r\n    this.rate = rate;\r\n  }\r\n\r\n  position(t) {\r\n    return Vector.unitFromRadians(t)\r\n      .times(this.scale * Math.exp(this.rate * t))\r\n      .plus(this.center);\r\n  }\r\n\r\n  derivative(t) {\r\n    const unit = Vector.unitFromRadians(t);\r\n    const radius = this.scale * Math.exp(this.rate * t);\r\n    return unit.times(radius * this.rate).plus(unit.left90.times(radius));\r\n  }\r\n\r\n  secondDerivative(t) {\r\n    const unit = Vector.unitFromRadians(t);\r\n    const radius = this.scale * Math.exp(this.rate * t);\r\n    return unit.times(radius * (this.rate * this.rate - 1))\r\n      .plus(unit.left90.times(2 * radius * this.rate));\r\n  }\r\n\r\n  shapeAt(t) {\r\n    const unit = Vector.unitFromRadians(t);\r\n    const radius = this.scale * Math.exp(this.rate * t);\r\n    const ur = unit.times(radius);\r\n    const d = ur.times(this.rate).plus(ur.left90);\r\n    return {\r\n      t,\r\n      position: ur.plus(this.center),\r\n      derivative: d,\r\n      direction: d.normalized,\r\n      curvature: 1 / (Math.abs(radius) * Math.sqrt(1 + this.rate * this.rate))\r\n    };\r\n  }\r\n\r\n  angleFromRadius(r) {\r\n    return Math.log(r / this.scale) / this.rate;\r\n  }\r\n\r\n  static fromPolarEndpoints(center, theta0, r0, theta1, r1) {\r\n    const rate = Math.log(r1 / r0) / (theta1 - theta0);\r\n    return new LogarithmicSpiral(center, r0 / Math.exp(rate * theta0), rate);\r\n  }\r\n};\r\n\r\nwindow.PiecewisePath = class PiecewisePath {\r\n  constructor(data = undefined) {\r\n    this.path = data ? data : [];\r\n  }\r\n\r\n  push(element) {\r\n    this.path.push(element);\r\n  }\r\n\r\n  transformedBy(tform) {\r\n    return new PiecewisePath(this.path.map(x => x.transformed(tform)));\r\n  }\r\n\r\n  toSVG(initialPrefix) {\r\n    const p0 = this.path[0].position(0);\r\n    const lines = [`${initialPrefix} ${p0.x} ${p0.y}\\n`];\r\n    for (const part of this.path) lines.push(part.relativeSVG);\r\n    return lines.join(\"\");\r\n  }\r\n\r\n  static cubicBezierFitToCurveSection(curve, t0, t1, tol = 1, minPieces = 1) {\r\n    const output = new PiecewisePath();\r\n    const shape0 = curve.shapeAt(t0);\r\n    const shape1 = curve.shapeAt(t1);\r\n    function subdivide(shapeStart, shapeEnd, maxDepth = 8) {\r\n      const shapeMid = curve.shapeAt(0.5 * (shapeStart.t + shapeEnd.t));\r\n      return single(shapeStart, shapeMid, maxDepth - 1) &&\r\n        single(shapeMid, shapeEnd, maxDepth - 1);\r\n    }\r\n    function single(shapeStart, shapeEnd, maxDepth = 8) {\r\n      const singleFit = CubicBezier.fitCurveSection(shapeStart, shapeEnd);\r\n      if (singleFit === null) {\r\n        if (maxDepth <= 0) throw new Error(\"coulnd't decompose curve\");\r\n        return subdivide(shapeStart, shapeEnd, maxDepth);\r\n      }\r\n      const tMid = 0.5 * (shapeStart.t + shapeEnd.t);\r\n      const err = singleFit.minimumDistanceTo(curve.position(tMid), 0, 1);\r\n      if (err > tol) {\r\n        return subdivide(shapeStart, shapeEnd, maxDepth);\r\n      }\r\n      output.push(singleFit);\r\n      return true;\r\n    }\r\n    if (minPieces > 1) subdivide(shape0, shape1);\r\n    else single(shape0, shape1);\r\n    return output;\r\n  }\r\n};\r\n\r\n// https://stackoverflow.com/a/9201081\r\nwindow.ExponentialMovingAverage = class ExponentialMovingAverage {\r\n  constructor(alpha = 0.02, maxOutliers = 5, highOutlierThreshold = 3, lowOutlierThreshold = 0.4) {\r\n    this.alpha = alpha;\r\n    this.maxOutliers = maxOutliers;\r\n    this.highOutlierThreshold = highOutlierThreshold;\r\n    this.lowOutlierThreshold = lowOutlierThreshold;\r\n    this.outliers = 0;\r\n    this._average = undefined;\r\n  }\r\n\r\n  get average() {\r\n    if (this._average === undefined) {\r\n      return 0;\r\n    }\r\n    return this._average;\r\n  }\r\n\r\n  addValue(value) {\r\n    if (this._average === undefined) {\r\n      this._average = value;\r\n    } else {\r\n      this._average += this.alpha * (value - this._average);\r\n\r\n      const absValue = Math.abs(value);\r\n      const absAverage = Math.abs(this._average);\r\n      const highOutlier = absValue > absAverage * this.highOutlierThreshold;\r\n      const lowOutlier = absValue < absAverage * this.lowOutlierThreshold;\r\n      const outlier = highOutlier || lowOutlier;\r\n\r\n      if (outlier) {\r\n        this.outliers++;\r\n        if (this.outliers >= this.maxOutliers) {\r\n          this._average = value;\r\n          this.outliers = 0;\r\n        }\r\n      } else {\r\n        this.outliers = 0;\r\n      }\r\n    }\r\n  }\r\n};\r\n"]},"metadata":{},"sourceType":"module"}