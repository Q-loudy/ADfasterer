{"ast":null,"code":"import _objectSpread from \"C:/Games/ADFasterer/ADfasterer/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array.flat-map.js\";\nimport \"core-js/modules/es.array.unscopables.flat-map.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.flat.js\";\nimport \"core-js/modules/es.array.unscopables.flat.js\";\n\nclass CosmeticGlyphType {\n  constructor(setup, isCosmetic) {\n    var _setup$preventBlur, _setup$fixedSymbolCol;\n\n    this.id = setup.id;\n    this._defaultSymbol = setup.symbol;\n    this._defaultColor = setup.color;\n    this.preventBlur = (_setup$preventBlur = setup.preventBlur) !== null && _setup$preventBlur !== void 0 ? _setup$preventBlur : false;\n    this.isUnlocked = setup.isUnlocked;\n    this._canCustomize = setup.canCustomize;\n    this.fixedSymbolColor = (_setup$fixedSymbolCol = setup.fixedSymbolColor) !== null && _setup$fixedSymbolCol !== void 0 ? _setup$fixedSymbolCol : false;\n    this.isCosmetic = isCosmetic;\n  } // This looks hacky because isUnlocked is also used for game mechanic purposes with non-cosmetic\n  // types and must be false for cursed, reality, and companion glyphs. However, we use it to determine\n  // if a type should be displayed at all in the case of cosmetic types\n\n\n  get canCustomize() {\n    var _this$isUnlocked, _this$isUnlocked2, _this$_canCustomize, _this$_canCustomize2;\n\n    return (!this.isCosmetic || ((_this$isUnlocked = (_this$isUnlocked2 = this.isUnlocked) === null || _this$isUnlocked2 === void 0 ? void 0 : _this$isUnlocked2.call(this)) !== null && _this$isUnlocked !== void 0 ? _this$isUnlocked : true)) && ((_this$_canCustomize = (_this$_canCustomize2 = this._canCustomize) === null || _this$_canCustomize2 === void 0 ? void 0 : _this$_canCustomize2.call(this)) !== null && _this$_canCustomize !== void 0 ? _this$_canCustomize : true);\n  }\n\n  get defaultSymbol() {\n    return {\n      symbol: this._defaultSymbol,\n      blur: !this.preventBlur\n    };\n  }\n\n  get defaultColor() {\n    const color = this.id === \"reality\" ? GlyphAppearanceHandler.realityColor : this._defaultColor;\n    const isNormallyDark = !GlyphAppearanceHandler.isLightBG;\n    return {\n      border: color,\n      bg: isNormallyDark === (this.id === \"cursed\") ? \"white\" : \"black\"\n    };\n  }\n\n  get currentSymbol() {\n    const custom = player.reality.glyphs.cosmetics.symbolMap[this.id];\n    if (!player.reality.glyphs.cosmetics.active || !custom) return this.defaultSymbol;\n    return {\n      symbol: custom,\n      blur: !(this.preventBlur || GlyphAppearanceHandler.unblurredSymbols.includes(custom))\n    };\n  }\n\n  get currentColor() {\n    const custom = player.reality.glyphs.cosmetics.colorMap[this.id];\n    if (!player.reality.glyphs.cosmetics.active || !custom) return this.defaultColor;\n    const colorProps = GlyphAppearanceHandler.getColorProps(custom);\n    return _objectSpread(_objectSpread({}, colorProps), {}, {\n      str: custom\n    });\n  }\n\n  get ignoreRarityColor() {\n    return this.isCosmetic || this.fixedSymbolColor;\n  }\n\n}\n\nconst functionalGlyphs = mapGameDataToObject(GameDatabase.reality.glyphTypes, config => new CosmeticGlyphType(config, false));\nconst cosmeticGlyphs = mapGameDataToObject(GameDatabase.reality.cosmeticGlyphs, config => new CosmeticGlyphType(config, true));\nexport const CosmeticGlyphTypes = _objectSpread(_objectSpread(_objectSpread({}, functionalGlyphs), cosmeticGlyphs), {}, {\n  get list() {\n    return Object.keys(_objectSpread(_objectSpread({}, GameDatabase.reality.glyphTypes), GameDatabase.reality.cosmeticGlyphs)).map(e => CosmeticGlyphTypes[e]);\n  }\n\n});\nexport const GlyphAppearanceHandler = {\n  setInModal: null,\n  chosenFromModal: null,\n\n  get cosmeticsEnabled() {\n    return player.reality.glyphs.cosmetics.active;\n  },\n\n  get symbolMap() {\n    return player.reality.glyphs.cosmetics.symbolMap;\n  },\n\n  get colorMap() {\n    return player.reality.glyphs.cosmetics.colorMap;\n  },\n\n  get availableSymbols() {\n    return Object.values(GameDatabase.reality.glyphCosmeticSets).filter(s => this.unlockedSets.includes(s.id)).map(s => s.symbol).filter(s => s);\n  },\n\n  // Sort the colors by hue, otherwise finding specific colors would be a mess for UX.\n  // However, colors \"close enough to grayscale\" are sorted separately and first\n  get availableColors() {\n    const sortedArray = Object.values(GameDatabase.reality.glyphCosmeticSets).filter(s => this.unlockedSets.includes(s.id)).flatMap(s => s.color).sort((a, b) => {\n      const getHue = hex => {\n        const parts = hex.split(\"#\");\n        const color = parts[1];\n        const rgb = [parseInt(color.substring(0, 2), 16) / 255, parseInt(color.substring(2, 4), 16) / 255, parseInt(color.substring(4), 16) / 255];\n        const min = Math.min(...rgb),\n              max = Math.max(...rgb);\n        if (max - min < 0.3) return max;\n        let rawHue;\n        if (rgb[0] === max) rawHue = (rgb[1] - rgb[2]) / (max - min);else if (rgb[1] === max) rawHue = 2 + (rgb[2] - rgb[1]) / (max - min);else rawHue = 4 + (rgb[0] - rgb[1]) / (max - min);\n        return 6 + (rawHue + 6) % 6;\n      };\n\n      return getHue(a) - getHue(b);\n    }).filter(c => c); // We want two rows in the color selection Vue component, but that displays options in columns (one column\n    // per set of symbol options). Here we do a bit of array manipulation to lay out colors as two rows, separated\n    // by BG color and with the longer row on top (UI doesn't handle empty top-row spots well)\n\n    const blackArr = sortedArray.filter(c => c.charAt(0) === \"B\");\n    const whiteArr = sortedArray.filter(c => c.charAt(0) === \"W\");\n    const longer = blackArr.length > whiteArr.length ? blackArr : whiteArr;\n    const shorter = blackArr.length > whiteArr.length ? whiteArr : blackArr;\n    const combined = [];\n\n    for (let index = 0; index < longer.length; index++) {\n      if (index < shorter.length) combined.push([longer[index], shorter[index]]);else combined.push([longer[index]]);\n    }\n\n    return combined;\n  },\n\n  get availableTypes() {\n    return Object.values(GameDatabase.reality.cosmeticGlyphs).map(type => CosmeticGlyphTypes[type.id]).filter(type => type.isUnlocked()).map(type => type.id);\n  },\n\n  get unblurredSymbols() {\n    return Object.values(GameDatabase.reality.glyphCosmeticSets).filter(s => s.preventBlur).map(s => s.symbol).flat();\n  },\n\n  // Note: This can *technically* be inconsistent with the actual number of sets, but only y a cheated save.\n  get expectedSetCount() {\n    return ShopPurchaseData.singleCosmeticSet + player.records.fullGameCompletions;\n  },\n\n  // Returns true for \"light\" BG glyphs and false for \"dark\" BG glyphs\n  get isLightBG() {\n    switch (player.options.glyphBG) {\n      case GLYPH_BG_SETTING.AUTO:\n        return !Theme.current().isDark();\n\n      case GLYPH_BG_SETTING.LIGHT:\n        return true;\n\n      case GLYPH_BG_SETTING.DARK:\n        return false;\n\n      default:\n        throw new Error(\"Unrecognized Glyph BG setting\");\n    }\n  },\n\n  getBorderColor(type) {\n    if (type === \"cursed\" && !CosmeticGlyphTypes.cursed.currentColor.str) return this.isLightBG ? \"#ffffff\" : \"#000000\";\n    return CosmeticGlyphTypes[type].currentColor.border;\n  },\n\n  getRarityColor(strength, type) {\n    const rarityEntry = getRarity(strength);\n    const isLight = CosmeticGlyphTypes[type].currentColor.bg === \"white\";\n    const colorKey = `${isLight ? \"light\" : \"dark\"}${player.options.highContrastRarity ? \"HighContrast\" : \"Color\"}`;\n    return rarityEntry[colorKey];\n  },\n\n  getColorProps(colorStr) {\n    // This condition is a bit odd - this specifically selects out the hybrid custom colors which have both a BG color\n    // and a hex code. Reality color looks like \"rgb(...\" and also goes in this conditional\n    if ((colorStr === null || colorStr === void 0 ? void 0 : colorStr.charAt(1)) !== \"#\") {\n      return {\n        border: colorStr,\n        bg: this.isLightBG ? \"white\" : \"black\"\n      };\n    }\n\n    return {\n      border: colorStr.substring(1),\n      bg: colorStr.charAt(0) === \"B\" ? \"black\" : \"white\"\n    };\n  },\n\n  // Only used to ensure readable glyph tooltips\n  getBaseColor(isInverted) {\n    const isNormallyDark = !this.isLightBG;\n    if (isInverted) return isNormallyDark ? \"white\" : \"black\";\n    return isNormallyDark ? \"black\" : \"white\";\n  },\n\n  // This produces a linearly interpolated color between the basic glyph colors, but with RGB channels copied and\n  // hardcoded from the color data because that's probably preferable to a very hacky hex conversion method. The\n  // order used is {infinity, dilation, power, replication, time, infinity, ... }. This is used in multiple places\n  // and this approach is much lighter on performance due to colored keyframe animations causing significant lag.\n  get realityColor() {\n    // RGB values for the colors to interpolate between\n    const r = [182, 100, 34, 3, 178, 182];\n    const g = [127, 221, 170, 169, 65, 127];\n    const b = [51, 23, 72, 244, 227, 51]; // Integer and fractional parts for interpolation parameter (10s period, equal 2s per step)\n\n    const timer = Date.now() % 10000;\n    const i = Math.floor(timer / 2000);\n    const f = timer / 2000 - i;\n    return `rgb(${r[i] * (1 - f) + r[i + 1] * f},\n      ${g[i] * (1 - f) + g[i + 1] * f},\n      ${b[i] * (1 - f) + b[i + 1] * f})`;\n  },\n\n  get unlockedSets() {\n    if (ShopPurchase.allCosmeticSets > 0) return Object.keys(GameDatabase.reality.glyphCosmeticSets);\n    return [...new Set(player.reality.glyphs.cosmetics.unlockedFromNG.concat(ShopPurchaseData.unlockedCosmetics))];\n  },\n\n  get lockedSets() {\n    return Object.keys(GameDatabase.reality.glyphCosmeticSets).filter(set => !this.unlockedSets.includes(set));\n  },\n\n  // Unlocks the set chosen in the modal, choosing a random available one as a fallback. This is only called for\n  // sets unlocked through game completions; STD purchases are handled with ShopPurchaseData\n  unlockSet() {\n    var _GlyphAppearanceHandl;\n\n    const lockedSets = this.lockedSets;\n    const toUnlock = (_GlyphAppearanceHandl = GlyphAppearanceHandler.chosenFromModal) === null || _GlyphAppearanceHandl === void 0 ? void 0 : _GlyphAppearanceHandl.id;\n    let unlocked;\n\n    if (toUnlock && lockedSets.includes(toUnlock)) {\n      unlocked = toUnlock;\n    } else if (!toUnlock && lockedSets.length > 0) {\n      // Randomness doesn't need to be seeded since we normally let the player choose and randomness is just a fallback\n      unlocked = lockedSets[Math.floor(Math.random() * lockedSets.length)];\n    } else {\n      return;\n    }\n\n    player.reality.glyphs.cosmetics.unlockedFromNG.push(unlocked);\n    const entry = GameDatabase.reality.glyphCosmeticSets[unlocked];\n    GameUI.notify.info(`You have unlocked the \"${entry.name}\" Set for Glyph cosmetics!`, 10000);\n    GlyphAppearanceHandler.chosenFromModal = null;\n    this.applyNotification();\n  },\n\n  applyNotification() {\n    TabNotification.newGlyphCosmetic.clearTrigger();\n    TabNotification.newGlyphCosmetic.tryTrigger();\n    player.reality.glyphs.cosmetics.glowNotification = true;\n  },\n\n  // Deletes invalid glyph cosmetics for individual symbols or colors which aren't unlocked. Note that this should only\n  // be called on import and not on page load, as there is a minor async delay on-load which will cause STD purchases\n  // to not be accounted for when loading an already-existing local save\n  clearInvalidCosmetics() {\n    const allGlyphs = player.reality.glyphs.active.concat(player.reality.glyphs.inventory);\n    const allSymbols = GlyphAppearanceHandler.availableSymbols.flat();\n    const allColors = GlyphAppearanceHandler.availableSymbols.flat();\n\n    for (const glyph of allGlyphs) {\n      if (!allSymbols.includes(glyph.symbol)) glyph.symbol = undefined;\n      if (!allColors.includes(glyph.color)) glyph.color = undefined;\n      if (!GlyphAppearanceHandler.availableTypes.includes(glyph.cosmetic)) glyph.cosmetic = undefined;\n    }\n\n    const cosmetics = player.reality.glyphs.cosmetics;\n\n    for (const key of Object.keys(cosmetics.symbolMap)) {\n      const selectedSymbol = cosmetics.symbolMap[key];\n      if (!allSymbols.includes(selectedSymbol)) cosmetics.symbolMap[key] = undefined;\n    }\n\n    for (const key of Object.keys(cosmetics.colorMap)) {\n      const selectedColor = cosmetics.symbolMap[key];\n      if (!allColors.includes(selectedColor)) cosmetics.colorMap[key] = undefined;\n    }\n  }\n\n};","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/glyphs/glyph-cosmetics.js"],"names":["CosmeticGlyphType","constructor","setup","isCosmetic","id","_defaultSymbol","symbol","_defaultColor","color","preventBlur","isUnlocked","_canCustomize","canCustomize","fixedSymbolColor","defaultSymbol","blur","defaultColor","GlyphAppearanceHandler","realityColor","isNormallyDark","isLightBG","border","bg","currentSymbol","custom","player","reality","glyphs","cosmetics","symbolMap","active","unblurredSymbols","includes","currentColor","colorMap","colorProps","getColorProps","str","ignoreRarityColor","functionalGlyphs","mapGameDataToObject","GameDatabase","glyphTypes","config","cosmeticGlyphs","CosmeticGlyphTypes","list","Object","keys","map","e","setInModal","chosenFromModal","cosmeticsEnabled","availableSymbols","values","glyphCosmeticSets","filter","s","unlockedSets","availableColors","sortedArray","flatMap","sort","a","b","getHue","hex","parts","split","rgb","parseInt","substring","min","Math","max","rawHue","c","blackArr","charAt","whiteArr","longer","length","shorter","combined","index","push","availableTypes","type","flat","expectedSetCount","ShopPurchaseData","singleCosmeticSet","records","fullGameCompletions","options","glyphBG","GLYPH_BG_SETTING","AUTO","Theme","current","isDark","LIGHT","DARK","Error","getBorderColor","cursed","getRarityColor","strength","rarityEntry","getRarity","isLight","colorKey","highContrastRarity","colorStr","getBaseColor","isInverted","r","g","timer","Date","now","i","floor","f","ShopPurchase","allCosmeticSets","Set","unlockedFromNG","concat","unlockedCosmetics","lockedSets","set","unlockSet","toUnlock","unlocked","random","entry","GameUI","notify","info","name","applyNotification","TabNotification","newGlyphCosmetic","clearTrigger","tryTrigger","glowNotification","clearInvalidCosmetics","allGlyphs","inventory","allSymbols","allColors","glyph","undefined","cosmetic","key","selectedSymbol","selectedColor"],"mappings":"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","sourcesContent":["class CosmeticGlyphType {\r\n  constructor(setup, isCosmetic) {\r\n    this.id = setup.id;\r\n    this._defaultSymbol = setup.symbol;\r\n    this._defaultColor = setup.color;\r\n    this.preventBlur = setup.preventBlur ?? false;\r\n    this.isUnlocked = setup.isUnlocked;\r\n    this._canCustomize = setup.canCustomize;\r\n    this.fixedSymbolColor = setup.fixedSymbolColor ?? false;\r\n    this.isCosmetic = isCosmetic;\r\n  }\r\n\r\n  // This looks hacky because isUnlocked is also used for game mechanic purposes with non-cosmetic\r\n  // types and must be false for cursed, reality, and companion glyphs. However, we use it to determine\r\n  // if a type should be displayed at all in the case of cosmetic types\r\n  get canCustomize() {\r\n    return (!this.isCosmetic || (this.isUnlocked?.() ?? true)) && (this._canCustomize?.() ?? true);\r\n  }\r\n\r\n  get defaultSymbol() {\r\n    return {\r\n      symbol: this._defaultSymbol,\r\n      blur: !this.preventBlur,\r\n    };\r\n  }\r\n\r\n  get defaultColor() {\r\n    const color = this.id === \"reality\" ? GlyphAppearanceHandler.realityColor : this._defaultColor;\r\n    const isNormallyDark = !GlyphAppearanceHandler.isLightBG;\r\n    return {\r\n      border: color,\r\n      bg: (isNormallyDark === (this.id === \"cursed\")) ? \"white\" : \"black\",\r\n    };\r\n  }\r\n\r\n  get currentSymbol() {\r\n    const custom = player.reality.glyphs.cosmetics.symbolMap[this.id];\r\n    if (!player.reality.glyphs.cosmetics.active || !custom) return this.defaultSymbol;\r\n    return {\r\n      symbol: custom,\r\n      blur: !(this.preventBlur || GlyphAppearanceHandler.unblurredSymbols.includes(custom)),\r\n    };\r\n  }\r\n\r\n  get currentColor() {\r\n    const custom = player.reality.glyphs.cosmetics.colorMap[this.id];\r\n    if (!player.reality.glyphs.cosmetics.active || !custom) return this.defaultColor;\r\n    const colorProps = GlyphAppearanceHandler.getColorProps(custom);\r\n    return {\r\n      ...colorProps,\r\n      str: custom,\r\n    };\r\n  }\r\n\r\n  get ignoreRarityColor() {\r\n    return this.isCosmetic || this.fixedSymbolColor;\r\n  }\r\n}\r\n\r\nconst functionalGlyphs = mapGameDataToObject(\r\n  GameDatabase.reality.glyphTypes,\r\n  config => new CosmeticGlyphType(config, false)\r\n);\r\n\r\nconst cosmeticGlyphs = mapGameDataToObject(\r\n  GameDatabase.reality.cosmeticGlyphs,\r\n  config => new CosmeticGlyphType(config, true)\r\n);\r\n\r\nexport const CosmeticGlyphTypes = {\r\n  ...functionalGlyphs,\r\n  ...cosmeticGlyphs,\r\n  get list() {\r\n    return Object.keys({ ...GameDatabase.reality.glyphTypes, ...GameDatabase.reality.cosmeticGlyphs })\r\n      .map(e => CosmeticGlyphTypes[e]);\r\n  },\r\n};\r\n\r\nexport const GlyphAppearanceHandler = {\r\n  setInModal: null,\r\n  chosenFromModal: null,\r\n  get cosmeticsEnabled() {\r\n    return player.reality.glyphs.cosmetics.active;\r\n  },\r\n  get symbolMap() {\r\n    return player.reality.glyphs.cosmetics.symbolMap;\r\n  },\r\n  get colorMap() {\r\n    return player.reality.glyphs.cosmetics.colorMap;\r\n  },\r\n  get availableSymbols() {\r\n    return Object.values(GameDatabase.reality.glyphCosmeticSets)\r\n      .filter(s => this.unlockedSets.includes(s.id))\r\n      .map(s => s.symbol)\r\n      .filter(s => s);\r\n  },\r\n  // Sort the colors by hue, otherwise finding specific colors would be a mess for UX.\r\n  // However, colors \"close enough to grayscale\" are sorted separately and first\r\n  get availableColors() {\r\n    const sortedArray = Object.values(GameDatabase.reality.glyphCosmeticSets)\r\n      .filter(s => this.unlockedSets.includes(s.id))\r\n      .flatMap(s => s.color)\r\n      .sort((a, b) => {\r\n        const getHue = hex => {\r\n          const parts = hex.split(\"#\");\r\n          const color = parts[1];\r\n          const rgb = [\r\n            parseInt(color.substring(0, 2), 16) / 255,\r\n            parseInt(color.substring(2, 4), 16) / 255,\r\n            parseInt(color.substring(4), 16) / 255\r\n          ];\r\n          const min = Math.min(...rgb), max = Math.max(...rgb);\r\n          if (max - min < 0.3) return max;\r\n          let rawHue;\r\n          if (rgb[0] === max) rawHue = (rgb[1] - rgb[2]) / (max - min);\r\n          else if (rgb[1] === max) rawHue = 2 + (rgb[2] - rgb[1]) / (max - min);\r\n          else rawHue = 4 + (rgb[0] - rgb[1]) / (max - min);\r\n          return 6 + ((rawHue + 6) % 6);\r\n        };\r\n        return getHue(a) - getHue(b);\r\n      })\r\n      .filter(c => c);\r\n\r\n    // We want two rows in the color selection Vue component, but that displays options in columns (one column\r\n    // per set of symbol options). Here we do a bit of array manipulation to lay out colors as two rows, separated\r\n    // by BG color and with the longer row on top (UI doesn't handle empty top-row spots well)\r\n    const blackArr = sortedArray.filter(c => c.charAt(0) === \"B\");\r\n    const whiteArr = sortedArray.filter(c => c.charAt(0) === \"W\");\r\n    const longer = blackArr.length > whiteArr.length ? blackArr : whiteArr;\r\n    const shorter = blackArr.length > whiteArr.length ? whiteArr : blackArr;\r\n    const combined = [];\r\n    for (let index = 0; index < longer.length; index++) {\r\n      if (index < shorter.length) combined.push([longer[index], shorter[index]]);\r\n      else combined.push([longer[index]]);\r\n    }\r\n\r\n    return combined;\r\n  },\r\n  get availableTypes() {\r\n    return Object.values(GameDatabase.reality.cosmeticGlyphs)\r\n      .map(type => CosmeticGlyphTypes[type.id])\r\n      .filter(type => type.isUnlocked())\r\n      .map(type => type.id);\r\n  },\r\n  get unblurredSymbols() {\r\n    return Object.values(GameDatabase.reality.glyphCosmeticSets)\r\n      .filter(s => s.preventBlur)\r\n      .map(s => s.symbol)\r\n      .flat();\r\n  },\r\n  // Note: This can *technically* be inconsistent with the actual number of sets, but only y a cheated save.\r\n  get expectedSetCount() {\r\n    return ShopPurchaseData.singleCosmeticSet + player.records.fullGameCompletions;\r\n  },\r\n\r\n  // Returns true for \"light\" BG glyphs and false for \"dark\" BG glyphs\r\n  get isLightBG() {\r\n    switch (player.options.glyphBG) {\r\n      case GLYPH_BG_SETTING.AUTO:\r\n        return !Theme.current().isDark();\r\n      case GLYPH_BG_SETTING.LIGHT:\r\n        return true;\r\n      case GLYPH_BG_SETTING.DARK:\r\n        return false;\r\n      default:\r\n        throw new Error(\"Unrecognized Glyph BG setting\");\r\n    }\r\n  },\r\n  getBorderColor(type) {\r\n    if (type === \"cursed\" && !CosmeticGlyphTypes.cursed.currentColor.str) return this.isLightBG ? \"#ffffff\" : \"#000000\";\r\n    return CosmeticGlyphTypes[type].currentColor.border;\r\n  },\r\n  getRarityColor(strength, type) {\r\n    const rarityEntry = getRarity(strength);\r\n    const isLight = CosmeticGlyphTypes[type].currentColor.bg === \"white\";\r\n    const colorKey = `${isLight ? \"light\" : \"dark\"}${player.options.highContrastRarity ? \"HighContrast\" : \"Color\"}`;\r\n    return rarityEntry[colorKey];\r\n  },\r\n  getColorProps(colorStr) {\r\n    // This condition is a bit odd - this specifically selects out the hybrid custom colors which have both a BG color\r\n    // and a hex code. Reality color looks like \"rgb(...\" and also goes in this conditional\r\n    if (colorStr?.charAt(1) !== \"#\") {\r\n      return {\r\n        border: colorStr,\r\n        bg: this.isLightBG ? \"white\" : \"black\",\r\n      };\r\n    }\r\n    return {\r\n      border: colorStr.substring(1),\r\n      bg: colorStr.charAt(0) === \"B\" ? \"black\" : \"white\",\r\n    };\r\n  },\r\n  // Only used to ensure readable glyph tooltips\r\n  getBaseColor(isInverted) {\r\n    const isNormallyDark = !this.isLightBG;\r\n    if (isInverted) return isNormallyDark ? \"white\" : \"black\";\r\n    return isNormallyDark ? \"black\" : \"white\";\r\n  },\r\n\r\n  // This produces a linearly interpolated color between the basic glyph colors, but with RGB channels copied and\r\n  // hardcoded from the color data because that's probably preferable to a very hacky hex conversion method. The\r\n  // order used is {infinity, dilation, power, replication, time, infinity, ... }. This is used in multiple places\r\n  // and this approach is much lighter on performance due to colored keyframe animations causing significant lag.\r\n  get realityColor() {\r\n    // RGB values for the colors to interpolate between\r\n    const r = [182, 100, 34, 3, 178, 182];\r\n    const g = [127, 221, 170, 169, 65, 127];\r\n    const b = [51, 23, 72, 244, 227, 51];\r\n\r\n    // Integer and fractional parts for interpolation parameter (10s period, equal 2s per step)\r\n    const timer = Date.now() % 10000;\r\n    const i = Math.floor(timer / 2000);\r\n    const f = timer / 2000 - i;\r\n\r\n    return `rgb(${r[i] * (1 - f) + r[i + 1] * f},\r\n      ${g[i] * (1 - f) + g[i + 1] * f},\r\n      ${b[i] * (1 - f) + b[i + 1] * f})`;\r\n  },\r\n\r\n  get unlockedSets() {\r\n    if (ShopPurchase.allCosmeticSets > 0) return Object.keys(GameDatabase.reality.glyphCosmeticSets);\r\n    return [...new Set(player.reality.glyphs.cosmetics.unlockedFromNG.concat(ShopPurchaseData.unlockedCosmetics))];\r\n  },\r\n  get lockedSets() {\r\n    return Object.keys(GameDatabase.reality.glyphCosmeticSets).filter(set => !this.unlockedSets.includes(set));\r\n  },\r\n  // Unlocks the set chosen in the modal, choosing a random available one as a fallback. This is only called for\r\n  // sets unlocked through game completions; STD purchases are handled with ShopPurchaseData\r\n  unlockSet() {\r\n    const lockedSets = this.lockedSets;\r\n    const toUnlock = GlyphAppearanceHandler.chosenFromModal?.id;\r\n\r\n    let unlocked;\r\n    if (toUnlock && lockedSets.includes(toUnlock)) {\r\n      unlocked = toUnlock;\r\n    } else if (!toUnlock && lockedSets.length > 0) {\r\n      // Randomness doesn't need to be seeded since we normally let the player choose and randomness is just a fallback\r\n      unlocked = lockedSets[Math.floor(Math.random() * lockedSets.length)];\r\n    } else {\r\n      return;\r\n    }\r\n\r\n    player.reality.glyphs.cosmetics.unlockedFromNG.push(unlocked);\r\n    const entry = GameDatabase.reality.glyphCosmeticSets[unlocked];\r\n    GameUI.notify.info(`You have unlocked the \"${entry.name}\" Set for Glyph cosmetics!`, 10000);\r\n    GlyphAppearanceHandler.chosenFromModal = null;\r\n    this.applyNotification();\r\n  },\r\n  applyNotification() {\r\n    TabNotification.newGlyphCosmetic.clearTrigger();\r\n    TabNotification.newGlyphCosmetic.tryTrigger();\r\n    player.reality.glyphs.cosmetics.glowNotification = true;\r\n  },\r\n\r\n  // Deletes invalid glyph cosmetics for individual symbols or colors which aren't unlocked. Note that this should only\r\n  // be called on import and not on page load, as there is a minor async delay on-load which will cause STD purchases\r\n  // to not be accounted for when loading an already-existing local save\r\n  clearInvalidCosmetics() {\r\n    const allGlyphs = player.reality.glyphs.active.concat(player.reality.glyphs.inventory);\r\n    const allSymbols = GlyphAppearanceHandler.availableSymbols.flat();\r\n    const allColors = GlyphAppearanceHandler.availableSymbols.flat();\r\n    for (const glyph of allGlyphs) {\r\n      if (!allSymbols.includes(glyph.symbol)) glyph.symbol = undefined;\r\n      if (!allColors.includes(glyph.color)) glyph.color = undefined;\r\n      if (!GlyphAppearanceHandler.availableTypes.includes(glyph.cosmetic)) glyph.cosmetic = undefined;\r\n    }\r\n    const cosmetics = player.reality.glyphs.cosmetics;\r\n    for (const key of Object.keys(cosmetics.symbolMap)) {\r\n      const selectedSymbol = cosmetics.symbolMap[key];\r\n      if (!allSymbols.includes(selectedSymbol)) cosmetics.symbolMap[key] = undefined;\r\n    }\r\n    for (const key of Object.keys(cosmetics.colorMap)) {\r\n      const selectedColor = cosmetics.symbolMap[key];\r\n      if (!allColors.includes(selectedColor)) cosmetics.colorMap[key] = undefined;\r\n    }\r\n  }\r\n};\r\n"]},"metadata":{},"sourceType":"module"}