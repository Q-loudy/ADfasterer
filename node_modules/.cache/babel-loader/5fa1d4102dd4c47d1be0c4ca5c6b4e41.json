{"ast":null,"code":"import _objectSpread from \"C:/Games/ADFasterer/ADfasterer/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.string.replace-all.js\";\nimport { lexer, tokenMap as T } from \"./lexer\";\nimport { AutomatorCommands } from \"./automator-commands\";\nimport { parser } from \"./parser\";\nconst BaseVisitor = parser.getBaseCstVisitorConstructorWithDefaults();\n\nclass Validator extends BaseVisitor {\n  constructor(rawText) {\n    super();\n    this.validateVisitor();\n    this.reset(rawText); // Commands can provide validation hooks; we might also have some here\n\n    for (const cmd of AutomatorCommands) {\n      if (!cmd.validate) continue;\n      const ownMethod = this[cmd.id];\n\n      this[cmd.id] = ctx => {\n        if (!cmd.validate(ctx, this)) return;\n        if (ownMethod) ownMethod.call(this, ctx);\n      };\n    }\n\n    const lexResult = lexer.tokenize(rawText);\n    const tokens = lexResult.tokens;\n    parser.input = tokens;\n    this.parseResult = parser.script();\n    this.visit(this.parseResult);\n    this.addLexerErrors(lexResult.errors);\n    this.addParserErrors(parser.errors, tokens);\n    this.modifyErrorMessages();\n    this.errorCount = lexResult.errors.length + this.errors.length + parser.errors.length;\n  }\n\n  addLexerErrors(errors) {\n    for (const err of errors) {\n      this.errors.push({\n        startLine: err.line,\n        startOffset: err.offset,\n        endOffset: err.offset + err.length,\n        info: `Unexpected characters: ${this.rawText.substr(err.offset, err.length)}`,\n        tip: `${this.rawText.substr(err.offset, err.length)} cannot be part of a command, remove them`\n      });\n    }\n  }\n\n  static combinePositionRanges(r1, r2) {\n    return {\n      startLine: Math.min(r1.startLine, r2.startLine),\n      startOffset: Math.min(r1.startOffset, r2.startOffset),\n      endOffset: Math.max(r1.endOffset, r2.endOffset)\n    };\n  }\n\n  addParserErrors(errors, tokens) {\n    for (const parseError of errors) {\n      let err = Validator.combinePositionRanges(Validator.getPositionRange(parseError.previousToken), Validator.getPositionRange(parseError.token)); // In some cases, at the end of the script we don't get any useful tokens out of the parse error\n\n      if (parseError.token.tokenType.name === \"EOF\" && parseError.previousToken.tokenType.name === \"EOF\") {\n        err = Validator.combinePositionRanges(err, Validator.getPositionRange(tokens[tokens.length - 1]));\n      } // Deal with literal EOL in error message:\n\n\n      err.info = parseError.message.replace(/'\\n[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]*'/i, \"End of line\");\n      const isEndToken = parseError.token.tokenType.name === \"EOF\" || parseError.token.tokenType.name === \"EOL\";\n\n      if (parseError.name === \"NoViableAltException\") {\n        if (!isEndToken) {\n          err.info = `Unexpected input ${parseError.token.image}`;\n          err.tip = `Remove ${parseError.token.image}`;\n        }\n      } else if (parseError.name === \"EarlyExitException\") {\n        err.info = \"Unexpected end of command\";\n        err.tip = \"Complete the command by adding the other parameters\";\n      }\n\n      this.errors.push(err);\n    }\n  }\n\n  static getPositionRange(ctx) {\n    let pos = {\n      startLine: Number.MAX_VALUE,\n      startOffset: Number.MAX_VALUE,\n      endOffset: 0\n    };\n    if (ctx === undefined || ctx === null) return pos;\n\n    if (ctx.startOffset !== undefined) {\n      return {\n        startLine: ctx.startLine,\n        startOffset: ctx.startOffset,\n        endOffset: ctx.endOffset\n      };\n    }\n\n    if (ctx.location !== undefined && ctx.location.startOffset !== undefined) {\n      return ctx.location;\n    }\n\n    if (ctx.children && !Array.isArray(ctx.children)) return Validator.getPositionRange(ctx.children);\n\n    if (Array.isArray(ctx)) {\n      return ctx.reduce((prev, el) => Validator.combinePositionRanges(prev, Validator.getPositionRange(el)), pos);\n    }\n\n    for (const k in ctx) {\n      if (!Object.prototype.hasOwnProperty.call(ctx, k) || !Array.isArray(ctx[k])) continue;\n      pos = Validator.combinePositionRanges(pos, Validator.getPositionRange(ctx[k]));\n    }\n\n    return pos;\n  }\n\n  addError(ctx, errInfo, errTip) {\n    const pos = Validator.getPositionRange(ctx);\n    pos.info = errInfo;\n    pos.tip = errTip;\n    this.errors.push(pos);\n  } // There are a few errors generated internally in chevrotain.js which are scanned for and modified in here and\n  // given appropriate fixing tips and minor formatting adjustments, or are alternatively marked as redundant and\n  // filtered out in other parts of the code. This isn't necessarily comprehensive, but should hopefully cover the\n  // most common cases.\n\n\n  modifyErrorMessages() {\n    // This function also gets called during loading the savefile, and if it somehow fails to execute properly then\n    // the game cache is never invalidated. This only seems to happen on re-initialization after full completions,\n    // but that means that in many cases a lot of endgame values are never cleared. Therefore we shortcut the whole\n    // function if the automator isn't unlocked or it attempts to error-check an empty script\n    if (!Player.automatorUnlocked || AutomatorData.currentScriptText() === undefined) return;\n    const modifiedErrors = [];\n    let lastLine = 0;\n\n    for (const err of this.errors.sort((a, b) => a.startLine - b.startLine)) {\n      // For some reason chevrotain occasionally gives NaN for error location but it seems like this only ever\n      // happens on the last line of the script, so we can fill in that value to fix it\n      if (isNaN(err.startLine)) {\n        err.startLine = AutomatorData.currentScriptText().split(\"\\n\").length;\n      } // Only take one error from each line. In many cases multiple errors will arise from the same line due to how\n      // the parser works, and many of them will be useless or redundant. Also sometimes chevrotain fails to generate\n      // a line for an error, in which case it's usually a redundant error which can be ignored.\n\n\n      if (err.startLine === lastLine) {\n        continue;\n      } // Errors that already have tips are more reliable in terms of knowing what they're pointing out; if there's\n      // already a tip, don't bother trying to parse and guess at its meaning.\n\n\n      if (err.tip) {\n        modifiedErrors.push(err);\n        lastLine = err.startLine;\n        continue;\n      }\n\n      if (err.info.match(/EOF but found(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*\\}/g)) {\n        err.info = err.info.replaceAll(\"--> \", \"[\").replaceAll(\" <--\", \"]\");\n        err.tip = \"Remove }. Parser halted at this line and may miss errors farther down the script.\";\n      } else if (err.info.match(/found(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*\\}/g)) {\n        err.info = err.info.replaceAll(\"--> \", \"[\").replaceAll(\" <--\", \"]\");\n        err.tip = \"Remove }\";\n      } else if (err.info.match(/Expecting/g)) {\n        err.info = err.info.replaceAll(\"--> \", \"[\").replaceAll(\" <--\", \"]\");\n        err.tip = \"Use the appropriate type of data in the command as specified in the command help\";\n      } else if (err.info.match(/End of line/g)) {\n        err.tip = \"Provide the remaining arguments to complete the incomplete command\";\n      } else if (err.info.match(/EOF but found:/g)) {\n        err.tip = \"Remove extra command argument\";\n      } else {\n        err.tip = \"This error's cause is unclear\";\n      }\n\n      modifiedErrors.push(err);\n      lastLine = err.startLine;\n    }\n\n    for (const err of modifiedErrors) {\n      err.startLine = AutomatorBackend.translateLineNumber(err.startLine);\n    }\n\n    this.errors = modifiedErrors;\n  }\n\n  reset(rawText) {\n    this.rawText = rawText;\n    this.variables = {};\n    this.errors = [];\n  }\n\n  checkTimeStudyNumber(token) {\n    const tsNumber = parseFloat(token.image);\n\n    if (!TimeStudy(tsNumber) || TimeStudy(tsNumber).isTriad && !Ra.canBuyTriad) {\n      this.addError(token, `Invalid Time Study identifier ${tsNumber}`, `Make sure you copied or typed in your time study IDs correctly`);\n      return 0;\n    }\n\n    return tsNumber;\n  }\n\n  lookupVar(identifier, type) {\n    const varName = identifier.image;\n    const varInfo = {};\n    const constants = player.reality.automator.constants;\n\n    if (!Object.keys(constants).includes(varName)) {\n      this.addError(identifier, `Variable ${varName} has not been defined`, `Use the definition panel to define ${varName} in order to reference it, or check for typos`);\n      return undefined;\n    }\n\n    const value = constants[varName];\n    let tree;\n\n    switch (type) {\n      case AUTOMATOR_VAR_TYPES.NUMBER:\n        varInfo.value = new Decimal(value);\n        break;\n\n      case AUTOMATOR_VAR_TYPES.STUDIES:\n        tree = new TimeStudyTree(value);\n        varInfo.value = {\n          normal: tree.selectedStudies.map(ts => ts.id),\n          ec: tree.ec,\n          startEC: tree.startEC\n        };\n        break;\n\n      case AUTOMATOR_VAR_TYPES.DURATION:\n        varInfo.value = parseInt(1000 * value, 10);\n        break;\n\n      default:\n        throw new Error(\"Unrecognized variable format in automator constant lookup\");\n    }\n\n    return varInfo;\n  }\n\n  isValidVarFormat(identifier, type) {\n    const varName = identifier.image;\n    const constants = player.reality.automator.constants;\n    if (!Object.keys(constants).includes(varName)) return false;\n    const value = constants[varName];\n\n    switch (type) {\n      case AUTOMATOR_VAR_TYPES.NUMBER:\n        // We can't rely on native Decimal parsing here because it largely just discards input past invalid\n        // characters and constructs something based on the start of the input string. Notably, this makes\n        // things like new Decimal(\"11,21,31\") return 11 instead of something indicating an error.\n        return value.match(/^\\x2D?(0|[1-9][0-9]*)(\\.[0-9]+)?([Ee][\\+\\x2D]?[0-9]+)?$/);\n\n      case AUTOMATOR_VAR_TYPES.STUDIES:\n        return TimeStudyTree.isValidImportString(value);\n\n      case AUTOMATOR_VAR_TYPES.DURATION:\n        return !Number.isNaN(parseInt(1000 * value, 10));\n\n      default:\n        throw new Error(\"Unrecognized variable format in automator constant lookup\");\n    }\n  }\n\n  duration(ctx) {\n    if (ctx.$value) return ctx.$value;\n\n    if (!ctx.TimeUnit || ctx.TimeUnit[0].isInsertedInRecovery) {\n      this.addError(ctx, \"Missing time unit\", \"Provide a unit of time (eg. seconds or minutes)\");\n      return undefined;\n    }\n\n    const value = parseFloat(ctx.NumberLiteral[0].image) * ctx.TimeUnit[0].tokenType.$scale;\n\n    if (isNaN(value)) {\n      this.addError(ctx, \"Error parsing duration\", \"Provide a properly-formatted number for time\");\n      return undefined;\n    }\n\n    ctx.$value = value;\n    return ctx.$value;\n  }\n\n  xHighest(ctx) {\n    if (ctx.$value) return ctx.$value;\n\n    if (!ctx.NumberLiteral || ctx.NumberLiteral[0].isInsertedInRecovery) {\n      this.addError(ctx, \"Missing multiplier\", \"Provide a multiplier to set the autobuyer to\");\n      return undefined;\n    }\n\n    ctx.$value = new Decimal(ctx.NumberLiteral[0].image);\n    return ctx.$value;\n  }\n\n  currencyAmount(ctx) {\n    if (ctx.$value) return ctx.$value;\n\n    if (!ctx.NumberLiteral || ctx.NumberLiteral[0].isInsertedInRecovery) {\n      this.addError(ctx, \"Missing amount\", \"Provide a threshold to set the autobuyer to\");\n      return undefined;\n    }\n\n    ctx.$value = new Decimal(ctx.NumberLiteral[0].image);\n    return ctx.$value;\n  }\n\n  studyRange(ctx, studiesOut) {\n    if (!ctx.firstStudy || ctx.firstStudy[0].isInsertedInRecovery || !ctx.lastStudy || ctx.lastStudy[0].isInsertedInRecovery) {\n      this.addError(ctx, \"Missing Time Study number in range\", \"Provide starting and ending IDs for Time Study number ranges\");\n      return;\n    }\n\n    const first = this.checkTimeStudyNumber(ctx.firstStudy[0]);\n    const last = this.checkTimeStudyNumber(ctx.lastStudy[0]);\n    if (!first || !last || !studiesOut) return;\n\n    for (let id = first; id <= last; ++id) {\n      if (TimeStudy(id)) studiesOut.push(id);\n    }\n  }\n\n  studyListEntry(ctx, studiesOut) {\n    if (ctx.studyRange) {\n      this.visit(ctx.studyRange, studiesOut);\n      return;\n    }\n\n    if (ctx.NumberLiteral) {\n      if (ctx.NumberLiteral[0].isInsertedInRecovery) {\n        this.addError(ctx, \"Missing Time Study number\", \"Provide a Time Study ID to purchase\");\n        return;\n      }\n\n      const id = this.checkTimeStudyNumber(ctx.NumberLiteral[0]);\n      if (id) studiesOut.push(id);\n      return;\n    }\n\n    if (ctx.StudyPath) {\n      const pathId = ctx.StudyPath[0].tokenType.$studyPath;\n      const pathStudies = NormalTimeStudies.paths[pathId];\n      studiesOut.push(...pathStudies);\n    }\n  }\n\n  studyList(ctx) {\n    if (ctx.$cached !== undefined) return ctx.$cached;\n    const studiesOut = [];\n\n    for (const sle of ctx.studyListEntry) this.visit(sle, studiesOut);\n\n    const positionRange = Validator.getPositionRange(ctx);\n    ctx.$cached = {\n      normal: studiesOut,\n      image: this.rawText.substr(positionRange.startOffset, positionRange.endOffset - positionRange.startOffset + 1),\n      ec: 0,\n      startEC: false\n    };\n\n    if (ctx.ECNumber) {\n      if (ctx.ECNumber.isInsertedInRecovery) {\n        this.addError(ctx.Pipe[0], \"Missing Eternity Challenge number\", \"Specify which Eternity Challenge is being referred to\");\n      }\n\n      const ecNumber = parseFloat(ctx.ECNumber[0].image);\n\n      if (!Number.isInteger(ecNumber) || ecNumber < 0 || ecNumber > 12) {\n        this.addError(ctx.ECNumber, `Invalid Eternity Challenge ID ${ecNumber}`, `Eternity Challenge ${ecNumber} does not exist, use an integer between ${format(1)} and ${format(12)}`);\n      }\n\n      ctx.$cached.ec = ecNumber;\n    }\n\n    if (ctx.Exclamation) ctx.$cached.startEC = true;\n    return ctx.$cached;\n  }\n\n  compareValue(ctx) {\n    if (ctx.NumberLiteral) {\n      ctx.$value = new Decimal(ctx.NumberLiteral[0].image);\n    } else if (ctx.Identifier) {\n      if (!this.isValidVarFormat(ctx.Identifier[0], AUTOMATOR_VAR_TYPES.NUMBER)) {\n        this.addError(ctx, `Constant ${ctx.Identifier[0].image} cannot be used for comparison`, `Ensure that ${ctx.Identifier[0].image} contains a properly-formatted number and not a Time Study string`);\n      }\n\n      const varLookup = this.lookupVar(ctx.Identifier[0], AUTOMATOR_VAR_TYPES.NUMBER);\n      if (varLookup) ctx.$value = ctx.Identifier[0].image;\n    }\n  }\n\n  comparison(ctx) {\n    super.comparison(ctx);\n\n    if (!ctx.compareValue || ctx.compareValue[0].recoveredNode || ctx.compareValue.length !== 2 || ctx.compareValue[1].recoveredNode) {\n      this.addError(ctx, \"Missing value for comparison\", \"Ensure that the comparison has two values\");\n    }\n\n    if (!ctx.ComparisonOperator || ctx.ComparisonOperator[0].isInsertedInRecovery) {\n      this.addError(ctx, \"Missing comparison operator (<, >, <=, >=)\", \"Insert the appropriate comparison operator\");\n      return;\n    }\n\n    if (ctx.ComparisonOperator[0].tokenType === T.OpEQ || ctx.ComparisonOperator[0].tokenType === T.EqualSign) {\n      this.addError(ctx, \"Please use an inequality comparison (>, <, >=, <=)\", \"Comparisons cannot be done with equality, only with inequality operators\");\n    }\n  }\n\n  badCommand(ctx) {\n    const firstToken = ctx.badCommandToken[0].children;\n    const firstTokenType = Object.keys(firstToken)[0];\n    this.addError(firstToken[firstTokenType][0], `Unrecognized command \"${firstToken[firstTokenType][0].image}\"`, \"Check to make sure you have typed in the command name correctly\");\n  }\n\n  eternityChallenge(ctx) {\n    let errToken, ecNumber;\n\n    if (ctx.ECLiteral) {\n      ecNumber = parseFloat(ctx.ECLiteral[0].image.substr(2));\n      errToken = ctx.ECLiteral[0];\n    } else if (ctx.NumberLiteral) {\n      ecNumber = parseFloat(ctx.NumberLiteral[0].image);\n      errToken = ctx.NumberLiteral[0];\n    } else {\n      this.addError(ctx, \"Missing Eternity Challenge number\", \"Specify which Eternity Challenge is being referred to\");\n      return;\n    }\n\n    if (!Number.isInteger(ecNumber) || ecNumber < 1 || ecNumber > 12) {\n      this.addError(errToken, `Invalid Eternity Challenge ID ${ecNumber}`, `Eternity Challenge ${ecNumber} does not exist, use an integer between ${format(1)} and ${format(12)}`);\n    }\n\n    ctx.$ecNumber = ecNumber;\n  }\n\n  checkBlock(ctx, commandToken) {\n    let hadError = false;\n\n    if (!ctx.RCurly || ctx.RCurly[0].isInsertedInRecovery) {\n      this.addError(commandToken[0], \"Missing closing }\", \"This loop has mismatched brackets, add a corresponding } on another line to close the loop\");\n      hadError = true;\n    }\n\n    if (!ctx.LCurly || ctx.LCurly[0].isInsertedInRecovery) {\n      this.addError(commandToken[0], \"Missing opening {\", \"This line has an extra } closing a loop which does not exist, remove the }\");\n      hadError = true;\n    }\n\n    return !hadError;\n  }\n\n  script(ctx) {\n    if (ctx.block) this.visit(ctx.block);\n    ctx.variables = this.variables;\n  }\n\n}\n\nclass Compiler extends BaseVisitor {\n  constructor() {\n    super(); // Commands provide compilation hooks; we might also have some here\n\n    for (const cmd of AutomatorCommands) {\n      if (!cmd.compile) continue;\n      const ownMethod = this[cmd.id]; // eslint-disable-next-line no-loop-func\n\n      this[cmd.id] = (ctx, output) => {\n        // For the compiler, we don't bother doing the default recursive visitation behavior\n        if (ownMethod && ownMethod !== super[cmd.id]) ownMethod.call(this, ctx, output);\n        let compiled = cmd.compile(ctx, this);\n        if (typeof compiled === \"function\") compiled = {\n          run: compiled\n        };\n        compiled.lineNumber = ctx.startLine;\n        output.push(compiled);\n      };\n    }\n\n    this.validateVisitor();\n  }\n\n  comparison(ctx) {\n    const getters = ctx.compareValue.map(cv => {\n      if (cv.children.AutomatorCurrency) return cv.children.AutomatorCurrency[0].tokenType.$getter;\n      const val = cv.children.$value;\n      if (typeof val === \"string\") return () => player.reality.automator.constants[val];\n      return () => val;\n    }); // Some currencies are locked and should always evaluate to false if they're attempted to be used\n\n    const canUseInComp = ctx.compareValue.map(cv => {\n      if (cv.children.AutomatorCurrency) {\n        const unlockedFn = cv.children.AutomatorCurrency[0].tokenType.$unlocked;\n        return unlockedFn ? unlockedFn() : true;\n      } // In this case, it's a constant (either automator-defined or literal)\n\n\n      return true;\n    });\n    if (!canUseInComp[0] || !canUseInComp[1]) return () => false;\n    const compareFun = ctx.ComparisonOperator[0].tokenType.$compare;\n    return () => compareFun(getters[0](), getters[1]());\n  }\n\n  block(ctx) {\n    const output = [];\n    if (ctx.command) for (const cmd of ctx.command) this.visit(cmd, output);\n    return output;\n  }\n\n  script(ctx) {\n    if (ctx.variables === undefined) {\n      throw new Error(\"Compiler called before Validator\");\n    }\n\n    return ctx.block ? this.visit(ctx.block) : [];\n  }\n\n}\n\nclass Blockifier extends BaseVisitor {\n  constructor() {\n    super();\n\n    for (const cmd of AutomatorCommands) {\n      const blockify = cmd.blockify;\n      if (!blockify) continue;\n      const ownMethod = this[cmd.id]; // eslint-disable-next-line no-loop-func\n\n      this[cmd.id] = (ctx, output) => {\n        if (ownMethod && ownMethod !== super[cmd.id]) ownMethod.call(this, ctx, output);\n\n        try {\n          const block = blockify(ctx, this);\n          output.push(_objectSpread(_objectSpread({}, block), {}, {\n            id: UIID.next()\n          }));\n        } catch (_unused) {// If a command is invalid, it will throw an exception in blockify and fail to assign a value to block\n          // We can't, generally, make good guesses to fill in any missing values in order to avoid the exception,\n          // so we instead just ignore that block\n        }\n      };\n    }\n\n    this.validateVisitor();\n  }\n\n  comparison(ctx) {\n    const parseInput = index => {\n      const comp = ctx.compareValue[index];\n      const isCurrency = Boolean(comp.children.AutomatorCurrency);\n      if (isCurrency) return comp.children.AutomatorCurrency[0].image;\n      return comp.children.$value;\n    };\n\n    return {\n      compOperator: ctx.ComparisonOperator[0].image,\n      genericInput1: parseInput(0),\n      genericInput2: parseInput(1)\n    };\n  }\n\n  script(ctx) {\n    const output = [];\n    if (ctx.block) this.visit(ctx.block, output);\n    return output;\n  }\n\n  block(ctx, output) {\n    if (ctx.command) {\n      for (const cmd of ctx.command) {\n        this.visit(cmd, output);\n      }\n    }\n  }\n\n}\n\nexport function compile(input, validateOnly = false) {\n  // The lexer and codemirror choke on the last line of the script, so we pad it with an invisible newline\n  const script = `${input}\\n `;\n  const validator = new Validator(script);\n  let compiled;\n\n  if (validator.errorCount === 0 && !validateOnly) {\n    compiled = new Compiler().visit(validator.parseResult);\n  }\n\n  return {\n    errors: validator.errors,\n    compiled\n  };\n}\nexport function hasCompilationErrors(input) {\n  return compile(input, true).errors.length !== 0;\n}\nexport function blockifyTextAutomator(input) {\n  const validator = new Validator(input);\n  const blockifier = new Blockifier();\n  const blocks = blockifier.visit(validator.parseResult); // The Validator grabs all the lines from the visible script, but the Blockifier will fail to visit any lines\n  // associated with unparsable commands. This results in a discrepancy in line count whenever a line can't be\n  // parsed as a specific command, and in general this is a problem we can't try to guess a fix for, so we just\n  // don't convert it at all. In both cases nested commands are stored recursively, but with different structure.\n\n  const validatedCount = entry => {\n    if (!entry) return 0;\n    const commandDepth = entry.children;\n    let foundChildren = 0; // Inner nested commands are found within a prop given the same name as the command itself - this should only\n    // actually evaluate to nonzero for at most one key, and will be undefined for all others\n\n    for (const key of Object.keys(commandDepth)) {\n      var _commandDepth$key$, _commandDepth$key$$ch;\n\n      const nestedBlock = (_commandDepth$key$ = commandDepth[key][0]) === null || _commandDepth$key$ === void 0 ? void 0 : (_commandDepth$key$$ch = _commandDepth$key$.children) === null || _commandDepth$key$$ch === void 0 ? void 0 : _commandDepth$key$$ch.block;\n      const nestedCommands = nestedBlock ? nestedBlock[0].children.command : [];\n      foundChildren += nestedCommands ? nestedCommands.map(c => validatedCount(c) + 1).reduce((sum, val) => sum + val, 0) : 0; // Trailing newlines get turned into a command with a single EOF argument; we return -1 because one level up\n      // on the recursion this looks like an otherwise valid command and would be counted as such\n\n      if (key === \"EOF\") return -1;\n    }\n\n    return foundChildren;\n  };\n\n  const visitedCount = block => {\n    if (!block.nest) return 1;\n    return 1 + block.nest.map(b => visitedCount(b)).reduce((sum, val) => sum + val, 0);\n  }; // Note: top-level structure is slightly different than the nesting structure\n\n\n  const validatedBlocks = validator.parseResult.children.block[0].children.command.map(c => validatedCount(c) + 1).reduce((sum, val) => sum + val, 0);\n  const visitedBlocks = blocks.map(b => visitedCount(b)).reduce((sum, val) => sum + val, 0);\n  return {\n    blocks,\n    validatedBlocks,\n    visitedBlocks\n  };\n}\nexport function validateLine(input) {\n  const validator = new Validator(input);\n  return validator;\n}","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/automator/compiler.js"],"names":["lexer","tokenMap","T","AutomatorCommands","parser","BaseVisitor","getBaseCstVisitorConstructorWithDefaults","Validator","constructor","rawText","validateVisitor","reset","cmd","validate","ownMethod","id","ctx","call","lexResult","tokenize","tokens","input","parseResult","script","visit","addLexerErrors","errors","addParserErrors","modifyErrorMessages","errorCount","length","err","push","startLine","line","startOffset","offset","endOffset","info","substr","tip","combinePositionRanges","r1","r2","Math","min","max","parseError","getPositionRange","previousToken","token","tokenType","name","message","replace","isEndToken","image","pos","Number","MAX_VALUE","undefined","location","children","Array","isArray","reduce","prev","el","k","Object","prototype","hasOwnProperty","addError","errInfo","errTip","Player","automatorUnlocked","AutomatorData","currentScriptText","modifiedErrors","lastLine","sort","a","b","isNaN","split","match","replaceAll","AutomatorBackend","translateLineNumber","variables","checkTimeStudyNumber","tsNumber","parseFloat","TimeStudy","isTriad","Ra","canBuyTriad","lookupVar","identifier","type","varName","varInfo","constants","player","reality","automator","keys","includes","value","tree","AUTOMATOR_VAR_TYPES","NUMBER","Decimal","STUDIES","TimeStudyTree","normal","selectedStudies","map","ts","ec","startEC","DURATION","parseInt","Error","isValidVarFormat","isValidImportString","duration","$value","TimeUnit","isInsertedInRecovery","NumberLiteral","$scale","xHighest","currencyAmount","studyRange","studiesOut","firstStudy","lastStudy","first","last","studyListEntry","StudyPath","pathId","$studyPath","pathStudies","NormalTimeStudies","paths","studyList","$cached","sle","positionRange","ECNumber","Pipe","ecNumber","isInteger","format","Exclamation","compareValue","Identifier","varLookup","comparison","recoveredNode","ComparisonOperator","OpEQ","EqualSign","badCommand","firstToken","badCommandToken","firstTokenType","eternityChallenge","errToken","ECLiteral","$ecNumber","checkBlock","commandToken","hadError","RCurly","LCurly","block","Compiler","compile","output","compiled","run","lineNumber","getters","cv","AutomatorCurrency","$getter","val","canUseInComp","unlockedFn","$unlocked","compareFun","$compare","command","Blockifier","blockify","UIID","next","parseInput","index","comp","isCurrency","Boolean","compOperator","genericInput1","genericInput2","validateOnly","validator","hasCompilationErrors","blockifyTextAutomator","blockifier","blocks","validatedCount","entry","commandDepth","foundChildren","key","nestedBlock","nestedCommands","c","sum","visitedCount","nest","validatedBlocks","visitedBlocks","validateLine"],"mappings":"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","sourcesContent":["import { lexer, tokenMap as T } from \"./lexer\";\r\nimport { AutomatorCommands } from \"./automator-commands\";\r\nimport { parser } from \"./parser\";\r\n\r\nconst BaseVisitor = parser.getBaseCstVisitorConstructorWithDefaults();\r\n\r\nclass Validator extends BaseVisitor {\r\n  constructor(rawText) {\r\n    super();\r\n    this.validateVisitor();\r\n    this.reset(rawText);\r\n    // Commands can provide validation hooks; we might also have some here\r\n    for (const cmd of AutomatorCommands) {\r\n      if (!cmd.validate) continue;\r\n      const ownMethod = this[cmd.id];\r\n      this[cmd.id] = ctx => {\r\n        if (!cmd.validate(ctx, this)) return;\r\n        if (ownMethod) ownMethod.call(this, ctx);\r\n      };\r\n    }\r\n\r\n    const lexResult = lexer.tokenize(rawText);\r\n    const tokens = lexResult.tokens;\r\n    parser.input = tokens;\r\n    this.parseResult = parser.script();\r\n    this.visit(this.parseResult);\r\n    this.addLexerErrors(lexResult.errors);\r\n    this.addParserErrors(parser.errors, tokens);\r\n    this.modifyErrorMessages();\r\n    this.errorCount = lexResult.errors.length + this.errors.length + parser.errors.length;\r\n  }\r\n\r\n  addLexerErrors(errors) {\r\n    for (const err of errors) {\r\n      this.errors.push({\r\n        startLine: err.line,\r\n        startOffset: err.offset,\r\n        endOffset: err.offset + err.length,\r\n        info: `Unexpected characters: ${this.rawText.substr(err.offset, err.length)}`,\r\n        tip: `${this.rawText.substr(err.offset, err.length)} cannot be part of a command, remove them`\r\n      });\r\n    }\r\n  }\r\n\r\n  static combinePositionRanges(r1, r2) {\r\n    return {\r\n      startLine: Math.min(r1.startLine, r2.startLine),\r\n      startOffset: Math.min(r1.startOffset, r2.startOffset),\r\n      endOffset: Math.max(r1.endOffset, r2.endOffset),\r\n    };\r\n  }\r\n\r\n  addParserErrors(errors, tokens) {\r\n    for (const parseError of errors) {\r\n      let err = Validator.combinePositionRanges(\r\n        Validator.getPositionRange(parseError.previousToken),\r\n        Validator.getPositionRange(parseError.token));\r\n      // In some cases, at the end of the script we don't get any useful tokens out of the parse error\r\n      if (parseError.token.tokenType.name === \"EOF\" && parseError.previousToken.tokenType.name === \"EOF\") {\r\n        err = Validator.combinePositionRanges(err, Validator.getPositionRange(tokens[tokens.length - 1]));\r\n      }\r\n      // Deal with literal EOL in error message:\r\n      err.info = parseError.message.replace(/'\\n\\s*'/ui, \"End of line\");\r\n      const isEndToken = parseError.token.tokenType.name === \"EOF\" || parseError.token.tokenType.name === \"EOL\";\r\n      if (parseError.name === \"NoViableAltException\") {\r\n        if (!isEndToken) {\r\n          err.info = `Unexpected input ${parseError.token.image}`;\r\n          err.tip = `Remove ${parseError.token.image}`;\r\n        }\r\n      } else if (parseError.name === \"EarlyExitException\") {\r\n        err.info = \"Unexpected end of command\";\r\n        err.tip = \"Complete the command by adding the other parameters\";\r\n      }\r\n      this.errors.push(err);\r\n    }\r\n  }\r\n\r\n  static getPositionRange(ctx) {\r\n    let pos = {\r\n      startLine: Number.MAX_VALUE,\r\n      startOffset: Number.MAX_VALUE,\r\n      endOffset: 0,\r\n    };\r\n    if (ctx === undefined || ctx === null) return pos;\r\n    if (ctx.startOffset !== undefined) {\r\n      return {\r\n        startLine: ctx.startLine,\r\n        startOffset: ctx.startOffset,\r\n        endOffset: ctx.endOffset,\r\n      };\r\n    }\r\n    if (ctx.location !== undefined && ctx.location.startOffset !== undefined) {\r\n      return ctx.location;\r\n    }\r\n    if (ctx.children && !Array.isArray(ctx.children)) return Validator.getPositionRange(ctx.children);\r\n    if (Array.isArray(ctx)) {\r\n      return ctx.reduce((prev, el) => Validator.combinePositionRanges(prev, Validator.getPositionRange(el)), pos);\r\n    }\r\n    for (const k in ctx) {\r\n      if (!Object.prototype.hasOwnProperty.call(ctx, k) || !Array.isArray(ctx[k])) continue;\r\n      pos = Validator.combinePositionRanges(pos, Validator.getPositionRange(ctx[k]));\r\n    }\r\n    return pos;\r\n  }\r\n\r\n  addError(ctx, errInfo, errTip) {\r\n    const pos = Validator.getPositionRange(ctx);\r\n    pos.info = errInfo;\r\n    pos.tip = errTip;\r\n    this.errors.push(pos);\r\n  }\r\n\r\n  // There are a few errors generated internally in chevrotain.js which are scanned for and modified in here and\r\n  // given appropriate fixing tips and minor formatting adjustments, or are alternatively marked as redundant and\r\n  // filtered out in other parts of the code. This isn't necessarily comprehensive, but should hopefully cover the\r\n  // most common cases.\r\n  modifyErrorMessages() {\r\n    // This function also gets called during loading the savefile, and if it somehow fails to execute properly then\r\n    // the game cache is never invalidated. This only seems to happen on re-initialization after full completions,\r\n    // but that means that in many cases a lot of endgame values are never cleared. Therefore we shortcut the whole\r\n    // function if the automator isn't unlocked or it attempts to error-check an empty script\r\n    if (!Player.automatorUnlocked || AutomatorData.currentScriptText() === undefined) return;\r\n\r\n    const modifiedErrors = [];\r\n    let lastLine = 0;\r\n    for (const err of this.errors.sort((a, b) => a.startLine - b.startLine)) {\r\n      // For some reason chevrotain occasionally gives NaN for error location but it seems like this only ever\r\n      // happens on the last line of the script, so we can fill in that value to fix it\r\n      if (isNaN(err.startLine)) {\r\n        err.startLine = AutomatorData.currentScriptText().split(\"\\n\").length;\r\n      }\r\n\r\n      // Only take one error from each line. In many cases multiple errors will arise from the same line due to how\r\n      // the parser works, and many of them will be useless or redundant. Also sometimes chevrotain fails to generate\r\n      // a line for an error, in which case it's usually a redundant error which can be ignored.\r\n      if (err.startLine === lastLine) {\r\n        continue;\r\n      }\r\n\r\n      // Errors that already have tips are more reliable in terms of knowing what they're pointing out; if there's\r\n      // already a tip, don't bother trying to parse and guess at its meaning.\r\n      if (err.tip) {\r\n        modifiedErrors.push(err);\r\n        lastLine = err.startLine;\r\n        continue;\r\n      }\r\n\r\n      if (err.info.match(/EOF but found.*\\}/gu)) {\r\n        err.info = err.info.replaceAll(\"--> \", \"[\").replaceAll(\" <--\", \"]\");\r\n        err.tip = \"Remove }. Parser halted at this line and may miss errors farther down the script.\";\r\n      } else if (err.info.match(/found.*\\}/gu)) {\r\n        err.info = err.info.replaceAll(\"--> \", \"[\").replaceAll(\" <--\", \"]\");\r\n        err.tip = \"Remove }\";\r\n      } else if (err.info.match(/Expecting/gu)) {\r\n        err.info = err.info.replaceAll(\"--> \", \"[\").replaceAll(\" <--\", \"]\");\r\n        err.tip = \"Use the appropriate type of data in the command as specified in the command help\";\r\n      } else if (err.info.match(/End of line/gu)) {\r\n        err.tip = \"Provide the remaining arguments to complete the incomplete command\";\r\n      } else if (err.info.match(/EOF but found:/gu)) {\r\n        err.tip = \"Remove extra command argument\";\r\n      } else {\r\n        err.tip = \"This error's cause is unclear\";\r\n      }\r\n      modifiedErrors.push(err);\r\n      lastLine = err.startLine;\r\n    }\r\n\r\n    for (const err of modifiedErrors) {\r\n      err.startLine = AutomatorBackend.translateLineNumber(err.startLine);\r\n    }\r\n\r\n    this.errors = modifiedErrors;\r\n  }\r\n\r\n  reset(rawText) {\r\n    this.rawText = rawText;\r\n    this.variables = {};\r\n    this.errors = [];\r\n  }\r\n\r\n  checkTimeStudyNumber(token) {\r\n    const tsNumber = parseFloat(token.image);\r\n    if (!TimeStudy(tsNumber) || (TimeStudy(tsNumber).isTriad && !Ra.canBuyTriad)) {\r\n      this.addError(token, `Invalid Time Study identifier ${tsNumber}`,\r\n        `Make sure you copied or typed in your time study IDs correctly`);\r\n      return 0;\r\n    }\r\n    return tsNumber;\r\n  }\r\n\r\n  lookupVar(identifier, type) {\r\n    const varName = identifier.image;\r\n    const varInfo = {};\r\n    const constants = player.reality.automator.constants;\r\n    if (!Object.keys(constants).includes(varName)) {\r\n      this.addError(identifier, `Variable ${varName} has not been defined`,\r\n        `Use the definition panel to define ${varName} in order to reference it, or check for typos`);\r\n      return undefined;\r\n    }\r\n    const value = constants[varName];\r\n\r\n    let tree;\r\n    switch (type) {\r\n      case AUTOMATOR_VAR_TYPES.NUMBER:\r\n        varInfo.value = new Decimal(value);\r\n        break;\r\n      case AUTOMATOR_VAR_TYPES.STUDIES:\r\n        tree = new TimeStudyTree(value);\r\n        varInfo.value = {\r\n          normal: tree.selectedStudies.map(ts => ts.id),\r\n          ec: tree.ec,\r\n          startEC: tree.startEC,\r\n        };\r\n        break;\r\n      case AUTOMATOR_VAR_TYPES.DURATION:\r\n        varInfo.value = parseInt(1000 * value, 10);\r\n        break;\r\n      default:\r\n        throw new Error(\"Unrecognized variable format in automator constant lookup\");\r\n    }\r\n\r\n    return varInfo;\r\n  }\r\n\r\n  isValidVarFormat(identifier, type) {\r\n    const varName = identifier.image;\r\n    const constants = player.reality.automator.constants;\r\n    if (!Object.keys(constants).includes(varName)) return false;\r\n    const value = constants[varName];\r\n\r\n    switch (type) {\r\n      case AUTOMATOR_VAR_TYPES.NUMBER:\r\n        // We can't rely on native Decimal parsing here because it largely just discards input past invalid\r\n        // characters and constructs something based on the start of the input string. Notably, this makes\r\n        // things like new Decimal(\"11,21,31\") return 11 instead of something indicating an error.\r\n        return value.match(/^-?(0|[1-9]\\d*)(\\.\\d+)?([eE][+-]?\\d+)?$/u);\r\n      case AUTOMATOR_VAR_TYPES.STUDIES:\r\n        return TimeStudyTree.isValidImportString(value);\r\n      case AUTOMATOR_VAR_TYPES.DURATION:\r\n        return !Number.isNaN(parseInt(1000 * value, 10));\r\n      default:\r\n        throw new Error(\"Unrecognized variable format in automator constant lookup\");\r\n    }\r\n  }\r\n\r\n  duration(ctx) {\r\n    if (ctx.$value) return ctx.$value;\r\n    if (!ctx.TimeUnit || ctx.TimeUnit[0].isInsertedInRecovery) {\r\n      this.addError(ctx, \"Missing time unit\", \"Provide a unit of time (eg. seconds or minutes)\");\r\n      return undefined;\r\n    }\r\n    const value = parseFloat(ctx.NumberLiteral[0].image) * ctx.TimeUnit[0].tokenType.$scale;\r\n    if (isNaN(value)) {\r\n      this.addError(ctx, \"Error parsing duration\", \"Provide a properly-formatted number for time\");\r\n      return undefined;\r\n    }\r\n    ctx.$value = value;\r\n    return ctx.$value;\r\n  }\r\n\r\n  xHighest(ctx) {\r\n    if (ctx.$value) return ctx.$value;\r\n    if (!ctx.NumberLiteral || ctx.NumberLiteral[0].isInsertedInRecovery) {\r\n      this.addError(ctx, \"Missing multiplier\", \"Provide a multiplier to set the autobuyer to\");\r\n      return undefined;\r\n    }\r\n    ctx.$value = new Decimal(ctx.NumberLiteral[0].image);\r\n    return ctx.$value;\r\n  }\r\n\r\n  currencyAmount(ctx) {\r\n    if (ctx.$value) return ctx.$value;\r\n    if (!ctx.NumberLiteral || ctx.NumberLiteral[0].isInsertedInRecovery) {\r\n      this.addError(ctx, \"Missing amount\", \"Provide a threshold to set the autobuyer to\");\r\n      return undefined;\r\n    }\r\n    ctx.$value = new Decimal(ctx.NumberLiteral[0].image);\r\n    return ctx.$value;\r\n  }\r\n\r\n  studyRange(ctx, studiesOut) {\r\n    if (!ctx.firstStudy || ctx.firstStudy[0].isInsertedInRecovery ||\r\n      !ctx.lastStudy || ctx.lastStudy[0].isInsertedInRecovery) {\r\n      this.addError(ctx, \"Missing Time Study number in range\",\r\n        \"Provide starting and ending IDs for Time Study number ranges\");\r\n      return;\r\n    }\r\n    const first = this.checkTimeStudyNumber(ctx.firstStudy[0]);\r\n    const last = this.checkTimeStudyNumber(ctx.lastStudy[0]);\r\n    if (!first || !last || !studiesOut) return;\r\n    for (let id = first; id <= last; ++id) {\r\n      if (TimeStudy(id)) studiesOut.push(id);\r\n    }\r\n  }\r\n\r\n  studyListEntry(ctx, studiesOut) {\r\n    if (ctx.studyRange) {\r\n      this.visit(ctx.studyRange, studiesOut);\r\n      return;\r\n    }\r\n    if (ctx.NumberLiteral) {\r\n      if (ctx.NumberLiteral[0].isInsertedInRecovery) {\r\n        this.addError(ctx, \"Missing Time Study number\", \"Provide a Time Study ID to purchase\");\r\n        return;\r\n      }\r\n      const id = this.checkTimeStudyNumber(ctx.NumberLiteral[0]);\r\n      if (id) studiesOut.push(id);\r\n      return;\r\n    }\r\n    if (ctx.StudyPath) {\r\n      const pathId = ctx.StudyPath[0].tokenType.$studyPath;\r\n      const pathStudies = NormalTimeStudies.paths[pathId];\r\n      studiesOut.push(...pathStudies);\r\n    }\r\n  }\r\n\r\n  studyList(ctx) {\r\n    if (ctx.$cached !== undefined) return ctx.$cached;\r\n    const studiesOut = [];\r\n    for (const sle of ctx.studyListEntry) this.visit(sle, studiesOut);\r\n    const positionRange = Validator.getPositionRange(ctx);\r\n    ctx.$cached = {\r\n      normal: studiesOut,\r\n      image: this.rawText.substr(positionRange.startOffset, positionRange.endOffset - positionRange.startOffset + 1),\r\n      ec: 0,\r\n      startEC: false,\r\n    };\r\n    if (ctx.ECNumber) {\r\n      if (ctx.ECNumber.isInsertedInRecovery) {\r\n        this.addError(ctx.Pipe[0], \"Missing Eternity Challenge number\",\r\n          \"Specify which Eternity Challenge is being referred to\");\r\n      }\r\n      const ecNumber = parseFloat(ctx.ECNumber[0].image);\r\n      if (!Number.isInteger(ecNumber) || ecNumber < 0 || ecNumber > 12) {\r\n        this.addError(ctx.ECNumber, `Invalid Eternity Challenge ID ${ecNumber}`,\r\n          `Eternity Challenge ${ecNumber} does not exist, use an integer between ${format(1)} and ${format(12)}`);\r\n      }\r\n      ctx.$cached.ec = ecNumber;\r\n    }\r\n    if (ctx.Exclamation) ctx.$cached.startEC = true;\r\n    return ctx.$cached;\r\n  }\r\n\r\n  compareValue(ctx) {\r\n    if (ctx.NumberLiteral) {\r\n      ctx.$value = new Decimal(ctx.NumberLiteral[0].image);\r\n    } else if (ctx.Identifier) {\r\n      if (!this.isValidVarFormat(ctx.Identifier[0], AUTOMATOR_VAR_TYPES.NUMBER)) {\r\n        this.addError(ctx, `Constant ${ctx.Identifier[0].image} cannot be used for comparison`,\r\n          `Ensure that ${ctx.Identifier[0].image} contains a properly-formatted number and not a Time Study string`);\r\n      }\r\n      const varLookup = this.lookupVar(ctx.Identifier[0], AUTOMATOR_VAR_TYPES.NUMBER);\r\n      if (varLookup) ctx.$value = ctx.Identifier[0].image;\r\n    }\r\n  }\r\n\r\n  comparison(ctx) {\r\n    super.comparison(ctx);\r\n    if (!ctx.compareValue || ctx.compareValue[0].recoveredNode ||\r\n      ctx.compareValue.length !== 2 || ctx.compareValue[1].recoveredNode) {\r\n      this.addError(ctx, \"Missing value for comparison\", \"Ensure that the comparison has two values\");\r\n    }\r\n    if (!ctx.ComparisonOperator || ctx.ComparisonOperator[0].isInsertedInRecovery) {\r\n      this.addError(ctx, \"Missing comparison operator (<, >, <=, >=)\", \"Insert the appropriate comparison operator\");\r\n      return;\r\n    }\r\n    if (ctx.ComparisonOperator[0].tokenType === T.OpEQ || ctx.ComparisonOperator[0].tokenType === T.EqualSign) {\r\n      this.addError(ctx, \"Please use an inequality comparison (>, <, >=, <=)\",\r\n        \"Comparisons cannot be done with equality, only with inequality operators\");\r\n    }\r\n  }\r\n\r\n  badCommand(ctx) {\r\n    const firstToken = ctx.badCommandToken[0].children;\r\n    const firstTokenType = Object.keys(firstToken)[0];\r\n    this.addError(firstToken[firstTokenType][0], `Unrecognized command \"${firstToken[firstTokenType][0].image}\"`,\r\n      \"Check to make sure you have typed in the command name correctly\");\r\n  }\r\n\r\n  eternityChallenge(ctx) {\r\n    let errToken, ecNumber;\r\n    if (ctx.ECLiteral) {\r\n      ecNumber = parseFloat(ctx.ECLiteral[0].image.substr(2));\r\n      errToken = ctx.ECLiteral[0];\r\n    } else if (ctx.NumberLiteral) {\r\n      ecNumber = parseFloat(ctx.NumberLiteral[0].image);\r\n      errToken = ctx.NumberLiteral[0];\r\n    } else {\r\n      this.addError(ctx, \"Missing Eternity Challenge number\",\r\n        \"Specify which Eternity Challenge is being referred to\");\r\n      return;\r\n    }\r\n    if (!Number.isInteger(ecNumber) || ecNumber < 1 || ecNumber > 12) {\r\n      this.addError(errToken, `Invalid Eternity Challenge ID ${ecNumber}`,\r\n        `Eternity Challenge ${ecNumber} does not exist, use an integer between ${format(1)} and ${format(12)}`);\r\n    }\r\n    ctx.$ecNumber = ecNumber;\r\n  }\r\n\r\n  checkBlock(ctx, commandToken) {\r\n    let hadError = false;\r\n    if (!ctx.RCurly || ctx.RCurly[0].isInsertedInRecovery) {\r\n      this.addError(commandToken[0], \"Missing closing }\",\r\n        \"This loop has mismatched brackets, add a corresponding } on another line to close the loop\");\r\n      hadError = true;\r\n    }\r\n    if (!ctx.LCurly || ctx.LCurly[0].isInsertedInRecovery) {\r\n      this.addError(commandToken[0], \"Missing opening {\",\r\n        \"This line has an extra } closing a loop which does not exist, remove the }\");\r\n      hadError = true;\r\n    }\r\n    return !hadError;\r\n  }\r\n\r\n  script(ctx) {\r\n    if (ctx.block) this.visit(ctx.block);\r\n    ctx.variables = this.variables;\r\n  }\r\n}\r\n\r\nclass Compiler extends BaseVisitor {\r\n  constructor() {\r\n    super();\r\n    // Commands provide compilation hooks; we might also have some here\r\n    for (const cmd of AutomatorCommands) {\r\n      if (!cmd.compile) continue;\r\n      const ownMethod = this[cmd.id];\r\n      // eslint-disable-next-line no-loop-func\r\n      this[cmd.id] = (ctx, output) => {\r\n        // For the compiler, we don't bother doing the default recursive visitation behavior\r\n        if (ownMethod && ownMethod !== super[cmd.id]) ownMethod.call(this, ctx, output);\r\n        let compiled = cmd.compile(ctx, this);\r\n        if (typeof compiled === \"function\") compiled = { run: compiled };\r\n        compiled.lineNumber = ctx.startLine;\r\n        output.push(compiled);\r\n      };\r\n    }\r\n    this.validateVisitor();\r\n  }\r\n\r\n  comparison(ctx) {\r\n    const getters = ctx.compareValue.map(cv => {\r\n      if (cv.children.AutomatorCurrency) return cv.children.AutomatorCurrency[0].tokenType.$getter;\r\n      const val = cv.children.$value;\r\n      if (typeof val === \"string\") return () => player.reality.automator.constants[val];\r\n      return () => val;\r\n    });\r\n    // Some currencies are locked and should always evaluate to false if they're attempted to be used\r\n    const canUseInComp = ctx.compareValue.map(cv => {\r\n      if (cv.children.AutomatorCurrency) {\r\n        const unlockedFn = cv.children.AutomatorCurrency[0].tokenType.$unlocked;\r\n        return unlockedFn ? unlockedFn() : true;\r\n      }\r\n      // In this case, it's a constant (either automator-defined or literal)\r\n      return true;\r\n    });\r\n\r\n    if (!canUseInComp[0] || !canUseInComp[1]) return () => false;\r\n    const compareFun = ctx.ComparisonOperator[0].tokenType.$compare;\r\n    return () => compareFun(getters[0](), getters[1]());\r\n  }\r\n\r\n  block(ctx) {\r\n    const output = [];\r\n    if (ctx.command) for (const cmd of ctx.command) this.visit(cmd, output);\r\n    return output;\r\n  }\r\n\r\n  script(ctx) {\r\n    if (ctx.variables === undefined) {\r\n      throw new Error(\"Compiler called before Validator\");\r\n    }\r\n    return ctx.block ? this.visit(ctx.block) : [];\r\n  }\r\n}\r\n\r\nclass Blockifier extends BaseVisitor {\r\n  constructor() {\r\n    super();\r\n    for (const cmd of AutomatorCommands) {\r\n      const blockify = cmd.blockify;\r\n      if (!blockify) continue;\r\n      const ownMethod = this[cmd.id];\r\n      // eslint-disable-next-line no-loop-func\r\n      this[cmd.id] = (ctx, output) => {\r\n        if (ownMethod && ownMethod !== super[cmd.id]) ownMethod.call(this, ctx, output);\r\n        try {\r\n          const block = blockify(ctx, this);\r\n          output.push({\r\n            ...block,\r\n            id: UIID.next()\r\n          });\r\n        } catch {\r\n          // If a command is invalid, it will throw an exception in blockify and fail to assign a value to block\r\n          // We can't, generally, make good guesses to fill in any missing values in order to avoid the exception,\r\n          // so we instead just ignore that block\r\n        }\r\n      };\r\n    }\r\n    this.validateVisitor();\r\n  }\r\n\r\n  comparison(ctx) {\r\n    const parseInput = index => {\r\n      const comp = ctx.compareValue[index];\r\n      const isCurrency = Boolean(comp.children.AutomatorCurrency);\r\n      if (isCurrency) return comp.children.AutomatorCurrency[0].image;\r\n      return comp.children.$value;\r\n    };\r\n\r\n    return {\r\n      compOperator: ctx.ComparisonOperator[0].image,\r\n      genericInput1: parseInput(0),\r\n      genericInput2: parseInput(1),\r\n    };\r\n  }\r\n\r\n  script(ctx) {\r\n    const output = [];\r\n    if (ctx.block) this.visit(ctx.block, output);\r\n    return output;\r\n  }\r\n\r\n  block(ctx, output) {\r\n    if (ctx.command) {\r\n      for (const cmd of ctx.command) {\r\n        this.visit(cmd, output);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function compile(input, validateOnly = false) {\r\n  // The lexer and codemirror choke on the last line of the script, so we pad it with an invisible newline\r\n  const script = `${input}\\n `;\r\n  const validator = new Validator(script);\r\n  let compiled;\r\n  if (validator.errorCount === 0 && !validateOnly) {\r\n    compiled = new Compiler().visit(validator.parseResult);\r\n  }\r\n  return {\r\n    errors: validator.errors,\r\n    compiled,\r\n  };\r\n}\r\n\r\nexport function hasCompilationErrors(input) {\r\n  return compile(input, true).errors.length !== 0;\r\n}\r\n\r\nexport function blockifyTextAutomator(input) {\r\n  const validator = new Validator(input);\r\n  const blockifier = new Blockifier();\r\n  const blocks = blockifier.visit(validator.parseResult);\r\n\r\n  // The Validator grabs all the lines from the visible script, but the Blockifier will fail to visit any lines\r\n  // associated with unparsable commands. This results in a discrepancy in line count whenever a line can't be\r\n  // parsed as a specific command, and in general this is a problem we can't try to guess a fix for, so we just\r\n  // don't convert it at all. In both cases nested commands are stored recursively, but with different structure.\r\n  const validatedCount = entry => {\r\n    if (!entry) return 0;\r\n    const commandDepth = entry.children;\r\n    let foundChildren = 0;\r\n    // Inner nested commands are found within a prop given the same name as the command itself - this should only\r\n    // actually evaluate to nonzero for at most one key, and will be undefined for all others\r\n    for (const key of Object.keys(commandDepth)) {\r\n      const nestedBlock = commandDepth[key][0]?.children?.block;\r\n      const nestedCommands = nestedBlock ? nestedBlock[0].children.command : [];\r\n      foundChildren += nestedCommands\r\n        ? nestedCommands.map(c => validatedCount(c) + 1).reduce((sum, val) => sum + val, 0)\r\n        : 0;\r\n\r\n      // Trailing newlines get turned into a command with a single EOF argument; we return -1 because one level up\r\n      // on the recursion this looks like an otherwise valid command and would be counted as such\r\n      if (key === \"EOF\") return -1;\r\n    }\r\n    return foundChildren;\r\n  };\r\n  const visitedCount = block => {\r\n    if (!block.nest) return 1;\r\n    return 1 + block.nest.map(b => visitedCount(b)).reduce((sum, val) => sum + val, 0);\r\n  };\r\n  // Note: top-level structure is slightly different than the nesting structure\r\n  const validatedBlocks = validator.parseResult.children.block[0].children.command\r\n    .map(c => validatedCount(c) + 1)\r\n    .reduce((sum, val) => sum + val, 0);\r\n  const visitedBlocks = blocks.map(b => visitedCount(b)).reduce((sum, val) => sum + val, 0);\r\n\r\n  return { blocks, validatedBlocks, visitedBlocks };\r\n}\r\n\r\nexport function validateLine(input) {\r\n  const validator = new Validator(input);\r\n  return validator;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}