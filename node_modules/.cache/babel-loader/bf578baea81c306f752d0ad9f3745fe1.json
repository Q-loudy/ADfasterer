{"ast":null,"code":"import { DC } from \"./constants\";\nexport const MachineHandler = {\n  get baseRMCap() {\n    return DC.E1000;\n  },\n\n  get hardcapRM() {\n    return this.baseRMCap.times(ImaginaryUpgrade(6).effectOrDefault(1));\n  },\n\n  get distanceToRMCap() {\n    return this.hardcapRM.minus(Currency.realityMachines.value);\n  },\n\n  get realityMachineMultiplier() {\n    return ShopPurchase.RMPurchases.currentMult * Teresa.rmMultiplier * Effects.max(1, PerkShopUpgrade.rmMult) * getAdjustedGlyphEffect(\"effarigrm\") * Achievement(167).effectOrDefault(1);\n  },\n\n  get uncappedRM() {\n    let log10FinalEP = player.records.thisReality.maxEP.plus(gainedEternityPoints()).log10();\n\n    if (!PlayerProgress.realityUnlocked()) {\n      if (log10FinalEP > 8000) log10FinalEP = 8000;\n      if (log10FinalEP > 6000) log10FinalEP -= (log10FinalEP - 6000) * 0.75;\n    }\n\n    let rmGain = DC.E3.pow(log10FinalEP / 4000 - 1); // Increase base RM gain if <10 RM\n\n    if (rmGain.gte(1) && rmGain.lt(10)) rmGain = new Decimal(27 / 4000 * log10FinalEP - 26);\n    rmGain = rmGain.times(this.realityMachineMultiplier);\n    return rmGain.floor();\n  },\n\n  get gainedRealityMachines() {\n    return this.uncappedRM.clampMax(this.hardcapRM);\n  },\n\n  get isIMUnlocked() {\n    return Currency.realityMachines.value.gte(this.hardcapRM) || Currency.imaginaryMachines.gt(0);\n  },\n\n  get baseIMCap() {\n    return Math.pow(Math.clampMin(this.uncappedRM.log10() - 1000, 0), 2) * Math.pow(Math.clampMin(this.uncappedRM.log10() - 100000, 1), 0.2);\n  },\n\n  get currentIMCap() {\n    return player.reality.iMCap * ImaginaryUpgrade(13).effectOrDefault(1);\n  },\n\n  // This is iM cap based on in-game values at that instant, may be lower than the actual cap\n  get projectedIMCap() {\n    return this.baseIMCap * ImaginaryUpgrade(13).effectOrDefault(1);\n  },\n\n  // Use iMCap to store the base cap; applying multipliers separately avoids some design issues the 3xTP upgrade has\n  updateIMCap() {\n    if (this.uncappedRM.gte(this.baseRMCap)) {\n      if (this.baseIMCap > player.reality.iMCap) {\n        player.records.bestReality.iMCapSet = Glyphs.copyForRecords(Glyphs.active.filter(g => g !== null));\n        player.reality.iMCap = this.baseIMCap;\n      }\n    }\n  },\n\n  // Time in seconds to reduce the missing amount by a factor of two\n  get scaleTimeForIM() {\n    return 60 / ImaginaryUpgrade(20).effectOrDefault(1);\n  },\n\n  gainedImaginaryMachines(diff) {\n    return (this.currentIMCap - Currency.imaginaryMachines.value) * (1 - Math.pow(2, -diff / 1000 / this.scaleTimeForIM));\n  },\n\n  estimateIMTimer(cost) {\n    const imCap = this.currentIMCap;\n    if (imCap <= cost) return Infinity;\n    const currentIM = Currency.imaginaryMachines.value; // This is doing log(a, 1/2) - log(b, 1/2) where a is % left to imCap of cost and b is % left to imCap of current\n    // iM. log(1 - x, 1/2) should be able to estimate the time taken for iM to increase from 0 to imCap * x since every\n    // fixed interval the difference between current iM to max iM should decrease by a factor of 1/2.\n\n    return Math.max(0, Math.log2(imCap / (imCap - cost)) - Math.log2(imCap / (imCap - currentIM))) * this.scaleTimeForIM;\n  }\n\n};","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/machines.js"],"names":["DC","MachineHandler","baseRMCap","E1000","hardcapRM","times","ImaginaryUpgrade","effectOrDefault","distanceToRMCap","minus","Currency","realityMachines","value","realityMachineMultiplier","ShopPurchase","RMPurchases","currentMult","Teresa","rmMultiplier","Effects","max","PerkShopUpgrade","rmMult","getAdjustedGlyphEffect","Achievement","uncappedRM","log10FinalEP","player","records","thisReality","maxEP","plus","gainedEternityPoints","log10","PlayerProgress","realityUnlocked","rmGain","E3","pow","gte","lt","Decimal","floor","gainedRealityMachines","clampMax","isIMUnlocked","imaginaryMachines","gt","baseIMCap","Math","clampMin","currentIMCap","reality","iMCap","projectedIMCap","updateIMCap","bestReality","iMCapSet","Glyphs","copyForRecords","active","filter","g","scaleTimeForIM","gainedImaginaryMachines","diff","estimateIMTimer","cost","imCap","Infinity","currentIM","log2"],"mappings":"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","sourcesContent":["import { DC } from \"./constants\";\r\n\r\nexport const MachineHandler = {\r\n  get baseRMCap() { return DC.E1000; },\r\n\r\n  get hardcapRM() {\r\n    return this.baseRMCap.times(ImaginaryUpgrade(6).effectOrDefault(1));\r\n  },\r\n\r\n  get distanceToRMCap() {\r\n    return this.hardcapRM.minus(Currency.realityMachines.value);\r\n  },\r\n\r\n  get realityMachineMultiplier() {\r\n    return ShopPurchase.RMPurchases.currentMult * Teresa.rmMultiplier * Effects.max(1, PerkShopUpgrade.rmMult) *\r\n      getAdjustedGlyphEffect(\"effarigrm\") * Achievement(167).effectOrDefault(1);\r\n  },\r\n\r\n  get uncappedRM() {\r\n    let log10FinalEP = player.records.thisReality.maxEP.plus(gainedEternityPoints()).log10();\r\n    if (!PlayerProgress.realityUnlocked()) {\r\n      if (log10FinalEP > 8000) log10FinalEP = 8000;\r\n      if (log10FinalEP > 6000) log10FinalEP -= (log10FinalEP - 6000) * 0.75;\r\n    }\r\n    let rmGain = DC.E3.pow(log10FinalEP / 4000 - 1);\r\n    // Increase base RM gain if <10 RM\r\n    if (rmGain.gte(1) && rmGain.lt(10)) rmGain = new Decimal(27 / 4000 * log10FinalEP - 26);\r\n    rmGain = rmGain.times(this.realityMachineMultiplier);\r\n    return rmGain.floor();\r\n  },\r\n\r\n  get gainedRealityMachines() {\r\n    return this.uncappedRM.clampMax(this.hardcapRM);\r\n  },\r\n\r\n  get isIMUnlocked() {\r\n    return Currency.realityMachines.value.gte(this.hardcapRM) || Currency.imaginaryMachines.gt(0);\r\n  },\r\n\r\n  get baseIMCap() {\r\n    return (Math.pow(Math.clampMin(this.uncappedRM.log10() - 1000, 0), 2)) *\r\n      (Math.pow(Math.clampMin(this.uncappedRM.log10() - 100000, 1), 0.2));\r\n  },\r\n\r\n  get currentIMCap() {\r\n    return player.reality.iMCap * ImaginaryUpgrade(13).effectOrDefault(1);\r\n  },\r\n\r\n  // This is iM cap based on in-game values at that instant, may be lower than the actual cap\r\n  get projectedIMCap() {\r\n    return this.baseIMCap * ImaginaryUpgrade(13).effectOrDefault(1);\r\n  },\r\n\r\n  // Use iMCap to store the base cap; applying multipliers separately avoids some design issues the 3xTP upgrade has\r\n  updateIMCap() {\r\n    if (this.uncappedRM.gte(this.baseRMCap)) {\r\n      if (this.baseIMCap > player.reality.iMCap) {\r\n        player.records.bestReality.iMCapSet = Glyphs.copyForRecords(Glyphs.active.filter(g => g !== null));\r\n        player.reality.iMCap = this.baseIMCap;\r\n      }\r\n    }\r\n  },\r\n\r\n  // Time in seconds to reduce the missing amount by a factor of two\r\n  get scaleTimeForIM() {\r\n    return 60 / ImaginaryUpgrade(20).effectOrDefault(1);\r\n  },\r\n\r\n  gainedImaginaryMachines(diff) {\r\n    return (this.currentIMCap - Currency.imaginaryMachines.value) *\r\n      (1 - Math.pow(2, (-diff / 1000 / this.scaleTimeForIM)));\r\n  },\r\n\r\n  estimateIMTimer(cost) {\r\n    const imCap = this.currentIMCap;\r\n    if (imCap <= cost) return Infinity;\r\n    const currentIM = Currency.imaginaryMachines.value;\r\n    // This is doing log(a, 1/2) - log(b, 1/2) where a is % left to imCap of cost and b is % left to imCap of current\r\n    // iM. log(1 - x, 1/2) should be able to estimate the time taken for iM to increase from 0 to imCap * x since every\r\n    // fixed interval the difference between current iM to max iM should decrease by a factor of 1/2.\r\n    return Math.max(0, Math.log2(imCap / (imCap - cost)) - Math.log2(imCap / (imCap - currentIM))) *\r\n      this.scaleTimeForIM;\r\n  }\r\n};\r\n"]},"metadata":{},"sourceType":"module"}