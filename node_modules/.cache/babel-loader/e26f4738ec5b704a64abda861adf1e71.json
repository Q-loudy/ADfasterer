{"ast":null,"code":"import \"core-js/modules/es.array.reduce.js\";\nimport { DC } from \"./constants\";\n/**\r\n * @abstract\r\n */\n\nexport class TimeTheoremPurchaseType {\n  /**\r\n  * @abstract\r\n  */\n  get amount() {\n    throw new NotImplementedError();\n  }\n  /**\r\n  * @abstract\r\n  */\n\n\n  set amount(value) {\n    throw new NotImplementedError();\n  }\n\n  add(amount) {\n    this.amount += amount;\n  }\n  /**\r\n  * @abstract\r\n  */\n\n\n  get currency() {\n    throw new NotImplementedError();\n  }\n\n  get cost() {\n    return this.costBase.times(this.costIncrement.pow(this.amount));\n  }\n  /**\r\n   * @abstract\r\n   */\n\n\n  get costBase() {\n    throw new NotImplementedError();\n  }\n  /**\r\n   * @abstract\r\n   */\n\n\n  get costIncrement() {\n    throw new NotImplementedError();\n  }\n\n  get bulkPossible() {\n    if (Perk.ttFree.canBeApplied) {\n      return Math.floor(this.currency.value.divide(this.cost).log10() / this.costIncrement.log10() + 1);\n    }\n\n    return Decimal.affordGeometricSeries(this.currency.value, this.cost, this.costIncrement, 0).toNumber();\n  } // Note: This is actually just the cost of the largest term of the geometric series. If buying EP without the\n  // perk that makes them free, this will be incorrect, but the EP object already overrides this anyway\n\n\n  bulkCost(amount) {\n    return this.cost.times(this.costIncrement.pow(amount - 1));\n  }\n\n  purchase(bulk) {\n    if (!this.canAfford) return false;\n    let purchased = false;\n    const amount = this.bulkPossible;\n\n    const buyFn = cost => Perk.ttFree.canBeApplied ? this.currency.gte(cost) : this.currency.purchase(cost); // This will sometimes buy one too few for EP, so we just have to buy 1 after.\n\n\n    if (bulk && buyFn(this.bulkCost(amount))) {\n      Currency.timeTheorems.add(amount);\n      this.add(amount);\n      purchased = true;\n    }\n\n    if (buyFn(this.cost)) {\n      Currency.timeTheorems.add(1);\n      this.add(1);\n      purchased = true;\n    }\n\n    if (purchased) player.requirementChecks.reality.noPurchasedTT = false;\n    if (TimeTheorems.totalPurchased() > 114) PelleStrikes.ECs.trigger();\n    return purchased;\n  }\n\n  get canAfford() {\n    return this.currency.gte(this.cost) && !player.eternities.eq(0);\n  }\n\n  reset() {\n    this.amount = 0;\n  }\n\n}\nTimeTheoremPurchaseType.am = new class extends TimeTheoremPurchaseType {\n  get amount() {\n    return player.timestudy.amBought;\n  }\n\n  set amount(value) {\n    player.timestudy.amBought = value;\n  }\n\n  get currency() {\n    return Currency.antimatter;\n  }\n\n  get costBase() {\n    return DC.E20000;\n  }\n\n  get costIncrement() {\n    return DC.E20000;\n  }\n\n}();\nTimeTheoremPurchaseType.ip = new class extends TimeTheoremPurchaseType {\n  get amount() {\n    return player.timestudy.ipBought;\n  }\n\n  set amount(value) {\n    player.timestudy.ipBought = value;\n  }\n\n  get currency() {\n    return Currency.infinityPoints;\n  }\n\n  get costBase() {\n    return DC.D1;\n  }\n\n  get costIncrement() {\n    return DC.E100;\n  }\n\n}();\nTimeTheoremPurchaseType.ep = new class extends TimeTheoremPurchaseType {\n  get amount() {\n    return player.timestudy.epBought;\n  }\n\n  set amount(value) {\n    player.timestudy.epBought = value;\n  }\n\n  get currency() {\n    return Currency.eternityPoints;\n  }\n\n  get costBase() {\n    return DC.D1;\n  }\n\n  get costIncrement() {\n    return DC.D2;\n  }\n\n  bulkCost(amount) {\n    if (Perk.ttFree.canBeApplied) return this.cost.times(this.costIncrement.pow(amount - 1));\n    return this.costIncrement.pow(amount + this.amount).subtract(this.cost);\n  }\n\n}();\nexport const TimeTheorems = {\n  checkForBuying(auto) {\n    if (PlayerProgress.realityUnlocked() || TimeDimension(1).bought) return true;\n    if (!auto) Modal.message.show(`You need to buy at least ${formatInt(1)} Time Dimension before you can purchase\n      Time Theorems.`, {\n      closeEvent: GAME_EVENT.REALITY_RESET_AFTER\n    });\n    return false;\n  },\n\n  buyOne(auto = false, type) {\n    if (!this.checkForBuying(auto)) return 0;\n    if (!TimeTheoremPurchaseType[type].purchase(false)) return 0;\n    return 1;\n  },\n\n  // This is only called via automation and there's no manual use-case, so we assume auto is true and simplify a bit\n  buyOneOfEach() {\n    if (!this.checkForBuying(true)) return 0;\n    const ttAM = this.buyOne(true, \"am\");\n    const ttIP = this.buyOne(true, \"ip\");\n    const ttEP = this.buyOne(true, \"ep\");\n    return ttAM + ttIP + ttEP;\n  },\n\n  buyMax(auto = false) {\n    if (!this.checkForBuying(auto)) return 0;\n    const ttAM = TimeTheoremPurchaseType.am.purchase(true);\n    const ttIP = TimeTheoremPurchaseType.ip.purchase(true);\n    const ttEP = TimeTheoremPurchaseType.ep.purchase(true);\n    return ttAM + ttIP + ttEP;\n  },\n\n  totalPurchased() {\n    return TimeTheoremPurchaseType.am.amount + TimeTheoremPurchaseType.ip.amount + TimeTheoremPurchaseType.ep.amount;\n  },\n\n  calculateTimeStudiesCost() {\n    let totalCost = TimeStudy.boughtNormalTS().map(ts => ts.cost).reduce(Number.sumReducer, 0);\n    const ecStudy = TimeStudy.eternityChallenge.current();\n\n    if (ecStudy !== undefined) {\n      totalCost += ecStudy.cost;\n    }\n\n    if (Enslaved.isRunning && player.celestials.enslaved.hasSecretStudy) totalCost -= 100;\n    return totalCost;\n  }\n\n};","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/time-theorems.js"],"names":["DC","TimeTheoremPurchaseType","amount","NotImplementedError","value","add","currency","cost","costBase","times","costIncrement","pow","bulkPossible","Perk","ttFree","canBeApplied","Math","floor","divide","log10","Decimal","affordGeometricSeries","toNumber","bulkCost","purchase","bulk","canAfford","purchased","buyFn","gte","Currency","timeTheorems","player","requirementChecks","reality","noPurchasedTT","TimeTheorems","totalPurchased","PelleStrikes","ECs","trigger","eternities","eq","reset","am","timestudy","amBought","antimatter","E20000","ip","ipBought","infinityPoints","D1","E100","ep","epBought","eternityPoints","D2","subtract","checkForBuying","auto","PlayerProgress","realityUnlocked","TimeDimension","bought","Modal","message","show","formatInt","closeEvent","GAME_EVENT","REALITY_RESET_AFTER","buyOne","type","buyOneOfEach","ttAM","ttIP","ttEP","buyMax","calculateTimeStudiesCost","totalCost","TimeStudy","boughtNormalTS","map","ts","reduce","Number","sumReducer","ecStudy","eternityChallenge","current","undefined","Enslaved","isRunning","celestials","enslaved","hasSecretStudy"],"mappings":";AAAA,SAASA,EAAT,QAAmB,aAAnB;AAEA;AACA;AACA;;AACA,OAAO,MAAMC,uBAAN,CAA8B;AACnC;AACF;AACA;AACY,MAANC,MAAM,GAAG;AAAE,UAAM,IAAIC,mBAAJ,EAAN;AAAkC;AAEjD;AACF;AACA;;;AACY,MAAND,MAAM,CAACE,KAAD,EAAQ;AAAE,UAAM,IAAID,mBAAJ,EAAN;AAAkC;;AAEtDE,EAAAA,GAAG,CAACH,MAAD,EAAS;AAAE,SAAKA,MAAL,IAAeA,MAAf;AAAwB;AAEtC;AACF;AACA;;;AACc,MAARI,QAAQ,GAAG;AAAE,UAAM,IAAIH,mBAAJ,EAAN;AAAkC;;AAE3C,MAAJI,IAAI,GAAG;AAAE,WAAO,KAAKC,QAAL,CAAcC,KAAd,CAAoB,KAAKC,aAAL,CAAmBC,GAAnB,CAAuB,KAAKT,MAA5B,CAApB,CAAP;AAAkE;AAE/E;AACF;AACA;;;AACc,MAARM,QAAQ,GAAG;AAAE,UAAM,IAAIL,mBAAJ,EAAN;AAAkC;AAEnD;AACF;AACA;;;AACmB,MAAbO,aAAa,GAAG;AAAE,UAAM,IAAIP,mBAAJ,EAAN;AAAkC;;AAExC,MAAZS,YAAY,GAAG;AACjB,QAAIC,IAAI,CAACC,MAAL,CAAYC,YAAhB,EAA8B;AAC5B,aAAOC,IAAI,CAACC,KAAL,CAAW,KAAKX,QAAL,CAAcF,KAAd,CAAoBc,MAApB,CAA2B,KAAKX,IAAhC,EAAsCY,KAAtC,KAAgD,KAAKT,aAAL,CAAmBS,KAAnB,EAAhD,GAA6E,CAAxF,CAAP;AACD;;AACD,WAAOC,OAAO,CAACC,qBAAR,CAA8B,KAAKf,QAAL,CAAcF,KAA5C,EAAmD,KAAKG,IAAxD,EAA8D,KAAKG,aAAnE,EAAkF,CAAlF,EAAqFY,QAArF,EAAP;AACD,GAnCkC,CAqCnC;AACA;;;AACAC,EAAAA,QAAQ,CAACrB,MAAD,EAAS;AACf,WAAO,KAAKK,IAAL,CAAUE,KAAV,CAAgB,KAAKC,aAAL,CAAmBC,GAAnB,CAAuBT,MAAM,GAAG,CAAhC,CAAhB,CAAP;AACD;;AAEDsB,EAAAA,QAAQ,CAACC,IAAD,EAAO;AACb,QAAI,CAAC,KAAKC,SAAV,EAAqB,OAAO,KAAP;AACrB,QAAIC,SAAS,GAAG,KAAhB;AACA,UAAMzB,MAAM,GAAG,KAAKU,YAApB;;AACA,UAAMgB,KAAK,GAAGrB,IAAI,IAAKM,IAAI,CAACC,MAAL,CAAYC,YAAZ,GAA2B,KAAKT,QAAL,CAAcuB,GAAd,CAAkBtB,IAAlB,CAA3B,GAAqD,KAAKD,QAAL,CAAckB,QAAd,CAAuBjB,IAAvB,CAA5E,CAJa,CAKb;;;AACA,QAAIkB,IAAI,IAAIG,KAAK,CAAC,KAAKL,QAAL,CAAcrB,MAAd,CAAD,CAAjB,EAA0C;AACxC4B,MAAAA,QAAQ,CAACC,YAAT,CAAsB1B,GAAtB,CAA0BH,MAA1B;AACA,WAAKG,GAAL,CAASH,MAAT;AACAyB,MAAAA,SAAS,GAAG,IAAZ;AACD;;AACD,QAAIC,KAAK,CAAC,KAAKrB,IAAN,CAAT,EAAsB;AACpBuB,MAAAA,QAAQ,CAACC,YAAT,CAAsB1B,GAAtB,CAA0B,CAA1B;AACA,WAAKA,GAAL,CAAS,CAAT;AACAsB,MAAAA,SAAS,GAAG,IAAZ;AACD;;AACD,QAAIA,SAAJ,EAAeK,MAAM,CAACC,iBAAP,CAAyBC,OAAzB,CAAiCC,aAAjC,GAAiD,KAAjD;AACf,QAAIC,YAAY,CAACC,cAAb,KAAgC,GAApC,EAAyCC,YAAY,CAACC,GAAb,CAAiBC,OAAjB;AACzC,WAAOb,SAAP;AACD;;AAEY,MAATD,SAAS,GAAG;AACd,WAAO,KAAKpB,QAAL,CAAcuB,GAAd,CAAkB,KAAKtB,IAAvB,KAAgC,CAACyB,MAAM,CAACS,UAAP,CAAkBC,EAAlB,CAAqB,CAArB,CAAxC;AACD;;AAEDC,EAAAA,KAAK,GAAG;AACN,SAAKzC,MAAL,GAAc,CAAd;AACD;;AAtEkC;AAyErCD,uBAAuB,CAAC2C,EAAxB,GAA6B,IAAI,cAAc3C,uBAAd,CAAsC;AAC3D,MAANC,MAAM,GAAG;AAAE,WAAO8B,MAAM,CAACa,SAAP,CAAiBC,QAAxB;AAAmC;;AACxC,MAAN5C,MAAM,CAACE,KAAD,EAAQ;AAAE4B,IAAAA,MAAM,CAACa,SAAP,CAAiBC,QAAjB,GAA4B1C,KAA5B;AAAoC;;AAE5C,MAARE,QAAQ,GAAG;AAAE,WAAOwB,QAAQ,CAACiB,UAAhB;AAA6B;;AAClC,MAARvC,QAAQ,GAAG;AAAE,WAAOR,EAAE,CAACgD,MAAV;AAAmB;;AACnB,MAAbtC,aAAa,GAAG;AAAE,WAAOV,EAAE,CAACgD,MAAV;AAAmB;;AAN4B,CAA1C,EAA7B;AASA/C,uBAAuB,CAACgD,EAAxB,GAA6B,IAAI,cAAchD,uBAAd,CAAsC;AAC3D,MAANC,MAAM,GAAG;AAAE,WAAO8B,MAAM,CAACa,SAAP,CAAiBK,QAAxB;AAAmC;;AACxC,MAANhD,MAAM,CAACE,KAAD,EAAQ;AAAE4B,IAAAA,MAAM,CAACa,SAAP,CAAiBK,QAAjB,GAA4B9C,KAA5B;AAAoC;;AAE5C,MAARE,QAAQ,GAAG;AAAE,WAAOwB,QAAQ,CAACqB,cAAhB;AAAiC;;AACtC,MAAR3C,QAAQ,GAAG;AAAE,WAAOR,EAAE,CAACoD,EAAV;AAAe;;AACf,MAAb1C,aAAa,GAAG;AAAE,WAAOV,EAAE,CAACqD,IAAV;AAAiB;;AAN8B,CAA1C,EAA7B;AASApD,uBAAuB,CAACqD,EAAxB,GAA6B,IAAI,cAAcrD,uBAAd,CAAsC;AAC3D,MAANC,MAAM,GAAG;AAAE,WAAO8B,MAAM,CAACa,SAAP,CAAiBU,QAAxB;AAAmC;;AACxC,MAANrD,MAAM,CAACE,KAAD,EAAQ;AAAE4B,IAAAA,MAAM,CAACa,SAAP,CAAiBU,QAAjB,GAA4BnD,KAA5B;AAAoC;;AAE5C,MAARE,QAAQ,GAAG;AAAE,WAAOwB,QAAQ,CAAC0B,cAAhB;AAAiC;;AACtC,MAARhD,QAAQ,GAAG;AAAE,WAAOR,EAAE,CAACoD,EAAV;AAAe;;AACf,MAAb1C,aAAa,GAAG;AAAE,WAAOV,EAAE,CAACyD,EAAV;AAAe;;AAErClC,EAAAA,QAAQ,CAACrB,MAAD,EAAS;AACf,QAAIW,IAAI,CAACC,MAAL,CAAYC,YAAhB,EAA8B,OAAO,KAAKR,IAAL,CAAUE,KAAV,CAAgB,KAAKC,aAAL,CAAmBC,GAAnB,CAAuBT,MAAM,GAAG,CAAhC,CAAhB,CAAP;AAC9B,WAAO,KAAKQ,aAAL,CAAmBC,GAAnB,CAAuBT,MAAM,GAAG,KAAKA,MAArC,EAA6CwD,QAA7C,CAAsD,KAAKnD,IAA3D,CAAP;AACD;;AAXoE,CAA1C,EAA7B;AAcA,OAAO,MAAM6B,YAAY,GAAG;AAC1BuB,EAAAA,cAAc,CAACC,IAAD,EAAO;AACnB,QAAIC,cAAc,CAACC,eAAf,MAAoCC,aAAa,CAAC,CAAD,CAAb,CAAiBC,MAAzD,EAAiE,OAAO,IAAP;AACjE,QAAI,CAACJ,IAAL,EAAWK,KAAK,CAACC,OAAN,CAAcC,IAAd,CAAoB,4BAA2BC,SAAS,CAAC,CAAD,CAAI;AAC3E,qBADe,EACQ;AAAEC,MAAAA,UAAU,EAAEC,UAAU,CAACC;AAAzB,KADR;AAEX,WAAO,KAAP;AACD,GANyB;;AAQ1BC,EAAAA,MAAM,CAACZ,IAAI,GAAG,KAAR,EAAea,IAAf,EAAqB;AACzB,QAAI,CAAC,KAAKd,cAAL,CAAoBC,IAApB,CAAL,EAAgC,OAAO,CAAP;AAChC,QAAI,CAAC3D,uBAAuB,CAACwE,IAAD,CAAvB,CAA8BjD,QAA9B,CAAuC,KAAvC,CAAL,EAAoD,OAAO,CAAP;AACpD,WAAO,CAAP;AACD,GAZyB;;AAc1B;AACAkD,EAAAA,YAAY,GAAG;AACb,QAAI,CAAC,KAAKf,cAAL,CAAoB,IAApB,CAAL,EAAgC,OAAO,CAAP;AAChC,UAAMgB,IAAI,GAAG,KAAKH,MAAL,CAAY,IAAZ,EAAkB,IAAlB,CAAb;AACA,UAAMI,IAAI,GAAG,KAAKJ,MAAL,CAAY,IAAZ,EAAkB,IAAlB,CAAb;AACA,UAAMK,IAAI,GAAG,KAAKL,MAAL,CAAY,IAAZ,EAAkB,IAAlB,CAAb;AACA,WAAOG,IAAI,GAAGC,IAAP,GAAcC,IAArB;AACD,GArByB;;AAuB1BC,EAAAA,MAAM,CAAClB,IAAI,GAAG,KAAR,EAAe;AACnB,QAAI,CAAC,KAAKD,cAAL,CAAoBC,IAApB,CAAL,EAAgC,OAAO,CAAP;AAChC,UAAMe,IAAI,GAAG1E,uBAAuB,CAAC2C,EAAxB,CAA2BpB,QAA3B,CAAoC,IAApC,CAAb;AACA,UAAMoD,IAAI,GAAG3E,uBAAuB,CAACgD,EAAxB,CAA2BzB,QAA3B,CAAoC,IAApC,CAAb;AACA,UAAMqD,IAAI,GAAG5E,uBAAuB,CAACqD,EAAxB,CAA2B9B,QAA3B,CAAoC,IAApC,CAAb;AACA,WAAOmD,IAAI,GAAGC,IAAP,GAAcC,IAArB;AACD,GA7ByB;;AA+B1BxC,EAAAA,cAAc,GAAG;AACf,WAAOpC,uBAAuB,CAAC2C,EAAxB,CAA2B1C,MAA3B,GACDD,uBAAuB,CAACgD,EAAxB,CAA2B/C,MAD1B,GAEDD,uBAAuB,CAACqD,EAAxB,CAA2BpD,MAFjC;AAGD,GAnCyB;;AAqC1B6E,EAAAA,wBAAwB,GAAG;AACzB,QAAIC,SAAS,GAAGC,SAAS,CAACC,cAAV,GACbC,GADa,CACTC,EAAE,IAAIA,EAAE,CAAC7E,IADA,EAEb8E,MAFa,CAENC,MAAM,CAACC,UAFD,EAEa,CAFb,CAAhB;AAGA,UAAMC,OAAO,GAAGP,SAAS,CAACQ,iBAAV,CAA4BC,OAA5B,EAAhB;;AACA,QAAIF,OAAO,KAAKG,SAAhB,EAA2B;AACzBX,MAAAA,SAAS,IAAIQ,OAAO,CAACjF,IAArB;AACD;;AACD,QAAIqF,QAAQ,CAACC,SAAT,IAAsB7D,MAAM,CAAC8D,UAAP,CAAkBC,QAAlB,CAA2BC,cAArD,EAAqEhB,SAAS,IAAI,GAAb;AACrE,WAAOA,SAAP;AACD;;AA/CyB,CAArB","sourcesContent":["import { DC } from \"./constants\";\r\n\r\n/**\r\n * @abstract\r\n */\r\nexport class TimeTheoremPurchaseType {\r\n  /**\r\n  * @abstract\r\n  */\r\n  get amount() { throw new NotImplementedError(); }\r\n\r\n  /**\r\n  * @abstract\r\n  */\r\n  set amount(value) { throw new NotImplementedError(); }\r\n\r\n  add(amount) { this.amount += amount; }\r\n\r\n  /**\r\n  * @abstract\r\n  */\r\n  get currency() { throw new NotImplementedError(); }\r\n\r\n  get cost() { return this.costBase.times(this.costIncrement.pow(this.amount)); }\r\n\r\n  /**\r\n   * @abstract\r\n   */\r\n  get costBase() { throw new NotImplementedError(); }\r\n\r\n  /**\r\n   * @abstract\r\n   */\r\n  get costIncrement() { throw new NotImplementedError(); }\r\n\r\n  get bulkPossible() {\r\n    if (Perk.ttFree.canBeApplied) {\r\n      return Math.floor(this.currency.value.divide(this.cost).log10() / this.costIncrement.log10() + 1);\r\n    }\r\n    return Decimal.affordGeometricSeries(this.currency.value, this.cost, this.costIncrement, 0).toNumber();\r\n  }\r\n\r\n  // Note: This is actually just the cost of the largest term of the geometric series. If buying EP without the\r\n  // perk that makes them free, this will be incorrect, but the EP object already overrides this anyway\r\n  bulkCost(amount) {\r\n    return this.cost.times(this.costIncrement.pow(amount - 1));\r\n  }\r\n\r\n  purchase(bulk) {\r\n    if (!this.canAfford) return false;\r\n    let purchased = false;\r\n    const amount = this.bulkPossible;\r\n    const buyFn = cost => (Perk.ttFree.canBeApplied ? this.currency.gte(cost) : this.currency.purchase(cost));\r\n    // This will sometimes buy one too few for EP, so we just have to buy 1 after.\r\n    if (bulk && buyFn(this.bulkCost(amount))) {\r\n      Currency.timeTheorems.add(amount);\r\n      this.add(amount);\r\n      purchased = true;\r\n    }\r\n    if (buyFn(this.cost)) {\r\n      Currency.timeTheorems.add(1);\r\n      this.add(1);\r\n      purchased = true;\r\n    }\r\n    if (purchased) player.requirementChecks.reality.noPurchasedTT = false;\r\n    if (TimeTheorems.totalPurchased() > 114) PelleStrikes.ECs.trigger();\r\n    return purchased;\r\n  }\r\n\r\n  get canAfford() {\r\n    return this.currency.gte(this.cost) && !player.eternities.eq(0);\r\n  }\r\n\r\n  reset() {\r\n    this.amount = 0;\r\n  }\r\n}\r\n\r\nTimeTheoremPurchaseType.am = new class extends TimeTheoremPurchaseType {\r\n  get amount() { return player.timestudy.amBought; }\r\n  set amount(value) { player.timestudy.amBought = value; }\r\n\r\n  get currency() { return Currency.antimatter; }\r\n  get costBase() { return DC.E20000; }\r\n  get costIncrement() { return DC.E20000; }\r\n}();\r\n\r\nTimeTheoremPurchaseType.ip = new class extends TimeTheoremPurchaseType {\r\n  get amount() { return player.timestudy.ipBought; }\r\n  set amount(value) { player.timestudy.ipBought = value; }\r\n\r\n  get currency() { return Currency.infinityPoints; }\r\n  get costBase() { return DC.D1; }\r\n  get costIncrement() { return DC.E100; }\r\n}();\r\n\r\nTimeTheoremPurchaseType.ep = new class extends TimeTheoremPurchaseType {\r\n  get amount() { return player.timestudy.epBought; }\r\n  set amount(value) { player.timestudy.epBought = value; }\r\n\r\n  get currency() { return Currency.eternityPoints; }\r\n  get costBase() { return DC.D1; }\r\n  get costIncrement() { return DC.D2; }\r\n\r\n  bulkCost(amount) {\r\n    if (Perk.ttFree.canBeApplied) return this.cost.times(this.costIncrement.pow(amount - 1));\r\n    return this.costIncrement.pow(amount + this.amount).subtract(this.cost);\r\n  }\r\n}();\r\n\r\nexport const TimeTheorems = {\r\n  checkForBuying(auto) {\r\n    if (PlayerProgress.realityUnlocked() || TimeDimension(1).bought) return true;\r\n    if (!auto) Modal.message.show(`You need to buy at least ${formatInt(1)} Time Dimension before you can purchase\r\n      Time Theorems.`, { closeEvent: GAME_EVENT.REALITY_RESET_AFTER });\r\n    return false;\r\n  },\r\n\r\n  buyOne(auto = false, type) {\r\n    if (!this.checkForBuying(auto)) return 0;\r\n    if (!TimeTheoremPurchaseType[type].purchase(false)) return 0;\r\n    return 1;\r\n  },\r\n\r\n  // This is only called via automation and there's no manual use-case, so we assume auto is true and simplify a bit\r\n  buyOneOfEach() {\r\n    if (!this.checkForBuying(true)) return 0;\r\n    const ttAM = this.buyOne(true, \"am\");\r\n    const ttIP = this.buyOne(true, \"ip\");\r\n    const ttEP = this.buyOne(true, \"ep\");\r\n    return ttAM + ttIP + ttEP;\r\n  },\r\n\r\n  buyMax(auto = false) {\r\n    if (!this.checkForBuying(auto)) return 0;\r\n    const ttAM = TimeTheoremPurchaseType.am.purchase(true);\r\n    const ttIP = TimeTheoremPurchaseType.ip.purchase(true);\r\n    const ttEP = TimeTheoremPurchaseType.ep.purchase(true);\r\n    return ttAM + ttIP + ttEP;\r\n  },\r\n\r\n  totalPurchased() {\r\n    return TimeTheoremPurchaseType.am.amount +\r\n          TimeTheoremPurchaseType.ip.amount +\r\n          TimeTheoremPurchaseType.ep.amount;\r\n  },\r\n\r\n  calculateTimeStudiesCost() {\r\n    let totalCost = TimeStudy.boughtNormalTS()\r\n      .map(ts => ts.cost)\r\n      .reduce(Number.sumReducer, 0);\r\n    const ecStudy = TimeStudy.eternityChallenge.current();\r\n    if (ecStudy !== undefined) {\r\n      totalCost += ecStudy.cost;\r\n    }\r\n    if (Enslaved.isRunning && player.celestials.enslaved.hasSecretStudy) totalCost -= 100;\r\n    return totalCost;\r\n  }\r\n};\r\n"]},"metadata":{},"sourceType":"module"}