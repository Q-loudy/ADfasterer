{"ast":null,"code":"import _objectSpread from \"C:/Games/ADFasterer/ADfasterer/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\n\n/**\r\n * Class which handles the creation of all automator script templates, with the final script and potential\r\n * warnings for inputs being the only parts which are meant to be externally exposed. All the messy parsing\r\n * and potential warning/error finding happens internally.\r\n *\r\n * @member {String[]} lines               Array of lines of code which can be used within the automator\r\n * @member {String[]} warnings            List of feedback statements to provide to the player based on possible\r\n *  undesired behavior which may result from their particular input parameters\r\n * @member {String} storedTreeStr         String for specifically importing a supplied study tree. All templates\r\n *  will contain at most one tree within; the expected usage is that if some task requires multiple trees, then\r\n *  the player will use multiple templates to do so\r\n * @member {TimeStudyTree} storedTreeObj  Study tree object for the specified study tree; storing it within the\r\n *  object instead of parsing it as-needed higher up in the call chain reduces boilerplate code\r\n */\nexport class ScriptTemplate {\n  constructor(params, templateName) {\n    this.lines = [];\n    this.warnings = [];\n\n    switch (templateName) {\n      case \"Climb EP\":\n        this.templateClimbEP(params);\n        break;\n\n      case \"Grind Eternities\":\n        this.templateGrindEternities(params);\n        break;\n\n      case \"Grind Infinities\":\n        this.templateGrindInfinities(params);\n        break;\n\n      case \"Complete Eternity Challenge\":\n        this.templateDoEC(params);\n        break;\n\n      case \"Unlock Dilation\":\n        this.templateUnlockDilation(params);\n        break;\n\n      default:\n        throw new Error(`Unrecognized template name ${templateName} in ScriptTemplate`);\n    }\n  }\n  /**\r\n   * Special formatting for numbers in templates; we can't use format() here because that will change based on the\r\n   * player's current notation. This is generally desirable in the rest of the game, but in most notations will\r\n   * result in unparseable garbage here. Numbers are formatted assuming they're integers, and Decimals are formatted\r\n   * with 2 decimal places (in scientific notation if above 1000)\r\n   * @param {Number | Decimal} num  Number to format, disregarding current notation settings\r\n   * @returns {String}  The properly-formatted number, in a reasonable-looking format valid for the automator\r\n   */\n\n\n  format(num) {\n    if (typeof num === \"number\") return Math.round(num);\n    if (num.lte(1000)) return num.toNumber().toFixed(2);\n    return `${num.mantissa.toFixed(2)}e${num.exponent}`;\n  }\n  /**\r\n   * Parses tree data out of the parameter object and stores within the storedTree fields. Relevant props of object\r\n   * passed in:\r\n   * @param {String} params.treePreset      Name of a preset to load instead of a study tree, will override treeStudies\r\n   *  if present\r\n   * @param {Boolean} params.treeNowait     Whether or not the automator should pause at this line and repeat\r\n   *  until the whole tree is bought\r\n   * @param {String} params.treeStudies     A study import string to buy\r\n   */\n\n\n  storeTreeData(params) {\n    const nowaitStr = params.treeNowait ? \" nowait\" : \"\";\n\n    if (params.treePreset) {\n      const presetObj = player.timestudy.presets.map((p, i) => _objectSpread(_objectSpread({}, p), {}, {\n        id: i + 1\n      })).find(p => p.name === params.treePreset || p.id === Number(params.treePreset));\n      const preset = presetObj.name ? `name ${presetObj.name}` : `id ${presetObj.id}`;\n      this.storedTreeStr = `studies${nowaitStr} load ${preset}`;\n      this.storedTreeObj = new TimeStudyTree(presetObj.studies);\n    } else {\n      this.storedTreeStr = `studies${nowaitStr} purchase ${params.treeStudies}`;\n      this.storedTreeObj = new TimeStudyTree(params.treeStudies);\n    }\n\n    if (this.storedTreeObj.invalidStudies.length > 0) this.warnings.push(\"Tree contains invalid Study IDs\");\n\n    if (this.storedTreeObj.purchasedStudies.length < this.storedTreeObj.selectedStudies.length) {\n      this.warnings.push(\"Tree structure results in some unbought studies when imported with an empty tree\");\n      if (!params.treeNowait) this.warnings.push(`Automator may possibly get stuck with \"Keep buying Studies\" setting`);\n    }\n  }\n  /**\r\n   * Parses automator data out of a two-prop object storing autobuyer settings, into a suffix of automator code which\r\n   * sets the autobuyer to those settings. Relevant props of object passed in:\r\n   * @param {String} mode     \"mult\" or \"time\" for times highest and time modes, respectively\r\n   * @param {Decimal} value   Numerical value for autobuyer settings (assumed to be seconds in time)\r\n   * @returns {String}        String suffix to feed into an automator script, should be prefixed by \"auto [prestige] \"\r\n   */\n\n\n  parseAutobuyerProp(mode, value) {\n    switch (mode) {\n      case \"mult\":\n        return `${this.format(value)} x highest`;\n\n      case \"time\":\n        return `${this.format(value)} seconds`;\n\n      default:\n        throw new Error(`Unrecognized autobuyer mode ${mode} in automator script templates`);\n    }\n  }\n  /**\r\n   * Parses the parameter object into a script that sets the infinity and eternity autobuyers and then repeatedly loops\r\n   * buying a tree and eternitying until a target EP is reached. Relevant props of object passed in:\r\n   * @param {Boolean} params.treeNowait     Nowait param to be passed into storeTreeData()\r\n   * @param {String} params.treeStudies     Study import param to be passed into storeTreeData()\r\n   * @param {Decimal} params.finalEP        EP value at which to stop looping the script and continue onward\r\n   * @param {Object} params.autoInfMode     Multiplier or time-based mode for infinity autobuyer\r\n   * @param {Object} params.autoInfValue    Multiplier threshold or time for infinity autobuyer\r\n   * @param {Object} params.autoEterMode    Multiplier or time-based mode for eternity autobuyer\r\n   * @param {Object} params.autoEterValue   Multiplier threshold or time for eternity autobuyer\r\n   */\n\n\n  templateClimbEP(params) {\n    this.lines.push(\"// Template: Climb EP\");\n    this.lines.push(`notify \"Running Template Climb EP (to ${format(params.finalEP)})\"`);\n    this.storeTreeData(params);\n    this.lines.push(`auto infinity ${this.parseAutobuyerProp(params.autoInfMode, params.autoInfValue)}`);\n    this.lines.push(`auto eternity ${this.parseAutobuyerProp(params.autoEterMode, params.autoEterValue)}`);\n    this.lines.push(`while ep < ${this.format(params.finalEP)} {`);\n    this.lines.push(` ${this.storedTreeStr}`);\n    this.lines.push(\" studies respec\");\n    this.lines.push(\" wait eternity\");\n    this.lines.push(\"}\");\n  }\n  /**\r\n   * Parses the parameter object into a script that sets autobuyer settings and then repeatedly eternities until a\r\n   * target total eternity count is reached. Relevant props of object passed in:\r\n   * @param {Boolean} params.treeNowait           Nowait param to be passed into storeTreeData()\r\n   * @param {String} params.treeStudies           Study import param to be passed into storeTreeData()\r\n   * @param {Number} params.crunchesPerEternity   Number of crunches per eternity\r\n   * @param {Decimal} params.eternities           Eternity count at which to stop grinding and move on\r\n   */\n\n\n  templateGrindEternities(params) {\n    this.lines.push(\"// Template: Grind Eternities\");\n    this.lines.push(`notify \"Running Template Grind Eternities (to ${format(params.eternities)})\"`);\n    this.storeTreeData(params);\n    this.lines.push(this.storedTreeStr);\n    this.lines.push(\"auto eternity 0 ep\"); // We give it a bit of an extra \"safety factor\" of 5x in order to make sure it doesn't end up repeatedly going\n    // to something like 1.6e308 due to poor rounding. The startingValue may fluctuate based on achievements, but\n    // this can be a significant time save that we want to actually give the player if they have the e130 perk\n\n    const gapToEternity = Number.MAX_VALUE / Currency.infinityPoints.startingValue.toNumber() * 5;\n    this.lines.push(`auto infinity ${this.format(Decimal.pow(gapToEternity, 1 / params.crunchesPerEternity))} x highest`);\n    this.lines.push(`wait eternities > ${this.format(params.eternities)}`);\n    this.lines.push(\"auto eternity off\");\n  }\n  /**\r\n   * Parses the parameter object into a script that sets autobuyer settings and then repeatedly infinities until a\r\n   * target total infinity or banked infinity count is reached. If threshold is banked infinities, assumes that the\r\n   * player also has the achievement that lets them bank. Relevant props of object passed in:\r\n   * @param {Boolean} params.treeNowait   Nowait param to be passed into storeTreeData()\r\n   * @param {String} params.treeStudies   Study import param to be passed into storeTreeData()\r\n   * @param {Decimal} params.infinities   Infinity count at which to stop grinding and move on\r\n   * @param {Boolean} params.isBanked     If the script should check for banked infinities instead of normal\r\n   *  infinities, calculating a modified threshold appropriately - we don't eternity repeatedly because this is\r\n   *  slower due to some resources needing to be rebuilt every eternity\r\n   */\n\n\n  templateGrindInfinities(params) {\n    this.lines.push(\"// Template: Grind Infinities\");\n    this.lines.push(`notify \"Running Template Grind Infinities (to ${format(params.infinities)})\"`);\n    this.storeTreeData(params);\n    this.lines.push(this.storedTreeStr);\n    this.lines.push(\"auto eternity off\");\n    this.lines.push(`auto infinity 5s`);\n\n    if (params.isBanked) {\n      const has191 = this.storedTreeObj.purchasedStudies.includes(TimeStudy(191));\n      if (!has191) this.warnings.push(`TS191 is not reachable from an empty tree; banking anything in this template\n        will require Achievement \"${Achievement(131).name}\"`);\n      const bankRate = has191 ? 0.1 : 0.05;\n      this.lines.push(\"// Note: This template attempts to get all the Banked Infinities within a single Eternity\");\n      this.lines.push(`wait infinities > ${this.format(params.infinities.dividedBy(bankRate), 2)}`);\n      this.lines.push(\"eternity\");\n    } else {\n      this.lines.push(`wait infinities > ${this.format(params.infinities, 2)}`);\n    }\n  }\n  /**\r\n   * Parses the parameter object into a script that respecs into a specified tree, unlocks a specified EC, changes\r\n   * autobuyer settings, and then waits until the EC can be completed before triggering an eternity through the\r\n   * automator. Relevant props of object passed in:\r\n   * @param {Boolean} params.treeNowait     Nowait param to be passed into storeTreeData()\r\n   * @param {String} params.treeStudies     Study import param to be passed into storeTreeData()\r\n   * @param {Number} params.ec              Numerical value denoting the EC to attempt\r\n   * @param {Number} params.completions     Minimum number of completions to wait for before moving onward\r\n   * @param {Object} params.autoInfMode     Multiplier or time-based mode for infinity autobuyer\r\n   * @param {Object} params.autoInfValue    Multiplier threshold or time for infinity autobuyer\r\n   */\n\n\n  templateDoEC(params) {\n    this.lines.push(\"// Template: Complete Eternity Challenge\");\n    this.lines.push(`notify \"Running Template Complete Eternity Challenge (EC${params.ec})\"`); // Force an eternity in order to buy the study tree first\n\n    this.lines.push(\"eternity respec\"); // Import the tree and the EC study, supplying errors as appropriate\n\n    this.storeTreeData(params);\n    this.lines.push(this.storedTreeStr);\n    const tree = this.storedTreeObj;\n\n    if (tree.ec === 0) {\n      this.lines.push(`unlock ec ${params.ec}`); // Attempt to buy it, supplying an error if we can't actually reach it\n\n      if (!tree.hasRequirements(TimeStudy.eternityChallenge(params.ec), true)) {\n        this.warnings.push(\"Specified Study Tree cannot reach specified EC\");\n      }\n    } else if (tree.ec !== params.ec) this.warnings.push(\"Specified Study Tree already has a different EC unlocked\"); // Apply autobuyer settings; we specifically want to turn auto-eternity off so that we can manually trigger the\n    // prestige - otherwise, the autobuyer may end up preempting multiple completions\n\n\n    this.lines.push(`auto infinity ${this.parseAutobuyerProp(params.autoInfMode, params.autoInfValue)}`);\n    this.lines.push(`auto eternity off`);\n    if (!TimeStudy.eternityChallenge(params.ec)) this.warnings.push(`Specified template EC does not exist`);\n    this.lines.push(`start ec ${params.ec}`);\n    if (params.completions > 5) this.warnings.push(`ECs cannot be completed more than ${formatInt(5)} times`);\n    this.lines.push(`wait pending completions >= ${params.completions}`);\n    this.lines.push(\"eternity\");\n  }\n  /**\r\n   * Parses the parameter object into a script that sets autobuyer settings and then repeatedly infinities until a\r\n   * target total infinity or banked infinity count is reached. Makes some assumptions on bank rate. Relevant props\r\n   * of object passed in:\r\n   * @param {Boolean} params.treeNowait     Nowait param to be passed into storeTreeData()\r\n   * @param {String} params.treeStudies     Study import param to be passed into storeTreeData()\r\n   * @param {Object} params.autoEterMode    Multiplier or time-based mode for eternity autobuyer\r\n   * @param {Object} params.autoEterValue   Multiplier threshold or time for eternity autobuyer\r\n   */\n\n\n  templateUnlockDilation(params) {\n    this.lines.push(\"// Template: Unlock Dilation\");\n    this.lines.push(`notify \"Running Template Unlock Dilation\"`);\n    this.storeTreeData(params);\n\n    if (![231, 232, 233, 234].some(s => this.storedTreeObj.purchasedStudies.includes(TimeStudy(s)))) {\n      this.warnings.push(\"Specified Study Tree cannot reach Dilation\");\n    }\n\n    this.lines.push(`auto infinity off`);\n    this.lines.push(`auto eternity ${this.parseAutobuyerProp(params.autoEterMode, params.autoEterValue)}`);\n    this.lines.push(`while total tt < ${this.format(TimeStudy.dilation.totalTimeTheoremRequirement)} {`);\n    this.lines.push(` ${this.storedTreeStr}`);\n    this.lines.push(\" studies respec\");\n    this.lines.push(\" wait eternity\");\n    this.lines.push(\"}\");\n    this.lines.push(\"unlock dilation\");\n  }\n\n  get script() {\n    return this.lines.join(\"\\n\");\n  }\n\n}","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/automator/script-templates.js"],"names":["ScriptTemplate","constructor","params","templateName","lines","warnings","templateClimbEP","templateGrindEternities","templateGrindInfinities","templateDoEC","templateUnlockDilation","Error","format","num","Math","round","lte","toNumber","toFixed","mantissa","exponent","storeTreeData","nowaitStr","treeNowait","treePreset","presetObj","player","timestudy","presets","map","p","i","id","find","name","Number","preset","storedTreeStr","storedTreeObj","TimeStudyTree","studies","treeStudies","invalidStudies","length","push","purchasedStudies","selectedStudies","parseAutobuyerProp","mode","value","finalEP","autoInfMode","autoInfValue","autoEterMode","autoEterValue","eternities","gapToEternity","MAX_VALUE","Currency","infinityPoints","startingValue","Decimal","pow","crunchesPerEternity","infinities","isBanked","has191","includes","TimeStudy","Achievement","bankRate","dividedBy","ec","tree","hasRequirements","eternityChallenge","completions","formatInt","some","s","dilation","totalTimeTheoremRequirement","script","join"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMA,cAAN,CAAqB;AAC1BC,EAAAA,WAAW,CAACC,MAAD,EAASC,YAAT,EAAuB;AAChC,SAAKC,KAAL,GAAa,EAAb;AACA,SAAKC,QAAL,GAAgB,EAAhB;;AACA,YAAQF,YAAR;AACE,WAAK,UAAL;AACE,aAAKG,eAAL,CAAqBJ,MAArB;AACA;;AACF,WAAK,kBAAL;AACE,aAAKK,uBAAL,CAA6BL,MAA7B;AACA;;AACF,WAAK,kBAAL;AACE,aAAKM,uBAAL,CAA6BN,MAA7B;AACA;;AACF,WAAK,6BAAL;AACE,aAAKO,YAAL,CAAkBP,MAAlB;AACA;;AACF,WAAK,iBAAL;AACE,aAAKQ,sBAAL,CAA4BR,MAA5B;AACA;;AACF;AACE,cAAM,IAAIS,KAAJ,CAAW,8BAA6BR,YAAa,oBAArD,CAAN;AAjBJ;AAmBD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACES,EAAAA,MAAM,CAACC,GAAD,EAAM;AACV,QAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B,OAAOC,IAAI,CAACC,KAAL,CAAWF,GAAX,CAAP;AAC7B,QAAIA,GAAG,CAACG,GAAJ,CAAQ,IAAR,CAAJ,EAAmB,OAAOH,GAAG,CAACI,QAAJ,GAAeC,OAAf,CAAuB,CAAvB,CAAP;AACnB,WAAQ,GAAEL,GAAG,CAACM,QAAJ,CAAaD,OAAb,CAAqB,CAArB,CAAwB,IAAGL,GAAG,CAACO,QAAS,EAAlD;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEC,EAAAA,aAAa,CAACnB,MAAD,EAAS;AACpB,UAAMoB,SAAS,GAAGpB,MAAM,CAACqB,UAAP,GAAoB,SAApB,GAAgC,EAAlD;;AACA,QAAIrB,MAAM,CAACsB,UAAX,EAAuB;AACrB,YAAMC,SAAS,GAAGC,MAAM,CAACC,SAAP,CAAiBC,OAAjB,CAAyBC,GAAzB,CAA6B,CAACC,CAAD,EAAIC,CAAJ,qCAAgBD,CAAhB;AAAmBE,QAAAA,EAAE,EAAED,CAAC,GAAG;AAA3B,QAA7B,EACfE,IADe,CACVH,CAAC,IAAKA,CAAC,CAACI,IAAF,KAAWhC,MAAM,CAACsB,UAAlB,IAAgCM,CAAC,CAACE,EAAF,KAASG,MAAM,CAACjC,MAAM,CAACsB,UAAR,CAD3C,CAAlB;AAEA,YAAMY,MAAM,GAAGX,SAAS,CAACS,IAAV,GAAkB,QAAOT,SAAS,CAACS,IAAK,EAAxC,GAA6C,MAAKT,SAAS,CAACO,EAAG,EAA9E;AACA,WAAKK,aAAL,GAAsB,UAASf,SAAU,SAAQc,MAAO,EAAxD;AACA,WAAKE,aAAL,GAAqB,IAAIC,aAAJ,CAAkBd,SAAS,CAACe,OAA5B,CAArB;AACD,KAND,MAMO;AACL,WAAKH,aAAL,GAAsB,UAASf,SAAU,aAAYpB,MAAM,CAACuC,WAAY,EAAxE;AACA,WAAKH,aAAL,GAAqB,IAAIC,aAAJ,CAAkBrC,MAAM,CAACuC,WAAzB,CAArB;AACD;;AACD,QAAI,KAAKH,aAAL,CAAmBI,cAAnB,CAAkCC,MAAlC,GAA2C,CAA/C,EAAkD,KAAKtC,QAAL,CAAcuC,IAAd,CAAmB,iCAAnB;;AAClD,QAAI,KAAKN,aAAL,CAAmBO,gBAAnB,CAAoCF,MAApC,GAA6C,KAAKL,aAAL,CAAmBQ,eAAnB,CAAmCH,MAApF,EAA4F;AAC1F,WAAKtC,QAAL,CAAcuC,IAAd,CAAmB,kFAAnB;AACA,UAAI,CAAC1C,MAAM,CAACqB,UAAZ,EAAwB,KAAKlB,QAAL,CAAcuC,IAAd,CAAoB,qEAApB;AACzB;AACF;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;AACEG,EAAAA,kBAAkB,CAACC,IAAD,EAAOC,KAAP,EAAc;AAC9B,YAAQD,IAAR;AACE,WAAK,MAAL;AACE,eAAQ,GAAE,KAAKpC,MAAL,CAAYqC,KAAZ,CAAmB,YAA7B;;AACF,WAAK,MAAL;AACE,eAAQ,GAAE,KAAKrC,MAAL,CAAYqC,KAAZ,CAAmB,UAA7B;;AACF;AACE,cAAM,IAAItC,KAAJ,CAAW,+BAA8BqC,IAAK,gCAA9C,CAAN;AANJ;AAQD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACE1C,EAAAA,eAAe,CAACJ,MAAD,EAAS;AACtB,SAAKE,KAAL,CAAWwC,IAAX,CAAgB,uBAAhB;AACA,SAAKxC,KAAL,CAAWwC,IAAX,CAAiB,yCAAwChC,MAAM,CAACV,MAAM,CAACgD,OAAR,CAAiB,IAAhF;AACA,SAAK7B,aAAL,CAAmBnB,MAAnB;AACA,SAAKE,KAAL,CAAWwC,IAAX,CAAiB,iBAAgB,KAAKG,kBAAL,CAAwB7C,MAAM,CAACiD,WAA/B,EAA4CjD,MAAM,CAACkD,YAAnD,CAAiE,EAAlG;AACA,SAAKhD,KAAL,CAAWwC,IAAX,CAAiB,iBAAgB,KAAKG,kBAAL,CAAwB7C,MAAM,CAACmD,YAA/B,EAA6CnD,MAAM,CAACoD,aAApD,CAAmE,EAApG;AACA,SAAKlD,KAAL,CAAWwC,IAAX,CAAiB,cAAa,KAAKhC,MAAL,CAAYV,MAAM,CAACgD,OAAnB,CAA4B,IAA1D;AACA,SAAK9C,KAAL,CAAWwC,IAAX,CAAiB,IAAG,KAAKP,aAAc,EAAvC;AACA,SAAKjC,KAAL,CAAWwC,IAAX,CAAgB,iBAAhB;AACA,SAAKxC,KAAL,CAAWwC,IAAX,CAAgB,gBAAhB;AACA,SAAKxC,KAAL,CAAWwC,IAAX,CAAgB,GAAhB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACErC,EAAAA,uBAAuB,CAACL,MAAD,EAAS;AAC9B,SAAKE,KAAL,CAAWwC,IAAX,CAAgB,+BAAhB;AACA,SAAKxC,KAAL,CAAWwC,IAAX,CAAiB,iDAAgDhC,MAAM,CAACV,MAAM,CAACqD,UAAR,CAAoB,IAA3F;AACA,SAAKlC,aAAL,CAAmBnB,MAAnB;AACA,SAAKE,KAAL,CAAWwC,IAAX,CAAgB,KAAKP,aAArB;AACA,SAAKjC,KAAL,CAAWwC,IAAX,CAAgB,oBAAhB,EAL8B,CAM9B;AACA;AACA;;AACA,UAAMY,aAAa,GAAGrB,MAAM,CAACsB,SAAP,GAAmBC,QAAQ,CAACC,cAAT,CAAwBC,aAAxB,CAAsC3C,QAAtC,EAAnB,GAAsE,CAA5F;AACA,SAAKb,KAAL,CAAWwC,IAAX,CAAiB,iBAAgB,KAAKhC,MAAL,CAC/BiD,OAAO,CAACC,GAAR,CAAYN,aAAZ,EAA2B,IAAItD,MAAM,CAAC6D,mBAAtC,CAD+B,CAC6B,YAD9D;AAEA,SAAK3D,KAAL,CAAWwC,IAAX,CAAiB,qBAAoB,KAAKhC,MAAL,CAAYV,MAAM,CAACqD,UAAnB,CAA+B,EAApE;AACA,SAAKnD,KAAL,CAAWwC,IAAX,CAAgB,mBAAhB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEpC,EAAAA,uBAAuB,CAACN,MAAD,EAAS;AAC9B,SAAKE,KAAL,CAAWwC,IAAX,CAAgB,+BAAhB;AACA,SAAKxC,KAAL,CAAWwC,IAAX,CAAiB,iDAAgDhC,MAAM,CAACV,MAAM,CAAC8D,UAAR,CAAoB,IAA3F;AACA,SAAK3C,aAAL,CAAmBnB,MAAnB;AACA,SAAKE,KAAL,CAAWwC,IAAX,CAAgB,KAAKP,aAArB;AACA,SAAKjC,KAAL,CAAWwC,IAAX,CAAgB,mBAAhB;AACA,SAAKxC,KAAL,CAAWwC,IAAX,CAAiB,kBAAjB;;AACA,QAAI1C,MAAM,CAAC+D,QAAX,EAAqB;AACnB,YAAMC,MAAM,GAAG,KAAK5B,aAAL,CAAmBO,gBAAnB,CAAoCsB,QAApC,CAA6CC,SAAS,CAAC,GAAD,CAAtD,CAAf;AACA,UAAI,CAACF,MAAL,EAAa,KAAK7D,QAAL,CAAcuC,IAAd,CAAoB;AACvC,oCAAoCyB,WAAW,CAAC,GAAD,CAAX,CAAiBnC,IAAK,GADvC;AAEb,YAAMoC,QAAQ,GAAGJ,MAAM,GAAG,GAAH,GAAS,IAAhC;AACA,WAAK9D,KAAL,CAAWwC,IAAX,CAAgB,2FAAhB;AACA,WAAKxC,KAAL,CAAWwC,IAAX,CAAiB,qBAAoB,KAAKhC,MAAL,CAAYV,MAAM,CAAC8D,UAAP,CAAkBO,SAAlB,CAA4BD,QAA5B,CAAZ,EAAmD,CAAnD,CAAsD,EAA3F;AACA,WAAKlE,KAAL,CAAWwC,IAAX,CAAgB,UAAhB;AACD,KARD,MAQO;AACL,WAAKxC,KAAL,CAAWwC,IAAX,CAAiB,qBAAoB,KAAKhC,MAAL,CAAYV,MAAM,CAAC8D,UAAnB,EAA+B,CAA/B,CAAkC,EAAvE;AACD;AACF;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEvD,EAAAA,YAAY,CAACP,MAAD,EAAS;AACnB,SAAKE,KAAL,CAAWwC,IAAX,CAAgB,0CAAhB;AACA,SAAKxC,KAAL,CAAWwC,IAAX,CAAiB,2DAA0D1C,MAAM,CAACsE,EAAG,IAArF,EAFmB,CAGnB;;AACA,SAAKpE,KAAL,CAAWwC,IAAX,CAAgB,iBAAhB,EAJmB,CAMnB;;AACA,SAAKvB,aAAL,CAAmBnB,MAAnB;AACA,SAAKE,KAAL,CAAWwC,IAAX,CAAgB,KAAKP,aAArB;AACA,UAAMoC,IAAI,GAAG,KAAKnC,aAAlB;;AACA,QAAImC,IAAI,CAACD,EAAL,KAAY,CAAhB,EAAmB;AACjB,WAAKpE,KAAL,CAAWwC,IAAX,CAAiB,aAAY1C,MAAM,CAACsE,EAAG,EAAvC,EADiB,CAEjB;;AACA,UAAI,CAACC,IAAI,CAACC,eAAL,CAAqBN,SAAS,CAACO,iBAAV,CAA4BzE,MAAM,CAACsE,EAAnC,CAArB,EAA6D,IAA7D,CAAL,EAAyE;AACvE,aAAKnE,QAAL,CAAcuC,IAAd,CAAmB,gDAAnB;AACD;AACF,KAND,MAMO,IAAI6B,IAAI,CAACD,EAAL,KAAYtE,MAAM,CAACsE,EAAvB,EAA2B,KAAKnE,QAAL,CAAcuC,IAAd,CAAmB,0DAAnB,EAhBf,CAkBnB;AACA;;;AACA,SAAKxC,KAAL,CAAWwC,IAAX,CAAiB,iBAAgB,KAAKG,kBAAL,CAAwB7C,MAAM,CAACiD,WAA/B,EAA4CjD,MAAM,CAACkD,YAAnD,CAAiE,EAAlG;AACA,SAAKhD,KAAL,CAAWwC,IAAX,CAAiB,mBAAjB;AACA,QAAI,CAACwB,SAAS,CAACO,iBAAV,CAA4BzE,MAAM,CAACsE,EAAnC,CAAL,EAA6C,KAAKnE,QAAL,CAAcuC,IAAd,CAAoB,sCAApB;AAC7C,SAAKxC,KAAL,CAAWwC,IAAX,CAAiB,YAAW1C,MAAM,CAACsE,EAAG,EAAtC;AAEA,QAAItE,MAAM,CAAC0E,WAAP,GAAqB,CAAzB,EAA4B,KAAKvE,QAAL,CAAcuC,IAAd,CAAoB,qCAAoCiC,SAAS,CAAC,CAAD,CAAI,QAArE;AAC5B,SAAKzE,KAAL,CAAWwC,IAAX,CAAiB,+BAA8B1C,MAAM,CAAC0E,WAAY,EAAlE;AACA,SAAKxE,KAAL,CAAWwC,IAAX,CAAgB,UAAhB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACElC,EAAAA,sBAAsB,CAACR,MAAD,EAAS;AAC7B,SAAKE,KAAL,CAAWwC,IAAX,CAAgB,8BAAhB;AACA,SAAKxC,KAAL,CAAWwC,IAAX,CAAiB,2CAAjB;AACA,SAAKvB,aAAL,CAAmBnB,MAAnB;;AACA,QAAI,CAAC,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgB,GAAhB,EAAqB4E,IAArB,CAA0BC,CAAC,IAAI,KAAKzC,aAAL,CAAmBO,gBAAnB,CAAoCsB,QAApC,CAA6CC,SAAS,CAACW,CAAD,CAAtD,CAA/B,CAAL,EAAiG;AAC/F,WAAK1E,QAAL,CAAcuC,IAAd,CAAmB,4CAAnB;AACD;;AACD,SAAKxC,KAAL,CAAWwC,IAAX,CAAiB,mBAAjB;AACA,SAAKxC,KAAL,CAAWwC,IAAX,CAAiB,iBAAgB,KAAKG,kBAAL,CAAwB7C,MAAM,CAACmD,YAA/B,EAA6CnD,MAAM,CAACoD,aAApD,CAAmE,EAApG;AACA,SAAKlD,KAAL,CAAWwC,IAAX,CAAiB,oBAAmB,KAAKhC,MAAL,CAAYwD,SAAS,CAACY,QAAV,CAAmBC,2BAA/B,CAA4D,IAAhG;AACA,SAAK7E,KAAL,CAAWwC,IAAX,CAAiB,IAAG,KAAKP,aAAc,EAAvC;AACA,SAAKjC,KAAL,CAAWwC,IAAX,CAAgB,iBAAhB;AACA,SAAKxC,KAAL,CAAWwC,IAAX,CAAgB,gBAAhB;AACA,SAAKxC,KAAL,CAAWwC,IAAX,CAAgB,GAAhB;AACA,SAAKxC,KAAL,CAAWwC,IAAX,CAAgB,iBAAhB;AACD;;AAES,MAANsC,MAAM,GAAG;AACX,WAAO,KAAK9E,KAAL,CAAW+E,IAAX,CAAgB,IAAhB,CAAP;AACD;;AAzOyB","sourcesContent":["/**\r\n * Class which handles the creation of all automator script templates, with the final script and potential\r\n * warnings for inputs being the only parts which are meant to be externally exposed. All the messy parsing\r\n * and potential warning/error finding happens internally.\r\n *\r\n * @member {String[]} lines               Array of lines of code which can be used within the automator\r\n * @member {String[]} warnings            List of feedback statements to provide to the player based on possible\r\n *  undesired behavior which may result from their particular input parameters\r\n * @member {String} storedTreeStr         String for specifically importing a supplied study tree. All templates\r\n *  will contain at most one tree within; the expected usage is that if some task requires multiple trees, then\r\n *  the player will use multiple templates to do so\r\n * @member {TimeStudyTree} storedTreeObj  Study tree object for the specified study tree; storing it within the\r\n *  object instead of parsing it as-needed higher up in the call chain reduces boilerplate code\r\n */\r\nexport class ScriptTemplate {\r\n  constructor(params, templateName) {\r\n    this.lines = [];\r\n    this.warnings = [];\r\n    switch (templateName) {\r\n      case \"Climb EP\":\r\n        this.templateClimbEP(params);\r\n        break;\r\n      case \"Grind Eternities\":\r\n        this.templateGrindEternities(params);\r\n        break;\r\n      case \"Grind Infinities\":\r\n        this.templateGrindInfinities(params);\r\n        break;\r\n      case \"Complete Eternity Challenge\":\r\n        this.templateDoEC(params);\r\n        break;\r\n      case \"Unlock Dilation\":\r\n        this.templateUnlockDilation(params);\r\n        break;\r\n      default:\r\n        throw new Error(`Unrecognized template name ${templateName} in ScriptTemplate`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Special formatting for numbers in templates; we can't use format() here because that will change based on the\r\n   * player's current notation. This is generally desirable in the rest of the game, but in most notations will\r\n   * result in unparseable garbage here. Numbers are formatted assuming they're integers, and Decimals are formatted\r\n   * with 2 decimal places (in scientific notation if above 1000)\r\n   * @param {Number | Decimal} num  Number to format, disregarding current notation settings\r\n   * @returns {String}  The properly-formatted number, in a reasonable-looking format valid for the automator\r\n   */\r\n  format(num) {\r\n    if (typeof num === \"number\") return Math.round(num);\r\n    if (num.lte(1000)) return num.toNumber().toFixed(2);\r\n    return `${num.mantissa.toFixed(2)}e${num.exponent}`;\r\n  }\r\n\r\n  /**\r\n   * Parses tree data out of the parameter object and stores within the storedTree fields. Relevant props of object\r\n   * passed in:\r\n   * @param {String} params.treePreset      Name of a preset to load instead of a study tree, will override treeStudies\r\n   *  if present\r\n   * @param {Boolean} params.treeNowait     Whether or not the automator should pause at this line and repeat\r\n   *  until the whole tree is bought\r\n   * @param {String} params.treeStudies     A study import string to buy\r\n   */\r\n  storeTreeData(params) {\r\n    const nowaitStr = params.treeNowait ? \" nowait\" : \"\";\r\n    if (params.treePreset) {\r\n      const presetObj = player.timestudy.presets.map((p, i) => ({ ...p, id: i + 1 }))\r\n        .find(p => (p.name === params.treePreset || p.id === Number(params.treePreset)));\r\n      const preset = presetObj.name ? `name ${presetObj.name}` : `id ${presetObj.id}`;\r\n      this.storedTreeStr = `studies${nowaitStr} load ${preset}`;\r\n      this.storedTreeObj = new TimeStudyTree(presetObj.studies);\r\n    } else {\r\n      this.storedTreeStr = `studies${nowaitStr} purchase ${params.treeStudies}`;\r\n      this.storedTreeObj = new TimeStudyTree(params.treeStudies);\r\n    }\r\n    if (this.storedTreeObj.invalidStudies.length > 0) this.warnings.push(\"Tree contains invalid Study IDs\");\r\n    if (this.storedTreeObj.purchasedStudies.length < this.storedTreeObj.selectedStudies.length) {\r\n      this.warnings.push(\"Tree structure results in some unbought studies when imported with an empty tree\");\r\n      if (!params.treeNowait) this.warnings.push(`Automator may possibly get stuck with \"Keep buying Studies\" setting`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parses automator data out of a two-prop object storing autobuyer settings, into a suffix of automator code which\r\n   * sets the autobuyer to those settings. Relevant props of object passed in:\r\n   * @param {String} mode     \"mult\" or \"time\" for times highest and time modes, respectively\r\n   * @param {Decimal} value   Numerical value for autobuyer settings (assumed to be seconds in time)\r\n   * @returns {String}        String suffix to feed into an automator script, should be prefixed by \"auto [prestige] \"\r\n   */\r\n  parseAutobuyerProp(mode, value) {\r\n    switch (mode) {\r\n      case \"mult\":\r\n        return `${this.format(value)} x highest`;\r\n      case \"time\":\r\n        return `${this.format(value)} seconds`;\r\n      default:\r\n        throw new Error(`Unrecognized autobuyer mode ${mode} in automator script templates`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parses the parameter object into a script that sets the infinity and eternity autobuyers and then repeatedly loops\r\n   * buying a tree and eternitying until a target EP is reached. Relevant props of object passed in:\r\n   * @param {Boolean} params.treeNowait     Nowait param to be passed into storeTreeData()\r\n   * @param {String} params.treeStudies     Study import param to be passed into storeTreeData()\r\n   * @param {Decimal} params.finalEP        EP value at which to stop looping the script and continue onward\r\n   * @param {Object} params.autoInfMode     Multiplier or time-based mode for infinity autobuyer\r\n   * @param {Object} params.autoInfValue    Multiplier threshold or time for infinity autobuyer\r\n   * @param {Object} params.autoEterMode    Multiplier or time-based mode for eternity autobuyer\r\n   * @param {Object} params.autoEterValue   Multiplier threshold or time for eternity autobuyer\r\n   */\r\n  templateClimbEP(params) {\r\n    this.lines.push(\"// Template: Climb EP\");\r\n    this.lines.push(`notify \"Running Template Climb EP (to ${format(params.finalEP)})\"`);\r\n    this.storeTreeData(params);\r\n    this.lines.push(`auto infinity ${this.parseAutobuyerProp(params.autoInfMode, params.autoInfValue)}`);\r\n    this.lines.push(`auto eternity ${this.parseAutobuyerProp(params.autoEterMode, params.autoEterValue)}`);\r\n    this.lines.push(`while ep < ${this.format(params.finalEP)} {`);\r\n    this.lines.push(` ${this.storedTreeStr}`);\r\n    this.lines.push(\" studies respec\");\r\n    this.lines.push(\" wait eternity\");\r\n    this.lines.push(\"}\");\r\n  }\r\n\r\n  /**\r\n   * Parses the parameter object into a script that sets autobuyer settings and then repeatedly eternities until a\r\n   * target total eternity count is reached. Relevant props of object passed in:\r\n   * @param {Boolean} params.treeNowait           Nowait param to be passed into storeTreeData()\r\n   * @param {String} params.treeStudies           Study import param to be passed into storeTreeData()\r\n   * @param {Number} params.crunchesPerEternity   Number of crunches per eternity\r\n   * @param {Decimal} params.eternities           Eternity count at which to stop grinding and move on\r\n   */\r\n  templateGrindEternities(params) {\r\n    this.lines.push(\"// Template: Grind Eternities\");\r\n    this.lines.push(`notify \"Running Template Grind Eternities (to ${format(params.eternities)})\"`);\r\n    this.storeTreeData(params);\r\n    this.lines.push(this.storedTreeStr);\r\n    this.lines.push(\"auto eternity 0 ep\");\r\n    // We give it a bit of an extra \"safety factor\" of 5x in order to make sure it doesn't end up repeatedly going\r\n    // to something like 1.6e308 due to poor rounding. The startingValue may fluctuate based on achievements, but\r\n    // this can be a significant time save that we want to actually give the player if they have the e130 perk\r\n    const gapToEternity = Number.MAX_VALUE / Currency.infinityPoints.startingValue.toNumber() * 5;\r\n    this.lines.push(`auto infinity ${this.format(\r\n      Decimal.pow(gapToEternity, 1 / params.crunchesPerEternity))} x highest`);\r\n    this.lines.push(`wait eternities > ${this.format(params.eternities)}`);\r\n    this.lines.push(\"auto eternity off\");\r\n  }\r\n\r\n  /**\r\n   * Parses the parameter object into a script that sets autobuyer settings and then repeatedly infinities until a\r\n   * target total infinity or banked infinity count is reached. If threshold is banked infinities, assumes that the\r\n   * player also has the achievement that lets them bank. Relevant props of object passed in:\r\n   * @param {Boolean} params.treeNowait   Nowait param to be passed into storeTreeData()\r\n   * @param {String} params.treeStudies   Study import param to be passed into storeTreeData()\r\n   * @param {Decimal} params.infinities   Infinity count at which to stop grinding and move on\r\n   * @param {Boolean} params.isBanked     If the script should check for banked infinities instead of normal\r\n   *  infinities, calculating a modified threshold appropriately - we don't eternity repeatedly because this is\r\n   *  slower due to some resources needing to be rebuilt every eternity\r\n   */\r\n  templateGrindInfinities(params) {\r\n    this.lines.push(\"// Template: Grind Infinities\");\r\n    this.lines.push(`notify \"Running Template Grind Infinities (to ${format(params.infinities)})\"`);\r\n    this.storeTreeData(params);\r\n    this.lines.push(this.storedTreeStr);\r\n    this.lines.push(\"auto eternity off\");\r\n    this.lines.push(`auto infinity 5s`);\r\n    if (params.isBanked) {\r\n      const has191 = this.storedTreeObj.purchasedStudies.includes(TimeStudy(191));\r\n      if (!has191) this.warnings.push(`TS191 is not reachable from an empty tree; banking anything in this template\r\n        will require Achievement \"${Achievement(131).name}\"`);\r\n      const bankRate = has191 ? 0.1 : 0.05;\r\n      this.lines.push(\"// Note: This template attempts to get all the Banked Infinities within a single Eternity\");\r\n      this.lines.push(`wait infinities > ${this.format(params.infinities.dividedBy(bankRate), 2)}`);\r\n      this.lines.push(\"eternity\");\r\n    } else {\r\n      this.lines.push(`wait infinities > ${this.format(params.infinities, 2)}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parses the parameter object into a script that respecs into a specified tree, unlocks a specified EC, changes\r\n   * autobuyer settings, and then waits until the EC can be completed before triggering an eternity through the\r\n   * automator. Relevant props of object passed in:\r\n   * @param {Boolean} params.treeNowait     Nowait param to be passed into storeTreeData()\r\n   * @param {String} params.treeStudies     Study import param to be passed into storeTreeData()\r\n   * @param {Number} params.ec              Numerical value denoting the EC to attempt\r\n   * @param {Number} params.completions     Minimum number of completions to wait for before moving onward\r\n   * @param {Object} params.autoInfMode     Multiplier or time-based mode for infinity autobuyer\r\n   * @param {Object} params.autoInfValue    Multiplier threshold or time for infinity autobuyer\r\n   */\r\n  templateDoEC(params) {\r\n    this.lines.push(\"// Template: Complete Eternity Challenge\");\r\n    this.lines.push(`notify \"Running Template Complete Eternity Challenge (EC${params.ec})\"`);\r\n    // Force an eternity in order to buy the study tree first\r\n    this.lines.push(\"eternity respec\");\r\n\r\n    // Import the tree and the EC study, supplying errors as appropriate\r\n    this.storeTreeData(params);\r\n    this.lines.push(this.storedTreeStr);\r\n    const tree = this.storedTreeObj;\r\n    if (tree.ec === 0) {\r\n      this.lines.push(`unlock ec ${params.ec}`);\r\n      // Attempt to buy it, supplying an error if we can't actually reach it\r\n      if (!tree.hasRequirements(TimeStudy.eternityChallenge(params.ec), true)) {\r\n        this.warnings.push(\"Specified Study Tree cannot reach specified EC\");\r\n      }\r\n    } else if (tree.ec !== params.ec) this.warnings.push(\"Specified Study Tree already has a different EC unlocked\");\r\n\r\n    // Apply autobuyer settings; we specifically want to turn auto-eternity off so that we can manually trigger the\r\n    // prestige - otherwise, the autobuyer may end up preempting multiple completions\r\n    this.lines.push(`auto infinity ${this.parseAutobuyerProp(params.autoInfMode, params.autoInfValue)}`);\r\n    this.lines.push(`auto eternity off`);\r\n    if (!TimeStudy.eternityChallenge(params.ec)) this.warnings.push(`Specified template EC does not exist`);\r\n    this.lines.push(`start ec ${params.ec}`);\r\n\r\n    if (params.completions > 5) this.warnings.push(`ECs cannot be completed more than ${formatInt(5)} times`);\r\n    this.lines.push(`wait pending completions >= ${params.completions}`);\r\n    this.lines.push(\"eternity\");\r\n  }\r\n\r\n  /**\r\n   * Parses the parameter object into a script that sets autobuyer settings and then repeatedly infinities until a\r\n   * target total infinity or banked infinity count is reached. Makes some assumptions on bank rate. Relevant props\r\n   * of object passed in:\r\n   * @param {Boolean} params.treeNowait     Nowait param to be passed into storeTreeData()\r\n   * @param {String} params.treeStudies     Study import param to be passed into storeTreeData()\r\n   * @param {Object} params.autoEterMode    Multiplier or time-based mode for eternity autobuyer\r\n   * @param {Object} params.autoEterValue   Multiplier threshold or time for eternity autobuyer\r\n   */\r\n  templateUnlockDilation(params) {\r\n    this.lines.push(\"// Template: Unlock Dilation\");\r\n    this.lines.push(`notify \"Running Template Unlock Dilation\"`);\r\n    this.storeTreeData(params);\r\n    if (![231, 232, 233, 234].some(s => this.storedTreeObj.purchasedStudies.includes(TimeStudy(s)))) {\r\n      this.warnings.push(\"Specified Study Tree cannot reach Dilation\");\r\n    }\r\n    this.lines.push(`auto infinity off`);\r\n    this.lines.push(`auto eternity ${this.parseAutobuyerProp(params.autoEterMode, params.autoEterValue)}`);\r\n    this.lines.push(`while total tt < ${this.format(TimeStudy.dilation.totalTimeTheoremRequirement)} {`);\r\n    this.lines.push(` ${this.storedTreeStr}`);\r\n    this.lines.push(\" studies respec\");\r\n    this.lines.push(\" wait eternity\");\r\n    this.lines.push(\"}\");\r\n    this.lines.push(\"unlock dilation\");\r\n  }\r\n\r\n  get script() {\r\n    return this.lines.join(\"\\n\");\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}