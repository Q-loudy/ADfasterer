{"ast":null,"code":"import \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport { GlyphInfo } from \"../../src/components/modals/options/SelectGlyphInfoDropdown\";\nimport GlyphTooltip from \"@/components/GlyphTooltip\"; // We generate the border effects with CSS gradients; for the sake of flexibility and for dynamically using\n// the glyph color instead of the fixed rarity color, the border patterns are stored below and then parsed\n// into the relevant CSS on a per-glyph basis\n\nconst rarityBorderStyles = {\n  common: [],\n  uncommon: [{\n    lineType: \"linear\",\n    angles: [45],\n    colorSplit: [14, 16, 84, 86]\n  }],\n  rare: [{\n    lineType: \"linear\",\n    angles: [45, 135],\n    colorSplit: [14, 16, 84, 86]\n  }],\n  epic: [{\n    lineType: \"linear\",\n    angles: [45, 135],\n    colorSplit: [12, 14, 16, 18, 82, 84, 86, 88]\n  }],\n  legendary: [{\n    lineType: \"bump\",\n    colorSplit: [15, 25]\n  }],\n  mythical: [{\n    lineType: \"bump\",\n    colorSplit: [15, 25]\n  }, {\n    lineType: \"linear\",\n    angles: [45, 135],\n    colorSplit: [10, 13, 87, 90]\n  }],\n  transcendent: [{\n    lineType: \"bump\",\n    colorSplit: [15, 35]\n  }, {\n    lineType: \"linear\",\n    angles: [45, 135],\n    colorSplit: [10, 12, 14, 16, 84, 86, 88, 90]\n  }],\n  celestial: [{\n    lineType: \"bump\",\n    colorSplit: [15, 35]\n  }, {\n    lineType: \"radial\",\n    colorSplit: [65, 85]\n  }],\n  cursed: [{\n    lineType: \"spike\",\n    center: [40, 40],\n    angles: [305, 325]\n  }, {\n    lineType: \"spike\",\n    center: [60, 40],\n    angles: [35, 55]\n  }, {\n    lineType: \"spike\",\n    center: [60, 60],\n    angles: [125, 145]\n  }, {\n    lineType: \"spike\",\n    center: [40, 60],\n    angles: [215, 235]\n  }],\n  companion: [{\n    lineType: \"companion\"\n  }]\n}; // This function does all the parsing of the above gradient specifications\n// eslint-disable-next-line max-params\n\nfunction generateGradient(data, color, glyph, isCircular) {\n  // The undefined declarations here are mostly to make ESLint happy, and aren't necessarily used in all cases\n  let borders,\n      scaleFn,\n      centers,\n      specialData,\n      isColor = false;\n  const entries = [],\n        elements = [];\n\n  switch (data.lineType) {\n    case \"linear\":\n      // Produces stripes at the specified angle, where color sharply switches between the specified color and\n      // transparent at each percentage in lines\n      borders = [0, ...data.colorSplit, 100];\n\n      scaleFn = perc => isCircular ? 50 + 0.7 * (perc - 50) : perc;\n\n      for (const angle of data.angles) {\n        for (let i = 0; i < borders.length - 1; i++) {\n          entries.push(`${isColor ? color : \"transparent\"} ${scaleFn(borders[i])}% ${scaleFn(borders[i + 1])}%`);\n          isColor = !isColor;\n        }\n\n        elements.push(`repeating-linear-gradient(${angle}deg, ${entries.join(\",\")})`);\n      }\n\n      return elements.join(\",\");\n\n    case \"bump\":\n      // Produces four bumps on the cardinal directions of the glyph border, with specified color fade distances.\n      // These bumps overlap some dots on effarig glyphs, so we conditionally make them more transparent (effectively\n      // shrinking them so they don't overlap)\n      specialData = glyph.type === \"effarig\" ? `${color}60` : color;\n      centers = [\"50% -25%\", \"50% 125%\", \"-25% 50%\", \"125% 50%\"];\n\n      scaleFn = perc => isCircular ? perc : 0.9 * perc;\n\n      for (let i = 0; i < 4; i++) {\n        entries.push(`radial-gradient(at ${centers[i]}, transparent, ${specialData} ${scaleFn(data.colorSplit[0])}%,\n          transparent ${scaleFn(data.colorSplit[1])}%)`);\n      }\n\n      return entries.join(\",\");\n\n    case \"radial\":\n      // Produces a centered circle that only shades within a certain radial distance\n      borders = [50, ...data.colorSplit, 100];\n\n      scaleFn = perc => isCircular ? 0.9 * perc : 100 - (100 - perc) / 2;\n\n      for (const border of borders) {\n        entries.push(`${isColor ? color : \"transparent\"} ${scaleFn(border)}%`);\n        isColor = !isColor;\n      }\n\n      return `radial-gradient(${entries.join(\",\")})`;\n\n    case \"spike\":\n      // Produces a single spike at the specified center, spanning between the specified angles with 5deg blur\n      entries.push(`transparent ${data.angles[0] - 5}deg`);\n      entries.push(`${color}b0 ${data.angles[0] + 5}deg`);\n      entries.push(`${color}b0 ${data.angles[1] - 5}deg`);\n      entries.push(`transparent ${data.angles[1] + 5}deg`);\n      return `conic-gradient(from 0deg at ${data.center[0]}% ${data.center[1]}%, ${entries.join(\",\")})`;\n\n    case \"companion\":\n      // Special case to make the companion border look like a heart\n      borders = [0, 30, 330, 360];\n      specialData = [color, \"transparent\", \"transparent\", color];\n\n      for (let i = 0; i < 4; i++) {\n        entries.push(`${specialData[i]} ${borders[i]}deg`);\n      }\n\n      elements.push(`conic-gradient(${entries.join(\",\")})`);\n      centers = [\"125% 125%\", \"-25% 125%\"];\n\n      scaleFn = perc => isCircular ? 0.9 * (perc + 10) : perc;\n\n      for (let i = 0; i < 2; i++) {\n        elements.push(`radial-gradient(at ${centers[i]}, transparent, ${color} ${scaleFn(30)}%,\n          transparent ${scaleFn(50)}%)`);\n      }\n\n      return elements.join(\",\");\n\n    default:\n      throw new Error(\"Unrecognized glyph border data\");\n  }\n}\n\nexport default {\n  name: \"GlyphComponent\",\n  components: {\n    GlyphTooltip\n  },\n  props: {\n    glyph: {\n      type: Object,\n      required: true\n    },\n    isInModal: {\n      type: Boolean,\n      required: false,\n      default: false\n    },\n    isNew: {\n      type: Boolean,\n      required: false,\n      default: false\n    },\n    isUnequipped: {\n      type: Boolean,\n      required: false,\n      default: false\n    },\n    showSacrifice: {\n      type: Boolean,\n      required: false,\n      default: false\n    },\n    ignoreModifiedLevel: {\n      type: Boolean,\n      required: false,\n      default: false\n    },\n    realityGlyphBoost: {\n      type: Number,\n      required: false,\n      default: 0\n    },\n    isInventoryGlyph: {\n      type: Boolean,\n      required: false,\n      default: false\n    },\n    isActiveGlyph: {\n      type: Boolean,\n      required: false,\n      default: false\n    },\n    size: {\n      type: String,\n      required: false,\n      default: \"5rem\"\n    },\n    glowBlur: {\n      type: String,\n      required: false,\n      default: \"1rem\"\n    },\n    glowSpread: {\n      type: String,\n      required: false,\n      default: \"0.2rem\"\n    },\n    bottomPadding: {\n      type: String,\n      required: false,\n      default: \"0.3rem\"\n    },\n    textProportion: {\n      type: Number,\n      required: false,\n      default: 0.5\n    },\n    circular: {\n      type: Boolean,\n      required: false,\n      default: false\n    },\n    draggable: {\n      type: Boolean,\n      required: false,\n      default: false\n    },\n    flipTooltip: {\n      type: Boolean,\n      required: false,\n      default: false\n    }\n  },\n\n  data() {\n    return {\n      componentID: UIID.next(),\n      isDragging: false,\n      // This flag is used to prevent the tooltip from being shown in some touch event sequences\n      suppressTooltip: false,\n      isTouched: false,\n      tooltipEnabled: false,\n      sacrificeReward: 0,\n      uncappedRefineReward: 0,\n      refineReward: 0,\n      displayLevel: 0,\n      // We use this to not create a ton of tooltip components as soon as the glyph tab loads.\n      tooltipLoaded: false,\n      logTotalSacrifice: 0,\n      realityColor: \"\"\n    };\n  },\n\n  computed: {\n    hasTooltip() {\n      return Boolean(this.glyph.effects);\n    },\n\n    typeConfig() {\n      return GlyphTypes[this.glyph.type];\n    },\n\n    cosmeticConfig() {\n      var _this$glyph$cosmetic;\n\n      return CosmeticGlyphTypes[(_this$glyph$cosmetic = this.glyph.cosmetic) !== null && _this$glyph$cosmetic !== void 0 ? _this$glyph$cosmetic : this.glyph.type];\n    },\n\n    isBlobHeart() {\n      return this.$viewModel.theme === \"S11\" && this.glyph.type === \"companion\";\n    },\n\n    symbol() {\n      const symbol = this.glyph.symbol; // \\uE019 = :blobheart:\n\n      if (this.isBlobHeart) return \"\\uE019\";\n      if (symbol) return symbol;\n      return this.$viewModel.theme === \"S4\" && !this.glyph.cosmetic ? CANCER_GLYPH_SYMBOLS[this.glyph.type] : this.cosmeticConfig.currentSymbol.symbol;\n    },\n\n    symbolBlur() {\n      if (this.isBlobHeart) return false;\n      if (!this.glyph.symbol) return this.cosmeticConfig.currentSymbol.blur;\n      return !GlyphAppearanceHandler.unblurredSymbols.includes(this.symbol);\n    },\n\n    zIndexStyle() {\n      return {\n        \"z-index\": this.isInModal ? 7 : 6\n      };\n    },\n\n    colorObj() {\n      var _overrideColor$border, _overrideColor, _overrideColor$border2, _overrideColor2, _overrideColor$bg, _overrideColor3;\n\n      let overrideColor;\n      if (this.glyph.color) overrideColor = GlyphAppearanceHandler.getColorProps(this.glyph.color);\n\n      if (this.glyph.cosmetic) {\n        if (this.glyph.cosmetic === this.glyph.type) {\n          overrideColor = this.glyph.type === \"cursed\" ? GlyphAppearanceHandler.getBaseColor(true) : this.cosmeticConfig.currentColor;\n        } else {\n          overrideColor = this.cosmeticConfig.currentColor;\n        }\n      }\n\n      let symbolColor;\n      if (this.isRealityGlyph && this.realityColor) symbolColor = this.realityColor;else {\n        symbolColor = this.cosmeticConfig.ignoreRarityColor ? GlyphAppearanceHandler.getBorderColor(this.glyph.type) : GlyphAppearanceHandler.getRarityColor(this.glyph.strength, this.glyph.type);\n      }\n      return {\n        border: (_overrideColor$border = (_overrideColor = overrideColor) === null || _overrideColor === void 0 ? void 0 : _overrideColor.border) !== null && _overrideColor$border !== void 0 ? _overrideColor$border : GlyphAppearanceHandler.getBorderColor(this.glyph.type),\n        symbol: (_overrideColor$border2 = (_overrideColor2 = overrideColor) === null || _overrideColor2 === void 0 ? void 0 : _overrideColor2.border) !== null && _overrideColor$border2 !== void 0 ? _overrideColor$border2 : symbolColor,\n        bg: (_overrideColor$bg = (_overrideColor3 = overrideColor) === null || _overrideColor3 === void 0 ? void 0 : _overrideColor3.bg) !== null && _overrideColor$bg !== void 0 ? _overrideColor$bg : this.cosmeticConfig.currentColor.bg\n      };\n    },\n\n    symbolColor() {\n      return player.options.swapGlyphColors ? this.colorObj.border : this.colorObj.symbol;\n    },\n\n    borderColor() {\n      return player.options.swapGlyphColors ? this.colorObj.symbol : this.colorObj.border;\n    },\n\n    bgColor() {\n      return this.colorObj.bg;\n    },\n\n    overStyle() {\n      return {\n        width: this.size,\n        height: this.size,\n        position: \"absolute\",\n        \"background-color\": \"rgba(0, 0, 0, 0)\",\n        \"box-shadow\": `0 0 ${this.glowBlur} calc(${this.glowSpread} + 0.1rem) ${this.borderColor} inset`,\n        \"border-radius\": this.circular ? \"50%\" : \"0\"\n      };\n    },\n\n    outerStyle() {\n      return {\n        width: this.size,\n        height: this.size,\n        \"background-color\": this.borderColor,\n        \"box-shadow\": `0 0 ${this.glowBlur} ${this.glowSpread} ${this.borderColor}`,\n        \"border-radius\": this.circular ? \"50%\" : \"0\",\n        \"-webkit-user-drag\": this.draggable ? \"\" : \"none\"\n      };\n    },\n\n    innerStyle() {\n      const color = this.symbolColor;\n      return {\n        width: `calc(${this.size} - 0.2rem)`,\n        height: `calc(${this.size} - 0.2rem)`,\n        \"font-size\": `calc( ${this.size} * ${this.textProportion} )`,\n        color,\n        \"text-shadow\": this.symbolBlur ? `-0.04em 0.04em 0.08em ${color}` : undefined,\n        \"border-radius\": this.circular ? \"50%\" : \"0\",\n        \"padding-bottom\": this.bottomPadding,\n        background: this.bgColor\n      };\n    },\n\n    mouseEventHandlers() {\n      const handlers = this.hasTooltip ? {\n        mouseenter: this.mouseEnter,\n        \"&mousemove\": this.mouseMove,\n        mouseleave: this.mouseLeave,\n        mousedown: this.mouseDown,\n        touchstart: this.touchStart,\n        touchend: this.touchEnd\n      } : {};\n\n      if (this.hasTooltip || this.draggable) {\n        handlers.touchmove = this.touchMove;\n      }\n\n      return handlers;\n    },\n\n    isCurrentTooltip() {\n      return this.$viewModel.tabs.reality.currentGlyphTooltip === this.componentID;\n    },\n\n    tooltipDirectionClass() {\n      let directionID = this.$viewModel.tabs.reality.glyphTooltipDirection;\n      if (this.flipTooltip) directionID += 1;\n\n      switch (directionID) {\n        case -1:\n          return \"l-glyph-tooltip--down-left\";\n\n        case 0:\n          return \"l-glyph-tooltip--down-right\";\n\n        case 1:\n          return \"l-glyph-tooltip--up-left\";\n\n        case 2:\n          return \"l-glyph-tooltip--up-right\";\n\n        default:\n          return \"\";\n      }\n    },\n\n    // This finds all the effects of a glyph and shifts all their IDs so that type's lowest-ID effect is 0 and all\n    // other effects count up to 3 (or 6 for effarig). Used to add dots in unique positions on glyphs to show effects.\n    glyphEffects() {\n      let minEffectID = 0;\n\n      switch (this.glyph.type) {\n        case \"time\":\n        case \"cursed\":\n        case \"companion\":\n          minEffectID = 0;\n          break;\n\n        case \"dilation\":\n        case \"reality\":\n          minEffectID = 4;\n          break;\n\n        case \"replication\":\n          minEffectID = 8;\n          break;\n\n        case \"infinity\":\n          minEffectID = 12;\n          break;\n\n        case \"power\":\n          minEffectID = 16;\n          break;\n\n        case \"effarig\":\n          minEffectID = 20;\n          break;\n\n        default:\n          throw new Error(`Unrecognized glyph type \"${this.glyph.type}\" in glyph effect icons`);\n      }\n\n      const effectIDs = [];\n      let remainingEffects = this.glyph.effects >> minEffectID;\n\n      for (let id = 0; remainingEffects > 0; id++) {\n        if ((remainingEffects & 1) === 1) effectIDs.push(id);\n        remainingEffects >>= 1;\n      }\n\n      return effectIDs;\n    },\n\n    isRealityGlyph() {\n      return this.glyph.type === \"reality\";\n    },\n\n    isCursedGlyph() {\n      return this.glyph.type === \"cursed\";\n    },\n\n    isCompanionGlyph() {\n      return this.glyph.type === \"companion\";\n    },\n\n    showGlyphEffectDots() {\n      return player.options.showHintText.glyphEffectDots;\n    },\n\n    displayedInfo() {\n      const blacklist = [\"companion\", \"cursed\"];\n      if (!this.isInventoryGlyph || blacklist.includes(this.glyph.type)) return null;\n      const options = player.options.showHintText;\n\n      if (options.glyphInfoType === GlyphInfo.types.NONE || !options.showGlyphInfoByDefault && !this.$viewModel.shiftDown) {\n        return null;\n      }\n\n      const typeEnum = GlyphInfo.types;\n\n      switch (options.glyphInfoType) {\n        case typeEnum.LEVEL:\n          this.updateDisplayLevel();\n          return formatInt(this.displayLevel === 0 ? this.glyph.level : this.displayLevel);\n\n        case typeEnum.RARITY:\n          return formatRarity(strengthToRarity(Pelle.isDoomed ? Pelle.glyphStrength : this.glyph.strength));\n\n        case typeEnum.SAC_VALUE:\n          return format(this.sacrificeReward, 2, 2);\n\n        case typeEnum.FILTER_SCORE:\n          return format(AutoGlyphProcessor.filterValue(this.glyph), 1, 1);\n\n        case typeEnum.CURRENT_REFINE:\n          return `${format(this.refineReward, 2, 2)} ${this.symbol}`;\n\n        case typeEnum.MAX_REFINE:\n          return `${format(this.uncappedRefineReward, 2, 2)} ${this.symbol}`;\n\n        default:\n          throw new Error(\"Unrecognized Glyph info type in info text\");\n      }\n    },\n\n    showBorders() {\n      return player.options.glyphBorders;\n    }\n\n  },\n  watch: {\n    logTotalSacrifice() {\n      this.tooltipLoaded = false;\n      if (this.isCurrentTooltip) this.showTooltip();\n    }\n\n  },\n\n  created() {\n    this.on$(GAME_EVENT.GLYPH_VISUAL_CHANGE, () => {\n      this.$recompute(\"typeConfig\");\n      this.$recompute(\"cosmeticConfig\");\n      this.$recompute(\"innerStyle\");\n      this.$recompute(\"overrideColor\");\n      this.$recompute(\"showGlyphEffectDots\");\n      this.$recompute(\"displayedInfo\");\n      this.$recompute(\"showBorders\");\n    });\n    this.on$(\"tooltip-touched\", () => this.hideTooltip());\n    this.on$(GAME_EVENT.TAB_CHANGED, () => this.hideTooltip()); // There are a few situations where a tooltip could attempt to render immediately upon component creation,\n    // which causes it to be placed in an odd \"default\" corner spot due to mouse position not being set properly.\n    // This is essentially a hack that force-suppresses tooltips from being shown in strange spots due to on-load\n    // events firing, but has the side effect that the mouse must leave and enter an element which was created\n    // underneath it in order to make the tooltip appear\n\n    setTimeout(() => this.tooltipEnabled = true, 10);\n  },\n\n  beforeDestroy() {\n    if (this.isCurrentTooltip) this.hideTooltip();\n    if (this.$viewModel.draggingUIID === this.componentID) this.$viewModel.draggingUIID = -1;\n  },\n\n  methods: {\n    update() {\n      this.logTotalSacrifice = GameCache.logTotalGlyphSacrifice.value; // This needs to be reactive in order to animate while using our low-lag workaround, but we also need to make\n      // sure it only animates when that color is actually active\n\n      this.realityColor = player.reality.glyphs.cosmetics.colorMap.reality ? null : GlyphAppearanceHandler.realityColor;\n      this.sacrificeReward = GlyphSacrificeHandler.glyphSacrificeGain(this.glyph);\n      this.uncappedRefineReward = ALCHEMY_BASIC_GLYPH_TYPES.includes(this.glyph.type) ? GlyphSacrificeHandler.glyphRawRefinementGain(this.glyph) : 0;\n      this.refineReward = ALCHEMY_BASIC_GLYPH_TYPES.includes(this.glyph.type) ? GlyphSacrificeHandler.glyphRefinementGain(this.glyph) : 0;\n      if (this.tooltipLoaded) this.updateDisplayLevel();\n    },\n\n    updateDisplayLevel() {\n      if (this.ignoreModifiedLevel) {\n        this.displayLevel = 0;\n        return;\n      } // We have to consider some odd interactions in order to properly show level. The getAdjustedGlyphLevel() function\n      // returns a modified level using celestial effects and reality glyphs based on the CURRENT game state, meaning\n      // that applying this globally will cause lots of glyphs to show altered levels even if they shouldn't. So:\n      // - Active glyphs should apply ALL adjusted effects based on the current game state, since they are guaranteed\n      //   to always be affected by them and this is exactly the purpose of getAdjustedGlyphLevel() as-is\n      // - Inventory glyphs should show the same current-state effects as active, but it should NEVER apply reality\n      //   glyph boosts. This allows for easier comparison when celestial effects are changing both active and\n      //   inventory glyphs, even though strictly speaking the inventory ones shouldn't be affected until equipped\n      // - All other glyphs should never apply effects from the current game state, and should in fact only apply the\n      //   reality glyph boost based on the rest of its existing set (which is passed in via realityGlyphBoost) and\n      //   nothing else. This case applies to glyphs appearing in presets, records, and previews.\n\n\n      if (this.isActiveGlyph) this.displayLevel = getAdjustedGlyphLevel(this.glyph);else if (this.isInventoryGlyph) this.displayLevel = getAdjustedGlyphLevel(this.glyph, 0);else {\n        this.displayLevel = this.glyph.level + (BASIC_GLYPH_TYPES.includes(this.glyph.type) ? this.realityGlyphBoost : 0);\n      }\n    },\n\n    hideTooltip() {\n      this.tooltipLoaded = false;\n      this.$viewModel.tabs.reality.mouseoverGlyphInfo.type = \"\";\n      this.$viewModel.tabs.reality.mouseoverGlyphInfo.inInventory = false;\n      this.$viewModel.tabs.reality.currentGlyphTooltip = -1;\n    },\n\n    showTooltip() {\n      if (!this.tooltipEnabled) return;\n      Glyphs.removeVisualFlag(\"unseen\", this.glyph);\n      Glyphs.removeVisualFlag(\"unequipped\", this.glyph);\n      this.tooltipLoaded = true;\n      this.$viewModel.tabs.reality.mouseoverGlyphInfo.inInventory = !this.circular;\n      const glyphInfo = this.$viewModel.tabs.reality.mouseoverGlyphInfo;\n      glyphInfo.type = this.glyph.type;\n      glyphInfo.sacrificeValue = GlyphSacrificeHandler.glyphSacrificeGain(this.glyph);\n      glyphInfo.refineValue = GlyphSacrificeHandler.glyphRawRefinementGain(this.glyph);\n      this.$viewModel.tabs.reality.currentGlyphTooltip = this.componentID;\n\n      if (AutoGlyphProcessor.sacMode === AUTO_GLYPH_REJECT.SACRIFICE || AutoGlyphProcessor.sacMode === AUTO_GLYPH_REJECT.REFINE_TO_CAP && this.refineReward === 0) {\n        this.currentAction = \"sacrifice\";\n      } else {\n        this.currentAction = \"refine\";\n      }\n\n      this.scoreMode = AutoGlyphProcessor.scoreMode;\n    },\n\n    moveTooltipTo(x, y) {\n      // If we are just creating the tooltip now, we can't move it yet.\n      if (!this.$refs.tooltip) return;\n      const tooltipEl = this.$refs.tooltip.$el;\n\n      if (tooltipEl) {\n        const rect = document.body.getBoundingClientRect();\n        tooltipEl.style.left = `${x - rect.left}px`;\n        tooltipEl.style.top = `${y - rect.top}px`;\n\n        if (this.$viewModel.tabs.reality.glyphTooltipDirection === 1) {\n          // In case of a really short screen, don't flicker back and forth\n          if (y - tooltipEl.offsetHeight <= 0 && y + tooltipEl.offsetHeight < rect.height) {\n            this.$viewModel.tabs.reality.glyphTooltipDirection = -1;\n          }\n        } else if (y + tooltipEl.offsetHeight >= rect.height) {\n          this.$viewModel.tabs.reality.glyphTooltipDirection = 1;\n        }\n      }\n    },\n\n    mouseEnter(ev) {\n      if (this.$viewModel.draggingUIID !== -1) return;\n      this.moveTooltipTo(ev.clientX, ev.clientY);\n      this.showTooltip();\n    },\n\n    mouseLeave() {\n      if (this.isCurrentTooltip) {\n        this.hideTooltip();\n      }\n    },\n\n    mouseDown() {\n      if (this.isTouched) return;\n      this.hideTooltip();\n    },\n\n    mouseMove(ev) {\n      if (this.isTouched) return;\n      this.moveTooltipTo(ev.clientX, ev.clientY);\n    },\n\n    dragStart(ev) {\n      this.hideTooltip();\n      this.isDragging = true;\n      this.suppressTooltip = true;\n      ev.dataTransfer.setData(GLYPH_MIME_TYPE, this.glyph.id.toString());\n      ev.dataTransfer.dropEffect = \"move\";\n      const rect = this.$refs.over.getBoundingClientRect();\n      ev.dataTransfer.setDragImage(this.$refs.over, ev.clientX - rect.left, ev.clientY - rect.top);\n      this.$viewModel.draggingUIID = this.componentID;\n      const dragInfo = this.$viewModel.tabs.reality.draggingGlyphInfo;\n      dragInfo.id = this.glyph.id;\n      dragInfo.type = this.glyph.type;\n      dragInfo.sacrificeValue = GlyphSacrificeHandler.glyphSacrificeGain(this.glyph);\n    },\n\n    dragEnd() {\n      this.isDragging = false;\n      this.suppressTooltip = false;\n      this.$viewModel.scrollWindow = 0;\n      const dragInfo = this.$viewModel.tabs.reality.draggingGlyphInfo;\n      dragInfo.id = -1;\n      dragInfo.type = \"\";\n      if (this.$viewModel.draggingUIID === this.componentID) this.$viewModel.draggingUIID = -1;\n    },\n\n    drag(ev) {\n      // It looks like dragging off the bottom of the window sometimes fires these\n      // odd events\n      if (ev.screenX === 0 && ev.screenY === 0) {\n        this.$viewModel.scrollWindow = 0;\n        return;\n      }\n\n      const boundary = 100;\n\n      if (ev.clientY < boundary) {\n        this.$viewModel.scrollWindow = -1 + 0.9 * ev.clientY / boundary;\n      } else if (ev.clientY > window.innerHeight - boundary) {\n        this.$viewModel.scrollWindow = 1 - 0.9 * (window.innerHeight - ev.clientY) / boundary;\n      } else {\n        this.$viewModel.scrollWindow = 0;\n      }\n    },\n\n    touchStart() {\n      this.isTouched = true;\n    },\n\n    touchEnd(e) {\n      if (this.isCurrentTooltip) {\n        e.preventDefault();\n        this.hideTooltip();\n      } else if (!this.suppressTooltip) {\n        e.preventDefault();\n        this.showTooltip();\n        this.moveTooltipTo(e.changedTouches[0].clientX, e.changedTouches[0].clientY);\n      }\n\n      this.suppressTooltip = false;\n      this.isTouched = false;\n    },\n\n    touchMove(e) {\n      const t = e.changedTouches[0];\n      const r = this.$refs.over.getBoundingClientRect();\n\n      if (t.clientX < r.left || t.clientY < r.top || t.clientX > r.left + r.width || t.clientY > r.top + r.height) {\n        this.suppressTooltip = true;\n      }\n\n      if (this.isDragging) {\n        // DragDropTouch doesn't seem to send drag events.\n        this.drag(t);\n      }\n    },\n\n    // Translates 0...3 into equally-spaced coordinates around a circle 90deg apart (0...6 and 45deg for effarig)\n    effectIconPos(id) {\n      // Place dots clockwise starting from the bottom left\n      const angle = this.glyph.type === \"effarig\" ? Math.PI / 4 * (id + 1) : Math.PI / 2 * (id + 0.5);\n      const scale = 0.28 * this.size.replace(\"rem\", \"\");\n      const dx = -scale * Math.sin(angle);\n      const dy = scale * (Math.cos(angle) + 0.15);\n      return {\n        dx,\n        dy\n      };\n    },\n\n    glyphEffectDots(id) {\n      if ([\"companion\", \"cursed\"].includes(this.glyph.type)) return {};\n      const pos = this.effectIconPos(id);\n      return {\n        position: \"absolute\",\n        width: \"0.3rem\",\n        height: \"0.3rem\",\n        \"border-radius\": \"50%\",\n        background: this.symbolColor,\n        transform: `translate(${pos.dx - 0.15 * 0.3}rem, ${pos.dy - 0.15 * 0.3}rem)`,\n        opacity: Theme.current().name === \"S9\" ? 0 : 0.8\n      };\n    },\n\n    glyphBorderStyle() {\n      if (!this.showBorders) return null;\n      let borderAttrs;\n      if (this.isCursedGlyph) borderAttrs = rarityBorderStyles.cursed;else if (this.isCompanionGlyph) borderAttrs = rarityBorderStyles.companion;else borderAttrs = rarityBorderStyles[getRarity(this.glyph.strength).name.toLowerCase()];\n      const lines = borderAttrs.map(attr => generateGradient(attr, this.borderColor, this.glyph, this.circular));\n      return {\n        position: \"absolute\",\n        left: \"2%\",\n        width: \"96%\",\n        height: \"96%\",\n        \"border-radius\": this.circular ? \"50%\" : \"0\",\n        // Some cases will have undefined lines which need to be removed to combine everything together properly\n        background: lines.filter(l => l).join(\",\")\n      };\n    }\n\n  }\n};","map":{"version":3,"sources":["GlyphComponent.vue"],"names":[],"mappings":"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","sourcesContent":["<script>\r\nimport { GlyphInfo } from \"../../src/components/modals/options/SelectGlyphInfoDropdown\";\r\n\r\nimport GlyphTooltip from \"@/components/GlyphTooltip\";\r\n\r\n// We generate the border effects with CSS gradients; for the sake of flexibility and for dynamically using\r\n// the glyph color instead of the fixed rarity color, the border patterns are stored below and then parsed\r\n// into the relevant CSS on a per-glyph basis\r\nconst rarityBorderStyles = {\r\n  common: [],\r\n  uncommon: [\r\n    {\r\n      lineType: \"linear\",\r\n      angles: [45],\r\n      colorSplit: [14, 16, 84, 86],\r\n    }\r\n  ],\r\n  rare: [\r\n    {\r\n      lineType: \"linear\",\r\n      angles: [45, 135],\r\n      colorSplit: [14, 16, 84, 86],\r\n    }\r\n  ],\r\n  epic: [\r\n    {\r\n      lineType: \"linear\",\r\n      angles: [45, 135],\r\n      colorSplit: [12, 14, 16, 18, 82, 84, 86, 88],\r\n    }\r\n  ],\r\n  legendary: [\r\n    {\r\n      lineType: \"bump\",\r\n      colorSplit: [15, 25],\r\n    }\r\n  ],\r\n  mythical: [\r\n    {\r\n      lineType: \"bump\",\r\n      colorSplit: [15, 25],\r\n    },\r\n    {\r\n      lineType: \"linear\",\r\n      angles: [45, 135],\r\n      colorSplit: [10, 13, 87, 90],\r\n    }\r\n  ],\r\n  transcendent: [\r\n    {\r\n      lineType: \"bump\",\r\n      colorSplit: [15, 35],\r\n    },\r\n    {\r\n      lineType: \"linear\",\r\n      angles: [45, 135],\r\n      colorSplit: [10, 12, 14, 16, 84, 86, 88, 90],\r\n    }\r\n  ],\r\n  celestial: [\r\n    {\r\n      lineType: \"bump\",\r\n      colorSplit: [15, 35],\r\n    },\r\n    {\r\n      lineType: \"radial\",\r\n      colorSplit: [65, 85],\r\n    },\r\n  ],\r\n  cursed: [\r\n    {\r\n      lineType: \"spike\",\r\n      center: [40, 40],\r\n      angles: [305, 325],\r\n    },\r\n    {\r\n      lineType: \"spike\",\r\n      center: [60, 40],\r\n      angles: [35, 55],\r\n    },\r\n    {\r\n      lineType: \"spike\",\r\n      center: [60, 60],\r\n      angles: [125, 145],\r\n    },\r\n    {\r\n      lineType: \"spike\",\r\n      center: [40, 60],\r\n      angles: [215, 235],\r\n    },\r\n  ],\r\n  companion: [\r\n    {\r\n      lineType: \"companion\",\r\n    },\r\n  ]\r\n};\r\n\r\n// This function does all the parsing of the above gradient specifications\r\n// eslint-disable-next-line max-params\r\nfunction generateGradient(data, color, glyph, isCircular) {\r\n  // The undefined declarations here are mostly to make ESLint happy, and aren't necessarily used in all cases\r\n  let borders, scaleFn, centers, specialData, isColor = false;\r\n  const entries = [], elements = [];\r\n  switch (data.lineType) {\r\n    case \"linear\":\r\n      // Produces stripes at the specified angle, where color sharply switches between the specified color and\r\n      // transparent at each percentage in lines\r\n      borders = [0, ...data.colorSplit, 100];\r\n      scaleFn = perc => (isCircular ? 50 + 0.7 * (perc - 50) : perc);\r\n      for (const angle of data.angles) {\r\n        for (let i = 0; i < borders.length - 1; i++) {\r\n          entries.push(`${isColor ? color : \"transparent\"} ${scaleFn(borders[i])}% ${scaleFn(borders[i + 1])}%`);\r\n          isColor = !isColor;\r\n        }\r\n        elements.push(`repeating-linear-gradient(${angle}deg, ${entries.join(\",\")})`);\r\n      }\r\n      return elements.join(\",\");\r\n    case \"bump\":\r\n      // Produces four bumps on the cardinal directions of the glyph border, with specified color fade distances.\r\n      // These bumps overlap some dots on effarig glyphs, so we conditionally make them more transparent (effectively\r\n      // shrinking them so they don't overlap)\r\n      specialData = glyph.type === \"effarig\"\r\n        ? `${color}60`\r\n        : color;\r\n      centers = [\"50% -25%\", \"50% 125%\", \"-25% 50%\", \"125% 50%\"];\r\n      scaleFn = perc => (isCircular ? perc : 0.9 * perc);\r\n      for (let i = 0; i < 4; i++) {\r\n        entries.push(`radial-gradient(at ${centers[i]}, transparent, ${specialData} ${scaleFn(data.colorSplit[0])}%,\r\n          transparent ${scaleFn(data.colorSplit[1])}%)`);\r\n      }\r\n      return entries.join(\",\");\r\n    case \"radial\":\r\n      // Produces a centered circle that only shades within a certain radial distance\r\n      borders = [50, ...data.colorSplit, 100];\r\n      scaleFn = perc => (isCircular ? 0.9 * perc : 100 - (100 - perc) / 2);\r\n      for (const border of borders) {\r\n        entries.push(`${isColor ? color : \"transparent\"} ${scaleFn(border)}%`);\r\n        isColor = !isColor;\r\n      }\r\n      return `radial-gradient(${entries.join(\",\")})`;\r\n    case \"spike\":\r\n      // Produces a single spike at the specified center, spanning between the specified angles with 5deg blur\r\n      entries.push(`transparent ${data.angles[0] - 5}deg`);\r\n      entries.push(`${color}b0 ${data.angles[0] + 5}deg`);\r\n      entries.push(`${color}b0 ${data.angles[1] - 5}deg`);\r\n      entries.push(`transparent ${data.angles[1] + 5}deg`);\r\n      return `conic-gradient(from 0deg at ${data.center[0]}% ${data.center[1]}%, ${entries.join(\",\")})`;\r\n    case \"companion\":\r\n      // Special case to make the companion border look like a heart\r\n      borders = [0, 30, 330, 360];\r\n      specialData = [color, \"transparent\", \"transparent\", color];\r\n      for (let i = 0; i < 4; i++) {\r\n        entries.push(`${specialData[i]} ${borders[i]}deg`);\r\n      }\r\n      elements.push(`conic-gradient(${entries.join(\",\")})`);\r\n\r\n      centers = [\"125% 125%\", \"-25% 125%\"];\r\n      scaleFn = perc => (isCircular ? 0.9 * (perc + 10) : perc);\r\n      for (let i = 0; i < 2; i++) {\r\n        elements.push(`radial-gradient(at ${centers[i]}, transparent, ${color} ${scaleFn(30)}%,\r\n          transparent ${scaleFn(50)}%)`);\r\n      }\r\n      return elements.join(\",\");\r\n    default:\r\n      throw new Error(\"Unrecognized glyph border data\");\r\n  }\r\n}\r\n\r\nexport default {\r\n  name: \"GlyphComponent\",\r\n  components: {\r\n    GlyphTooltip\r\n  },\r\n  props: {\r\n    glyph: {\r\n      type: Object,\r\n      required: true\r\n    },\r\n    isInModal: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: false\r\n    },\r\n    isNew: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: false\r\n    },\r\n    isUnequipped: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: false\r\n    },\r\n    showSacrifice: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: false\r\n    },\r\n    ignoreModifiedLevel: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: false\r\n    },\r\n    realityGlyphBoost: {\r\n      type: Number,\r\n      required: false,\r\n      default: 0\r\n    },\r\n    isInventoryGlyph: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: false\r\n    },\r\n    isActiveGlyph: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: false\r\n    },\r\n    size: {\r\n      type: String,\r\n      required: false,\r\n      default: \"5rem\",\r\n    },\r\n    glowBlur: {\r\n      type: String,\r\n      required: false,\r\n      default: \"1rem\"\r\n    },\r\n    glowSpread: {\r\n      type: String,\r\n      required: false,\r\n      default: \"0.2rem\"\r\n    },\r\n    bottomPadding: {\r\n      type: String,\r\n      required: false,\r\n      default: \"0.3rem\"\r\n    },\r\n    textProportion: {\r\n      type: Number,\r\n      required: false,\r\n      default: 0.5\r\n    },\r\n    circular: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: false,\r\n    },\r\n    draggable: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: false,\r\n    },\r\n    flipTooltip: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: false,\r\n    }\r\n  },\r\n  data() {\r\n    return {\r\n      componentID: UIID.next(),\r\n      isDragging: false,\r\n      // This flag is used to prevent the tooltip from being shown in some touch event sequences\r\n      suppressTooltip: false,\r\n      isTouched: false,\r\n      tooltipEnabled: false,\r\n      sacrificeReward: 0,\r\n      uncappedRefineReward: 0,\r\n      refineReward: 0,\r\n      displayLevel: 0,\r\n      // We use this to not create a ton of tooltip components as soon as the glyph tab loads.\r\n      tooltipLoaded: false,\r\n      logTotalSacrifice: 0,\r\n      realityColor: \"\",\r\n    };\r\n  },\r\n  computed: {\r\n    hasTooltip() {\r\n      return Boolean(this.glyph.effects);\r\n    },\r\n    typeConfig() {\r\n      return GlyphTypes[this.glyph.type];\r\n    },\r\n    cosmeticConfig() {\r\n      return CosmeticGlyphTypes[this.glyph.cosmetic ?? this.glyph.type];\r\n    },\r\n    isBlobHeart() {\r\n      return this.$viewModel.theme === \"S11\" && this.glyph.type === \"companion\";\r\n    },\r\n    symbol() {\r\n      const symbol = this.glyph.symbol;\r\n      // \\uE019 = :blobheart:\r\n      if (this.isBlobHeart) return \"\\uE019\";\r\n      if (symbol) return symbol;\r\n      return (this.$viewModel.theme === \"S4\" && !this.glyph.cosmetic)\r\n        ? CANCER_GLYPH_SYMBOLS[this.glyph.type]\r\n        : this.cosmeticConfig.currentSymbol.symbol;\r\n    },\r\n    symbolBlur() {\r\n      if (this.isBlobHeart) return false;\r\n      if (!this.glyph.symbol) return this.cosmeticConfig.currentSymbol.blur;\r\n      return !GlyphAppearanceHandler.unblurredSymbols.includes(this.symbol);\r\n    },\r\n    zIndexStyle() {\r\n      return { \"z-index\": this.isInModal ? 7 : 6 };\r\n    },\r\n    colorObj() {\r\n      let overrideColor;\r\n      if (this.glyph.color) overrideColor = GlyphAppearanceHandler.getColorProps(this.glyph.color);\r\n      if (this.glyph.cosmetic) {\r\n        if (this.glyph.cosmetic === this.glyph.type) {\r\n          overrideColor = this.glyph.type === \"cursed\"\r\n            ? GlyphAppearanceHandler.getBaseColor(true)\r\n            : this.cosmeticConfig.currentColor;\r\n        } else {\r\n          overrideColor = this.cosmeticConfig.currentColor;\r\n        }\r\n      }\r\n\r\n      let symbolColor;\r\n      if (this.isRealityGlyph && this.realityColor) symbolColor = this.realityColor;\r\n      else {\r\n        symbolColor = this.cosmeticConfig.ignoreRarityColor\r\n          ? GlyphAppearanceHandler.getBorderColor(this.glyph.type)\r\n          : GlyphAppearanceHandler.getRarityColor(this.glyph.strength, this.glyph.type);\r\n      }\r\n\r\n      return {\r\n        border: overrideColor?.border ?? GlyphAppearanceHandler.getBorderColor(this.glyph.type),\r\n        symbol: overrideColor?.border ?? symbolColor,\r\n        bg: overrideColor?.bg ?? this.cosmeticConfig.currentColor.bg\r\n      };\r\n    },\r\n    symbolColor() {\r\n      return player.options.swapGlyphColors ? this.colorObj.border : this.colorObj.symbol;\r\n    },\r\n    borderColor() {\r\n      return player.options.swapGlyphColors ? this.colorObj.symbol : this.colorObj.border;\r\n    },\r\n    bgColor() {\r\n      return this.colorObj.bg;\r\n    },\r\n    overStyle() {\r\n      return {\r\n        width: this.size,\r\n        height: this.size,\r\n        position: \"absolute\",\r\n        \"background-color\": \"rgba(0, 0, 0, 0)\",\r\n        \"box-shadow\": `0 0 ${this.glowBlur} calc(${this.glowSpread} + 0.1rem) ${this.borderColor} inset`,\r\n        \"border-radius\": this.circular ? \"50%\" : \"0\",\r\n      };\r\n    },\r\n    outerStyle() {\r\n      return {\r\n        width: this.size,\r\n        height: this.size,\r\n        \"background-color\": this.borderColor,\r\n        \"box-shadow\": `0 0 ${this.glowBlur} ${this.glowSpread} ${this.borderColor}`,\r\n        \"border-radius\": this.circular ? \"50%\" : \"0\",\r\n        \"-webkit-user-drag\": this.draggable ? \"\" : \"none\"\r\n      };\r\n    },\r\n    innerStyle() {\r\n      const color = this.symbolColor;\r\n      return {\r\n        width: `calc(${this.size} - 0.2rem)`,\r\n        height: `calc(${this.size} - 0.2rem)`,\r\n        \"font-size\": `calc( ${this.size} * ${this.textProportion} )`,\r\n        color,\r\n        \"text-shadow\": this.symbolBlur ? `-0.04em 0.04em 0.08em ${color}` : undefined,\r\n        \"border-radius\": this.circular ? \"50%\" : \"0\",\r\n        \"padding-bottom\": this.bottomPadding,\r\n        background: this.bgColor\r\n      };\r\n    },\r\n    mouseEventHandlers() {\r\n      const handlers = this.hasTooltip ? {\r\n        mouseenter: this.mouseEnter,\r\n        \"&mousemove\": this.mouseMove,\r\n        mouseleave: this.mouseLeave,\r\n        mousedown: this.mouseDown,\r\n        touchstart: this.touchStart,\r\n        touchend: this.touchEnd\r\n      } : {};\r\n      if (this.hasTooltip || this.draggable) {\r\n        handlers.touchmove = this.touchMove;\r\n      }\r\n      return handlers;\r\n    },\r\n    isCurrentTooltip() {\r\n      return this.$viewModel.tabs.reality.currentGlyphTooltip === this.componentID;\r\n    },\r\n    tooltipDirectionClass() {\r\n      let directionID = this.$viewModel.tabs.reality.glyphTooltipDirection;\r\n      if (this.flipTooltip) directionID += 1;\r\n      switch (directionID) {\r\n        case -1:\r\n          return \"l-glyph-tooltip--down-left\";\r\n        case 0:\r\n          return \"l-glyph-tooltip--down-right\";\r\n        case 1:\r\n          return \"l-glyph-tooltip--up-left\";\r\n        case 2:\r\n          return \"l-glyph-tooltip--up-right\";\r\n        default:\r\n          return \"\";\r\n      }\r\n    },\r\n    // This finds all the effects of a glyph and shifts all their IDs so that type's lowest-ID effect is 0 and all\r\n    // other effects count up to 3 (or 6 for effarig). Used to add dots in unique positions on glyphs to show effects.\r\n    glyphEffects() {\r\n      let minEffectID = 0;\r\n      switch (this.glyph.type) {\r\n        case \"time\":\r\n        case \"cursed\":\r\n        case \"companion\":\r\n          minEffectID = 0;\r\n          break;\r\n        case \"dilation\":\r\n        case \"reality\":\r\n          minEffectID = 4;\r\n          break;\r\n        case \"replication\":\r\n          minEffectID = 8;\r\n          break;\r\n        case \"infinity\":\r\n          minEffectID = 12;\r\n          break;\r\n        case \"power\":\r\n          minEffectID = 16;\r\n          break;\r\n        case \"effarig\":\r\n          minEffectID = 20;\r\n          break;\r\n        default:\r\n          throw new Error(`Unrecognized glyph type \"${this.glyph.type}\" in glyph effect icons`);\r\n      }\r\n      const effectIDs = [];\r\n      let remainingEffects = this.glyph.effects >> minEffectID;\r\n      for (let id = 0; remainingEffects > 0; id++) {\r\n        if ((remainingEffects & 1) === 1) effectIDs.push(id);\r\n        remainingEffects >>= 1;\r\n      }\r\n      return effectIDs;\r\n    },\r\n    isRealityGlyph() {\r\n      return this.glyph.type === \"reality\";\r\n    },\r\n    isCursedGlyph() {\r\n      return this.glyph.type === \"cursed\";\r\n    },\r\n    isCompanionGlyph() {\r\n      return this.glyph.type === \"companion\";\r\n    },\r\n    showGlyphEffectDots() {\r\n      return player.options.showHintText.glyphEffectDots;\r\n    },\r\n    displayedInfo() {\r\n      const blacklist = [\"companion\", \"cursed\"];\r\n      if (!this.isInventoryGlyph || blacklist.includes(this.glyph.type)) return null;\r\n\r\n      const options = player.options.showHintText;\r\n      if (options.glyphInfoType === GlyphInfo.types.NONE ||\r\n        (!options.showGlyphInfoByDefault && !this.$viewModel.shiftDown)) {\r\n        return null;\r\n      }\r\n\r\n      const typeEnum = GlyphInfo.types;\r\n      switch (options.glyphInfoType) {\r\n        case typeEnum.LEVEL:\r\n          this.updateDisplayLevel();\r\n          return formatInt(this.displayLevel === 0 ? this.glyph.level : this.displayLevel);\r\n        case typeEnum.RARITY:\r\n          return formatRarity(strengthToRarity(Pelle.isDoomed ? Pelle.glyphStrength : this.glyph.strength));\r\n        case typeEnum.SAC_VALUE:\r\n          return format(this.sacrificeReward, 2, 2);\r\n        case typeEnum.FILTER_SCORE:\r\n          return format(AutoGlyphProcessor.filterValue(this.glyph), 1, 1);\r\n        case typeEnum.CURRENT_REFINE:\r\n          return `${format(this.refineReward, 2, 2)} ${this.symbol}`;\r\n        case typeEnum.MAX_REFINE:\r\n          return `${format(this.uncappedRefineReward, 2, 2)} ${this.symbol}`;\r\n        default:\r\n          throw new Error(\"Unrecognized Glyph info type in info text\");\r\n      }\r\n    },\r\n    showBorders() {\r\n      return player.options.glyphBorders;\r\n    }\r\n  },\r\n  watch: {\r\n    logTotalSacrifice() {\r\n      this.tooltipLoaded = false;\r\n      if (this.isCurrentTooltip) this.showTooltip();\r\n    }\r\n  },\r\n  created() {\r\n    this.on$(GAME_EVENT.GLYPH_VISUAL_CHANGE, () => {\r\n      this.$recompute(\"typeConfig\");\r\n      this.$recompute(\"cosmeticConfig\");\r\n      this.$recompute(\"innerStyle\");\r\n      this.$recompute(\"overrideColor\");\r\n      this.$recompute(\"showGlyphEffectDots\");\r\n      this.$recompute(\"displayedInfo\");\r\n      this.$recompute(\"showBorders\");\r\n    });\r\n    this.on$(\"tooltip-touched\", () => this.hideTooltip());\r\n    this.on$(GAME_EVENT.TAB_CHANGED, () => this.hideTooltip());\r\n\r\n    // There are a few situations where a tooltip could attempt to render immediately upon component creation,\r\n    // which causes it to be placed in an odd \"default\" corner spot due to mouse position not being set properly.\r\n    // This is essentially a hack that force-suppresses tooltips from being shown in strange spots due to on-load\r\n    // events firing, but has the side effect that the mouse must leave and enter an element which was created\r\n    // underneath it in order to make the tooltip appear\r\n    setTimeout(() => this.tooltipEnabled = true, 10);\r\n  },\r\n  beforeDestroy() {\r\n    if (this.isCurrentTooltip) this.hideTooltip();\r\n    if (this.$viewModel.draggingUIID === this.componentID) this.$viewModel.draggingUIID = -1;\r\n  },\r\n  methods: {\r\n    update() {\r\n      this.logTotalSacrifice = GameCache.logTotalGlyphSacrifice.value;\r\n      // This needs to be reactive in order to animate while using our low-lag workaround, but we also need to make\r\n      // sure it only animates when that color is actually active\r\n      this.realityColor = player.reality.glyphs.cosmetics.colorMap.reality\r\n        ? null\r\n        : GlyphAppearanceHandler.realityColor;\r\n      this.sacrificeReward = GlyphSacrificeHandler.glyphSacrificeGain(this.glyph);\r\n      this.uncappedRefineReward = ALCHEMY_BASIC_GLYPH_TYPES.includes(this.glyph.type)\r\n        ? GlyphSacrificeHandler.glyphRawRefinementGain(this.glyph)\r\n        : 0;\r\n      this.refineReward = ALCHEMY_BASIC_GLYPH_TYPES.includes(this.glyph.type)\r\n        ? GlyphSacrificeHandler.glyphRefinementGain(this.glyph)\r\n        : 0;\r\n      if (this.tooltipLoaded) this.updateDisplayLevel();\r\n    },\r\n    updateDisplayLevel() {\r\n      if (this.ignoreModifiedLevel) {\r\n        this.displayLevel = 0;\r\n        return;\r\n      }\r\n      // We have to consider some odd interactions in order to properly show level. The getAdjustedGlyphLevel() function\r\n      // returns a modified level using celestial effects and reality glyphs based on the CURRENT game state, meaning\r\n      // that applying this globally will cause lots of glyphs to show altered levels even if they shouldn't. So:\r\n      // - Active glyphs should apply ALL adjusted effects based on the current game state, since they are guaranteed\r\n      //   to always be affected by them and this is exactly the purpose of getAdjustedGlyphLevel() as-is\r\n      // - Inventory glyphs should show the same current-state effects as active, but it should NEVER apply reality\r\n      //   glyph boosts. This allows for easier comparison when celestial effects are changing both active and\r\n      //   inventory glyphs, even though strictly speaking the inventory ones shouldn't be affected until equipped\r\n      // - All other glyphs should never apply effects from the current game state, and should in fact only apply the\r\n      //   reality glyph boost based on the rest of its existing set (which is passed in via realityGlyphBoost) and\r\n      //   nothing else. This case applies to glyphs appearing in presets, records, and previews.\r\n      if (this.isActiveGlyph) this.displayLevel = getAdjustedGlyphLevel(this.glyph);\r\n      else if (this.isInventoryGlyph) this.displayLevel = getAdjustedGlyphLevel(this.glyph, 0);\r\n      else {\r\n        this.displayLevel = this.glyph.level +\r\n          (BASIC_GLYPH_TYPES.includes(this.glyph.type) ? this.realityGlyphBoost : 0);\r\n      }\r\n    },\r\n    hideTooltip() {\r\n      this.tooltipLoaded = false;\r\n      this.$viewModel.tabs.reality.mouseoverGlyphInfo.type = \"\";\r\n      this.$viewModel.tabs.reality.mouseoverGlyphInfo.inInventory = false;\r\n      this.$viewModel.tabs.reality.currentGlyphTooltip = -1;\r\n    },\r\n    showTooltip() {\r\n      if (!this.tooltipEnabled) return;\r\n      Glyphs.removeVisualFlag(\"unseen\", this.glyph);\r\n      Glyphs.removeVisualFlag(\"unequipped\", this.glyph);\r\n      this.tooltipLoaded = true;\r\n      this.$viewModel.tabs.reality.mouseoverGlyphInfo.inInventory = !this.circular;\r\n      const glyphInfo = this.$viewModel.tabs.reality.mouseoverGlyphInfo;\r\n      glyphInfo.type = this.glyph.type;\r\n      glyphInfo.sacrificeValue = GlyphSacrificeHandler.glyphSacrificeGain(this.glyph);\r\n      glyphInfo.refineValue = GlyphSacrificeHandler.glyphRawRefinementGain(this.glyph);\r\n      this.$viewModel.tabs.reality.currentGlyphTooltip = this.componentID;\r\n      if (\r\n        AutoGlyphProcessor.sacMode === AUTO_GLYPH_REJECT.SACRIFICE ||\r\n        (AutoGlyphProcessor.sacMode === AUTO_GLYPH_REJECT.REFINE_TO_CAP && this.refineReward === 0)\r\n      ) {\r\n        this.currentAction = \"sacrifice\";\r\n      } else {\r\n        this.currentAction = \"refine\";\r\n      }\r\n      this.scoreMode = AutoGlyphProcessor.scoreMode;\r\n    },\r\n    moveTooltipTo(x, y) {\r\n      // If we are just creating the tooltip now, we can't move it yet.\r\n      if (!this.$refs.tooltip) return;\r\n      const tooltipEl = this.$refs.tooltip.$el;\r\n      if (tooltipEl) {\r\n        const rect = document.body.getBoundingClientRect();\r\n        tooltipEl.style.left = `${x - rect.left}px`;\r\n        tooltipEl.style.top = `${y - rect.top}px`;\r\n        if (this.$viewModel.tabs.reality.glyphTooltipDirection === 1) {\r\n          // In case of a really short screen, don't flicker back and forth\r\n          if (y - tooltipEl.offsetHeight <= 0 && y + tooltipEl.offsetHeight < rect.height) {\r\n            this.$viewModel.tabs.reality.glyphTooltipDirection = -1;\r\n          }\r\n        } else if (y + tooltipEl.offsetHeight >= rect.height) {\r\n          this.$viewModel.tabs.reality.glyphTooltipDirection = 1;\r\n        }\r\n      }\r\n    },\r\n    mouseEnter(ev) {\r\n      if (this.$viewModel.draggingUIID !== -1) return;\r\n      this.moveTooltipTo(ev.clientX, ev.clientY);\r\n      this.showTooltip();\r\n    },\r\n    mouseLeave() {\r\n      if (this.isCurrentTooltip) {\r\n        this.hideTooltip();\r\n      }\r\n    },\r\n    mouseDown() {\r\n      if (this.isTouched) return;\r\n      this.hideTooltip();\r\n    },\r\n    mouseMove(ev) {\r\n      if (this.isTouched) return;\r\n      this.moveTooltipTo(ev.clientX, ev.clientY);\r\n    },\r\n    dragStart(ev) {\r\n      this.hideTooltip();\r\n      this.isDragging = true;\r\n      this.suppressTooltip = true;\r\n      ev.dataTransfer.setData(GLYPH_MIME_TYPE, this.glyph.id.toString());\r\n      ev.dataTransfer.dropEffect = \"move\";\r\n      const rect = this.$refs.over.getBoundingClientRect();\r\n      ev.dataTransfer.setDragImage(this.$refs.over, ev.clientX - rect.left, ev.clientY - rect.top);\r\n      this.$viewModel.draggingUIID = this.componentID;\r\n      const dragInfo = this.$viewModel.tabs.reality.draggingGlyphInfo;\r\n      dragInfo.id = this.glyph.id;\r\n      dragInfo.type = this.glyph.type;\r\n      dragInfo.sacrificeValue = GlyphSacrificeHandler.glyphSacrificeGain(this.glyph);\r\n    },\r\n    dragEnd() {\r\n      this.isDragging = false;\r\n      this.suppressTooltip = false;\r\n      this.$viewModel.scrollWindow = 0;\r\n      const dragInfo = this.$viewModel.tabs.reality.draggingGlyphInfo;\r\n      dragInfo.id = -1;\r\n      dragInfo.type = \"\";\r\n      if (this.$viewModel.draggingUIID === this.componentID) this.$viewModel.draggingUIID = -1;\r\n    },\r\n    drag(ev) {\r\n      // It looks like dragging off the bottom of the window sometimes fires these\r\n      // odd events\r\n      if (ev.screenX === 0 && ev.screenY === 0) {\r\n        this.$viewModel.scrollWindow = 0;\r\n        return;\r\n      }\r\n      const boundary = 100;\r\n      if (ev.clientY < boundary) {\r\n        this.$viewModel.scrollWindow = -1 + 0.9 * ev.clientY / boundary;\r\n      } else if (ev.clientY > window.innerHeight - boundary) {\r\n        this.$viewModel.scrollWindow = 1 - 0.9 * (window.innerHeight - ev.clientY) / boundary;\r\n      } else {\r\n        this.$viewModel.scrollWindow = 0;\r\n      }\r\n    },\r\n    touchStart() {\r\n      this.isTouched = true;\r\n    },\r\n    touchEnd(e) {\r\n      if (this.isCurrentTooltip) {\r\n        e.preventDefault();\r\n        this.hideTooltip();\r\n      } else if (!this.suppressTooltip) {\r\n        e.preventDefault();\r\n        this.showTooltip();\r\n        this.moveTooltipTo(e.changedTouches[0].clientX, e.changedTouches[0].clientY);\r\n      }\r\n      this.suppressTooltip = false;\r\n      this.isTouched = false;\r\n    },\r\n    touchMove(e) {\r\n      const t = e.changedTouches[0];\r\n      const r = this.$refs.over.getBoundingClientRect();\r\n      if (t.clientX < r.left || t.clientY < r.top || t.clientX > r.left + r.width || t.clientY > r.top + r.height) {\r\n        this.suppressTooltip = true;\r\n      }\r\n      if (this.isDragging) {\r\n        // DragDropTouch doesn't seem to send drag events.\r\n        this.drag(t);\r\n      }\r\n    },\r\n    // Translates 0...3 into equally-spaced coordinates around a circle 90deg apart (0...6 and 45deg for effarig)\r\n    effectIconPos(id) {\r\n      // Place dots clockwise starting from the bottom left\r\n      const angle = this.glyph.type === \"effarig\"\r\n        ? (Math.PI / 4) * (id + 1)\r\n        : (Math.PI / 2) * (id + 0.5);\r\n      const scale = 0.28 * this.size.replace(\"rem\", \"\");\r\n      const dx = -scale * Math.sin(angle);\r\n      const dy = scale * (Math.cos(angle) + 0.15);\r\n      return { dx, dy };\r\n    },\r\n    glyphEffectDots(id) {\r\n      if ([\"companion\", \"cursed\"].includes(this.glyph.type)) return {};\r\n      const pos = this.effectIconPos(id);\r\n\r\n      return {\r\n        position: \"absolute\",\r\n        width: \"0.3rem\",\r\n        height: \"0.3rem\",\r\n        \"border-radius\": \"50%\",\r\n        background: this.symbolColor,\r\n        transform: `translate(${pos.dx - 0.15 * 0.3}rem, ${pos.dy - 0.15 * 0.3}rem)`,\r\n        opacity: Theme.current().name === \"S9\" ? 0 : 0.8\r\n      };\r\n    },\r\n    glyphBorderStyle() {\r\n      if (!this.showBorders) return null;\r\n      let borderAttrs;\r\n      if (this.isCursedGlyph) borderAttrs = rarityBorderStyles.cursed;\r\n      else if (this.isCompanionGlyph) borderAttrs = rarityBorderStyles.companion;\r\n      else borderAttrs = rarityBorderStyles[getRarity(this.glyph.strength).name.toLowerCase()];\r\n      const lines = borderAttrs.map(attr => generateGradient(attr, this.borderColor, this.glyph, this.circular));\r\n\r\n      return {\r\n        position: \"absolute\",\r\n        left: \"2%\",\r\n        width: \"96%\",\r\n        height: \"96%\",\r\n        \"border-radius\": this.circular ? \"50%\" : \"0\",\r\n        // Some cases will have undefined lines which need to be removed to combine everything together properly\r\n        background: lines.filter(l => l).join(\",\")\r\n      };\r\n    }\r\n  }\r\n};\r\n</script>\r\n\r\n<template>\r\n  <!--\r\n    The naive approach with a border and box-shadow seems to have problems with\r\n    weird seams/artifacts at the edges. This makes for a rather complex workaround\r\n  -->\r\n  <div\r\n    :style=\"outerStyle\"\r\n    :class=\"['l-glyph-component', {'c-glyph-component--dragging': isDragging}]\"\r\n    :draggable=\"draggable\"\r\n    v-on=\"draggable ? { dragstart: dragStart, dragend: dragEnd, drag: drag } : {}\"\r\n  >\r\n    <div\r\n      ref=\"glyph\"\r\n      :style=\"innerStyle\"\r\n      :class=\"['l-glyph-component', 'c-glyph-component']\"\r\n    >\r\n      {{ symbol }}\r\n      <template v-if=\"$viewModel.shiftDown || showGlyphEffectDots\">\r\n        <div\r\n          v-for=\"x in glyphEffects\"\r\n          :key=\"x\"\r\n          :style=\"glyphEffectDots(x)\"\r\n        />\r\n      </template>\r\n    </div>\r\n    <div :style=\"glyphBorderStyle()\" />\r\n    <GlyphTooltip\r\n      v-if=\"hasTooltip && tooltipLoaded\"\r\n      v-show=\"isCurrentTooltip\"\r\n      ref=\"tooltip\"\r\n      v-bind=\"glyph\"\r\n      :class=\"tooltipDirectionClass\"\r\n      :style=\"zIndexStyle\"\r\n      :sacrifice-reward=\"sacrificeReward\"\r\n      :refine-reward=\"refineReward\"\r\n      :uncapped-refine-reward=\"uncappedRefineReward\"\r\n      :current-action=\"currentAction\"\r\n      :score-mode=\"scoreMode\"\r\n      :show-deletion-text=\"showSacrifice\"\r\n      :display-level=\"displayLevel\"\r\n      :component=\"componentID\"\r\n      :change-watcher=\"logTotalSacrifice\"\r\n    />\r\n    <div\r\n      v-if=\"isNew\"\r\n      class=\"l-corner-icon l-new-glyph\"\r\n    >\r\n      New!\r\n    </div>\r\n    <div\r\n      v-else-if=\"isUnequipped\"\r\n      class=\"l-corner-icon l-unequipped-glyph fas fa-arrow-up-from-bracket\"\r\n    />\r\n    <div\r\n      v-if=\"displayedInfo\"\r\n      class=\"l-glyph-info\"\r\n    >\r\n      {{ displayedInfo }}\r\n    </div>\r\n    <div\r\n      ref=\"over\"\r\n      :style=\"overStyle\"\r\n      v-on=\"mouseEventHandlers\"\r\n      @click.shift.exact=\"$emit('shiftClicked', glyph.id)\"\r\n      @click.ctrl.shift.exact=\"$emit('ctrlShiftClicked', glyph.id)\"\r\n      @click.meta.shift.exact=\"$emit('ctrlShiftClicked', glyph.id)\"\r\n      @click.exact=\"$emit('clicked', glyph.id)\"\r\n    />\r\n  </div>\r\n</template>\r\n\r\n<style scoped>\r\n.l-corner-icon {\r\n  position: absolute;\r\n  z-index: 5;\r\n  color: black;\r\n  border-radius: var(--var-border-radius, 0.2rem);\r\n  padding: 0.2rem;\r\n}\r\n\r\n.l-new-glyph {\r\n  top: -0.7rem;\r\n  left: -0.7rem;\r\n  font-size: 1rem;\r\n  background-color: yellow;\r\n}\r\n\r\n.l-unequipped-glyph {\r\n  top: -0.5rem;\r\n  left: -0.5rem;\r\n  font-size: 1.2rem;\r\n  background-color: orange;\r\n}\r\n</style>\r\n"],"sourceRoot":"src/components"},"metadata":{},"sourceType":"module"}