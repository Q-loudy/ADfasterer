{"ast":null,"code":"import draggable from \"vuedraggable\";\nimport AutomatorBlockSingleInput from \"./AutomatorBlockSingleInput\";\nexport default {\n  name: \"AutomatorBlockSingleRow\",\n  components: {\n    draggable,\n    AutomatorBlockSingleInput\n  },\n  props: {\n    block: {\n      type: Object,\n      required: true\n    },\n    updateBlock: {\n      type: Function,\n      required: true\n    },\n    deleteBlock: {\n      type: Function,\n      required: true\n    }\n  },\n\n  data() {\n    return {\n      b: {},\n      activeLine: -1,\n      eventLine: -1,\n      errorLine: -1\n    };\n  },\n\n  computed: {\n    lineNumber() {\n      return BlockAutomator.lineNumberFromBlockID(this.b.id);\n    },\n\n    isActiveLine() {\n      return this.lineNumber === this.activeLine;\n    },\n\n    isEventLine() {\n      return this.lineNumber === this.eventLine;\n    },\n\n    isErrorLine() {\n      return this.lineNumber === this.errorLine;\n    }\n\n  },\n\n  created() {\n    this.recalculateErrorCount();\n  },\n\n  destroyed() {\n    this.recalculateErrorCount();\n  },\n\n  mounted() {\n    this.b = this.block;\n  },\n\n  methods: {\n    update() {\n      const lines = AutomatorHighlighter.lines;\n      this.activeLine = lines.active;\n      this.eventLine = lines.event;\n      this.errorLine = lines.error;\n    },\n\n    parseRequest() {\n      BlockAutomator.parseTextFromBlocks();\n    },\n\n    deleteBlockFromNest(id) {\n      const idx = this.b.nest.findIndex(x => x.id === id);\n      this.b.nest.splice(idx, 1);\n    },\n\n    updateBlockFromNest(block, id) {\n      this.$set(this.b.nest, this.b.nest.findIndex(x => x.id === id), block);\n      this.parseRequest();\n    },\n\n    // Not entirely sure why, but updating error count only seems to work if it's done exactly here in the execution\n    // stack; moving it to the definition of updateBlock seems to stop it from working\n    removeBlock(block, id) {\n      this.deleteBlock(block, id);\n      this.recalculateErrorCount();\n    },\n\n    // This gets called whenever blocks are changed, but we also need to halt execution if the currently visible script\n    // is also the one being run\n    recalculateErrorCount() {\n      AutomatorData.recalculateErrors();\n\n      if (AutomatorBackend.currentEditingScript.id === AutomatorBackend.currentRunningScript.id) {\n        AutomatorBackend.stop();\n      }\n    },\n\n    highlightClass() {\n      return {\n        \"c-automator-block-row-active\": this.isActiveLine,\n        \"c-automator-block-row-event\": this.isEventLine,\n        \"c-automator-block-row-error\": this.isErrorLine\n      };\n    },\n\n    // The target value is either a String or some kind of a number - we need to force it to be a String for the\n    // component type-checking (Numbers are implicitly cast, but Decimals are not)\n    nextSelection() {\n      const val = this.b.targets ? this.b[this.b.targets[0]] : \"\";\n      return val;\n    }\n\n  }\n};","map":{"version":3,"sources":["AutomatorBlockSingleRow.vue"],"names":[],"mappings":"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","sourcesContent":["<script>\r\nimport draggable from \"vuedraggable\";\r\n\r\nimport AutomatorBlockSingleInput from \"./AutomatorBlockSingleInput\";\r\n\r\nexport default {\r\n  name: \"AutomatorBlockSingleRow\",\r\n  components: {\r\n    draggable,\r\n    AutomatorBlockSingleInput\r\n  },\r\n  props: {\r\n    block: {\r\n      type: Object,\r\n      required: true\r\n    },\r\n    updateBlock: {\r\n      type: Function,\r\n      required: true\r\n    },\r\n    deleteBlock: {\r\n      type: Function,\r\n      required: true\r\n    }\r\n  },\r\n  data() {\r\n    return {\r\n      b: {},\r\n      activeLine: -1,\r\n      eventLine: -1,\r\n      errorLine: -1,\r\n    };\r\n  },\r\n  computed: {\r\n    lineNumber() {\r\n      return BlockAutomator.lineNumberFromBlockID(this.b.id);\r\n    },\r\n    isActiveLine() {\r\n      return this.lineNumber === this.activeLine;\r\n    },\r\n    isEventLine() {\r\n      return this.lineNumber === this.eventLine;\r\n    },\r\n    isErrorLine() {\r\n      return this.lineNumber === this.errorLine;\r\n    },\r\n  },\r\n  created() {\r\n    this.recalculateErrorCount();\r\n  },\r\n  destroyed() {\r\n    this.recalculateErrorCount();\r\n  },\r\n  mounted() {\r\n    this.b = this.block;\r\n  },\r\n  methods: {\r\n    update() {\r\n      const lines = AutomatorHighlighter.lines;\r\n      this.activeLine = lines.active;\r\n      this.eventLine = lines.event;\r\n      this.errorLine = lines.error;\r\n    },\r\n    parseRequest() {\r\n      BlockAutomator.parseTextFromBlocks();\r\n    },\r\n    deleteBlockFromNest(id) {\r\n      const idx = this.b.nest.findIndex(x => x.id === id);\r\n      this.b.nest.splice(idx, 1);\r\n    },\r\n    updateBlockFromNest(block, id) {\r\n      this.$set(this.b.nest, this.b.nest.findIndex(x => x.id === id), block);\r\n      this.parseRequest();\r\n    },\r\n\r\n    // Not entirely sure why, but updating error count only seems to work if it's done exactly here in the execution\r\n    // stack; moving it to the definition of updateBlock seems to stop it from working\r\n    removeBlock(block, id) {\r\n      this.deleteBlock(block, id);\r\n      this.recalculateErrorCount();\r\n    },\r\n\r\n    // This gets called whenever blocks are changed, but we also need to halt execution if the currently visible script\r\n    // is also the one being run\r\n    recalculateErrorCount() {\r\n      AutomatorData.recalculateErrors();\r\n      if (AutomatorBackend.currentEditingScript.id === AutomatorBackend.currentRunningScript.id) {\r\n        AutomatorBackend.stop();\r\n      }\r\n    },\r\n\r\n    highlightClass() {\r\n      return {\r\n        \"c-automator-block-row-active\": this.isActiveLine,\r\n        \"c-automator-block-row-event\": this.isEventLine,\r\n        \"c-automator-block-row-error\": this.isErrorLine\r\n      };\r\n    },\r\n    // The target value is either a String or some kind of a number - we need to force it to be a String for the\r\n    // component type-checking (Numbers are implicitly cast, but Decimals are not)\r\n    nextSelection() {\r\n      const val = this.b.targets ? this.b[this.b.targets[0]] : \"\";\r\n      return val;\r\n    }\r\n  }\r\n};\r\n</script>\r\n\r\n<template>\r\n  <div class=\"c-automator-block-row--container\">\r\n    <div\r\n      class=\"c-automator-block-row\"\r\n      :class=\"highlightClass()\"\r\n    >\r\n      <AutomatorBlockSingleInput\r\n        :constant=\"b.alias ? b.alias : b.cmd\"\r\n        :block=\"b\"\r\n        :update-function=\"updateBlock\"\r\n      />\r\n      <AutomatorBlockSingleInput\r\n        v-if=\"b.canWait\"\r\n        :block=\"b\"\r\n        block-target=\"nowait\"\r\n        :initial-selection=\"b.nowait ? 'NOWAIT' : ''\"\r\n        :update-function=\"updateBlock\"\r\n      />\r\n      <AutomatorBlockSingleInput\r\n        v-if=\"b.canRespec\"\r\n        :block=\"b\"\r\n        block-target=\"respec\"\r\n        :initial-selection=\"b.respec ? 'RESPEC' : ''\"\r\n        :update-function=\"updateBlock\"\r\n      />\r\n      <AutomatorBlockSingleInput\r\n        v-if=\"b.allowedPatterns\"\r\n        :block=\"b\"\r\n        :block-target=\"b.targets[0]\"\r\n        :patterns=\"b.allowedPatterns\"\r\n        :initial-selection=\"nextSelection()\"\r\n        :update-function=\"updateBlock\"\r\n        :recursive=\"true\"\r\n      />\r\n      <div\r\n        class=\"o-automator-block-delete\"\r\n        @click=\"removeBlock(b.id)\"\r\n      >\r\n        X\r\n      </div>\r\n    </div>\r\n    <draggable\r\n      v-if=\"block.nested\"\r\n      v-model=\"block.nest\"\r\n      class=\"l-automator-nested-block\"\r\n      group=\"code-blocks\"\r\n    >\r\n      <AutomatorBlockSingleRow\r\n        v-for=\"subblock in block.nest\"\r\n        :key=\"subblock.id\"\r\n        :block=\"subblock\"\r\n        :update-block=\"updateBlockFromNest\"\r\n        :delete-block=\"deleteBlockFromNest\"\r\n      />\r\n    </draggable>\r\n  </div>\r\n</template>\r\n\r\n<style scoped>\r\n.c-automator-block-row--container {\r\n  margin: -0.002rem;\r\n  /* The only purpose of this is to prevent margin overlapping so the nested blocks can fit nicer */\r\n  padding: 0.002rem;\r\n}\r\n\r\n.l-automator-nested-block {\r\n  width: fit-content;\r\n  min-width: 30rem;\r\n  min-height: 3.65rem;\r\n  border: 0.1rem dotted #55ff55;\r\n  margin: -0.1rem 0 -0.1rem 3rem;\r\n  padding: 0 0.5rem;\r\n}\r\n</style>\r\n"],"sourceRoot":"src/components/tabs/automator"},"metadata":{},"sourceType":"module"}