{"ast":null,"code":"import ModalWrapperChoice from \"@/components/modals/ModalWrapperChoice\";\nimport PrimaryButton from \"@/components/PrimaryButton\";\nconst OFFLINE_PROGRESS_TYPE = {\n  IMPORTED: 0,\n  LOCAL: 1,\n  IGNORED: 2\n};\nexport default {\n  name: \"ImportSaveModal\",\n  components: {\n    ModalWrapperChoice,\n    PrimaryButton\n  },\n\n  data() {\n    return {\n      input: \"\",\n      offlineImport: OFFLINE_PROGRESS_TYPE.IMPORTED\n    };\n  },\n\n  computed: {\n    saveCheckString() {\n      const save = GameSaveSerializer.deserialize(this.input);\n      const rawString = GameStorage.checkPlayerObject(save); // Keep the length bounded; we don't want the modal to be too big for the screen for particularly bad errors\n\n      return rawString.length > 300 ? `${rawString.slice(0, 297)}...` : rawString;\n    },\n\n    player() {\n      return this.saveCheckString === \"\" ? GameSaveSerializer.deserialize(this.input) : undefined;\n    },\n\n    progress() {\n      return PlayerProgress.of(this.player);\n    },\n\n    fileName() {\n      return this.player.options.saveFileName;\n    },\n\n    antimatter() {\n      return this.player.antimatter || this.player.money;\n    },\n\n    infinities() {\n      // Infinity count data is stored in either player.infinitied or player.infinities based on if the save is before\n      // or after the reality update, and this explicit check is needed as it runs before any migration code.\n      const infinityData = this.player.infinitied ? this.player.infinitied : this.player.infinities;\n      return new Decimal(infinityData);\n    },\n\n    hasInput() {\n      return this.input !== \"\";\n    },\n\n    inputIsValid() {\n      return this.inputIsValidSave || this.inputIsSecret;\n    },\n\n    inputIsValidSave() {\n      return this.player !== undefined;\n    },\n\n    inputIsSecret() {\n      return isSecretImport(this.input) || Theme.isSecretTheme(this.input);\n    },\n\n    isFromFuture() {\n      return this.player.lastUpdate > Date.now();\n    },\n\n    lastOpened() {\n      const ms = Date.now() - this.player.lastUpdate;\n      return this.isFromFuture ? `This save is from ${TimeSpan.fromMilliseconds(-ms).toString()} in the future.` : `This save was last opened ${TimeSpan.fromMilliseconds(ms).toString()} ago.`;\n    },\n\n    offlineType() {\n      // We update here in the computed method instead of elsewhere because otherwise it initializes the text\n      // to a wrong or undefined setting\n      this.updateOfflineSettings();\n\n      switch (this.offlineImport) {\n        case OFFLINE_PROGRESS_TYPE.IMPORTED:\n          return \"Using imported save settings\";\n\n        case OFFLINE_PROGRESS_TYPE.LOCAL:\n          return \"Using existing save settings\";\n\n        case OFFLINE_PROGRESS_TYPE.IGNORED:\n          return \"Will not simulate offline time\";\n\n        default:\n          throw new Error(\"Unrecognized offline progress setting for importing\");\n      }\n    },\n\n    offlineDetails() {\n      if (this.offlineImport === OFFLINE_PROGRESS_TYPE.IGNORED) {\n        return `Save will be imported without offline progress.`;\n      }\n\n      if (!GameStorage.offlineEnabled) return \"This setting will not apply any offline progress after importing.\";\n      if (this.isFromFuture) return \"Offline progress cannot be simulated due to an inconsistent system clock time.\";\n      const durationInMs = Date.now() - this.player.lastUpdate;\n      const ticks = GameStorage.maxOfflineTicks(durationInMs);\n      return `After importing, will simulate ${formatInt(ticks)} ticks of duration\n        ${TimeSpan.fromMilliseconds(durationInMs / ticks).toStringShort()} each.`;\n    },\n\n    willLoseCosmetics() {\n      var _this$player$reality$, _this$player$reality, _this$player$reality$2;\n\n      const currSets = player.reality.glyphs.cosmetics.unlockedFromNG;\n      const importedSets = (_this$player$reality$ = (_this$player$reality = this.player.reality) === null || _this$player$reality === void 0 ? void 0 : (_this$player$reality$2 = _this$player$reality.glyphs.cosmetics) === null || _this$player$reality$2 === void 0 ? void 0 : _this$player$reality$2.unlockedFromNG) !== null && _this$player$reality$ !== void 0 ? _this$player$reality$ : [];\n      return currSets.filter(set => !importedSets.includes(set)).length > 0;\n    },\n\n    willLoseSpeedrun() {\n      var _this$player$speedrun;\n\n      return player.speedrun.isUnlocked && !((_this$player$speedrun = this.player.speedrun) !== null && _this$player$speedrun !== void 0 && _this$player$speedrun.isUnlocked);\n    }\n\n  },\n\n  mounted() {\n    this.$refs.input.select();\n  },\n\n  destroyed() {\n    // Explicitly setting this to undefined after closing forces the game to fall-back to the stored settings within\n    // the player object if this modal is closed - ie. it makes sure actions in the modal don't persist\n    GameStorage.offlineEnabled = undefined;\n    GameStorage.offlineTicks = undefined;\n  },\n\n  methods: {\n    changeOfflineSetting() {\n      this.offlineImport = (this.offlineImport + 1) % 3;\n    },\n\n    updateOfflineSettings() {\n      var _this$player$options$, _this$player$options$2;\n\n      switch (this.offlineImport) {\n        case OFFLINE_PROGRESS_TYPE.IMPORTED:\n          // These are default values from a new save, used if importing from pre-reality where these props don't exist\n          GameStorage.offlineEnabled = (_this$player$options$ = this.player.options.offlineProgress) !== null && _this$player$options$ !== void 0 ? _this$player$options$ : true;\n          GameStorage.offlineTicks = (_this$player$options$2 = this.player.options.offlineTicks) !== null && _this$player$options$2 !== void 0 ? _this$player$options$2 : 1e5;\n          break;\n\n        case OFFLINE_PROGRESS_TYPE.LOCAL:\n          GameStorage.offlineEnabled = player.options.offlineProgress;\n          GameStorage.offlineTicks = player.options.offlineTicks;\n          break;\n\n        case OFFLINE_PROGRESS_TYPE.IGNORED:\n          GameStorage.offlineEnabled = false;\n          break;\n      }\n    },\n\n    importSave() {\n      if (!this.inputIsValid) return;\n      this.emitClose();\n      GameStorage.import(this.input);\n    }\n\n  }\n};","map":{"version":3,"sources":["ImportSaveModal.vue"],"names":[],"mappings":"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","sourcesContent":["<script>\r\nimport ModalWrapperChoice from \"@/components/modals/ModalWrapperChoice\";\r\nimport PrimaryButton from \"@/components/PrimaryButton\";\r\n\r\nconst OFFLINE_PROGRESS_TYPE = {\r\n  IMPORTED: 0,\r\n  LOCAL: 1,\r\n  IGNORED: 2,\r\n};\r\n\r\nexport default {\r\n  name: \"ImportSaveModal\",\r\n  components: {\r\n    ModalWrapperChoice,\r\n    PrimaryButton\r\n  },\r\n  data() {\r\n    return {\r\n      input: \"\",\r\n      offlineImport: OFFLINE_PROGRESS_TYPE.IMPORTED,\r\n    };\r\n  },\r\n  computed: {\r\n    saveCheckString() {\r\n      const save = GameSaveSerializer.deserialize(this.input);\r\n      const rawString = GameStorage.checkPlayerObject(save);\r\n      // Keep the length bounded; we don't want the modal to be too big for the screen for particularly bad errors\r\n      return rawString.length > 300 ? `${rawString.slice(0, 297)}...` : rawString;\r\n    },\r\n    player() {\r\n      return this.saveCheckString === \"\" ? GameSaveSerializer.deserialize(this.input) : undefined;\r\n    },\r\n    progress() {\r\n      return PlayerProgress.of(this.player);\r\n    },\r\n    fileName() {\r\n      return this.player.options.saveFileName;\r\n    },\r\n    antimatter() {\r\n      return this.player.antimatter || this.player.money;\r\n    },\r\n    infinities() {\r\n      // Infinity count data is stored in either player.infinitied or player.infinities based on if the save is before\r\n      // or after the reality update, and this explicit check is needed as it runs before any migration code.\r\n      const infinityData = this.player.infinitied ? this.player.infinitied : this.player.infinities;\r\n      return new Decimal(infinityData);\r\n    },\r\n    hasInput() {\r\n      return this.input !== \"\";\r\n    },\r\n    inputIsValid() {\r\n      return this.inputIsValidSave || this.inputIsSecret;\r\n    },\r\n    inputIsValidSave() {\r\n      return this.player !== undefined;\r\n    },\r\n    inputIsSecret() {\r\n      return isSecretImport(this.input) || Theme.isSecretTheme(this.input);\r\n    },\r\n    isFromFuture() {\r\n      return this.player.lastUpdate > Date.now();\r\n    },\r\n    lastOpened() {\r\n      const ms = Date.now() - this.player.lastUpdate;\r\n      return this.isFromFuture\r\n        ? `This save is from ${TimeSpan.fromMilliseconds(-ms).toString()} in the future.`\r\n        : `This save was last opened ${TimeSpan.fromMilliseconds(ms).toString()} ago.`;\r\n    },\r\n    offlineType() {\r\n      // We update here in the computed method instead of elsewhere because otherwise it initializes the text\r\n      // to a wrong or undefined setting\r\n      this.updateOfflineSettings();\r\n\r\n      switch (this.offlineImport) {\r\n        case OFFLINE_PROGRESS_TYPE.IMPORTED:\r\n          return \"Using imported save settings\";\r\n        case OFFLINE_PROGRESS_TYPE.LOCAL:\r\n          return \"Using existing save settings\";\r\n        case OFFLINE_PROGRESS_TYPE.IGNORED:\r\n          return \"Will not simulate offline time\";\r\n        default:\r\n          throw new Error(\"Unrecognized offline progress setting for importing\");\r\n      }\r\n    },\r\n    offlineDetails() {\r\n      if (this.offlineImport === OFFLINE_PROGRESS_TYPE.IGNORED) {\r\n        return `Save will be imported without offline progress.`;\r\n      }\r\n      if (!GameStorage.offlineEnabled) return \"This setting will not apply any offline progress after importing.\";\r\n      if (this.isFromFuture) return \"Offline progress cannot be simulated due to an inconsistent system clock time.\";\r\n\r\n      const durationInMs = Date.now() - this.player.lastUpdate;\r\n      const ticks = GameStorage.maxOfflineTicks(durationInMs);\r\n      return `After importing, will simulate ${formatInt(ticks)} ticks of duration\r\n        ${TimeSpan.fromMilliseconds(durationInMs / ticks).toStringShort()} each.`;\r\n    },\r\n    willLoseCosmetics() {\r\n      const currSets = player.reality.glyphs.cosmetics.unlockedFromNG;\r\n      const importedSets = this.player.reality?.glyphs.cosmetics?.unlockedFromNG ?? [];\r\n      return currSets.filter(set => !importedSets.includes(set)).length > 0;\r\n    },\r\n    willLoseSpeedrun() {\r\n      return player.speedrun.isUnlocked && !this.player.speedrun?.isUnlocked;\r\n    }\r\n  },\r\n  mounted() {\r\n    this.$refs.input.select();\r\n  },\r\n  destroyed() {\r\n    // Explicitly setting this to undefined after closing forces the game to fall-back to the stored settings within\r\n    // the player object if this modal is closed - ie. it makes sure actions in the modal don't persist\r\n    GameStorage.offlineEnabled = undefined;\r\n    GameStorage.offlineTicks = undefined;\r\n  },\r\n  methods: {\r\n    changeOfflineSetting() {\r\n      this.offlineImport = (this.offlineImport + 1) % 3;\r\n    },\r\n    updateOfflineSettings() {\r\n      switch (this.offlineImport) {\r\n        case OFFLINE_PROGRESS_TYPE.IMPORTED:\r\n          // These are default values from a new save, used if importing from pre-reality where these props don't exist\r\n          GameStorage.offlineEnabled = this.player.options.offlineProgress ?? true;\r\n          GameStorage.offlineTicks = this.player.options.offlineTicks ?? 1e5;\r\n          break;\r\n        case OFFLINE_PROGRESS_TYPE.LOCAL:\r\n          GameStorage.offlineEnabled = player.options.offlineProgress;\r\n          GameStorage.offlineTicks = player.options.offlineTicks;\r\n          break;\r\n        case OFFLINE_PROGRESS_TYPE.IGNORED:\r\n          GameStorage.offlineEnabled = false;\r\n          break;\r\n      }\r\n    },\r\n    importSave() {\r\n      if (!this.inputIsValid) return;\r\n      this.emitClose();\r\n      GameStorage.import(this.input);\r\n    },\r\n  },\r\n};\r\n</script>\r\n\r\n<template>\r\n  <ModalWrapperChoice\r\n    :show-cancel=\"!inputIsValid\"\r\n    :show-confirm=\"false\"\r\n  >\r\n    <template #header>\r\n      Input your save\r\n    </template>\r\n    <input\r\n      ref=\"input\"\r\n      v-model=\"input\"\r\n      type=\"text\"\r\n      class=\"c-modal-input c-modal-import__input\"\r\n      @keyup.enter=\"importSave\"\r\n      @keyup.esc=\"emitClose\"\r\n    >\r\n    <div class=\"c-modal-import__save-info\">\r\n      <div v-if=\"inputIsSecret\">\r\n        ???\r\n      </div>\r\n      <template v-else-if=\"inputIsValidSave\">\r\n        <div v-if=\"fileName\">\r\n          File name: {{ fileName }}\r\n        </div>\r\n        <div>Antimatter: {{ formatPostBreak(antimatter, 2, 1) }}</div>\r\n        <div v-if=\"progress.isInfinityUnlocked\">\r\n          Infinities: {{ formatPostBreak(infinities, 2) }}\r\n        </div>\r\n        <div v-if=\"progress.isEternityUnlocked\">\r\n          Eternities: {{ formatPostBreak(player.eternities, 2) }}\r\n        </div>\r\n        <div v-if=\"progress.isRealityUnlocked\">\r\n          Realities: {{ formatPostBreak(player.realities, 2) }}\r\n        </div>\r\n        <div v-if=\"progress.hasFullCompletion\">\r\n          Full game completions: {{ formatInt(player.records.fullGameCompletions) }}\r\n        </div>\r\n        <div class=\"c-modal-import__warning\">\r\n          (Your current save file will be overwritten!)\r\n        </div>\r\n        <br>\r\n        <div>\r\n          {{ lastOpened }}\r\n          <div\r\n            class=\"o-primary-btn\"\r\n            @click=\"changeOfflineSetting\"\r\n          >\r\n            Offline Progress: {{ offlineType }}\r\n          </div>\r\n          <span v-html=\"offlineDetails\" />\r\n        </div>\r\n      </template>\r\n      <div v-else-if=\"hasInput\">\r\n        Not a valid save:\r\n        <br>\r\n        {{ saveCheckString }}\r\n      </div>\r\n      <div\r\n        v-if=\"player\"\r\n        class=\"c-modal-hard-reset-danger\"\r\n      >\r\n        <div v-if=\"willLoseCosmetics\">\r\n          <br>\r\n          Glyph cosmetic sets from completing the game are tied to your save.\r\n          <br>\r\n          Importing this save will cause you to lose some sets.\r\n        </div>\r\n        <div v-if=\"willLoseSpeedrun\">\r\n          <br>\r\n          You will lose the ability to do a Speedrun, as this save does not have it unlocked.\r\n        </div>\r\n      </div>\r\n    </div>\r\n\r\n    <PrimaryButton\r\n      v-if=\"inputIsValid\"\r\n      class=\"o-primary-btn--width-medium c-modal-message__okay-btn c-modal__confirm-btn\"\r\n      @click=\"importSave\"\r\n    >\r\n      Import\r\n    </PrimaryButton>\r\n  </ModalWrapperChoice>\r\n</template>"],"sourceRoot":"src/components/modals"},"metadata":{},"sourceType":"module"}