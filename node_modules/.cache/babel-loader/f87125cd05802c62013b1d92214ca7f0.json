{"ast":null,"code":"import \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.reverse.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport { GameMechanicState } from \"../game-mechanics\";\nexport const orderedEffectList = [\"powerpow\", \"infinitypow\", \"replicationpow\", \"timepow\", \"dilationpow\", \"timeshardpow\", \"powermult\", \"powerdimboost\", \"powerbuy10\", \"dilationTTgen\", \"infinityinfmult\", \"infinityIP\", \"timeEP\", \"dilationDT\", \"replicationdtgain\", \"replicationspeed\", \"timeetermult\", \"dilationgalaxyThreshold\", \"infinityrate\", \"replicationglyphlevel\", \"timespeed\", \"effarigrm\", \"effarigglyph\", \"effarigblackhole\", \"effarigachievement\", \"effarigforgotten\", \"effarigdimensions\", \"effarigantimatter\", \"cursedgalaxies\", \"cursedtickspeed\", \"curseddimensions\", \"cursedEP\", \"realityglyphlevel\", \"realitygalaxies\", \"realityrow1pow\", \"realityDTglyph\", \"companiondescription\", \"companionEP\"];\nexport const generatedTypes = [\"power\", \"infinity\", \"replication\", \"time\", \"dilation\", \"effarig\"]; // eslint-disable-next-line no-unused-vars\n\nexport const GlyphEffectOrder = orderedEffectList.mapToObject(e => e, (e, idx) => idx);\nexport function rarityToStrength(x) {\n  return x * 2.5 / 100 + 1;\n}\nexport function strengthToRarity(x) {\n  return (x - 1) * 100 / 2.5;\n}\nexport const Glyphs = {\n  inventory: [],\n  active: [],\n  unseen: [],\n  unequipped: [],\n  levelBoost: 0,\n  factorsOpen: false,\n  bestUndoGlyphCount: 0,\n\n  get inventoryList() {\n    return player.reality.glyphs.inventory;\n  },\n\n  get sortedInventoryList() {\n    return this.inventoryList.sort((a, b) => -a.level * a.strength + b.level * b.strength);\n  },\n\n  get activeList() {\n    return player.reality.glyphs.active;\n  },\n\n  get activeWithoutCompanion() {\n    return this.activeList.filter(g => g.type !== \"companion\");\n  },\n\n  get allGlyphs() {\n    return this.inventoryList.concat(this.activeList);\n  },\n\n  // Returns an array of inventory indices of all glyphs, with all null entries filtered out\n  get glyphIndexArray() {\n    return this.inventory.filter(g => g).map(g => g.idx);\n  },\n\n  findFreeIndex(useProtectedSlots) {\n    this.validate();\n\n    const isUsableIndex = index => useProtectedSlots ? index < this.protectedSlots : index >= this.protectedSlots;\n\n    return this.inventory.findIndex((slot, index) => slot === null && isUsableIndex(index));\n  },\n\n  // This is stored in GameCache and only invalidated if glyphs change; we check for free inventory space often in\n  // lots of places and this is an expensive operation\n  get freeInventorySpace() {\n    this.validate();\n    return this.inventory.filter((e, idx) => e === null && idx >= this.protectedSlots).length;\n  },\n\n  get activeSlotCount() {\n    if (Pelle.isDoomed) {\n      if (PelleRifts.vacuum.milestones[0].canBeApplied) return 1;\n      return 0;\n    }\n\n    return 3 + Effects.sum(RealityUpgrade(9), RealityUpgrade(24));\n  },\n\n  get protectedSlots() {\n    return 10 * player.reality.glyphs.protectedRows;\n  },\n\n  get totalSlots() {\n    return 120;\n  },\n\n  changeProtectedRows(rowChange) {\n    // Always ensure at least one unprotected row for new glyphs, to prevent some potentially odd-looking behavior\n    const newRows = Math.clamp(player.reality.glyphs.protectedRows + rowChange, 0, this.totalSlots / 10 - 1);\n    const rowsToAdd = newRows - player.reality.glyphs.protectedRows;\n\n    if (rowsToAdd > 0) {\n      // Attempt to shift unprotected glyphs downward if there are any empty unprotected rows. The time complexity on\n      // this algorithm isn't that good, but this isn't a particularly hot path and any \"smarter\" algorithms likely\n      // aren't worth the reduced code readability\n      let rowsMoved = 0;\n\n      while (rowsMoved < rowsToAdd) {\n        // Try to shift down all the unprotected rows from top to bottom, repeating until either no shifting is\n        // possible or we've freed up the row\n        let hasMoved = false;\n\n        for (let orig = this.protectedSlots / 10 + rowsMoved; !hasMoved && orig < this.totalSlots / 10; orig++) {\n          hasMoved = hasMoved || this.moveGlyphRow(orig, orig + 1);\n        } // No movement happened this scan; there's nothing else we can do here\n\n\n        if (!hasMoved) break; // Check if the topmost unprotected row is free. This isn't necessarily guaranteed because it could come from\n        // merging lower rows, which means the empty row isn't in the right spot\n\n        if (!this.glyphIndexArray.some(idx => Math.floor(idx / 10) === this.protectedSlots / 10)) {\n          rowsMoved++;\n        }\n      }\n    } else {\n      // Similar algorithm to above; we scan repeatedly over protected slots and repeatedly attempt to free up the row\n      // that's going to switch to being unprotected\n      let rowsMoved = 0;\n\n      while (rowsMoved < -rowsToAdd) {\n        let hasMoved = false;\n\n        for (let orig = this.protectedSlots / 10 - rowsMoved - 1; !hasMoved && orig > 0; orig--) {\n          hasMoved = hasMoved || this.moveGlyphRow(orig, orig - 1);\n        }\n\n        if (!hasMoved) break;\n\n        if (!this.glyphIndexArray.some(idx => Math.floor(idx / 10) === this.protectedSlots / 10 - 1)) {\n          rowsMoved++; // In addition to all the protected glyph movement, we also move the entire unprotected inventory up one row\n\n          for (let orig = this.protectedSlots / 10 - rowsMoved; orig < this.totalSlots / 10; orig++) {\n            this.moveGlyphRow(orig, orig - 1);\n          }\n        }\n      }\n    }\n\n    player.reality.glyphs.protectedRows = newRows;\n    this.validate();\n    GameCache.glyphInventorySpace.invalidate();\n  },\n\n  // Move all glyphs from the origin row to the destination row, does nothing if a column-preserving move operation\n  // isn't possible. Returns a boolean indicating success/failure on glyph moving. Row is 0-indexed\n  moveGlyphRow(orig, dest) {\n    if (!player.reality.moveGlyphsOnProtection) return false;\n    if (orig >= this.totalSlots / 10 || dest >= this.totalSlots / 10) return false;\n\n    if (this.glyphIndexArray.some(idx => Math.floor(idx / 10) === dest)) {\n      // Destination row has some glyphs, attempt to merge the rows\n      const hasOverlap = [...Array(10).keys()].some(col => this.inventory[10 * orig + col] !== null && this.inventory[10 * dest + col] !== null);\n      if (hasOverlap) return false;\n\n      for (let col = 0; col < 10; col++) {\n        const glyph = this.inventory[10 * orig + col];\n\n        if (glyph !== null) {\n          this.moveToSlot(glyph, 10 * dest + col);\n        }\n      }\n\n      this.validate();\n      return true;\n    } // Destination row is empty, just move the glyphs\n\n\n    for (let col = 0; col < 10; col++) {\n      const glyph = this.inventory[10 * orig + col];\n\n      if (glyph !== null) {\n        this.moveToSlot(glyph, 10 * dest + col);\n      }\n    }\n\n    this.validate();\n    return true;\n  },\n\n  refreshActive() {\n    this.active = new Array(this.activeSlotCount).fill(null);\n\n    for (const g of player.reality.glyphs.active) {\n      if (this.active[g.idx]) {\n        throw new Error(\"Stacked active glyphs?\");\n      }\n\n      this.active[g.idx] = g;\n    }\n  },\n\n  refresh() {\n    this.refreshActive();\n    this.inventory = new Array(this.totalSlots).fill(null); // Glyphs could previously end up occupying the same inventory slot (Stacking)\n\n    const stacked = [];\n\n    for (const g of player.reality.glyphs.inventory) {\n      if (this.inventory[g.idx]) {\n        stacked.push(g);\n      } else {\n        this.inventory[g.idx] = g;\n      }\n    } // Try to unstack glyphs:\n\n\n    while (stacked.length) {\n      const freeIndex = this.findFreeIndex();\n\n      if (freeIndex >= 0) {\n        const glyph = stacked.shift();\n        this.inventory[freeIndex] = glyph;\n        glyph.idx = freeIndex;\n      } else {\n        break;\n      }\n    }\n\n    while (stacked.length) {\n      this.removeFromInventory(stacked.pop());\n    }\n\n    this.validate();\n    EventHub.dispatch(GAME_EVENT.GLYPHS_CHANGED);\n  },\n\n  // This compares targetGlyph to all the glyphs in searchList, returning a subset of them which fulfills the comparison\n  // direction specified by the parameters in fuzzyMatch:\n  //  -1: Will find glyphs which are equal to or worse than targetGlyph\n  //   0: Will only return glyphs which have identical values\n  //  +1: Will find glyphs which are equal to or better than targetGlyph\n  findByValues(targetGlyph, searchList, fuzzyMatch = {\n    level,\n    strength,\n    effects\n  }) {\n    // We need comparison to go both ways for normal matching and subset matching for partially-equipped sets\n    const compFn = (op, comp1, comp2) => {\n      switch (op) {\n        case -1:\n          return comp2 - comp1;\n\n        case 0:\n          return comp1 === comp2 ? 0 : -1;\n\n        case 1:\n          return comp1 - comp2;\n      }\n\n      return false;\n    }; // Returns a number based on how much the small mask is found inside of the large mask. Returns a non-negative\n    // number if small contains all of large, with a value equal to the number of extra bits. Otherwise, returns a\n    // negative number equal to the negative of the number of bits that large has which small doesn't.\n\n\n    const matchedEffects = (large, small) => {\n      if ((large & small) === large) return countValuesFromBitmask(small - large);\n      return -countValuesFromBitmask(large - (large & small));\n    }; // Make an array containing all glyphs which match the given criteria, with an additional \"quality\" prop in order\n    // to determine roughly how good the glyph itself is relative to other matches\n\n\n    const allMatches = [];\n\n    for (const glyph of searchList) {\n      const type = glyph.type === targetGlyph.type;\n      let eff;\n\n      switch (fuzzyMatch.effects) {\n        case -1:\n          eff = matchedEffects(glyph.effects, targetGlyph.effects);\n          break;\n\n        case 0:\n          eff = glyph.effects === targetGlyph.effects ? 0 : -1;\n          break;\n\n        case 1:\n          eff = matchedEffects(targetGlyph.effects, glyph.effects);\n          break;\n      }\n\n      const str = compFn(fuzzyMatch.strength, glyph.strength, targetGlyph.strength) / 2.5;\n      const lvl = compFn(fuzzyMatch.level, glyph.level, targetGlyph.level) / 5000;\n      const sym = glyph.symbol === targetGlyph.symbol;\n\n      if (type && eff >= 0 && str >= 0 && lvl >= 0 && sym) {\n        allMatches.push({\n          glyph,\n          // Flatten glyph qualities, with 10% rarity, 500 levels, and an extra effect all being equal value. This\n          // is used to sort the options by some rough measure of distance from the target glyph\n          gap: str + lvl + eff / 10\n        });\n      }\n    } // Sort by increasing gap, then discard the value as it's not directly used anywhere else\n\n\n    allMatches.sort((a, b) => a.gap - b.gap);\n    return allMatches.map(m => m.glyph);\n  },\n\n  findById(id) {\n    return player.reality.glyphs.inventory.find(glyph => glyph.id === id);\n  },\n\n  findByInventoryIndex(inventoryIndex) {\n    return this.inventory[inventoryIndex];\n  },\n\n  activeGlyph(activeIndex) {\n    return this.active[activeIndex];\n  },\n\n  equip(glyph, targetSlot) {\n    const forbiddenByPelle = Pelle.isDisabled(\"glyphs\") || [\"effarig\", \"reality\", \"cursed\"].includes(glyph.type);\n    if (Pelle.isDoomed && forbiddenByPelle) return;\n    if (GameEnd.creditsEverClosed) return;\n\n    if (glyph.type !== \"companion\") {\n      if (RealityUpgrade(9).isLockingMechanics) {\n        if (this.activeWithoutCompanion.length > 0) {\n          RealityUpgrade(9).tryShowWarningModal(\"equip another non-Companion Glyph\");\n          return;\n        }\n\n        if (glyph.level < 3) {\n          RealityUpgrade(9).tryShowWarningModal(`equip a Glyph whose level is less than ${formatInt(3)}`);\n          return;\n        }\n      }\n\n      if (RealityUpgrade(24).isLockingMechanics && this.activeWithoutCompanion.length === 0) {\n        RealityUpgrade(24).tryShowWarningModal();\n        return;\n      }\n\n      if (ImaginaryUpgrade(25).isLockingMechanics && this.activeWithoutCompanion.length === 1) {\n        ImaginaryUpgrade(25).tryShowWarningModal();\n        return;\n      }\n    }\n\n    this.validate();\n\n    if (this.findByInventoryIndex(glyph.idx) !== glyph) {\n      throw new Error(\"Inconsistent inventory indexing\");\n    }\n\n    let sameSpecialTypeIndex = -1;\n\n    if ([\"effarig\", \"reality\"].includes(glyph.type)) {\n      sameSpecialTypeIndex = this.active.findIndex(x => x && x.type === glyph.type);\n    }\n\n    if (this.active[targetSlot] === null) {\n      if (sameSpecialTypeIndex >= 0) {\n        Modal.message.show(`You may only have one ${glyph.type.capitalize()} Glyph equipped!`, {\n          closeEvent: GAME_EVENT.GLYPHS_CHANGED\n        });\n        return;\n      }\n\n      this.removeFromInventory(glyph);\n      this.saveUndo(targetSlot);\n      player.reality.glyphs.active.push(glyph);\n      glyph.idx = targetSlot;\n      this.active[targetSlot] = glyph;\n      this.updateRealityGlyphEffects();\n      this.updateMaxGlyphCount();\n      EventHub.dispatch(GAME_EVENT.GLYPHS_EQUIPPED_CHANGED);\n      EventHub.dispatch(GAME_EVENT.GLYPHS_CHANGED);\n      this.validate();\n    } else {\n      // We can only replace effarig/reality glyph\n      if (sameSpecialTypeIndex >= 0 && sameSpecialTypeIndex !== targetSlot) {\n        Modal.message.show(`You may only have one ${glyph.type.capitalize()} Glyph equipped!`, {\n          closeEvent: GAME_EVENT.GLYPHS_CHANGED\n        });\n        return;\n      }\n\n      if (!player.options.confirmations.glyphReplace) {\n        this.swapIntoActive(glyph, targetSlot);\n        return;\n      }\n\n      Modal.glyphReplace.show({\n        targetSlot,\n        inventoryIndex: glyph.idx\n      });\n    } // Loading glyph sets might directly choose glyphs, bypassing the hover-over flag-clearing code\n\n\n    this.removeVisualFlag(\"unseen\", glyph);\n    this.removeVisualFlag(\"unequipped\", glyph);\n  },\n\n  // We only ever force when draining rifts causes the single slot to be lost (which will never show the modal)\n  unequipAll(forceToUnprotected = false) {\n    this.unequipped = [];\n    const targetRegion = forceToUnprotected ? false : player.options.respecIntoProtected;\n\n    while (player.reality.glyphs.active.length) {\n      const freeIndex = this.findFreeIndex(targetRegion);\n      if (freeIndex < 0) break;\n      const glyph = player.reality.glyphs.active.pop();\n      this.active[glyph.idx] = null;\n      this.addToInventory(glyph, freeIndex, true);\n    }\n\n    this.updateRealityGlyphEffects();\n    this.updateMaxGlyphCount(true); // We need to add a slight delay as a setTimeout in order to make sure that the EventHub calls following this\n    // don't immediately close this modal after it's shown. Additionally, we want to prevent the modal from appearing\n    // for realities shorter than a few seconds in order to stop a UI-based softlock; however at this point the time\n    // has already been reset, so we just use the most recent real time record (this leads to some inconsistent behavior\n    // when restarting, but that's not easily avoidable)\n\n    const stillEquipped = player.reality.glyphs.active.length;\n    const fastReality = player.records.recentRealities[0][1] < 3000;\n\n    if (stillEquipped && !fastReality) {\n      const target = player.options.respecIntoProtected ? \"Protected slots\" : \"Main Inventory\";\n      const hasOther = this.findFreeIndex(!player.options.respecIntoProtected) !== -1;\n      setTimeout(() => Modal.message.show(`${quantifyInt(\"Glyph\", stillEquipped)} could not be unequipped due to lack\n        of space. Free up some space in your ${target}${hasOther ? \" or switch where you are unequipping to\" : \"\"}\n        in order to unequip ${stillEquipped === 1 ? \"it\" : \"them\"}.`, {\n        closeEvent: GAME_EVENT.GLYPHS_CHANGED\n      }), 50);\n    }\n\n    EventHub.dispatch(GAME_EVENT.GLYPHS_EQUIPPED_CHANGED);\n    EventHub.dispatch(GAME_EVENT.GLYPHS_CHANGED);\n    return !player.reality.glyphs.active.length;\n  },\n\n  unequip(activeIndex, requestedInventoryIndex) {\n    if (this.active[activeIndex] === null) return;\n    const storedIndex = player.reality.glyphs.active.findIndex(glyph => glyph.idx === activeIndex);\n    if (storedIndex < 0) return;\n    const glyph = player.reality.glyphs.active.splice(storedIndex, 1)[0];\n    this.active[activeIndex] = null;\n    this.addToInventory(glyph, requestedInventoryIndex, true);\n    this.updateRealityGlyphEffects();\n    this.updateMaxGlyphCount(true);\n    EventHub.dispatch(GAME_EVENT.GLYPHS_EQUIPPED_CHANGED);\n    EventHub.dispatch(GAME_EVENT.GLYPHS_CHANGED);\n  },\n\n  updateRealityGlyphEffects() {\n    // There should only be one reality glyph; this picks one pseudo-randomly if multiple are cheated/glitched in\n    const realityGlyph = player.reality.glyphs.active.filter(g => g.type === \"reality\")[0];\n\n    if (realityGlyph === undefined) {\n      this.levelBoost = 0;\n      return;\n    } // The cache at this point may not be correct yet (if we're importing a save),\n    // so we use the uncached value.\n\n\n    this.levelBoost = getAdjustedGlyphEffectUncached(\"realityglyphlevel\");\n  },\n\n  moveToSlot(glyph, targetSlot) {\n    if (this.inventory[targetSlot] === null) this.moveToEmpty(glyph, targetSlot);else this.swap(glyph, this.inventory[targetSlot]);\n  },\n\n  moveToEmpty(glyph, targetSlot) {\n    this.validate();\n\n    if (this.findByInventoryIndex(glyph.idx) !== glyph) {\n      throw new Error(\"Inconsistent inventory indexing\");\n    }\n\n    if (this.inventory[targetSlot] === null) {\n      this.inventory[glyph.idx] = null;\n      this.inventory[targetSlot] = glyph;\n      glyph.idx = targetSlot;\n      EventHub.dispatch(GAME_EVENT.GLYPHS_CHANGED);\n    } else {\n      throw new Error(\"Attempted glyph move into non-empty slot\");\n    }\n\n    this.validate();\n  },\n\n  swap(glyphA, glyphB) {\n    if (glyphA.idx === glyphB.idx) return;\n    this.validate();\n    this.inventory[glyphA.idx] = glyphB;\n    this.inventory[glyphB.idx] = glyphA;\n    const swapGlyph = glyphA.idx;\n    glyphA.idx = glyphB.idx;\n    glyphB.idx = swapGlyph;\n    this.validate();\n    EventHub.dispatch(GAME_EVENT.GLYPHS_CHANGED);\n  },\n\n  addToInventory(glyph, requestedInventoryIndex, isExistingGlyph = false) {\n    this.validate();\n    if (!isExistingGlyph) glyph.id = GlyphGenerator.makeID();\n    const isProtectedIndex = requestedInventoryIndex < this.protectedSlots;\n    let index = this.findFreeIndex(isProtectedIndex);\n    if (index < 0) return;\n\n    if (requestedInventoryIndex !== undefined) {\n      if (this.inventory[requestedInventoryIndex] === null) index = requestedInventoryIndex;\n    }\n\n    this.inventory[index] = glyph;\n    glyph.idx = index; // This is done here when adding to the inventory in order to keep it out of the glyph generation hot path\n    // It thus doesn't show up in manually choosing a glyph\n    // This also only does anything if Ra has the appropriate unlock already.\n\n    this.applyGamespeed(glyph); // This should only apply to glyphs you actually choose, so can't be done in glyph generation.\n    // Sometimes a glyph you already have is added to the inventory (for example, unequipping),\n    // but that's not an issue because then this line just won't do anything, which is fine.\n\n    player.records.bestReality.glyphStrength = Math.clampMin(player.records.bestReality.glyphStrength, glyph.strength);\n    player.reality.glyphs.inventory.push(glyph);\n    if (requestedInventoryIndex === undefined && !isExistingGlyph) this.addVisualFlag(\"unseen\", glyph);\n    if (isExistingGlyph) this.addVisualFlag(\"unequipped\", glyph);\n    EventHub.dispatch(GAME_EVENT.GLYPHS_CHANGED);\n    this.validate();\n  },\n\n  // These two visual flag functions update the corner tooltips for \"New!\" and unequipped glyphs\n  addVisualFlag(target, glyph) {\n    if (!this[target].includes(glyph.id)) this[target].push(glyph.id);\n  },\n\n  removeVisualFlag(target, glyph) {\n    const index = Glyphs[target].indexOf(glyph.id);\n    if (index > -1) Glyphs[target].splice(index, 1);\n  },\n\n  isMusicGlyph(glyph) {\n    return (glyph === null || glyph === void 0 ? void 0 : glyph.cosmetic) === \"music\";\n  },\n\n  removeFromInventory(glyph) {\n    // This can get called on a glyph not in inventory, during auto sacrifice.\n    if (glyph.idx === null) return;\n    this.validate();\n    const index = player.reality.glyphs.inventory.indexOf(glyph);\n    if (index < 0) return;\n    this.inventory[glyph.idx] = null;\n    player.reality.glyphs.inventory.splice(index, 1);\n    EventHub.dispatch(GAME_EVENT.GLYPHS_CHANGED);\n    this.validate();\n  },\n\n  validate() {\n    for (const glyph of player.reality.glyphs.inventory) {\n      if (this.inventory[glyph.idx] !== glyph) {\n        throw new Error(\"validation error\");\n      }\n    }\n\n    for (let i = 0; i < this.inventory.length; ++i) {\n      if (this.inventory[i] && this.inventory[i].idx !== i) {\n        throw new Error(\"backwards validation error\");\n      }\n    }\n  },\n\n  sort(sortFunction) {\n    const glyphsToSort = player.reality.glyphs.inventory.filter(g => g.idx >= this.protectedSlots);\n    const freeSpace = GameCache.glyphInventorySpace.value;\n    const sortOrder = [\"power\", \"infinity\", \"replication\", \"time\", \"dilation\", \"effarig\", \"reality\", \"cursed\", \"companion\"];\n    const byType = sortOrder.mapToObject(g => g, () => ({\n      glyphs: [],\n      padding: 0\n    }));\n\n    for (const g of glyphsToSort) byType[g.type].glyphs.push(g);\n\n    let totalDesiredPadding = 0;\n\n    for (const t of Object.values(byType)) {\n      t.glyphs.sort(sortFunction);\n      t.padding = Math.ceil(t.glyphs.length / 10) * 10 - t.glyphs.length;\n      totalDesiredPadding += t.padding;\n    } // If we want more padding than we actually have available, trim it down until it fits\n\n\n    while (totalDesiredPadding > freeSpace) {\n      let biggestPadding = sortOrder[0];\n\n      for (const t of sortOrder) {\n        if (byType[t].padding > byType[biggestPadding].padding) biggestPadding = t;\n      } // Try to remove padding 5 at a time if possible\n\n\n      const delta = byType[biggestPadding].padding > 5 ? 5 : 1;\n      totalDesiredPadding -= delta;\n      byType[biggestPadding].padding -= delta;\n    }\n\n    let outIndex = this.protectedSlots;\n\n    for (const t of Object.values(byType)) {\n      for (const g of t.glyphs) {\n        if (this.inventory[outIndex]) this.swap(this.inventory[outIndex], g);else this.moveToEmpty(g, outIndex);\n        ++outIndex;\n      }\n\n      outIndex += t.padding;\n    }\n\n    if (player.reality.autoCollapse) this.collapseEmptySlots();\n  },\n\n  sortByLevel() {\n    this.sort((a, b) => b.level - a.level);\n  },\n\n  sortByPower() {\n    this.sort((a, b) => b.level * b.strength - a.level * a.strength);\n  },\n\n  sortByScore() {\n    this.sort((a, b) => AutoGlyphProcessor.filterValue(b) - AutoGlyphProcessor.filterValue(a));\n  },\n\n  sortByEffect() {\n    function reverseBitstring(eff) {\n      return parseInt(((1 << 30) + (eff >>> 0)).toString(2).split(\"\").reverse().join(\"\"), 2);\n    } // The bitwise reversal is so that the effects with the LOWER id are valued higher in the sorting.\n    // This primarily meant for effarig glyph effect sorting, which makes it prioritize timespeed pow highest.\n\n\n    this.sort((a, b) => reverseBitstring(b.effects) - reverseBitstring(a.effects));\n  },\n\n  // If there are enough glyphs that are better than the specified glyph, in every way, then\n  // the glyph is objectively a useless piece of garbage.\n  isObjectivelyUseless(glyph, threshold, inventoryIn) {\n    if (player.reality.applyFilterToPurge && AutoGlyphProcessor.wouldKeep(glyph)) return false;\n\n    function hasSomeBetterEffects(glyphA, glyphB, comparedEffects) {\n      for (const effect of comparedEffects) {\n        const c = effect.compareValues(effect.effect(glyphA.level, glyphA.strength), effect.effect(glyphB.level, glyphB.strength)); // If the glyph in question is better in even one effect, it passes this comparison\n\n        if (c > 0) return true;\n      }\n\n      return false;\n    }\n\n    const toCompare = (inventoryIn !== null && inventoryIn !== void 0 ? inventoryIn : this.inventory).concat(this.active).filter(g => g !== null && g.type === glyph.type && g.id !== glyph.id && (g.level >= glyph.level || g.strength >= glyph.strength) && (g.effects & glyph.effects) === glyph.effects);\n    let compareThreshold = glyph.type === \"effarig\" || glyph.type === \"reality\" ? 1 : 5;\n    compareThreshold = Math.clampMax(compareThreshold, threshold);\n    if (toCompare.length < compareThreshold) return false;\n    const comparedEffects = getGlyphEffectsFromBitmask(glyph.effects).filter(x => x.id.startsWith(glyph.type));\n    const betterCount = toCompare.countWhere(other => !hasSomeBetterEffects(glyph, other, comparedEffects));\n    return betterCount >= compareThreshold;\n  },\n\n  // Note that this same function is called with different parameters for purge (5), harsh purge (1), and sac all (0)\n  // If deleteGlyphs === false, we are running this from the modal and are doing so purely to *count* the number of\n  // removed glyphs. In this case, we copy the inventory and run the purge on the copy - we need to be able to remove\n  // glyphs as we go, or else the purge logic will be wrong (eg. 7 identical glyphs will all be \"worse than 5 others\")\n  autoClean(threshold = 5, deleteGlyphs = true) {\n    const isHarsh = threshold < 5;\n    let toBeDeleted = 0;\n    const inventoryCopy = deleteGlyphs ? undefined : this.fakePurgeInventory(); // If the player hasn't unlocked sacrifice yet, prevent them from removing any glyphs.\n\n    if (!GlyphSacrificeHandler.canSacrifice) return toBeDeleted; // We look in backwards order so that later glyphs get cleaned up first\n\n    for (let inventoryIndex = this.totalSlots - 1; inventoryIndex >= this.protectedSlots; --inventoryIndex) {\n      const glyph = (inventoryCopy !== null && inventoryCopy !== void 0 ? inventoryCopy : this.inventory)[inventoryIndex]; // Never clean companion, and only clean cursed if we choose to sacrifice all\n\n      if (glyph === null || glyph.type === \"companion\" || glyph.type === \"cursed\" && threshold !== 0) continue; // Don't auto-clean custom glyphs (eg. music glyphs) unless it's harsh or delete all\n\n      const isCustomGlyph = glyph.color !== undefined || glyph.symbol !== undefined;\n      if (isCustomGlyph && !isHarsh) continue; // If the threshold for better glyphs needed is zero, the glyph is definitely getting deleted\n      // no matter what (well, unless it can't be gotten rid of in current glyph removal mode).\n\n      if (threshold === 0 || this.isObjectivelyUseless(glyph, threshold, inventoryCopy)) {\n        if (deleteGlyphs) AutoGlyphProcessor.getRidOfGlyph(glyph);else inventoryCopy.splice(inventoryCopy.indexOf(glyph), 1);\n        toBeDeleted++;\n      }\n    }\n\n    if (player.reality.autoCollapse && deleteGlyphs) this.collapseEmptySlots();\n    return toBeDeleted;\n  },\n\n  // Similar to copyForRecords, except that it also preserves null entries, passes on the IDs, and doesn't\n  // sort the glyphs; these are all necessary for the purge logic to work correctly\n  fakePurgeInventory() {\n    return this.inventory.map(g => g === null ? null : {\n      id: g.id,\n      type: g.type,\n      level: g.level,\n      strength: g.strength,\n      effects: g.effects,\n      color: g.color,\n      symbol: g.symbol\n    });\n  },\n\n  harshAutoClean() {\n    this.autoClean(1);\n  },\n\n  deleteAllUnprotected() {\n    this.autoClean(0);\n  },\n\n  deleteAllRejected(deleteGlyphs = true) {\n    let toBeDeleted = 0;\n\n    for (const glyph of Glyphs.inventory) {\n      if (glyph !== null && glyph.idx >= this.protectedSlots && !AutoGlyphProcessor.wouldKeep(glyph)) {\n        if (deleteGlyphs) AutoGlyphProcessor.getRidOfGlyph(glyph);\n        toBeDeleted++;\n      }\n    }\n\n    if (player.reality.autoCollapse && deleteGlyphs) this.collapseEmptySlots();\n    return toBeDeleted;\n  },\n\n  collapseEmptySlots() {\n    const unprotectedGlyphs = player.reality.glyphs.inventory.filter(g => g.idx >= this.protectedSlots).sort((a, b) => a.idx - b.idx);\n\n    for (let index = 0; index < unprotectedGlyphs.length; index++) {\n      this.moveToSlot(unprotectedGlyphs[index], this.protectedSlots + index);\n    }\n  },\n\n  processSortingAfterReality() {\n    if (VUnlocks.autoAutoClean.canBeApplied && player.reality.autoAutoClean) this.autoClean();\n\n    switch (player.reality.autoSort) {\n      case AUTO_SORT_MODE.NONE:\n        break;\n\n      case AUTO_SORT_MODE.LEVEL:\n        this.sortByLevel();\n        break;\n\n      case AUTO_SORT_MODE.POWER:\n        this.sortByPower();\n        break;\n\n      case AUTO_SORT_MODE.EFFECT:\n        this.sortByEffect();\n        break;\n\n      case AUTO_SORT_MODE.SCORE:\n        this.sortByScore();\n        break;\n\n      default:\n        throw new Error(\"Unrecognized auto-sort mode\");\n    }\n  },\n\n  get levelCap() {\n    return 1000000;\n  },\n\n  get instabilityThreshold() {\n    return 1000 + getAdjustedGlyphEffect(\"effarigglyph\") + ImaginaryUpgrade(7).effectOrDefault(0);\n  },\n\n  get hyperInstabilityThreshold() {\n    return 3000 + this.instabilityThreshold;\n  },\n\n  clearUndo() {\n    player.reality.glyphs.undo = [];\n  },\n\n  saveUndo(targetSlot) {\n    const undoData = {\n      targetSlot,\n      am: new Decimal(Currency.antimatter.value),\n      ip: new Decimal(Currency.infinityPoints.value),\n      ep: new Decimal(Currency.eternityPoints.value),\n      tt: Currency.timeTheorems.max.minus(TimeTheorems.totalPurchased()),\n      ecs: EternityChallenges.all.map(e => e.completions),\n      thisInfinityTime: player.records.thisInfinity.time,\n      thisInfinityRealTime: player.records.thisInfinity.realTime,\n      thisEternityTime: player.records.thisEternity.time,\n      thisEternityRealTime: player.records.thisEternity.realTime,\n      thisRealityTime: player.records.thisReality.time,\n      thisRealityRealTime: player.records.thisReality.realTime,\n      storedTime: player.celestials.enslaved.stored,\n      dilationStudies: player.dilation.studies.toBitmask(),\n      dilationUpgrades: player.dilation.upgrades.toBitmask(),\n      dilationRebuyables: DilationUpgrades.rebuyable.mapToObject(d => d.id, d => d.boughtAmount),\n      tp: new Decimal(Currency.tachyonParticles.value),\n      dt: new Decimal(Currency.dilatedTime.value)\n    };\n    player.reality.glyphs.undo.push(undoData);\n  },\n\n  undo() {\n    const inventorySlot = Glyphs.findFreeIndex(player.options.respecIntoProtected);\n    if (inventorySlot === -1 || player.reality.glyphs.undo.length === 0) return;\n    const undoData = player.reality.glyphs.undo.pop(); // We store this value here so that we can restore it later on in the reality reset code, since we immediately\n    // change equipped glyph status here but only update requirement checks within finishProcessReality()\n\n    this.bestUndoGlyphCount = player.requirementChecks.reality.maxGlyphs;\n    this.unequip(undoData.targetSlot, inventorySlot);\n    finishProcessReality({\n      reset: true,\n      glyphUndo: true,\n      restoreCelestialState: true\n    });\n    Currency.antimatter.value = new Decimal(undoData.am);\n    Currency.infinityPoints.value = new Decimal(undoData.ip);\n    Currency.eternityPoints.value = new Decimal(undoData.ep);\n    Currency.timeTheorems.value = new Decimal(undoData.tt);\n    EternityChallenges.all.map((ec, ecIndex) => ec.completions = undoData.ecs[ecIndex]);\n    player.records.thisInfinity.time = undoData.thisInfinityTime;\n    player.records.thisInfinity.realTime = undoData.thisInfinityRealTime;\n    player.records.thisEternity.time = undoData.thisEternityTime;\n    player.records.thisEternity.realTime = undoData.thisEternityRealTime;\n    player.records.thisReality.time = undoData.thisRealityTime;\n    player.records.thisReality.realTime = undoData.thisRealityRealTime;\n    player.celestials.enslaved.stored = undoData.storedTime || 0;\n\n    if (undoData.dilationStudies) {\n      player.dilation.studies = Array.fromBitmask(undoData.dilationStudies);\n      player.dilation.upgrades = new Set(Array.fromBitmask(undoData.dilationUpgrades));\n\n      for (const id of Object.keys(undoData.dilationRebuyables)) {\n        DilationUpgrades.fromId(id).boughtAmount = undoData.dilationRebuyables[id];\n      }\n\n      Currency.tachyonParticles.value = new Decimal(undoData.tp);\n      Currency.dilatedTime.value = new Decimal(undoData.dt);\n    }\n\n    if (Player.automatorUnlocked && AutomatorBackend.state.forceRestart) {\n      AutomatorBackend.start(player.reality.automator.state.editorScript);\n    }\n  },\n\n  copyForRecords(glyphList) {\n    // Sorting by effect ensures consistent ordering by type, based on how the effect bitmasks are structured\n    return glyphList.map(g => ({\n      type: g.type,\n      level: g.level,\n      strength: g.strength,\n      effects: g.effects,\n      color: g.color,\n      symbol: g.symbol\n    })).sort((a, b) => b.effects - a.effects);\n  },\n\n  // Normal glyph count minus 3 for each cursed glyph, uses 4 instead of 3 in the calculation because cursed glyphs\n  // still contribute to the length of the active list. Note that it only ever decreases if startingReality is true.\n  updateMaxGlyphCount(startingReality = false) {\n    const activeGlyphList = this.activeWithoutCompanion;\n    const currCount = activeGlyphList.length - 4 * activeGlyphList.filter(x => x && x.type === \"cursed\").length;\n    if (startingReality) player.requirementChecks.reality.maxGlyphs = currCount;\n    player.requirementChecks.reality.maxGlyphs = Math.max(player.requirementChecks.reality.maxGlyphs, currCount);\n  },\n\n  // Modifies a basic glyph to have timespeed, and adds the new effect to time glyphs\n  applyGamespeed(glyph) {\n    if (!Ra.unlocks.allGamespeedGlyphs.canBeApplied) return;\n\n    if (BASIC_GLYPH_TYPES.includes(glyph.type)) {\n      glyph.effects |= 1 << GlyphEffects.timespeed.bitmaskIndex;\n\n      if (glyph.type === \"time\") {\n        glyph.effects |= 1 << GlyphEffects.timeshardpow.bitmaskIndex;\n      }\n    }\n  },\n\n  swapIntoActive(glyph, targetSlot) {\n    this.removeFromInventory(glyph);\n    this.unequip(targetSlot, glyph.idx);\n    finishProcessReality({\n      reset: true,\n      glyphUndo: false,\n      restoreCelestialState: true\n    });\n    player.reality.glyphs.active.push(glyph);\n    this.active[targetSlot] = glyph;\n    glyph.idx = targetSlot;\n    this.updateRealityGlyphEffects();\n    this.updateMaxGlyphCount(true);\n    EventHub.dispatch(GAME_EVENT.GLYPHS_EQUIPPED_CHANGED);\n    EventHub.dispatch(GAME_EVENT.GLYPHS_CHANGED);\n    this.validate();\n  },\n\n  // Mostly used for key-swapping glyph set UI elements; composites the entire glyph set together in a way which is\n  // relatively unlikely to cause collisions between different glyph sets unless they're actually the same glyphs.\n  // Different permutations of the same glyphs should produce the same hash, but aren't guaranteed to\n  hash(glyphSet) {\n    let hash = 1;\n\n    for (const glyph of glyphSet) {\n      // This should be at most around e23 or so in practice\n      const singleGlyphHash = Math.pow(glyph.level, 2) * Math.pow(glyph.strength, 4) * glyph.effects * glyph.type.charCodeAt(0);\n      hash *= singleGlyphHash;\n    }\n\n    return hash;\n  },\n\n  giveCursedGlyph() {\n    if (GameCache.glyphInventorySpace.value === 0) {\n      Modal.message.show(\"No available inventory space; Sacrifice some Glyphs to free up space.\", {\n        closeEvent: GAME_EVENT.GLYPHS_CHANGED\n      });\n      return;\n    }\n\n    const cursedCount = this.allGlyphs.filter(g => g !== null && g.type === \"cursed\").length;\n\n    if (cursedCount >= 5) {\n      GameUI.notify.error(`You don't need more than ${format(5)} Cursed Glyphs!`);\n    } else {\n      this.addToInventory(GlyphGenerator.cursedGlyph());\n      GameUI.notify.error(\"Created a Cursed Glyph\");\n    }\n  }\n\n};\n\nclass GlyphSacrificeState extends GameMechanicState {}\n\nexport const GlyphSacrifice = mapGameDataToObject(GameDatabase.reality.glyphSacrifice, config => new GlyphSacrificeState(config));\nexport function recalculateAllGlyphs() {\n  for (let i = 0; i < player.reality.glyphs.active.length; i++) {\n    calculateGlyph(player.reality.glyphs.active[i]);\n  } // Delete any glyphs that are in overflow spots:\n\n\n  player.reality.glyphs.inventory = player.reality.glyphs.inventory.filter(glyph => glyph.idx < Glyphs.totalSlots);\n\n  for (let i = 0; i < player.reality.glyphs.inventory.length; i++) {\n    calculateGlyph(player.reality.glyphs.inventory[i]);\n  }\n\n  Glyphs.updateRealityGlyphEffects();\n  Glyphs.refresh();\n} // Makes sure level is a positive whole number and rarity is >0% (retroactive fixes) and recalculates effects\n\nexport function calculateGlyph(glyph) {\n  if (glyph.color === undefined && glyph.symbol === undefined) {\n    glyph.level = Math.max(1, Math.round(glyph.level));\n\n    if (glyph.rawLevel === undefined) {\n      // Only correct below the second round of instability, but it only matters for glyphs produced before\n      // this was merged, so it's not a big deal.\n      glyph.rawLevel = glyph.level < 1000 ? glyph.level : (Math.pow(0.004 * glyph.level - 3, 2) - 1) * 125 + 1000;\n    } // Used to randomly generate strength in this case; I don't think we actually care.\n\n\n    if (glyph.strength === 1) glyph.strength = 1.5;\n    glyph.strength = Math.min(rarityToStrength(100), glyph.strength);\n  }\n}\nexport function getRarity(x) {\n  return GlyphRarities.find(e => x >= e.minStrength);\n}\nexport function getAdjustedGlyphLevel(glyph, realityGlyphBoost = Glyphs.levelBoost, ignoreCelestialEffects = false) {\n  const level = glyph.level;\n\n  if (!ignoreCelestialEffects) {\n    if (Pelle.isDoomed) return Math.min(level, Pelle.glyphMaxLevel);\n    if (Enslaved.isRunning) return Math.max(level, Enslaved.glyphLevelMin);\n    if (Effarig.isRunning) return Math.min(level, Effarig.glyphLevelCap);\n  }\n\n  if (BASIC_GLYPH_TYPES.includes(glyph.type)) return level + realityGlyphBoost;\n  return level;\n}\nexport function respecGlyphs() {\n  if (!Glyphs.unequipAll()) {\n    Modal.message.show(\"Some of your Glyphs could not be unequipped due to lack of inventory space.\", {\n      closeEvent: GAME_EVENT.GLYPHS_CHANGED\n    });\n  }\n\n  player.reality.respec = false;\n}","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/glyphs/glyph-core.js"],"names":["GameMechanicState","orderedEffectList","generatedTypes","GlyphEffectOrder","mapToObject","e","idx","rarityToStrength","x","strengthToRarity","Glyphs","inventory","active","unseen","unequipped","levelBoost","factorsOpen","bestUndoGlyphCount","inventoryList","player","reality","glyphs","sortedInventoryList","sort","a","b","level","strength","activeList","activeWithoutCompanion","filter","g","type","allGlyphs","concat","glyphIndexArray","map","findFreeIndex","useProtectedSlots","validate","isUsableIndex","index","protectedSlots","findIndex","slot","freeInventorySpace","length","activeSlotCount","Pelle","isDoomed","PelleRifts","vacuum","milestones","canBeApplied","Effects","sum","RealityUpgrade","protectedRows","totalSlots","changeProtectedRows","rowChange","newRows","Math","clamp","rowsToAdd","rowsMoved","hasMoved","orig","moveGlyphRow","some","floor","GameCache","glyphInventorySpace","invalidate","dest","moveGlyphsOnProtection","hasOverlap","Array","keys","col","glyph","moveToSlot","refreshActive","fill","Error","refresh","stacked","push","freeIndex","shift","removeFromInventory","pop","EventHub","dispatch","GAME_EVENT","GLYPHS_CHANGED","findByValues","targetGlyph","searchList","fuzzyMatch","effects","compFn","op","comp1","comp2","matchedEffects","large","small","countValuesFromBitmask","allMatches","eff","str","lvl","sym","symbol","gap","m","findById","id","find","findByInventoryIndex","inventoryIndex","activeGlyph","activeIndex","equip","targetSlot","forbiddenByPelle","isDisabled","includes","GameEnd","creditsEverClosed","isLockingMechanics","tryShowWarningModal","formatInt","ImaginaryUpgrade","sameSpecialTypeIndex","Modal","message","show","capitalize","closeEvent","saveUndo","updateRealityGlyphEffects","updateMaxGlyphCount","GLYPHS_EQUIPPED_CHANGED","options","confirmations","glyphReplace","swapIntoActive","removeVisualFlag","unequipAll","forceToUnprotected","targetRegion","respecIntoProtected","addToInventory","stillEquipped","fastReality","records","recentRealities","target","hasOther","setTimeout","quantifyInt","unequip","requestedInventoryIndex","storedIndex","splice","realityGlyph","undefined","getAdjustedGlyphEffectUncached","moveToEmpty","swap","glyphA","glyphB","swapGlyph","isExistingGlyph","GlyphGenerator","makeID","isProtectedIndex","applyGamespeed","bestReality","glyphStrength","clampMin","addVisualFlag","indexOf","isMusicGlyph","cosmetic","i","sortFunction","glyphsToSort","freeSpace","value","sortOrder","byType","padding","totalDesiredPadding","t","Object","values","ceil","biggestPadding","delta","outIndex","autoCollapse","collapseEmptySlots","sortByLevel","sortByPower","sortByScore","AutoGlyphProcessor","filterValue","sortByEffect","reverseBitstring","parseInt","toString","split","reverse","join","isObjectivelyUseless","threshold","inventoryIn","applyFilterToPurge","wouldKeep","hasSomeBetterEffects","comparedEffects","effect","c","compareValues","toCompare","compareThreshold","clampMax","getGlyphEffectsFromBitmask","startsWith","betterCount","countWhere","other","autoClean","deleteGlyphs","isHarsh","toBeDeleted","inventoryCopy","fakePurgeInventory","GlyphSacrificeHandler","canSacrifice","isCustomGlyph","color","getRidOfGlyph","harshAutoClean","deleteAllUnprotected","deleteAllRejected","unprotectedGlyphs","processSortingAfterReality","VUnlocks","autoAutoClean","autoSort","AUTO_SORT_MODE","NONE","LEVEL","POWER","EFFECT","SCORE","levelCap","instabilityThreshold","getAdjustedGlyphEffect","effectOrDefault","hyperInstabilityThreshold","clearUndo","undo","undoData","am","Decimal","Currency","antimatter","ip","infinityPoints","ep","eternityPoints","tt","timeTheorems","max","minus","TimeTheorems","totalPurchased","ecs","EternityChallenges","all","completions","thisInfinityTime","thisInfinity","time","thisInfinityRealTime","realTime","thisEternityTime","thisEternity","thisEternityRealTime","thisRealityTime","thisReality","thisRealityRealTime","storedTime","celestials","enslaved","stored","dilationStudies","dilation","studies","toBitmask","dilationUpgrades","upgrades","dilationRebuyables","DilationUpgrades","rebuyable","d","boughtAmount","tp","tachyonParticles","dt","dilatedTime","inventorySlot","requirementChecks","maxGlyphs","finishProcessReality","reset","glyphUndo","restoreCelestialState","ec","ecIndex","fromBitmask","Set","fromId","Player","automatorUnlocked","AutomatorBackend","state","forceRestart","start","automator","editorScript","copyForRecords","glyphList","startingReality","activeGlyphList","currCount","Ra","unlocks","allGamespeedGlyphs","BASIC_GLYPH_TYPES","GlyphEffects","timespeed","bitmaskIndex","timeshardpow","hash","glyphSet","singleGlyphHash","pow","charCodeAt","giveCursedGlyph","cursedCount","GameUI","notify","error","format","cursedGlyph","GlyphSacrificeState","GlyphSacrifice","mapGameDataToObject","GameDatabase","glyphSacrifice","config","recalculateAllGlyphs","calculateGlyph","round","rawLevel","min","getRarity","GlyphRarities","minStrength","getAdjustedGlyphLevel","realityGlyphBoost","ignoreCelestialEffects","glyphMaxLevel","Enslaved","isRunning","glyphLevelMin","Effarig","glyphLevelCap","respecGlyphs","respec"],"mappings":"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","sourcesContent":["import { GameMechanicState } from \"../game-mechanics\";\r\n\r\nexport const orderedEffectList = [\"powerpow\", \"infinitypow\", \"replicationpow\", \"timepow\",\r\n  \"dilationpow\", \"timeshardpow\", \"powermult\", \"powerdimboost\", \"powerbuy10\",\r\n  \"dilationTTgen\", \"infinityinfmult\", \"infinityIP\", \"timeEP\",\r\n  \"dilationDT\", \"replicationdtgain\", \"replicationspeed\",\r\n  \"timeetermult\", \"dilationgalaxyThreshold\", \"infinityrate\", \"replicationglyphlevel\",\r\n  \"timespeed\",\r\n  \"effarigrm\", \"effarigglyph\", \"effarigblackhole\", \"effarigachievement\",\r\n  \"effarigforgotten\", \"effarigdimensions\", \"effarigantimatter\",\r\n  \"cursedgalaxies\", \"cursedtickspeed\", \"curseddimensions\", \"cursedEP\",\r\n  \"realityglyphlevel\", \"realitygalaxies\", \"realityrow1pow\", \"realityDTglyph\",\r\n  \"companiondescription\", \"companionEP\"];\r\n\r\nexport const generatedTypes = [\"power\", \"infinity\", \"replication\", \"time\", \"dilation\", \"effarig\"];\r\n\r\n// eslint-disable-next-line no-unused-vars\r\nexport const GlyphEffectOrder = orderedEffectList.mapToObject(e => e, (e, idx) => idx);\r\n\r\nexport function rarityToStrength(x) {\r\n  return x * 2.5 / 100 + 1;\r\n}\r\n\r\nexport function strengthToRarity(x) {\r\n  return (x - 1) * 100 / 2.5;\r\n}\r\n\r\nexport const Glyphs = {\r\n  inventory: [],\r\n  active: [],\r\n  unseen: [],\r\n  unequipped: [],\r\n  levelBoost: 0,\r\n  factorsOpen: false,\r\n  bestUndoGlyphCount: 0,\r\n  get inventoryList() {\r\n    return player.reality.glyphs.inventory;\r\n  },\r\n  get sortedInventoryList() {\r\n    return this.inventoryList.sort((a, b) => -a.level * a.strength + b.level * b.strength);\r\n  },\r\n  get activeList() {\r\n    return player.reality.glyphs.active;\r\n  },\r\n  get activeWithoutCompanion() {\r\n    return this.activeList.filter(g => g.type !== \"companion\");\r\n  },\r\n  get allGlyphs() {\r\n    return this.inventoryList.concat(this.activeList);\r\n  },\r\n  // Returns an array of inventory indices of all glyphs, with all null entries filtered out\r\n  get glyphIndexArray() {\r\n    return this.inventory.filter(g => g).map(g => g.idx);\r\n  },\r\n  findFreeIndex(useProtectedSlots) {\r\n    this.validate();\r\n    const isUsableIndex = index => (useProtectedSlots ? index < this.protectedSlots : index >= this.protectedSlots);\r\n    return this.inventory.findIndex((slot, index) => slot === null && isUsableIndex(index));\r\n  },\r\n  // This is stored in GameCache and only invalidated if glyphs change; we check for free inventory space often in\r\n  // lots of places and this is an expensive operation\r\n  get freeInventorySpace() {\r\n    this.validate();\r\n    return this.inventory.filter((e, idx) => e === null && idx >= this.protectedSlots).length;\r\n  },\r\n  get activeSlotCount() {\r\n    if (Pelle.isDoomed) {\r\n      if (PelleRifts.vacuum.milestones[0].canBeApplied) return 1;\r\n      return 0;\r\n    }\r\n    return 3 + Effects.sum(RealityUpgrade(9), RealityUpgrade(24));\r\n  },\r\n  get protectedSlots() {\r\n    return 10 * player.reality.glyphs.protectedRows;\r\n  },\r\n  get totalSlots() {\r\n    return 120;\r\n  },\r\n  changeProtectedRows(rowChange) {\r\n    // Always ensure at least one unprotected row for new glyphs, to prevent some potentially odd-looking behavior\r\n    const newRows = Math.clamp(player.reality.glyphs.protectedRows + rowChange, 0, this.totalSlots / 10 - 1);\r\n    const rowsToAdd = newRows - player.reality.glyphs.protectedRows;\r\n\r\n    if (rowsToAdd > 0) {\r\n      // Attempt to shift unprotected glyphs downward if there are any empty unprotected rows. The time complexity on\r\n      // this algorithm isn't that good, but this isn't a particularly hot path and any \"smarter\" algorithms likely\r\n      // aren't worth the reduced code readability\r\n      let rowsMoved = 0;\r\n      while (rowsMoved < rowsToAdd) {\r\n        // Try to shift down all the unprotected rows from top to bottom, repeating until either no shifting is\r\n        // possible or we've freed up the row\r\n        let hasMoved = false;\r\n        for (let orig = this.protectedSlots / 10 + rowsMoved; !hasMoved && orig < this.totalSlots / 10; orig++) {\r\n          hasMoved = hasMoved || this.moveGlyphRow(orig, orig + 1);\r\n        }\r\n        // No movement happened this scan; there's nothing else we can do here\r\n        if (!hasMoved) break;\r\n        // Check if the topmost unprotected row is free. This isn't necessarily guaranteed because it could come from\r\n        // merging lower rows, which means the empty row isn't in the right spot\r\n        if (!this.glyphIndexArray.some(idx => Math.floor(idx / 10) === this.protectedSlots / 10)) {\r\n          rowsMoved++;\r\n        }\r\n      }\r\n    } else {\r\n      // Similar algorithm to above; we scan repeatedly over protected slots and repeatedly attempt to free up the row\r\n      // that's going to switch to being unprotected\r\n      let rowsMoved = 0;\r\n      while (rowsMoved < -rowsToAdd) {\r\n        let hasMoved = false;\r\n        for (let orig = this.protectedSlots / 10 - rowsMoved - 1; !hasMoved && orig > 0; orig--) {\r\n          hasMoved = hasMoved || this.moveGlyphRow(orig, orig - 1);\r\n        }\r\n        if (!hasMoved) break;\r\n        if (!this.glyphIndexArray.some(idx => Math.floor(idx / 10) === this.protectedSlots / 10 - 1)) {\r\n          rowsMoved++;\r\n          // In addition to all the protected glyph movement, we also move the entire unprotected inventory up one row\r\n          for (let orig = this.protectedSlots / 10 - rowsMoved; orig < this.totalSlots / 10; orig++) {\r\n            this.moveGlyphRow(orig, orig - 1);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    player.reality.glyphs.protectedRows = newRows;\r\n    this.validate();\r\n    GameCache.glyphInventorySpace.invalidate();\r\n  },\r\n  // Move all glyphs from the origin row to the destination row, does nothing if a column-preserving move operation\r\n  // isn't possible. Returns a boolean indicating success/failure on glyph moving. Row is 0-indexed\r\n  moveGlyphRow(orig, dest) {\r\n    if (!player.reality.moveGlyphsOnProtection) return false;\r\n    if (orig >= this.totalSlots / 10 || dest >= this.totalSlots / 10) return false;\r\n    if (this.glyphIndexArray.some(idx => Math.floor(idx / 10) === dest)) {\r\n      // Destination row has some glyphs, attempt to merge the rows\r\n      const hasOverlap = [...Array(10).keys()]\r\n        .some(col => this.inventory[10 * orig + col] !== null && this.inventory[10 * dest + col] !== null);\r\n      if (hasOverlap) return false;\r\n      for (let col = 0; col < 10; col++) {\r\n        const glyph = this.inventory[10 * orig + col];\r\n        if (glyph !== null) {\r\n          this.moveToSlot(glyph, 10 * dest + col);\r\n        }\r\n      }\r\n      this.validate();\r\n      return true;\r\n    }\r\n    // Destination row is empty, just move the glyphs\r\n    for (let col = 0; col < 10; col++) {\r\n      const glyph = this.inventory[10 * orig + col];\r\n      if (glyph !== null) {\r\n        this.moveToSlot(glyph, 10 * dest + col);\r\n      }\r\n    }\r\n    this.validate();\r\n    return true;\r\n  },\r\n  refreshActive() {\r\n    this.active = new Array(this.activeSlotCount).fill(null);\r\n    for (const g of player.reality.glyphs.active) {\r\n      if (this.active[g.idx]) {\r\n        throw new Error(\"Stacked active glyphs?\");\r\n      }\r\n      this.active[g.idx] = g;\r\n    }\r\n  },\r\n  refresh() {\r\n    this.refreshActive();\r\n    this.inventory = new Array(this.totalSlots).fill(null);\r\n    // Glyphs could previously end up occupying the same inventory slot (Stacking)\r\n    const stacked = [];\r\n    for (const g of player.reality.glyphs.inventory) {\r\n      if (this.inventory[g.idx]) {\r\n        stacked.push(g);\r\n      } else {\r\n        this.inventory[g.idx] = g;\r\n      }\r\n    }\r\n    // Try to unstack glyphs:\r\n    while (stacked.length) {\r\n      const freeIndex = this.findFreeIndex();\r\n      if (freeIndex >= 0) {\r\n        const glyph = stacked.shift();\r\n        this.inventory[freeIndex] = glyph;\r\n        glyph.idx = freeIndex;\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n    while (stacked.length) {\r\n      this.removeFromInventory(stacked.pop());\r\n    }\r\n    this.validate();\r\n    EventHub.dispatch(GAME_EVENT.GLYPHS_CHANGED);\r\n  },\r\n  // This compares targetGlyph to all the glyphs in searchList, returning a subset of them which fulfills the comparison\r\n  // direction specified by the parameters in fuzzyMatch:\r\n  //  -1: Will find glyphs which are equal to or worse than targetGlyph\r\n  //   0: Will only return glyphs which have identical values\r\n  //  +1: Will find glyphs which are equal to or better than targetGlyph\r\n  findByValues(targetGlyph, searchList, fuzzyMatch = { level, strength, effects }) {\r\n    // We need comparison to go both ways for normal matching and subset matching for partially-equipped sets\r\n    const compFn = (op, comp1, comp2) => {\r\n      switch (op) {\r\n        case -1:\r\n          return comp2 - comp1;\r\n        case 0:\r\n          return comp1 === comp2 ? 0 : -1;\r\n        case 1:\r\n          return comp1 - comp2;\r\n      }\r\n      return false;\r\n    };\r\n\r\n    // Returns a number based on how much the small mask is found inside of the large mask. Returns a non-negative\r\n    // number if small contains all of large, with a value equal to the number of extra bits. Otherwise, returns a\r\n    // negative number equal to the negative of the number of bits that large has which small doesn't.\r\n    const matchedEffects = (large, small) => {\r\n      if ((large & small) === large) return countValuesFromBitmask(small - large);\r\n      return -countValuesFromBitmask(large - (large & small));\r\n    };\r\n\r\n    // Make an array containing all glyphs which match the given criteria, with an additional \"quality\" prop in order\r\n    // to determine roughly how good the glyph itself is relative to other matches\r\n    const allMatches = [];\r\n    for (const glyph of searchList) {\r\n      const type = glyph.type === targetGlyph.type;\r\n      let eff;\r\n      switch (fuzzyMatch.effects) {\r\n        case -1:\r\n          eff = matchedEffects(glyph.effects, targetGlyph.effects);\r\n          break;\r\n        case 0:\r\n          eff = glyph.effects === targetGlyph.effects ? 0 : -1;\r\n          break;\r\n        case 1:\r\n          eff = matchedEffects(targetGlyph.effects, glyph.effects);\r\n          break;\r\n      }\r\n      const str = compFn(fuzzyMatch.strength, glyph.strength, targetGlyph.strength) / 2.5;\r\n      const lvl = compFn(fuzzyMatch.level, glyph.level, targetGlyph.level) / 5000;\r\n      const sym = glyph.symbol === targetGlyph.symbol;\r\n      if (type && eff >= 0 && str >= 0 && lvl >= 0 && sym) {\r\n        allMatches.push({\r\n          glyph,\r\n          // Flatten glyph qualities, with 10% rarity, 500 levels, and an extra effect all being equal value. This\r\n          // is used to sort the options by some rough measure of distance from the target glyph\r\n          gap: str + lvl + eff / 10\r\n        });\r\n      }\r\n    }\r\n\r\n    // Sort by increasing gap, then discard the value as it's not directly used anywhere else\r\n    allMatches.sort((a, b) => a.gap - b.gap);\r\n    return allMatches.map(m => m.glyph);\r\n  },\r\n  findById(id) {\r\n    return player.reality.glyphs.inventory.find(glyph => glyph.id === id);\r\n  },\r\n  findByInventoryIndex(inventoryIndex) {\r\n    return this.inventory[inventoryIndex];\r\n  },\r\n  activeGlyph(activeIndex) {\r\n    return this.active[activeIndex];\r\n  },\r\n  equip(glyph, targetSlot) {\r\n    const forbiddenByPelle = Pelle.isDisabled(\"glyphs\") || [\"effarig\", \"reality\", \"cursed\"].includes(glyph.type);\r\n    if (Pelle.isDoomed && forbiddenByPelle) return;\r\n    if (GameEnd.creditsEverClosed) return;\r\n\r\n    if (glyph.type !== \"companion\") {\r\n      if (RealityUpgrade(9).isLockingMechanics) {\r\n        if (this.activeWithoutCompanion.length > 0) {\r\n          RealityUpgrade(9).tryShowWarningModal(\"equip another non-Companion Glyph\");\r\n          return;\r\n        }\r\n        if (glyph.level < 3) {\r\n          RealityUpgrade(9).tryShowWarningModal(`equip a Glyph whose level is less than ${formatInt(3)}`);\r\n          return;\r\n        }\r\n      }\r\n      if (RealityUpgrade(24).isLockingMechanics && this.activeWithoutCompanion.length === 0) {\r\n        RealityUpgrade(24).tryShowWarningModal();\r\n        return;\r\n      }\r\n      if (ImaginaryUpgrade(25).isLockingMechanics && this.activeWithoutCompanion.length === 1) {\r\n        ImaginaryUpgrade(25).tryShowWarningModal();\r\n        return;\r\n      }\r\n    }\r\n\r\n    this.validate();\r\n    if (this.findByInventoryIndex(glyph.idx) !== glyph) {\r\n      throw new Error(\"Inconsistent inventory indexing\");\r\n    }\r\n    let sameSpecialTypeIndex = -1;\r\n    if ([\"effarig\", \"reality\"].includes(glyph.type)) {\r\n      sameSpecialTypeIndex = this.active.findIndex(x => x && x.type === glyph.type);\r\n    }\r\n    if (this.active[targetSlot] === null) {\r\n      if (sameSpecialTypeIndex >= 0) {\r\n        Modal.message.show(`You may only have one ${glyph.type.capitalize()} Glyph equipped!`,\r\n          { closeEvent: GAME_EVENT.GLYPHS_CHANGED });\r\n        return;\r\n      }\r\n      this.removeFromInventory(glyph);\r\n      this.saveUndo(targetSlot);\r\n      player.reality.glyphs.active.push(glyph);\r\n      glyph.idx = targetSlot;\r\n      this.active[targetSlot] = glyph;\r\n      this.updateRealityGlyphEffects();\r\n      this.updateMaxGlyphCount();\r\n      EventHub.dispatch(GAME_EVENT.GLYPHS_EQUIPPED_CHANGED);\r\n      EventHub.dispatch(GAME_EVENT.GLYPHS_CHANGED);\r\n      this.validate();\r\n    } else {\r\n      // We can only replace effarig/reality glyph\r\n      if (sameSpecialTypeIndex >= 0 && sameSpecialTypeIndex !== targetSlot) {\r\n        Modal.message.show(`You may only have one ${glyph.type.capitalize()} Glyph equipped!`,\r\n          { closeEvent: GAME_EVENT.GLYPHS_CHANGED });\r\n        return;\r\n      }\r\n      if (!player.options.confirmations.glyphReplace) {\r\n        this.swapIntoActive(glyph, targetSlot);\r\n        return;\r\n      }\r\n      Modal.glyphReplace.show({ targetSlot, inventoryIndex: glyph.idx });\r\n    }\r\n    // Loading glyph sets might directly choose glyphs, bypassing the hover-over flag-clearing code\r\n    this.removeVisualFlag(\"unseen\", glyph);\r\n    this.removeVisualFlag(\"unequipped\", glyph);\r\n  },\r\n  // We only ever force when draining rifts causes the single slot to be lost (which will never show the modal)\r\n  unequipAll(forceToUnprotected = false) {\r\n    this.unequipped = [];\r\n    const targetRegion = forceToUnprotected ? false : player.options.respecIntoProtected;\r\n    while (player.reality.glyphs.active.length) {\r\n      const freeIndex = this.findFreeIndex(targetRegion);\r\n      if (freeIndex < 0) break;\r\n      const glyph = player.reality.glyphs.active.pop();\r\n      this.active[glyph.idx] = null;\r\n      this.addToInventory(glyph, freeIndex, true);\r\n    }\r\n    this.updateRealityGlyphEffects();\r\n    this.updateMaxGlyphCount(true);\r\n\r\n    // We need to add a slight delay as a setTimeout in order to make sure that the EventHub calls following this\r\n    // don't immediately close this modal after it's shown. Additionally, we want to prevent the modal from appearing\r\n    // for realities shorter than a few seconds in order to stop a UI-based softlock; however at this point the time\r\n    // has already been reset, so we just use the most recent real time record (this leads to some inconsistent behavior\r\n    // when restarting, but that's not easily avoidable)\r\n    const stillEquipped = player.reality.glyphs.active.length;\r\n    const fastReality = player.records.recentRealities[0][1] < 3000;\r\n    if (stillEquipped && !fastReality) {\r\n      const target = player.options.respecIntoProtected ? \"Protected slots\" : \"Main Inventory\";\r\n      const hasOther = this.findFreeIndex(!player.options.respecIntoProtected) !== -1;\r\n      setTimeout(() => Modal.message.show(`${quantifyInt(\"Glyph\", stillEquipped)} could not be unequipped due to lack\r\n        of space. Free up some space in your ${target}${hasOther ? \" or switch where you are unequipping to\" : \"\"}\r\n        in order to unequip ${stillEquipped === 1 ? \"it\" : \"them\"}.`, { closeEvent: GAME_EVENT.GLYPHS_CHANGED }),\r\n      50);\r\n    }\r\n\r\n    EventHub.dispatch(GAME_EVENT.GLYPHS_EQUIPPED_CHANGED);\r\n    EventHub.dispatch(GAME_EVENT.GLYPHS_CHANGED);\r\n    return !player.reality.glyphs.active.length;\r\n  },\r\n  unequip(activeIndex, requestedInventoryIndex) {\r\n    if (this.active[activeIndex] === null) return;\r\n    const storedIndex = player.reality.glyphs.active.findIndex(glyph => glyph.idx === activeIndex);\r\n    if (storedIndex < 0) return;\r\n    const glyph = player.reality.glyphs.active.splice(storedIndex, 1)[0];\r\n    this.active[activeIndex] = null;\r\n    this.addToInventory(glyph, requestedInventoryIndex, true);\r\n    this.updateRealityGlyphEffects();\r\n    this.updateMaxGlyphCount(true);\r\n    EventHub.dispatch(GAME_EVENT.GLYPHS_EQUIPPED_CHANGED);\r\n    EventHub.dispatch(GAME_EVENT.GLYPHS_CHANGED);\r\n  },\r\n  updateRealityGlyphEffects() {\r\n    // There should only be one reality glyph; this picks one pseudo-randomly if multiple are cheated/glitched in\r\n    const realityGlyph = player.reality.glyphs.active.filter(g => g.type === \"reality\")[0];\r\n    if (realityGlyph === undefined) {\r\n      this.levelBoost = 0;\r\n      return;\r\n    }\r\n    // The cache at this point may not be correct yet (if we're importing a save),\r\n    // so we use the uncached value.\r\n    this.levelBoost = getAdjustedGlyphEffectUncached(\"realityglyphlevel\");\r\n  },\r\n  moveToSlot(glyph, targetSlot) {\r\n    if (this.inventory[targetSlot] === null) this.moveToEmpty(glyph, targetSlot);\r\n    else this.swap(glyph, this.inventory[targetSlot]);\r\n  },\r\n  moveToEmpty(glyph, targetSlot) {\r\n    this.validate();\r\n    if (this.findByInventoryIndex(glyph.idx) !== glyph) {\r\n      throw new Error(\"Inconsistent inventory indexing\");\r\n    }\r\n    if (this.inventory[targetSlot] === null) {\r\n      this.inventory[glyph.idx] = null;\r\n      this.inventory[targetSlot] = glyph;\r\n      glyph.idx = targetSlot;\r\n      EventHub.dispatch(GAME_EVENT.GLYPHS_CHANGED);\r\n    } else {\r\n      throw new Error(\"Attempted glyph move into non-empty slot\");\r\n    }\r\n    this.validate();\r\n  },\r\n  swap(glyphA, glyphB) {\r\n    if (glyphA.idx === glyphB.idx) return;\r\n    this.validate();\r\n    this.inventory[glyphA.idx] = glyphB;\r\n    this.inventory[glyphB.idx] = glyphA;\r\n    const swapGlyph = glyphA.idx;\r\n    glyphA.idx = glyphB.idx;\r\n    glyphB.idx = swapGlyph;\r\n    this.validate();\r\n    EventHub.dispatch(GAME_EVENT.GLYPHS_CHANGED);\r\n  },\r\n  addToInventory(glyph, requestedInventoryIndex, isExistingGlyph = false) {\r\n    this.validate();\r\n    if (!isExistingGlyph) glyph.id = GlyphGenerator.makeID();\r\n    const isProtectedIndex = requestedInventoryIndex < this.protectedSlots;\r\n    let index = this.findFreeIndex(isProtectedIndex);\r\n    if (index < 0) return;\r\n    if (requestedInventoryIndex !== undefined) {\r\n      if (this.inventory[requestedInventoryIndex] === null) index = requestedInventoryIndex;\r\n    }\r\n    this.inventory[index] = glyph;\r\n    glyph.idx = index;\r\n\r\n    // This is done here when adding to the inventory in order to keep it out of the glyph generation hot path\r\n    // It thus doesn't show up in manually choosing a glyph\r\n    // This also only does anything if Ra has the appropriate unlock already.\r\n    this.applyGamespeed(glyph);\r\n\r\n    // This should only apply to glyphs you actually choose, so can't be done in glyph generation.\r\n    // Sometimes a glyph you already have is added to the inventory (for example, unequipping),\r\n    // but that's not an issue because then this line just won't do anything, which is fine.\r\n    player.records.bestReality.glyphStrength = Math.clampMin(player.records.bestReality.glyphStrength, glyph.strength);\r\n\r\n    player.reality.glyphs.inventory.push(glyph);\r\n    if (requestedInventoryIndex === undefined && !isExistingGlyph) this.addVisualFlag(\"unseen\", glyph);\r\n    if (isExistingGlyph) this.addVisualFlag(\"unequipped\", glyph);\r\n    EventHub.dispatch(GAME_EVENT.GLYPHS_CHANGED);\r\n    this.validate();\r\n  },\r\n  // These two visual flag functions update the corner tooltips for \"New!\" and unequipped glyphs\r\n  addVisualFlag(target, glyph) {\r\n    if (!this[target].includes(glyph.id)) this[target].push(glyph.id);\r\n  },\r\n  removeVisualFlag(target, glyph) {\r\n    const index = Glyphs[target].indexOf(glyph.id);\r\n    if (index > -1) Glyphs[target].splice(index, 1);\r\n  },\r\n  isMusicGlyph(glyph) {\r\n    return glyph?.cosmetic === \"music\";\r\n  },\r\n  removeFromInventory(glyph) {\r\n    // This can get called on a glyph not in inventory, during auto sacrifice.\r\n    if (glyph.idx === null) return;\r\n    this.validate();\r\n    const index = player.reality.glyphs.inventory.indexOf(glyph);\r\n    if (index < 0) return;\r\n    this.inventory[glyph.idx] = null;\r\n    player.reality.glyphs.inventory.splice(index, 1);\r\n    EventHub.dispatch(GAME_EVENT.GLYPHS_CHANGED);\r\n    this.validate();\r\n  },\r\n  validate() {\r\n    for (const glyph of player.reality.glyphs.inventory) {\r\n      if (this.inventory[glyph.idx] !== glyph) {\r\n        throw new Error(\"validation error\");\r\n      }\r\n    }\r\n    for (let i = 0; i < this.inventory.length; ++i) {\r\n      if (this.inventory[i] && this.inventory[i].idx !== i) {\r\n        throw new Error(\"backwards validation error\");\r\n      }\r\n    }\r\n  },\r\n  sort(sortFunction) {\r\n    const glyphsToSort = player.reality.glyphs.inventory.filter(g => g.idx >= this.protectedSlots);\r\n    const freeSpace = GameCache.glyphInventorySpace.value;\r\n    const sortOrder = [\"power\", \"infinity\", \"replication\", \"time\", \"dilation\", \"effarig\",\r\n      \"reality\", \"cursed\", \"companion\"];\r\n    const byType = sortOrder.mapToObject(g => g, () => ({ glyphs: [], padding: 0 }));\r\n    for (const g of glyphsToSort) byType[g.type].glyphs.push(g);\r\n    let totalDesiredPadding = 0;\r\n    for (const t of Object.values(byType)) {\r\n      t.glyphs.sort(sortFunction);\r\n      t.padding = Math.ceil(t.glyphs.length / 10) * 10 - t.glyphs.length;\r\n      totalDesiredPadding += t.padding;\r\n    }\r\n    // If we want more padding than we actually have available, trim it down until it fits\r\n    while (totalDesiredPadding > freeSpace) {\r\n      let biggestPadding = sortOrder[0];\r\n      for (const t of sortOrder) {\r\n        if (byType[t].padding > byType[biggestPadding].padding) biggestPadding = t;\r\n      }\r\n      // Try to remove padding 5 at a time if possible\r\n      const delta = byType[biggestPadding].padding > 5 ? 5 : 1;\r\n      totalDesiredPadding -= delta;\r\n      byType[biggestPadding].padding -= delta;\r\n    }\r\n    let outIndex = this.protectedSlots;\r\n    for (const t of Object.values(byType)) {\r\n      for (const g of t.glyphs) {\r\n        if (this.inventory[outIndex]) this.swap(this.inventory[outIndex], g);\r\n        else this.moveToEmpty(g, outIndex);\r\n        ++outIndex;\r\n      }\r\n      outIndex += t.padding;\r\n    }\r\n    if (player.reality.autoCollapse) this.collapseEmptySlots();\r\n  },\r\n  sortByLevel() {\r\n    this.sort((a, b) => b.level - a.level);\r\n  },\r\n  sortByPower() {\r\n    this.sort((a, b) => b.level * b.strength - a.level * a.strength);\r\n  },\r\n  sortByScore() {\r\n    this.sort((a, b) => AutoGlyphProcessor.filterValue(b) - AutoGlyphProcessor.filterValue(a));\r\n  },\r\n  sortByEffect() {\r\n    function reverseBitstring(eff) {\r\n      return parseInt(((1 << 30) + (eff >>> 0)).toString(2).split(\"\").reverse().join(\"\"), 2);\r\n    }\r\n    // The bitwise reversal is so that the effects with the LOWER id are valued higher in the sorting.\r\n    // This primarily meant for effarig glyph effect sorting, which makes it prioritize timespeed pow highest.\r\n    this.sort((a, b) => reverseBitstring(b.effects) - reverseBitstring(a.effects));\r\n  },\r\n  // If there are enough glyphs that are better than the specified glyph, in every way, then\r\n  // the glyph is objectively a useless piece of garbage.\r\n  isObjectivelyUseless(glyph, threshold, inventoryIn) {\r\n    if (player.reality.applyFilterToPurge && AutoGlyphProcessor.wouldKeep(glyph)) return false;\r\n    function hasSomeBetterEffects(glyphA, glyphB, comparedEffects) {\r\n      for (const effect of comparedEffects) {\r\n        const c = effect.compareValues(\r\n          effect.effect(glyphA.level, glyphA.strength),\r\n          effect.effect(glyphB.level, glyphB.strength));\r\n        // If the glyph in question is better in even one effect, it passes this comparison\r\n        if (c > 0) return true;\r\n      }\r\n      return false;\r\n    }\r\n    const toCompare = (inventoryIn ?? this.inventory).concat(this.active)\r\n      .filter(g => g !== null &&\r\n        g.type === glyph.type &&\r\n        g.id !== glyph.id &&\r\n        (g.level >= glyph.level || g.strength >= glyph.strength) &&\r\n        ((g.effects & glyph.effects) === glyph.effects));\r\n    let compareThreshold = glyph.type === \"effarig\" || glyph.type === \"reality\" ? 1 : 5;\r\n    compareThreshold = Math.clampMax(compareThreshold, threshold);\r\n    if (toCompare.length < compareThreshold) return false;\r\n    const comparedEffects = getGlyphEffectsFromBitmask(glyph.effects).filter(x => x.id.startsWith(glyph.type));\r\n    const betterCount = toCompare.countWhere(other => !hasSomeBetterEffects(glyph, other, comparedEffects));\r\n    return betterCount >= compareThreshold;\r\n  },\r\n  // Note that this same function is called with different parameters for purge (5), harsh purge (1), and sac all (0)\r\n  // If deleteGlyphs === false, we are running this from the modal and are doing so purely to *count* the number of\r\n  // removed glyphs. In this case, we copy the inventory and run the purge on the copy - we need to be able to remove\r\n  // glyphs as we go, or else the purge logic will be wrong (eg. 7 identical glyphs will all be \"worse than 5 others\")\r\n  autoClean(threshold = 5, deleteGlyphs = true) {\r\n    const isHarsh = threshold < 5;\r\n    let toBeDeleted = 0;\r\n    const inventoryCopy = deleteGlyphs ? undefined : this.fakePurgeInventory();\r\n    // If the player hasn't unlocked sacrifice yet, prevent them from removing any glyphs.\r\n    if (!GlyphSacrificeHandler.canSacrifice) return toBeDeleted;\r\n    // We look in backwards order so that later glyphs get cleaned up first\r\n    for (let inventoryIndex = this.totalSlots - 1; inventoryIndex >= this.protectedSlots; --inventoryIndex) {\r\n      const glyph = (inventoryCopy ?? this.inventory)[inventoryIndex];\r\n      // Never clean companion, and only clean cursed if we choose to sacrifice all\r\n      if (glyph === null || glyph.type === \"companion\" || (glyph.type === \"cursed\" && threshold !== 0)) continue;\r\n      // Don't auto-clean custom glyphs (eg. music glyphs) unless it's harsh or delete all\r\n      const isCustomGlyph = glyph.color !== undefined || glyph.symbol !== undefined;\r\n      if (isCustomGlyph && !isHarsh) continue;\r\n      // If the threshold for better glyphs needed is zero, the glyph is definitely getting deleted\r\n      // no matter what (well, unless it can't be gotten rid of in current glyph removal mode).\r\n      if (threshold === 0 || this.isObjectivelyUseless(glyph, threshold, inventoryCopy)) {\r\n        if (deleteGlyphs) AutoGlyphProcessor.getRidOfGlyph(glyph);\r\n        else inventoryCopy.splice(inventoryCopy.indexOf(glyph), 1);\r\n        toBeDeleted++;\r\n      }\r\n    }\r\n    if (player.reality.autoCollapse && deleteGlyphs) this.collapseEmptySlots();\r\n    return toBeDeleted;\r\n  },\r\n  // Similar to copyForRecords, except that it also preserves null entries, passes on the IDs, and doesn't\r\n  // sort the glyphs; these are all necessary for the purge logic to work correctly\r\n  fakePurgeInventory() {\r\n    return this.inventory.map(g => (g === null\r\n      ? null\r\n      : {\r\n        id: g.id,\r\n        type: g.type,\r\n        level: g.level,\r\n        strength: g.strength,\r\n        effects: g.effects,\r\n        color: g.color,\r\n        symbol: g.symbol\r\n      }));\r\n  },\r\n  harshAutoClean() {\r\n    this.autoClean(1);\r\n  },\r\n  deleteAllUnprotected() {\r\n    this.autoClean(0);\r\n  },\r\n  deleteAllRejected(deleteGlyphs = true) {\r\n    let toBeDeleted = 0;\r\n    for (const glyph of Glyphs.inventory) {\r\n      if (glyph !== null && glyph.idx >= this.protectedSlots && !AutoGlyphProcessor.wouldKeep(glyph)) {\r\n        if (deleteGlyphs) AutoGlyphProcessor.getRidOfGlyph(glyph);\r\n        toBeDeleted++;\r\n      }\r\n    }\r\n    if (player.reality.autoCollapse && deleteGlyphs) this.collapseEmptySlots();\r\n    return toBeDeleted;\r\n  },\r\n  collapseEmptySlots() {\r\n    const unprotectedGlyphs = player.reality.glyphs.inventory\r\n      .filter(g => g.idx >= this.protectedSlots)\r\n      .sort((a, b) => a.idx - b.idx);\r\n    for (let index = 0; index < unprotectedGlyphs.length; index++) {\r\n      this.moveToSlot(unprotectedGlyphs[index], this.protectedSlots + index);\r\n    }\r\n  },\r\n  processSortingAfterReality() {\r\n    if (VUnlocks.autoAutoClean.canBeApplied && player.reality.autoAutoClean) this.autoClean();\r\n    switch (player.reality.autoSort) {\r\n      case AUTO_SORT_MODE.NONE:\r\n        break;\r\n      case AUTO_SORT_MODE.LEVEL:\r\n        this.sortByLevel();\r\n        break;\r\n      case AUTO_SORT_MODE.POWER:\r\n        this.sortByPower();\r\n        break;\r\n      case AUTO_SORT_MODE.EFFECT:\r\n        this.sortByEffect();\r\n        break;\r\n      case AUTO_SORT_MODE.SCORE:\r\n        this.sortByScore();\r\n        break;\r\n      default:\r\n        throw new Error(\"Unrecognized auto-sort mode\");\r\n    }\r\n  },\r\n  get levelCap() {\r\n    return 1000000;\r\n  },\r\n  get instabilityThreshold() {\r\n    return 1000 + getAdjustedGlyphEffect(\"effarigglyph\") + ImaginaryUpgrade(7).effectOrDefault(0);\r\n  },\r\n  get hyperInstabilityThreshold() {\r\n    return 3000 + this.instabilityThreshold;\r\n  },\r\n  clearUndo() {\r\n    player.reality.glyphs.undo = [];\r\n  },\r\n  saveUndo(targetSlot) {\r\n    const undoData = {\r\n      targetSlot,\r\n      am: new Decimal(Currency.antimatter.value),\r\n      ip: new Decimal(Currency.infinityPoints.value),\r\n      ep: new Decimal(Currency.eternityPoints.value),\r\n      tt: Currency.timeTheorems.max.minus(TimeTheorems.totalPurchased()),\r\n      ecs: EternityChallenges.all.map(e => e.completions),\r\n      thisInfinityTime: player.records.thisInfinity.time,\r\n      thisInfinityRealTime: player.records.thisInfinity.realTime,\r\n      thisEternityTime: player.records.thisEternity.time,\r\n      thisEternityRealTime: player.records.thisEternity.realTime,\r\n      thisRealityTime: player.records.thisReality.time,\r\n      thisRealityRealTime: player.records.thisReality.realTime,\r\n      storedTime: player.celestials.enslaved.stored,\r\n      dilationStudies: player.dilation.studies.toBitmask(),\r\n      dilationUpgrades: player.dilation.upgrades.toBitmask(),\r\n      dilationRebuyables: DilationUpgrades.rebuyable.mapToObject(d => d.id, d => d.boughtAmount),\r\n      tp: new Decimal(Currency.tachyonParticles.value),\r\n      dt: new Decimal(Currency.dilatedTime.value),\r\n    };\r\n    player.reality.glyphs.undo.push(undoData);\r\n  },\r\n  undo() {\r\n    const inventorySlot = Glyphs.findFreeIndex(player.options.respecIntoProtected);\r\n    if (inventorySlot === -1 || player.reality.glyphs.undo.length === 0) return;\r\n    const undoData = player.reality.glyphs.undo.pop();\r\n    // We store this value here so that we can restore it later on in the reality reset code, since we immediately\r\n    // change equipped glyph status here but only update requirement checks within finishProcessReality()\r\n    this.bestUndoGlyphCount = player.requirementChecks.reality.maxGlyphs;\r\n    this.unequip(undoData.targetSlot, inventorySlot);\r\n    finishProcessReality({\r\n      reset: true,\r\n      glyphUndo: true,\r\n      restoreCelestialState: true,\r\n    });\r\n    Currency.antimatter.value = new Decimal(undoData.am);\r\n    Currency.infinityPoints.value = new Decimal(undoData.ip);\r\n    Currency.eternityPoints.value = new Decimal(undoData.ep);\r\n    Currency.timeTheorems.value = new Decimal(undoData.tt);\r\n    EternityChallenges.all.map((ec, ecIndex) => ec.completions = undoData.ecs[ecIndex]);\r\n    player.records.thisInfinity.time = undoData.thisInfinityTime;\r\n    player.records.thisInfinity.realTime = undoData.thisInfinityRealTime;\r\n    player.records.thisEternity.time = undoData.thisEternityTime;\r\n    player.records.thisEternity.realTime = undoData.thisEternityRealTime;\r\n    player.records.thisReality.time = undoData.thisRealityTime;\r\n    player.records.thisReality.realTime = undoData.thisRealityRealTime;\r\n    player.celestials.enslaved.stored = undoData.storedTime || 0;\r\n    if (undoData.dilationStudies) {\r\n      player.dilation.studies = Array.fromBitmask(undoData.dilationStudies);\r\n      player.dilation.upgrades = new Set(Array.fromBitmask(undoData.dilationUpgrades));\r\n      for (const id of Object.keys(undoData.dilationRebuyables)) {\r\n        DilationUpgrades.fromId(id).boughtAmount = undoData.dilationRebuyables[id];\r\n      }\r\n      Currency.tachyonParticles.value = new Decimal(undoData.tp);\r\n      Currency.dilatedTime.value = new Decimal(undoData.dt);\r\n    }\r\n    if (Player.automatorUnlocked && AutomatorBackend.state.forceRestart) {\r\n      AutomatorBackend.start(player.reality.automator.state.editorScript);\r\n    }\r\n  },\r\n  copyForRecords(glyphList) {\r\n    // Sorting by effect ensures consistent ordering by type, based on how the effect bitmasks are structured\r\n    return glyphList.map(g => ({\r\n      type: g.type,\r\n      level: g.level,\r\n      strength: g.strength,\r\n      effects: g.effects,\r\n      color: g.color,\r\n      symbol: g.symbol, }))\r\n      .sort((a, b) => b.effects - a.effects);\r\n  },\r\n  // Normal glyph count minus 3 for each cursed glyph, uses 4 instead of 3 in the calculation because cursed glyphs\r\n  // still contribute to the length of the active list. Note that it only ever decreases if startingReality is true.\r\n  updateMaxGlyphCount(startingReality = false) {\r\n    const activeGlyphList = this.activeWithoutCompanion;\r\n    const currCount = activeGlyphList.length - 4 * activeGlyphList.filter(x => x && x.type === \"cursed\").length;\r\n    if (startingReality) player.requirementChecks.reality.maxGlyphs = currCount;\r\n    player.requirementChecks.reality.maxGlyphs = Math.max(player.requirementChecks.reality.maxGlyphs, currCount);\r\n  },\r\n  // Modifies a basic glyph to have timespeed, and adds the new effect to time glyphs\r\n  applyGamespeed(glyph) {\r\n    if (!Ra.unlocks.allGamespeedGlyphs.canBeApplied) return;\r\n    if (BASIC_GLYPH_TYPES.includes(glyph.type)) {\r\n      glyph.effects |= (1 << GlyphEffects.timespeed.bitmaskIndex);\r\n      if (glyph.type === \"time\") {\r\n        glyph.effects |= (1 << GlyphEffects.timeshardpow.bitmaskIndex);\r\n      }\r\n    }\r\n  },\r\n  swapIntoActive(glyph, targetSlot) {\r\n    this.removeFromInventory(glyph);\r\n    this.unequip(targetSlot, glyph.idx);\r\n    finishProcessReality({\r\n      reset: true,\r\n      glyphUndo: false,\r\n      restoreCelestialState: true,\r\n    });\r\n    player.reality.glyphs.active.push(glyph);\r\n    this.active[targetSlot] = glyph;\r\n    glyph.idx = targetSlot;\r\n    this.updateRealityGlyphEffects();\r\n    this.updateMaxGlyphCount(true);\r\n    EventHub.dispatch(GAME_EVENT.GLYPHS_EQUIPPED_CHANGED);\r\n    EventHub.dispatch(GAME_EVENT.GLYPHS_CHANGED);\r\n    this.validate();\r\n  },\r\n  // Mostly used for key-swapping glyph set UI elements; composites the entire glyph set together in a way which is\r\n  // relatively unlikely to cause collisions between different glyph sets unless they're actually the same glyphs.\r\n  // Different permutations of the same glyphs should produce the same hash, but aren't guaranteed to\r\n  hash(glyphSet) {\r\n    let hash = 1;\r\n    for (const glyph of glyphSet) {\r\n      // This should be at most around e23 or so in practice\r\n      const singleGlyphHash = Math.pow(glyph.level, 2) * Math.pow(glyph.strength, 4) * glyph.effects *\r\n        glyph.type.charCodeAt(0);\r\n      hash *= singleGlyphHash;\r\n    }\r\n    return hash;\r\n  },\r\n  giveCursedGlyph() {\r\n    if (GameCache.glyphInventorySpace.value === 0) {\r\n      Modal.message.show(\"No available inventory space; Sacrifice some Glyphs to free up space.\",\r\n        { closeEvent: GAME_EVENT.GLYPHS_CHANGED });\r\n      return;\r\n    }\r\n    const cursedCount = this.allGlyphs.filter(g => g !== null && g.type === \"cursed\").length;\r\n    if (cursedCount >= 5) {\r\n      GameUI.notify.error(`You don't need more than ${format(5)} Cursed Glyphs!`);\r\n    } else {\r\n      this.addToInventory(GlyphGenerator.cursedGlyph());\r\n      GameUI.notify.error(\"Created a Cursed Glyph\");\r\n    }\r\n  }\r\n};\r\n\r\nclass GlyphSacrificeState extends GameMechanicState { }\r\n\r\nexport const GlyphSacrifice = mapGameDataToObject(\r\n  GameDatabase.reality.glyphSacrifice,\r\n  config => new GlyphSacrificeState(config)\r\n);\r\n\r\nexport function recalculateAllGlyphs() {\r\n  for (let i = 0; i < player.reality.glyphs.active.length; i++) {\r\n    calculateGlyph(player.reality.glyphs.active[i]);\r\n  }\r\n  // Delete any glyphs that are in overflow spots:\r\n  player.reality.glyphs.inventory = player.reality.glyphs.inventory.filter(\r\n    glyph => glyph.idx < Glyphs.totalSlots);\r\n  for (let i = 0; i < player.reality.glyphs.inventory.length; i++) {\r\n    calculateGlyph(player.reality.glyphs.inventory[i]);\r\n  }\r\n  Glyphs.updateRealityGlyphEffects();\r\n  Glyphs.refresh();\r\n}\r\n\r\n// Makes sure level is a positive whole number and rarity is >0% (retroactive fixes) and recalculates effects\r\nexport function calculateGlyph(glyph) {\r\n  if (glyph.color === undefined && glyph.symbol === undefined) {\r\n    glyph.level = Math.max(1, Math.round(glyph.level));\r\n    if (glyph.rawLevel === undefined) {\r\n      // Only correct below the second round of instability, but it only matters for glyphs produced before\r\n      // this was merged, so it's not a big deal.\r\n      glyph.rawLevel = glyph.level < 1000 ? glyph.level : (Math.pow(0.004 * glyph.level - 3, 2) - 1) * 125 + 1000;\r\n    }\r\n\r\n    // Used to randomly generate strength in this case; I don't think we actually care.\r\n    if (glyph.strength === 1) glyph.strength = 1.5;\r\n    glyph.strength = Math.min(rarityToStrength(100), glyph.strength);\r\n  }\r\n}\r\n\r\nexport function getRarity(x) {\r\n  return GlyphRarities.find(e => x >= e.minStrength);\r\n}\r\n\r\nexport function getAdjustedGlyphLevel(glyph, realityGlyphBoost = Glyphs.levelBoost, ignoreCelestialEffects = false) {\r\n  const level = glyph.level;\r\n  if (!ignoreCelestialEffects) {\r\n    if (Pelle.isDoomed) return Math.min(level, Pelle.glyphMaxLevel);\r\n    if (Enslaved.isRunning) return Math.max(level, Enslaved.glyphLevelMin);\r\n    if (Effarig.isRunning) return Math.min(level, Effarig.glyphLevelCap);\r\n  }\r\n  if (BASIC_GLYPH_TYPES.includes(glyph.type)) return level + realityGlyphBoost;\r\n  return level;\r\n}\r\n\r\nexport function respecGlyphs() {\r\n  if (!Glyphs.unequipAll()) {\r\n    Modal.message.show(\"Some of your Glyphs could not be unequipped due to lack of inventory space.\",\r\n      { closeEvent: GAME_EVENT.GLYPHS_CHANGED });\r\n  }\r\n  player.reality.respec = false;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}