{"ast":null,"code":"import \"core-js/modules/web.dom-collections.iterator.js\";\nimport { DC } from \"../../constants\";\nimport { DimensionState } from \"../../dimensions/dimension\";\n/**\r\n * Constants for easily adjusting values\r\n */\n\nconst INTERVAL_COST_MULT = 5;\nconst POWER_DM_COST_MULT = 10;\nconst POWER_DE_COST_MULTS = [1.65, 1.6, 1.55, 1.5];\nconst INTERVAL_START_COST = 10;\nconst POWER_DM_START_COST = 10;\nconst POWER_DE_START_COST = 10;\nconst INTERVAL_PER_UPGRADE = 0.92; // No constant for interval since it's tied to a milestone\n\nexport const POWER_DM_PER_ASCENSION = 500;\nexport const POWER_DE_PER_ASCENSION = 500;\nconst COST_MULT_PER_TIER = 1200;\nexport class DarkMatterDimensionState extends DimensionState {\n  constructor(tier) {\n    super(() => player.celestials.laitela.dimensions, tier);\n  } // Does not include DM, only DE per second\n\n\n  get productionPerSecond() {\n    return this.powerDE * 1000 / this.interval;\n  }\n\n  get unlockUpgrade() {\n    // The 15th Imaginary Upgrade unlocked Laitela and the 1st DMD\n    return ImaginaryUpgrade(this.tier + 14);\n  }\n\n  get isUnlocked() {\n    return this.unlockUpgrade.isBought;\n  }\n\n  get ascensions() {\n    return this.data.ascensionCount;\n  }\n\n  get intervalPurchaseCap() {\n    return 10;\n  }\n\n  get rawInterval() {\n    const perUpgrade = INTERVAL_PER_UPGRADE;\n    const tierFactor = Math.pow(4, this.tier - 1);\n    return 1000 * tierFactor * Math.pow(perUpgrade, this.data.intervalUpgrades) * Math.pow(SingularityMilestone.ascensionIntervalScaling.effectOrDefault(1200), this.ascensions) * SingularityMilestone.darkDimensionIntervalReduction.effectOrDefault(1);\n  }\n\n  get interval() {\n    return Math.clampMin(this.intervalPurchaseCap, this.rawInterval);\n  }\n\n  get commonDarkMult() {\n    return DC.D1.timesEffectsOf(SingularityMilestone.darkFromTesseracts, SingularityMilestone.darkFromGlyphLevel, SingularityMilestone.darkFromTheorems, SingularityMilestone.darkFromDM4, SingularityMilestone.darkFromGamespeed, SingularityMilestone.darkFromDilatedTime);\n  }\n\n  get powerDMPerAscension() {\n    return POWER_DM_PER_ASCENSION + SingularityMilestone.improvedAscensionDM.effectOrDefault(0);\n  }\n\n  get powerDM() {\n    if (!this.isUnlocked) return new Decimal(0);\n    return new Decimal(1 + 2 * Math.pow(1.15, this.data.powerDMUpgrades)).times(Laitela.realityReward).times(Laitela.darkMatterMult).times(this.commonDarkMult).times(Math.pow(this.powerDMPerAscension, this.ascensions)).timesEffectsOf(SingularityMilestone.darkMatterMult, SingularityMilestone.multFromInfinitied).dividedBy(Math.pow(1e4, Math.pow(this.tier - 1, 0.5)));\n  }\n\n  get powerDE() {\n    if (!this.isUnlocked || Pelle.isDoomed) return 0;\n    const tierFactor = Math.pow(15, this.tier - 1);\n    const destabilizeBoost = Laitela.isFullyDestabilized ? 8 : 1;\n    return new Decimal((1 + this.data.powerDEUpgrades * 0.1) * Math.pow(1.005, this.data.powerDEUpgrades) * tierFactor / 1000).times(this.commonDarkMult).times(Math.pow(POWER_DE_PER_ASCENSION, this.ascensions)).timesEffectsOf(SingularityMilestone.darkEnergyMult, SingularityMilestone.realityDEMultiplier, SingularityMilestone.multFromInfinitied).toNumber() * destabilizeBoost;\n  }\n\n  get intervalAfterAscension() {\n    const purchases = Decimal.affordGeometricSeries(Currency.darkMatter.value, this.rawIntervalCost, this.intervalCostIncrease, 0).toNumber();\n    return Math.clampMin(this.intervalPurchaseCap, SingularityMilestone.ascensionIntervalScaling.effectOrDefault(1200) * this.rawInterval * Math.pow(INTERVAL_PER_UPGRADE, purchases));\n  }\n\n  get adjustedStartingCost() {\n    const tiers = [null, 0, 2, 5, 13];\n    return 10 * Math.pow(COST_MULT_PER_TIER, tiers[this.tier]) * SingularityMilestone.darkDimensionCostReduction.effectOrDefault(1);\n  }\n\n  get rawIntervalCost() {\n    return Decimal.pow(this.intervalCostIncrease, this.data.intervalUpgrades).times(this.adjustedStartingCost).times(INTERVAL_START_COST);\n  }\n\n  get intervalCost() {\n    return this.rawIntervalCost.floor();\n  }\n\n  get intervalCostIncrease() {\n    return Math.pow(INTERVAL_COST_MULT, SingularityMilestone.intervalCostScalingReduction.effectOrDefault(1));\n  }\n\n  get rawPowerDMCost() {\n    return Decimal.pow(this.powerDMCostIncrease, this.data.powerDMUpgrades).times(this.adjustedStartingCost).times(POWER_DM_START_COST);\n  }\n\n  get powerDMCost() {\n    return this.rawPowerDMCost.floor();\n  }\n\n  get powerDMCostIncrease() {\n    return POWER_DM_COST_MULT;\n  }\n\n  get rawPowerDECost() {\n    return Decimal.pow(this.powerDECostIncrease, this.data.powerDEUpgrades).times(this.adjustedStartingCost).times(POWER_DE_START_COST);\n  }\n\n  get powerDECost() {\n    return this.rawPowerDECost.floor();\n  }\n\n  get powerDECostIncrease() {\n    return POWER_DE_COST_MULTS[this.tier - 1];\n  }\n\n  get timeSinceLastUpdate() {\n    return this.data.timeSinceLastUpdate;\n  }\n\n  set timeSinceLastUpdate(ms) {\n    this.data.timeSinceLastUpdate = ms;\n  }\n\n  get canBuyInterval() {\n    return Currency.darkMatter.gte(this.intervalCost) && this.interval > this.intervalPurchaseCap;\n  }\n\n  get canBuyPowerDM() {\n    return Currency.darkMatter.gte(this.powerDMCost);\n  }\n\n  get canBuyPowerDE() {\n    return Currency.darkMatter.gte(this.powerDECost);\n  }\n\n  get maxIntervalPurchases() {\n    return Math.ceil(Math.log(this.intervalPurchaseCap / this.interval) / Math.log(INTERVAL_PER_UPGRADE));\n  }\n\n  buyManyInterval(x) {\n    if (x > this.maxIntervalPurchases) return false;\n    const cost = this.rawIntervalCost.times(Decimal.pow(this.intervalCostIncrease, x).minus(1)).div(this.intervalCostIncrease - 1).floor();\n    if (!Currency.darkMatter.purchase(cost)) return false;\n    this.data.intervalUpgrades += x;\n    return true;\n  }\n\n  buyManyPowerDM(x) {\n    const cost = this.rawPowerDMCost.times(Decimal.pow(this.powerDMCostIncrease, x).minus(1)).div(this.powerDMCostIncrease - 1).floor();\n    if (!Currency.darkMatter.purchase(cost)) return false;\n    this.data.powerDMUpgrades += x;\n    return true;\n  }\n\n  buyManyPowerDE(x) {\n    const cost = this.rawPowerDECost.times(Decimal.pow(this.powerDECostIncrease, x).minus(1)).div(this.powerDECostIncrease - 1).floor();\n    if (!Currency.darkMatter.purchase(cost)) return false;\n    this.data.powerDEUpgrades += x;\n    return true;\n  }\n\n  buyInterval() {\n    return this.buyManyInterval(1);\n  }\n\n  buyPowerDM() {\n    return this.buyManyPowerDM(1);\n  }\n\n  buyPowerDE() {\n    return this.buyManyPowerDE(1);\n  }\n\n  ascend() {\n    if (this.interval > this.intervalPurchaseCap) return;\n    this.data.ascensionCount++; // Immediately buy as many interval upgrades as possible\n\n    while (this.buyInterval());\n  }\n\n  static get dimensionCount() {\n    return 4;\n  }\n\n  reset() {\n    this.data.amount = DC.D1;\n    this.data.intervalUpgrades = 0;\n    this.data.powerDMUpgrades = 0;\n    this.data.powerDEUpgrades = 0;\n    this.data.timeSinceLastUpdate = 0;\n    this.data.ascensionCount = 0;\n  }\n\n}\n/**\r\n * @function\r\n * @param {number} tier\r\n * @return {DarkMatterDimensionState}\r\n */\n\nexport const DarkMatterDimension = DarkMatterDimensionState.createAccessor();\nexport const DarkMatterDimensions = {\n  /**\r\n   * @type {DarkMatterDimension[]}\r\n   */\n  all: DarkMatterDimension.index.compact(),\n\n  tick(realDiff) {\n    if (!Laitela.isUnlocked) return;\n\n    for (let tier = 4; tier >= 1; tier--) {\n      const dim = DarkMatterDimension(tier);\n      if (!dim.isUnlocked) continue;\n      dim.timeSinceLastUpdate += realDiff;\n\n      if (dim.interval < dim.timeSinceLastUpdate) {\n        const ticks = Math.floor(dim.timeSinceLastUpdate / dim.interval);\n        const productionDM = dim.amount.times(ticks).times(dim.powerDM);\n\n        if (tier === 1) {\n          Currency.darkMatter.add(productionDM);\n        } else {\n          DarkMatterDimension(tier - 1).amount = DarkMatterDimension(tier - 1).amount.plus(productionDM);\n        }\n\n        Currency.darkEnergy.add(ticks * dim.powerDE);\n        dim.timeSinceLastUpdate -= dim.interval * ticks;\n      }\n    }\n\n    if (SingularityMilestone.dim4Generation.canBeApplied && Laitela.annihilationUnlocked) {\n      DarkMatterDimension(4).amount = DarkMatterDimension(4).amount.plus(SingularityMilestone.dim4Generation.effectValue * realDiff / 1000);\n    }\n  },\n\n  reset() {\n    for (const dimension of DarkMatterDimensions.all) {\n      dimension.reset();\n    }\n\n    Currency.darkMatter.reset();\n  }\n\n};","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/celestials/laitela/dark-matter-dimension.js"],"names":["DC","DimensionState","INTERVAL_COST_MULT","POWER_DM_COST_MULT","POWER_DE_COST_MULTS","INTERVAL_START_COST","POWER_DM_START_COST","POWER_DE_START_COST","INTERVAL_PER_UPGRADE","POWER_DM_PER_ASCENSION","POWER_DE_PER_ASCENSION","COST_MULT_PER_TIER","DarkMatterDimensionState","constructor","tier","player","celestials","laitela","dimensions","productionPerSecond","powerDE","interval","unlockUpgrade","ImaginaryUpgrade","isUnlocked","isBought","ascensions","data","ascensionCount","intervalPurchaseCap","rawInterval","perUpgrade","tierFactor","Math","pow","intervalUpgrades","SingularityMilestone","ascensionIntervalScaling","effectOrDefault","darkDimensionIntervalReduction","clampMin","commonDarkMult","D1","timesEffectsOf","darkFromTesseracts","darkFromGlyphLevel","darkFromTheorems","darkFromDM4","darkFromGamespeed","darkFromDilatedTime","powerDMPerAscension","improvedAscensionDM","powerDM","Decimal","powerDMUpgrades","times","Laitela","realityReward","darkMatterMult","multFromInfinitied","dividedBy","Pelle","isDoomed","destabilizeBoost","isFullyDestabilized","powerDEUpgrades","darkEnergyMult","realityDEMultiplier","toNumber","intervalAfterAscension","purchases","affordGeometricSeries","Currency","darkMatter","value","rawIntervalCost","intervalCostIncrease","adjustedStartingCost","tiers","darkDimensionCostReduction","intervalCost","floor","intervalCostScalingReduction","rawPowerDMCost","powerDMCostIncrease","powerDMCost","rawPowerDECost","powerDECostIncrease","powerDECost","timeSinceLastUpdate","ms","canBuyInterval","gte","canBuyPowerDM","canBuyPowerDE","maxIntervalPurchases","ceil","log","buyManyInterval","x","cost","minus","div","purchase","buyManyPowerDM","buyManyPowerDE","buyInterval","buyPowerDM","buyPowerDE","ascend","dimensionCount","reset","amount","DarkMatterDimension","createAccessor","DarkMatterDimensions","all","index","compact","tick","realDiff","dim","ticks","productionDM","add","plus","darkEnergy","dim4Generation","canBeApplied","annihilationUnlocked","effectValue","dimension"],"mappings":";AAAA,SAASA,EAAT,QAAmB,iBAAnB;AACA,SAASC,cAAT,QAA+B,4BAA/B;AAEA;AACA;AACA;;AAEA,MAAMC,kBAAkB,GAAG,CAA3B;AACA,MAAMC,kBAAkB,GAAG,EAA3B;AACA,MAAMC,mBAAmB,GAAG,CAAC,IAAD,EAAO,GAAP,EAAY,IAAZ,EAAkB,GAAlB,CAA5B;AAEA,MAAMC,mBAAmB,GAAG,EAA5B;AACA,MAAMC,mBAAmB,GAAG,EAA5B;AACA,MAAMC,mBAAmB,GAAG,EAA5B;AAEA,MAAMC,oBAAoB,GAAG,IAA7B,C,CAEA;;AACA,OAAO,MAAMC,sBAAsB,GAAG,GAA/B;AACP,OAAO,MAAMC,sBAAsB,GAAG,GAA/B;AAEP,MAAMC,kBAAkB,GAAG,IAA3B;AAEA,OAAO,MAAMC,wBAAN,SAAuCX,cAAvC,CAAsD;AAC3DY,EAAAA,WAAW,CAACC,IAAD,EAAO;AAChB,UAAM,MAAMC,MAAM,CAACC,UAAP,CAAkBC,OAAlB,CAA0BC,UAAtC,EAAkDJ,IAAlD;AACD,GAH0D,CAK3D;;;AACuB,MAAnBK,mBAAmB,GAAG;AAAE,WAAO,KAAKC,OAAL,GAAe,IAAf,GAAsB,KAAKC,QAAlC;AAA6C;;AAExD,MAAbC,aAAa,GAAG;AAClB;AACA,WAAOC,gBAAgB,CAAC,KAAKT,IAAL,GAAY,EAAb,CAAvB;AACD;;AAEa,MAAVU,UAAU,GAAG;AACf,WAAO,KAAKF,aAAL,CAAmBG,QAA1B;AACD;;AAEa,MAAVC,UAAU,GAAG;AACf,WAAO,KAAKC,IAAL,CAAUC,cAAjB;AACD;;AAEsB,MAAnBC,mBAAmB,GAAG;AACxB,WAAO,EAAP;AACD;;AAEc,MAAXC,WAAW,GAAG;AAChB,UAAMC,UAAU,GAAGvB,oBAAnB;AACA,UAAMwB,UAAU,GAAGC,IAAI,CAACC,GAAL,CAAS,CAAT,EAAY,KAAKpB,IAAL,GAAY,CAAxB,CAAnB;AACA,WAAO,OAAOkB,UAAP,GAAoBC,IAAI,CAACC,GAAL,CAASH,UAAT,EAAqB,KAAKJ,IAAL,CAAUQ,gBAA/B,CAApB,GACLF,IAAI,CAACC,GAAL,CAASE,oBAAoB,CAACC,wBAArB,CAA8CC,eAA9C,CAA8D,IAA9D,CAAT,EAA8E,KAAKZ,UAAnF,CADK,GAELU,oBAAoB,CAACG,8BAArB,CAAoDD,eAApD,CAAoE,CAApE,CAFF;AAGD;;AAEW,MAARjB,QAAQ,GAAG;AACb,WAAOY,IAAI,CAACO,QAAL,CAAc,KAAKX,mBAAnB,EAAwC,KAAKC,WAA7C,CAAP;AACD;;AAEiB,MAAdW,cAAc,GAAG;AACnB,WAAOzC,EAAE,CAAC0C,EAAH,CAAMC,cAAN,CACLP,oBAAoB,CAACQ,kBADhB,EAELR,oBAAoB,CAACS,kBAFhB,EAGLT,oBAAoB,CAACU,gBAHhB,EAILV,oBAAoB,CAACW,WAJhB,EAKLX,oBAAoB,CAACY,iBALhB,EAMLZ,oBAAoB,CAACa,mBANhB,CAAP;AAQD;;AAEsB,MAAnBC,mBAAmB,GAAG;AACxB,WAAOzC,sBAAsB,GAAG2B,oBAAoB,CAACe,mBAArB,CAAyCb,eAAzC,CAAyD,CAAzD,CAAhC;AACD;;AAEU,MAAPc,OAAO,GAAG;AACZ,QAAI,CAAC,KAAK5B,UAAV,EAAsB,OAAO,IAAI6B,OAAJ,CAAY,CAAZ,CAAP;AACtB,WAAO,IAAIA,OAAJ,CAAY,IAAI,IAAIpB,IAAI,CAACC,GAAL,CAAS,IAAT,EAAe,KAAKP,IAAL,CAAU2B,eAAzB,CAApB,EACJC,KADI,CACEC,OAAO,CAACC,aADV,EAEJF,KAFI,CAEEC,OAAO,CAACE,cAFV,EAGJH,KAHI,CAGE,KAAKd,cAHP,EAIJc,KAJI,CAIEtB,IAAI,CAACC,GAAL,CAAS,KAAKgB,mBAAd,EAAmC,KAAKxB,UAAxC,CAJF,EAKJiB,cALI,CAKWP,oBAAoB,CAACsB,cALhC,EAKgDtB,oBAAoB,CAACuB,kBALrE,EAMJC,SANI,CAMM3B,IAAI,CAACC,GAAL,CAAS,GAAT,EAAcD,IAAI,CAACC,GAAL,CAAS,KAAKpB,IAAL,GAAY,CAArB,EAAwB,GAAxB,CAAd,CANN,CAAP;AAOD;;AAEU,MAAPM,OAAO,GAAG;AACZ,QAAI,CAAC,KAAKI,UAAN,IAAoBqC,KAAK,CAACC,QAA9B,EAAwC,OAAO,CAAP;AACxC,UAAM9B,UAAU,GAAGC,IAAI,CAACC,GAAL,CAAS,EAAT,EAAa,KAAKpB,IAAL,GAAY,CAAzB,CAAnB;AACA,UAAMiD,gBAAgB,GAAGP,OAAO,CAACQ,mBAAR,GAA8B,CAA9B,GAAkC,CAA3D;AACA,WAAO,IAAIX,OAAJ,CAAa,CAAC,IAAI,KAAK1B,IAAL,CAAUsC,eAAV,GAA4B,GAAjC,IAClBhC,IAAI,CAACC,GAAL,CAAS,KAAT,EAAgB,KAAKP,IAAL,CAAUsC,eAA1B,CADiB,GAC6BjC,UAD7B,GAC0C,IADtD,EAEJuB,KAFI,CAEE,KAAKd,cAFP,EAGJc,KAHI,CAGEtB,IAAI,CAACC,GAAL,CAASxB,sBAAT,EAAiC,KAAKgB,UAAtC,CAHF,EAIJiB,cAJI,CAKHP,oBAAoB,CAAC8B,cALlB,EAMH9B,oBAAoB,CAAC+B,mBANlB,EAOH/B,oBAAoB,CAACuB,kBAPlB,EAQHS,QARG,KAQUL,gBARjB;AASD;;AAEyB,MAAtBM,sBAAsB,GAAG;AAC3B,UAAMC,SAAS,GAAGjB,OAAO,CAACkB,qBAAR,CAA8BC,QAAQ,CAACC,UAAT,CAAoBC,KAAlD,EAAyD,KAAKC,eAA9D,EAChB,KAAKC,oBADW,EACW,CADX,EACcR,QADd,EAAlB;AAEA,WAAOnC,IAAI,CAACO,QAAL,CAAc,KAAKX,mBAAnB,EAAwCO,oBAAoB,CAACC,wBAArB,CAA8CC,eAA9C,CAA8D,IAA9D,IAC7C,KAAKR,WADwC,GAC1BG,IAAI,CAACC,GAAL,CAAS1B,oBAAT,EAA+B8D,SAA/B,CADd,CAAP;AAED;;AAEuB,MAApBO,oBAAoB,GAAG;AACzB,UAAMC,KAAK,GAAG,CAAC,IAAD,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,EAAhB,CAAd;AACA,WAAO,KAAK7C,IAAI,CAACC,GAAL,CAASvB,kBAAT,EAA6BmE,KAAK,CAAC,KAAKhE,IAAN,CAAlC,CAAL,GACLsB,oBAAoB,CAAC2C,0BAArB,CAAgDzC,eAAhD,CAAgE,CAAhE,CADF;AAED;;AAEkB,MAAfqC,eAAe,GAAG;AACpB,WAAOtB,OAAO,CAACnB,GAAR,CAAY,KAAK0C,oBAAjB,EAAuC,KAAKjD,IAAL,CAAUQ,gBAAjD,EACJoB,KADI,CACE,KAAKsB,oBADP,EAC6BtB,KAD7B,CACmClD,mBADnC,CAAP;AAED;;AAEe,MAAZ2E,YAAY,GAAG;AACjB,WAAO,KAAKL,eAAL,CAAqBM,KAArB,EAAP;AACD;;AAEuB,MAApBL,oBAAoB,GAAG;AACzB,WAAO3C,IAAI,CAACC,GAAL,CAAShC,kBAAT,EAA6BkC,oBAAoB,CAAC8C,4BAArB,CAAkD5C,eAAlD,CAAkE,CAAlE,CAA7B,CAAP;AACD;;AAEiB,MAAd6C,cAAc,GAAG;AACnB,WAAO9B,OAAO,CAACnB,GAAR,CAAY,KAAKkD,mBAAjB,EAAsC,KAAKzD,IAAL,CAAU2B,eAAhD,EACJC,KADI,CACE,KAAKsB,oBADP,EAC6BtB,KAD7B,CACmCjD,mBADnC,CAAP;AAED;;AAEc,MAAX+E,WAAW,GAAG;AAChB,WAAO,KAAKF,cAAL,CAAoBF,KAApB,EAAP;AACD;;AAEsB,MAAnBG,mBAAmB,GAAG;AACxB,WAAOjF,kBAAP;AACD;;AAEiB,MAAdmF,cAAc,GAAG;AACnB,WAAOjC,OAAO,CAACnB,GAAR,CAAY,KAAKqD,mBAAjB,EAAsC,KAAK5D,IAAL,CAAUsC,eAAhD,EACJV,KADI,CACE,KAAKsB,oBADP,EAC6BtB,KAD7B,CACmChD,mBADnC,CAAP;AAED;;AAEc,MAAXiF,WAAW,GAAG;AAChB,WAAO,KAAKF,cAAL,CAAoBL,KAApB,EAAP;AACD;;AAEsB,MAAnBM,mBAAmB,GAAG;AACxB,WAAOnF,mBAAmB,CAAC,KAAKU,IAAL,GAAY,CAAb,CAA1B;AACD;;AAEsB,MAAnB2E,mBAAmB,GAAG;AACxB,WAAO,KAAK9D,IAAL,CAAU8D,mBAAjB;AACD;;AAEsB,MAAnBA,mBAAmB,CAACC,EAAD,EAAK;AAC1B,SAAK/D,IAAL,CAAU8D,mBAAV,GAAgCC,EAAhC;AACD;;AAEiB,MAAdC,cAAc,GAAG;AACnB,WAAOnB,QAAQ,CAACC,UAAT,CAAoBmB,GAApB,CAAwB,KAAKZ,YAA7B,KAA8C,KAAK3D,QAAL,GAAgB,KAAKQ,mBAA1E;AACD;;AAEgB,MAAbgE,aAAa,GAAG;AAClB,WAAOrB,QAAQ,CAACC,UAAT,CAAoBmB,GAApB,CAAwB,KAAKP,WAA7B,CAAP;AACD;;AAEgB,MAAbS,aAAa,GAAG;AAClB,WAAOtB,QAAQ,CAACC,UAAT,CAAoBmB,GAApB,CAAwB,KAAKJ,WAA7B,CAAP;AACD;;AAEuB,MAApBO,oBAAoB,GAAG;AACzB,WAAO9D,IAAI,CAAC+D,IAAL,CAAU/D,IAAI,CAACgE,GAAL,CAAS,KAAKpE,mBAAL,GAA2B,KAAKR,QAAzC,IAAqDY,IAAI,CAACgE,GAAL,CAASzF,oBAAT,CAA/D,CAAP;AACD;;AAED0F,EAAAA,eAAe,CAACC,CAAD,EAAI;AACjB,QAAIA,CAAC,GAAG,KAAKJ,oBAAb,EAAmC,OAAO,KAAP;AACnC,UAAMK,IAAI,GAAG,KAAKzB,eAAL,CAAqBpB,KAArB,CACXF,OAAO,CAACnB,GAAR,CAAY,KAAK0C,oBAAjB,EAAuCuB,CAAvC,EAA0CE,KAA1C,CAAgD,CAAhD,CADW,EACyCC,GADzC,CAC6C,KAAK1B,oBAAL,GAA4B,CADzE,EAC4EK,KAD5E,EAAb;AAEA,QAAI,CAACT,QAAQ,CAACC,UAAT,CAAoB8B,QAApB,CAA6BH,IAA7B,CAAL,EAAyC,OAAO,KAAP;AACzC,SAAKzE,IAAL,CAAUQ,gBAAV,IAA8BgE,CAA9B;AACA,WAAO,IAAP;AACD;;AAEDK,EAAAA,cAAc,CAACL,CAAD,EAAI;AAChB,UAAMC,IAAI,GAAG,KAAKjB,cAAL,CAAoB5B,KAApB,CACXF,OAAO,CAACnB,GAAR,CAAY,KAAKkD,mBAAjB,EAAsCe,CAAtC,EAAyCE,KAAzC,CAA+C,CAA/C,CADW,EACwCC,GADxC,CAC4C,KAAKlB,mBAAL,GAA2B,CADvE,EAC0EH,KAD1E,EAAb;AAEA,QAAI,CAACT,QAAQ,CAACC,UAAT,CAAoB8B,QAApB,CAA6BH,IAA7B,CAAL,EAAyC,OAAO,KAAP;AACzC,SAAKzE,IAAL,CAAU2B,eAAV,IAA6B6C,CAA7B;AACA,WAAO,IAAP;AACD;;AAEDM,EAAAA,cAAc,CAACN,CAAD,EAAI;AAChB,UAAMC,IAAI,GAAG,KAAKd,cAAL,CAAoB/B,KAApB,CACXF,OAAO,CAACnB,GAAR,CAAY,KAAKqD,mBAAjB,EAAsCY,CAAtC,EAAyCE,KAAzC,CAA+C,CAA/C,CADW,EACwCC,GADxC,CAC4C,KAAKf,mBAAL,GAA2B,CADvE,EAC0EN,KAD1E,EAAb;AAEA,QAAI,CAACT,QAAQ,CAACC,UAAT,CAAoB8B,QAApB,CAA6BH,IAA7B,CAAL,EAAyC,OAAO,KAAP;AACzC,SAAKzE,IAAL,CAAUsC,eAAV,IAA6BkC,CAA7B;AACA,WAAO,IAAP;AACD;;AAEDO,EAAAA,WAAW,GAAG;AACZ,WAAO,KAAKR,eAAL,CAAqB,CAArB,CAAP;AACD;;AAEDS,EAAAA,UAAU,GAAG;AACX,WAAO,KAAKH,cAAL,CAAoB,CAApB,CAAP;AACD;;AAEDI,EAAAA,UAAU,GAAG;AACX,WAAO,KAAKH,cAAL,CAAoB,CAApB,CAAP;AACD;;AAEDI,EAAAA,MAAM,GAAG;AACP,QAAI,KAAKxF,QAAL,GAAgB,KAAKQ,mBAAzB,EAA8C;AAC9C,SAAKF,IAAL,CAAUC,cAAV,GAFO,CAIP;;AACA,WAAO,KAAK8E,WAAL,EAAP,CAA0B;AAC3B;;AAEwB,aAAdI,cAAc,GAAG;AAAE,WAAO,CAAP;AAAW;;AAEzCC,EAAAA,KAAK,GAAG;AACN,SAAKpF,IAAL,CAAUqF,MAAV,GAAmBhH,EAAE,CAAC0C,EAAtB;AACA,SAAKf,IAAL,CAAUQ,gBAAV,GAA6B,CAA7B;AACA,SAAKR,IAAL,CAAU2B,eAAV,GAA4B,CAA5B;AACA,SAAK3B,IAAL,CAAUsC,eAAV,GAA4B,CAA5B;AACA,SAAKtC,IAAL,CAAU8D,mBAAV,GAAgC,CAAhC;AACA,SAAK9D,IAAL,CAAUC,cAAV,GAA2B,CAA3B;AACD;;AAhN0D;AAmN7D;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMqF,mBAAmB,GAAGrG,wBAAwB,CAACsG,cAAzB,EAA5B;AAEP,OAAO,MAAMC,oBAAoB,GAAG;AAClC;AACF;AACA;AACEC,EAAAA,GAAG,EAAEH,mBAAmB,CAACI,KAApB,CAA0BC,OAA1B,EAJ6B;;AAMlCC,EAAAA,IAAI,CAACC,QAAD,EAAW;AACb,QAAI,CAAChE,OAAO,CAAChC,UAAb,EAAyB;;AACzB,SAAK,IAAIV,IAAI,GAAG,CAAhB,EAAmBA,IAAI,IAAI,CAA3B,EAA8BA,IAAI,EAAlC,EAAsC;AACpC,YAAM2G,GAAG,GAAGR,mBAAmB,CAACnG,IAAD,CAA/B;AACA,UAAI,CAAC2G,GAAG,CAACjG,UAAT,EAAqB;AACrBiG,MAAAA,GAAG,CAAChC,mBAAJ,IAA2B+B,QAA3B;;AACA,UAAIC,GAAG,CAACpG,QAAJ,GAAeoG,GAAG,CAAChC,mBAAvB,EAA4C;AAC1C,cAAMiC,KAAK,GAAGzF,IAAI,CAACgD,KAAL,CAAWwC,GAAG,CAAChC,mBAAJ,GAA0BgC,GAAG,CAACpG,QAAzC,CAAd;AACA,cAAMsG,YAAY,GAAGF,GAAG,CAACT,MAAJ,CAAWzD,KAAX,CAAiBmE,KAAjB,EAAwBnE,KAAxB,CAA8BkE,GAAG,CAACrE,OAAlC,CAArB;;AACA,YAAItC,IAAI,KAAK,CAAb,EAAgB;AACd0D,UAAAA,QAAQ,CAACC,UAAT,CAAoBmD,GAApB,CAAwBD,YAAxB;AACD,SAFD,MAEO;AACLV,UAAAA,mBAAmB,CAACnG,IAAI,GAAG,CAAR,CAAnB,CAA8BkG,MAA9B,GAAuCC,mBAAmB,CAACnG,IAAI,GAAG,CAAR,CAAnB,CAA8BkG,MAA9B,CAAqCa,IAArC,CAA0CF,YAA1C,CAAvC;AACD;;AACDnD,QAAAA,QAAQ,CAACsD,UAAT,CAAoBF,GAApB,CAAwBF,KAAK,GAAGD,GAAG,CAACrG,OAApC;AACAqG,QAAAA,GAAG,CAAChC,mBAAJ,IAA2BgC,GAAG,CAACpG,QAAJ,GAAeqG,KAA1C;AACD;AACF;;AACD,QAAItF,oBAAoB,CAAC2F,cAArB,CAAoCC,YAApC,IAAoDxE,OAAO,CAACyE,oBAAhE,EAAsF;AACpFhB,MAAAA,mBAAmB,CAAC,CAAD,CAAnB,CAAuBD,MAAvB,GAAgCC,mBAAmB,CAAC,CAAD,CAAnB,CAAuBD,MAAvB,CAC7Ba,IAD6B,CACxBzF,oBAAoB,CAAC2F,cAArB,CAAoCG,WAApC,GAAkDV,QAAlD,GAA6D,IADrC,CAAhC;AAED;AACF,GA5BiC;;AA8BlCT,EAAAA,KAAK,GAAG;AACN,SAAK,MAAMoB,SAAX,IAAwBhB,oBAAoB,CAACC,GAA7C,EAAkD;AAChDe,MAAAA,SAAS,CAACpB,KAAV;AACD;;AACDvC,IAAAA,QAAQ,CAACC,UAAT,CAAoBsC,KAApB;AACD;;AAnCiC,CAA7B","sourcesContent":["import { DC } from \"../../constants\";\r\nimport { DimensionState } from \"../../dimensions/dimension\";\r\n\r\n/**\r\n * Constants for easily adjusting values\r\n */\r\n\r\nconst INTERVAL_COST_MULT = 5;\r\nconst POWER_DM_COST_MULT = 10;\r\nconst POWER_DE_COST_MULTS = [1.65, 1.6, 1.55, 1.5];\r\n\r\nconst INTERVAL_START_COST = 10;\r\nconst POWER_DM_START_COST = 10;\r\nconst POWER_DE_START_COST = 10;\r\n\r\nconst INTERVAL_PER_UPGRADE = 0.92;\r\n\r\n// No constant for interval since it's tied to a milestone\r\nexport const POWER_DM_PER_ASCENSION = 500;\r\nexport const POWER_DE_PER_ASCENSION = 500;\r\n\r\nconst COST_MULT_PER_TIER = 1200;\r\n\r\nexport class DarkMatterDimensionState extends DimensionState {\r\n  constructor(tier) {\r\n    super(() => player.celestials.laitela.dimensions, tier);\r\n  }\r\n\r\n  // Does not include DM, only DE per second\r\n  get productionPerSecond() { return this.powerDE * 1000 / this.interval; }\r\n\r\n  get unlockUpgrade() {\r\n    // The 15th Imaginary Upgrade unlocked Laitela and the 1st DMD\r\n    return ImaginaryUpgrade(this.tier + 14);\r\n  }\r\n\r\n  get isUnlocked() {\r\n    return this.unlockUpgrade.isBought;\r\n  }\r\n\r\n  get ascensions() {\r\n    return this.data.ascensionCount;\r\n  }\r\n\r\n  get intervalPurchaseCap() {\r\n    return 10;\r\n  }\r\n\r\n  get rawInterval() {\r\n    const perUpgrade = INTERVAL_PER_UPGRADE;\r\n    const tierFactor = Math.pow(4, this.tier - 1);\r\n    return 1000 * tierFactor * Math.pow(perUpgrade, this.data.intervalUpgrades) *\r\n      Math.pow(SingularityMilestone.ascensionIntervalScaling.effectOrDefault(1200), this.ascensions) *\r\n      SingularityMilestone.darkDimensionIntervalReduction.effectOrDefault(1);\r\n  }\r\n\r\n  get interval() {\r\n    return Math.clampMin(this.intervalPurchaseCap, this.rawInterval);\r\n  }\r\n\r\n  get commonDarkMult() {\r\n    return DC.D1.timesEffectsOf(\r\n      SingularityMilestone.darkFromTesseracts,\r\n      SingularityMilestone.darkFromGlyphLevel,\r\n      SingularityMilestone.darkFromTheorems,\r\n      SingularityMilestone.darkFromDM4,\r\n      SingularityMilestone.darkFromGamespeed,\r\n      SingularityMilestone.darkFromDilatedTime\r\n    );\r\n  }\r\n\r\n  get powerDMPerAscension() {\r\n    return POWER_DM_PER_ASCENSION + SingularityMilestone.improvedAscensionDM.effectOrDefault(0);\r\n  }\r\n\r\n  get powerDM() {\r\n    if (!this.isUnlocked) return new Decimal(0);\r\n    return new Decimal(1 + 2 * Math.pow(1.15, this.data.powerDMUpgrades))\r\n      .times(Laitela.realityReward)\r\n      .times(Laitela.darkMatterMult)\r\n      .times(this.commonDarkMult)\r\n      .times(Math.pow(this.powerDMPerAscension, this.ascensions))\r\n      .timesEffectsOf(SingularityMilestone.darkMatterMult, SingularityMilestone.multFromInfinitied)\r\n      .dividedBy(Math.pow(1e4, Math.pow(this.tier - 1, 0.5)));\r\n  }\r\n\r\n  get powerDE() {\r\n    if (!this.isUnlocked || Pelle.isDoomed) return 0;\r\n    const tierFactor = Math.pow(15, this.tier - 1);\r\n    const destabilizeBoost = Laitela.isFullyDestabilized ? 8 : 1;\r\n    return new Decimal(((1 + this.data.powerDEUpgrades * 0.1) *\r\n      Math.pow(1.005, this.data.powerDEUpgrades)) * tierFactor / 1000)\r\n      .times(this.commonDarkMult)\r\n      .times(Math.pow(POWER_DE_PER_ASCENSION, this.ascensions))\r\n      .timesEffectsOf(\r\n        SingularityMilestone.darkEnergyMult,\r\n        SingularityMilestone.realityDEMultiplier,\r\n        SingularityMilestone.multFromInfinitied\r\n      ).toNumber() * destabilizeBoost;\r\n  }\r\n\r\n  get intervalAfterAscension() {\r\n    const purchases = Decimal.affordGeometricSeries(Currency.darkMatter.value, this.rawIntervalCost,\r\n      this.intervalCostIncrease, 0).toNumber();\r\n    return Math.clampMin(this.intervalPurchaseCap, SingularityMilestone.ascensionIntervalScaling.effectOrDefault(1200) *\r\n      this.rawInterval * Math.pow(INTERVAL_PER_UPGRADE, purchases));\r\n  }\r\n\r\n  get adjustedStartingCost() {\r\n    const tiers = [null, 0, 2, 5, 13];\r\n    return 10 * Math.pow(COST_MULT_PER_TIER, tiers[this.tier]) *\r\n      SingularityMilestone.darkDimensionCostReduction.effectOrDefault(1);\r\n  }\r\n\r\n  get rawIntervalCost() {\r\n    return Decimal.pow(this.intervalCostIncrease, this.data.intervalUpgrades)\r\n      .times(this.adjustedStartingCost).times(INTERVAL_START_COST);\r\n  }\r\n\r\n  get intervalCost() {\r\n    return this.rawIntervalCost.floor();\r\n  }\r\n\r\n  get intervalCostIncrease() {\r\n    return Math.pow(INTERVAL_COST_MULT, SingularityMilestone.intervalCostScalingReduction.effectOrDefault(1));\r\n  }\r\n\r\n  get rawPowerDMCost() {\r\n    return Decimal.pow(this.powerDMCostIncrease, this.data.powerDMUpgrades)\r\n      .times(this.adjustedStartingCost).times(POWER_DM_START_COST);\r\n  }\r\n\r\n  get powerDMCost() {\r\n    return this.rawPowerDMCost.floor();\r\n  }\r\n\r\n  get powerDMCostIncrease() {\r\n    return POWER_DM_COST_MULT;\r\n  }\r\n\r\n  get rawPowerDECost() {\r\n    return Decimal.pow(this.powerDECostIncrease, this.data.powerDEUpgrades)\r\n      .times(this.adjustedStartingCost).times(POWER_DE_START_COST);\r\n  }\r\n\r\n  get powerDECost() {\r\n    return this.rawPowerDECost.floor();\r\n  }\r\n\r\n  get powerDECostIncrease() {\r\n    return POWER_DE_COST_MULTS[this.tier - 1];\r\n  }\r\n\r\n  get timeSinceLastUpdate() {\r\n    return this.data.timeSinceLastUpdate;\r\n  }\r\n\r\n  set timeSinceLastUpdate(ms) {\r\n    this.data.timeSinceLastUpdate = ms;\r\n  }\r\n\r\n  get canBuyInterval() {\r\n    return Currency.darkMatter.gte(this.intervalCost) && this.interval > this.intervalPurchaseCap;\r\n  }\r\n\r\n  get canBuyPowerDM() {\r\n    return Currency.darkMatter.gte(this.powerDMCost);\r\n  }\r\n\r\n  get canBuyPowerDE() {\r\n    return Currency.darkMatter.gte(this.powerDECost);\r\n  }\r\n\r\n  get maxIntervalPurchases() {\r\n    return Math.ceil(Math.log(this.intervalPurchaseCap / this.interval) / Math.log(INTERVAL_PER_UPGRADE));\r\n  }\r\n\r\n  buyManyInterval(x) {\r\n    if (x > this.maxIntervalPurchases) return false;\r\n    const cost = this.rawIntervalCost.times(\r\n      Decimal.pow(this.intervalCostIncrease, x).minus(1)).div(this.intervalCostIncrease - 1).floor();\r\n    if (!Currency.darkMatter.purchase(cost)) return false;\r\n    this.data.intervalUpgrades += x;\r\n    return true;\r\n  }\r\n\r\n  buyManyPowerDM(x) {\r\n    const cost = this.rawPowerDMCost.times(\r\n      Decimal.pow(this.powerDMCostIncrease, x).minus(1)).div(this.powerDMCostIncrease - 1).floor();\r\n    if (!Currency.darkMatter.purchase(cost)) return false;\r\n    this.data.powerDMUpgrades += x;\r\n    return true;\r\n  }\r\n\r\n  buyManyPowerDE(x) {\r\n    const cost = this.rawPowerDECost.times(\r\n      Decimal.pow(this.powerDECostIncrease, x).minus(1)).div(this.powerDECostIncrease - 1).floor();\r\n    if (!Currency.darkMatter.purchase(cost)) return false;\r\n    this.data.powerDEUpgrades += x;\r\n    return true;\r\n  }\r\n\r\n  buyInterval() {\r\n    return this.buyManyInterval(1);\r\n  }\r\n\r\n  buyPowerDM() {\r\n    return this.buyManyPowerDM(1);\r\n  }\r\n\r\n  buyPowerDE() {\r\n    return this.buyManyPowerDE(1);\r\n  }\r\n\r\n  ascend() {\r\n    if (this.interval > this.intervalPurchaseCap) return;\r\n    this.data.ascensionCount++;\r\n\r\n    // Immediately buy as many interval upgrades as possible\r\n    while (this.buyInterval());\r\n  }\r\n\r\n  static get dimensionCount() { return 4; }\r\n\r\n  reset() {\r\n    this.data.amount = DC.D1;\r\n    this.data.intervalUpgrades = 0;\r\n    this.data.powerDMUpgrades = 0;\r\n    this.data.powerDEUpgrades = 0;\r\n    this.data.timeSinceLastUpdate = 0;\r\n    this.data.ascensionCount = 0;\r\n  }\r\n}\r\n\r\n/**\r\n * @function\r\n * @param {number} tier\r\n * @return {DarkMatterDimensionState}\r\n */\r\nexport const DarkMatterDimension = DarkMatterDimensionState.createAccessor();\r\n\r\nexport const DarkMatterDimensions = {\r\n  /**\r\n   * @type {DarkMatterDimension[]}\r\n   */\r\n  all: DarkMatterDimension.index.compact(),\r\n\r\n  tick(realDiff) {\r\n    if (!Laitela.isUnlocked) return;\r\n    for (let tier = 4; tier >= 1; tier--) {\r\n      const dim = DarkMatterDimension(tier);\r\n      if (!dim.isUnlocked) continue;\r\n      dim.timeSinceLastUpdate += realDiff;\r\n      if (dim.interval < dim.timeSinceLastUpdate) {\r\n        const ticks = Math.floor(dim.timeSinceLastUpdate / dim.interval);\r\n        const productionDM = dim.amount.times(ticks).times(dim.powerDM);\r\n        if (tier === 1) {\r\n          Currency.darkMatter.add(productionDM);\r\n        } else {\r\n          DarkMatterDimension(tier - 1).amount = DarkMatterDimension(tier - 1).amount.plus(productionDM);\r\n        }\r\n        Currency.darkEnergy.add(ticks * dim.powerDE);\r\n        dim.timeSinceLastUpdate -= dim.interval * ticks;\r\n      }\r\n    }\r\n    if (SingularityMilestone.dim4Generation.canBeApplied && Laitela.annihilationUnlocked) {\r\n      DarkMatterDimension(4).amount = DarkMatterDimension(4).amount\r\n        .plus(SingularityMilestone.dim4Generation.effectValue * realDiff / 1000);\r\n    }\r\n  },\r\n\r\n  reset() {\r\n    for (const dimension of DarkMatterDimensions.all) {\r\n      dimension.reset();\r\n    }\r\n    Currency.darkMatter.reset();\r\n  },\r\n};\r\n"]},"metadata":{},"sourceType":"module"}