{"ast":null,"code":"import \"core-js/modules/web.dom-collections.iterator.js\";\nexport const BlackHoleAnimation = function () {\n  const PLANET_SIZE = 1.5;\n  const PARTICLE_SIZE = 0.5;\n  const PARTICLE_COUNT = 120; // Basically orbit size in pixels\n\n  const SEMIMAJOR_AXIS = 100; // Black Hole active time approximately corresponds to time with >2x\n\n  const ACTIVE_THRESHOLD = 2;\n  let holeSize; // Calculates \"eccentric anomaly\" from \"mean anomaly\",\n  // see https://en.wikipedia.org/wiki/Kepler%27s_equation#Numerical_approximation_of_inverse_problem\n  // Needed for accurate Keplerian orbit shape and velocity, apparently math is hard\n\n  function eccentricAnomaly(eccentricity, meanAnomaly) {\n    let E0 = meanAnomaly; // I hope 20 is enough to converge\n\n    const maxIter = 20;\n\n    for (let k = 0; k < maxIter; k++) {\n      E0 = meanAnomaly + eccentricity * Math.sin(E0);\n    }\n\n    return E0;\n  }\n\n  class Dot {\n    draw(context) {\n      context.beginPath();\n      context.lineWidth = 2 * this.size;\n      this.performDraw(context);\n      context.stroke();\n    }\n    /**\r\n     * @abstract\r\n     */\n    // eslint-disable-next-line no-empty-function, no-unused-vars\n\n\n    performDraw(context) {}\n\n    static calculatePosition(distance, angle) {\n      return {\n        x: distance * Math.sin(2 * Math.PI * angle),\n        y: distance * Math.cos(2 * Math.PI * angle)\n      };\n    }\n\n  }\n\n  class Planet extends Dot {\n    constructor() {\n      super();\n      this.angle = 0;\n      this.distance = 0;\n      this.size = PLANET_SIZE;\n    }\n\n    update(totalPhase, eccentricity, period) {\n      // Update orbital position parameters (polar coordinates centered on hole,\n      // theta goes 0 to 1 because I'm apparently stupid)\n      const E0 = eccentricAnomaly(eccentricity, 2 * Math.PI * totalPhase / period);\n      const r = SEMIMAJOR_AXIS * (1 - eccentricity * Math.cos(E0));\n      let theta = 2 * Math.atan(Math.sqrt((1 + eccentricity) / (1 - eccentricity) * Math.pow(Math.tan(E0 / 2), 2)));\n      if (Math.tan(E0 / 2) < 0) theta *= -1;\n      this.distance = r;\n      this.angle = theta / (2 * Math.PI);\n    }\n\n    performDraw(context) {\n      const {\n        x,\n        y\n      } = Dot.calculatePosition(this.distance, this.angle);\n      context.arc(x + 200, y + 200, PLANET_SIZE, 0, 2 * Math.PI);\n      context.strokeStyle = \"rgb(0, 0, 255)\";\n    }\n\n  }\n\n  class Hole extends Dot {\n    constructor(size) {\n      super();\n      this.size = size;\n    }\n\n    performDraw(context) {\n      // Glowing effect to make the hole more visible on dark themes\n      const glow = context.createRadialGradient(200, 200, 0, 200, 200, this.size * 2);\n\n      if (BlackHoles.areNegative) {\n        glow.addColorStop(0, \"rgba(255, 255, 255, 1)\");\n        glow.addColorStop(0.85, \"rgba(190, 190, 190, 1)\");\n        glow.addColorStop(0.87, \"rgba(170, 170, 170, 1)\");\n        glow.addColorStop(1, \"rgba(135, 135, 135, 0)\");\n      } else {\n        glow.addColorStop(0, \"rgba(0, 0, 0, 1)\");\n        glow.addColorStop(0.9, \"rgba(0, 0, 0, 1)\");\n        glow.addColorStop(0.92, \"rgba(100, 100, 100, 1)\");\n        glow.addColorStop(1, \"rgba(100, 100, 100, 0)\");\n      }\n\n      context.fillStyle = glow;\n      context.fillRect(0, 0, 400, 400);\n      context.strokeStyle = \"black\";\n    }\n\n  }\n\n  const blobs = \"\";\n\n  class Particle extends Dot {\n    constructor() {\n      super();\n      this.size = PARTICLE_SIZE;\n      this.respawn();\n    }\n\n    respawn() {\n      this.distance = Particle.randomDistance();\n      this.lastDistance = this.distance;\n      this.preLastDistance = this.distance;\n      this.angle = Math.random();\n      this.lastAngle = this.angle;\n      this.preLastAngle = this.angle;\n      this.respawnTick = true;\n      this.isInside = BlackHoles.areNegative;\n      this.blob = blobs[Math.floor(Math.random() * blobs.length)];\n      this.isBlob = Theme.currentName() === \"S11\";\n    }\n\n    static randomDistance() {\n      return BlackHoles.areNegative ? (1.97 * Math.random() + 0.03) * holeSize : holeSize + 0.5 * SEMIMAJOR_AXIS * Math.random() * (BlackHole(1).isActive ? 2 : 1);\n    }\n\n    update(delta, dilationFactor) {\n      const baseSpeed = 1.5;\n      const speedFactor = Math.min(Math.pow(Math.max(dilationFactor, 2) / 2, 3), 5);\n      const particleSpeed = baseSpeed * speedFactor * Math.min(delta, 16) / 1000;\n\n      if (!this.isInside) {\n        this.preLastAngle = this.lastAngle;\n        this.lastAngle = this.angle;\n        this.angle = (this.angle + 20 * particleSpeed * Math.PI * Math.pow(this.distance, -1.5)) % 1;\n      }\n\n      this.preLastDistance = this.lastDistance;\n      this.lastDistance = this.distance;\n      const distFactor = 1 + 0.3 * particleSpeed * Math.pow(this.distance / holeSize, -2);\n\n      if (BlackHoles.areNegative) {\n        this.distance *= distFactor;\n      } else {\n        this.distance /= distFactor;\n      } // This magic number is a numerical result from the arcane (and probably now-unneeded) math below\n      // in the Animation constructor, assuming reasonable values for the game state at the point when\n      // inverting is unlocked. The end result is that particles despawn in the inverted animation at\n      // roughly the maximum spawning distance as the forward animation\n\n\n      if (this.distance > 2.74645 * holeSize && BlackHoles.areNegative) {\n        this.respawn();\n      } else if (this.distance < 0.01 * holeSize && !BlackHoles.areNegative) {\n        this.respawn();\n        return;\n      }\n\n      this.isInside = this.distance <= holeSize * 0.865;\n      this.respawnTick = false;\n    }\n\n    performDraw(context) {\n      this.drawTrail(context);\n\n      if (!BlackHole(1).isActive) {\n        context.strokeStyle = \"rgb(127, 127, 127)\";\n        return;\n      }\n\n      const {\n        distance\n      } = this;\n\n      if (distance > holeSize) {\n        // Trails outside black hole\n        const dist = Math.floor(127 * (distance - holeSize) / SEMIMAJOR_AXIS);\n        context.strokeStyle = `rgb(${135 - dist}, ${dist}, ${dist})`;\n      }\n\n      if (distance <= holeSize) {\n        // Trails inside black hole\n        const dist = Math.floor(255 * Math.sqrt(distance / holeSize));\n        context.strokeStyle = `rgb(${dist}, 0, 0)`;\n      }\n    }\n\n    drawTrail(context) {\n      if (this.isInside && !BlackHole(2).isActive) {\n        return;\n      }\n\n      const {\n        x,\n        y\n      } = Dot.calculatePosition(this.distance, this.angle);\n\n      if (this.respawnTick || !BlackHole(1).isActive) {\n        context.arc(x + 200, y + 200, this.size, 0, 2 * Math.PI);\n        if (this.isBlob) this.drawAndRotateBlob(context, x, y);\n        return;\n      }\n\n      const angle = this.isInside ? this.angle : this.preLastAngle;\n      const {\n        x: lastX,\n        y: lastY\n      } = Dot.calculatePosition(this.preLastDistance, angle);\n      context.lineCap = \"round\";\n\n      if (this.isBlob) {\n        this.drawAndRotateBlob(context, x, y);\n      } else {\n        context.lineWidth *= 1;\n        context.moveTo(x + 200, y + 200);\n        context.lineTo(lastX + 200, lastY + 200);\n      }\n    }\n\n    drawAndRotateBlob(context, x, y) {\n      const FONT_SIZE = 18;\n      context.textAlign = \"center\";\n      context.fillStyle = \"orange\";\n\n      if (this.distance <= holeSize) {\n        const scale = this.distance / holeSize;\n        const px = FONT_SIZE * Math.sqrt(scale);\n        const green = 165 * scale ** 2;\n        context.fillStyle = `rgba(255, ${green}, 0, ${scale * 2})`;\n        context.font = `${px}px Typewriter`;\n      } else {\n        context.font = `${FONT_SIZE}px Typewriter`;\n      }\n\n      context.save();\n      context.translate(x + 200, y + 200);\n      context.rotate(-this.angle * Math.PI * 2 + Math.PI);\n      context.fillText(this.blob, 0, 0);\n      context.restore();\n    }\n\n  }\n\n  return class Animation {\n    constructor(context) {\n      this.context = context;\n      this.planet = new Planet(); // Time taken for one orbit (in seconds)\n\n      this.period = BlackHole(1).cycleLength; // Fixed-point iteration for eccentricity (I'm really hoping this always converges)\n\n      const y = (1 - Math.pow(ACTIVE_THRESHOLD, -2)) / (1 - Math.pow(BlackHole(1).power, -2));\n      let eccentricity = 0.5;\n      const maxIter = 1000;\n      const meanAnomaly = 2 * Math.PI * Math.min(0.9, BlackHole(1).duration / this.period);\n\n      for (let k = 0; k < maxIter; k++) {\n        const E0 = eccentricAnomaly(eccentricity, meanAnomaly);\n        eccentricity = (y - 1) / (y * Math.cos(E0) - 1);\n      }\n\n      this.eccentricity = eccentricity; // Black Hole size, calculated from orbit shape in order to give the right max boost\n\n      holeSize = SEMIMAJOR_AXIS * (1 - eccentricity) * (1 - Math.pow(BlackHole(1).power, -2)); // Prevent planet + hole overlapping\n\n      this.hole = new Hole((holeSize - PLANET_SIZE) / 2); // Particles (scaled to take the same range as the orbit)\n\n      this.particles = Array.range(0, PARTICLE_COUNT).map(() => new Particle());\n      this.frameRequest = requestAnimationFrame(time => this.update(time));\n    }\n\n    update(time) {\n      this.frameRequest = requestAnimationFrame(t => this.update(t));\n\n      if (time === undefined || this.lastFrame === undefined) {\n        this.lastFrame = time;\n        return;\n      }\n\n      const delta = time - this.lastFrame;\n      this.lastFrame = time;\n      this.planet.update(this.totalPhase(), this.eccentricity, this.period);\n      this.context.clearRect(0, 0, 400, 400);\n      this.hole.draw(this.context);\n\n      for (const particle of this.particles) {\n        particle.draw(this.context);\n      }\n\n      if (BlackHoles.arePaused && !BlackHoles.areNegative) return; // Time dilation factor (Realistic formula, but only actually used for particle speed)\n\n      const dilationFactor = 1 / Math.sqrt(1 - holeSize / this.planet.distance);\n\n      for (const particle of this.particles) {\n        particle.update(delta, dilationFactor);\n      }\n    } // Code was originally written to use phase over a cycle of active+inactive time and\n    // would be really difficult to rewrite to use the current black hole phase\n    // Example on what this is: if the black hole has intervals of 100+10 then this ranges\n    // from 0 to 110 and is active when less than 5 or more than 105\n\n\n    totalPhase() {\n      const blackHole = BlackHole(1);\n\n      if (blackHole.isActive) {\n        return (blackHole.phase - blackHole.duration / 2 + this.period) % this.period;\n      }\n\n      return blackHole.phase + blackHole.duration / 2;\n    }\n\n    unmount() {\n      cancelAnimationFrame(this.frameRequest);\n    }\n\n  };\n}();","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/components/tabs/black-hole/black-hole-animation.js"],"names":["BlackHoleAnimation","PLANET_SIZE","PARTICLE_SIZE","PARTICLE_COUNT","SEMIMAJOR_AXIS","ACTIVE_THRESHOLD","holeSize","eccentricAnomaly","eccentricity","meanAnomaly","E0","maxIter","k","Math","sin","Dot","draw","context","beginPath","lineWidth","size","performDraw","stroke","calculatePosition","distance","angle","x","PI","y","cos","Planet","constructor","update","totalPhase","period","r","theta","atan","sqrt","pow","tan","arc","strokeStyle","Hole","glow","createRadialGradient","BlackHoles","areNegative","addColorStop","fillStyle","fillRect","blobs","Particle","respawn","randomDistance","lastDistance","preLastDistance","random","lastAngle","preLastAngle","respawnTick","isInside","blob","floor","length","isBlob","Theme","currentName","BlackHole","isActive","delta","dilationFactor","baseSpeed","speedFactor","min","max","particleSpeed","distFactor","drawTrail","dist","drawAndRotateBlob","lastX","lastY","lineCap","moveTo","lineTo","FONT_SIZE","textAlign","scale","px","green","font","save","translate","rotate","fillText","restore","Animation","planet","cycleLength","power","duration","hole","particles","Array","range","map","frameRequest","requestAnimationFrame","time","t","undefined","lastFrame","clearRect","particle","arePaused","blackHole","phase","unmount","cancelAnimationFrame"],"mappings":";AAAA,OAAO,MAAMA,kBAAkB,GAAI,YAAW;AAC5C,QAAMC,WAAW,GAAG,GAApB;AACA,QAAMC,aAAa,GAAG,GAAtB;AACA,QAAMC,cAAc,GAAG,GAAvB,CAH4C,CAI5C;;AACA,QAAMC,cAAc,GAAG,GAAvB,CAL4C,CAM5C;;AACA,QAAMC,gBAAgB,GAAG,CAAzB;AAEA,MAAIC,QAAJ,CAT4C,CAW5C;AACA;AACA;;AACA,WAASC,gBAAT,CAA0BC,YAA1B,EAAwCC,WAAxC,EAAqD;AACnD,QAAIC,EAAE,GAAGD,WAAT,CADmD,CAEnD;;AACA,UAAME,OAAO,GAAG,EAAhB;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,OAApB,EAA6BC,CAAC,EAA9B,EAAkC;AAChCF,MAAAA,EAAE,GAAGD,WAAW,GAAGD,YAAY,GAAGK,IAAI,CAACC,GAAL,CAASJ,EAAT,CAAlC;AACD;;AACD,WAAOA,EAAP;AACD;;AAED,QAAMK,GAAN,CAAU;AACRC,IAAAA,IAAI,CAACC,OAAD,EAAU;AACZA,MAAAA,OAAO,CAACC,SAAR;AACAD,MAAAA,OAAO,CAACE,SAAR,GAAoB,IAAI,KAAKC,IAA7B;AACA,WAAKC,WAAL,CAAiBJ,OAAjB;AACAA,MAAAA,OAAO,CAACK,MAAR;AACD;AAED;AACJ;AACA;AACI;;;AACAD,IAAAA,WAAW,CAACJ,OAAD,EAAU,CAAG;;AAEA,WAAjBM,iBAAiB,CAACC,QAAD,EAAWC,KAAX,EAAkB;AACxC,aAAO;AACLC,QAAAA,CAAC,EAAEF,QAAQ,GAAGX,IAAI,CAACC,GAAL,CAAS,IAAID,IAAI,CAACc,EAAT,GAAcF,KAAvB,CADT;AAELG,QAAAA,CAAC,EAAEJ,QAAQ,GAAGX,IAAI,CAACgB,GAAL,CAAS,IAAIhB,IAAI,CAACc,EAAT,GAAcF,KAAvB;AAFT,OAAP;AAID;;AAnBO;;AAsBV,QAAMK,MAAN,SAAqBf,GAArB,CAAyB;AACvBgB,IAAAA,WAAW,GAAG;AACZ;AACA,WAAKN,KAAL,GAAa,CAAb;AACA,WAAKD,QAAL,GAAgB,CAAhB;AACA,WAAKJ,IAAL,GAAYnB,WAAZ;AACD;;AAED+B,IAAAA,MAAM,CAACC,UAAD,EAAazB,YAAb,EAA2B0B,MAA3B,EAAmC;AACvC;AACA;AACA,YAAMxB,EAAE,GAAGH,gBAAgB,CAACC,YAAD,EAAe,IAAIK,IAAI,CAACc,EAAT,GAAcM,UAAd,GAA2BC,MAA1C,CAA3B;AACA,YAAMC,CAAC,GAAG/B,cAAc,IAAI,IAAII,YAAY,GAAGK,IAAI,CAACgB,GAAL,CAASnB,EAAT,CAAvB,CAAxB;AACA,UAAI0B,KAAK,GAAG,IAAIvB,IAAI,CAACwB,IAAL,CAAUxB,IAAI,CAACyB,IAAL,CAAU,CAAC,IAAI9B,YAAL,KAAsB,IAAIA,YAA1B,IAA0CK,IAAI,CAAC0B,GAAL,CAAS1B,IAAI,CAAC2B,GAAL,CAAS9B,EAAE,GAAG,CAAd,CAAT,EAA2B,CAA3B,CAApD,CAAV,CAAhB;AACA,UAAIG,IAAI,CAAC2B,GAAL,CAAS9B,EAAE,GAAG,CAAd,IAAmB,CAAvB,EAA0B0B,KAAK,IAAI,CAAC,CAAV;AAC1B,WAAKZ,QAAL,GAAgBW,CAAhB;AACA,WAAKV,KAAL,GAAaW,KAAK,IAAI,IAAIvB,IAAI,CAACc,EAAb,CAAlB;AACD;;AAEDN,IAAAA,WAAW,CAACJ,OAAD,EAAU;AACnB,YAAM;AAAES,QAAAA,CAAF;AAAKE,QAAAA;AAAL,UAAWb,GAAG,CAACQ,iBAAJ,CAAsB,KAAKC,QAA3B,EAAqC,KAAKC,KAA1C,CAAjB;AACAR,MAAAA,OAAO,CAACwB,GAAR,CAAYf,CAAC,GAAG,GAAhB,EAAqBE,CAAC,GAAG,GAAzB,EAA8B3B,WAA9B,EAA2C,CAA3C,EAA8C,IAAIY,IAAI,CAACc,EAAvD;AACAV,MAAAA,OAAO,CAACyB,WAAR,GAAsB,gBAAtB;AACD;;AAvBsB;;AA0BzB,QAAMC,IAAN,SAAmB5B,GAAnB,CAAuB;AACrBgB,IAAAA,WAAW,CAACX,IAAD,EAAO;AAChB;AACA,WAAKA,IAAL,GAAYA,IAAZ;AACD;;AAEDC,IAAAA,WAAW,CAACJ,OAAD,EAAU;AACnB;AACA,YAAM2B,IAAI,GAAG3B,OAAO,CAAC4B,oBAAR,CAA6B,GAA7B,EAAkC,GAAlC,EAAuC,CAAvC,EAA0C,GAA1C,EAA+C,GAA/C,EAAoD,KAAKzB,IAAL,GAAY,CAAhE,CAAb;;AACA,UAAI0B,UAAU,CAACC,WAAf,EAA4B;AAC1BH,QAAAA,IAAI,CAACI,YAAL,CAAkB,CAAlB,EAAqB,wBAArB;AACAJ,QAAAA,IAAI,CAACI,YAAL,CAAkB,IAAlB,EAAwB,wBAAxB;AACAJ,QAAAA,IAAI,CAACI,YAAL,CAAkB,IAAlB,EAAwB,wBAAxB;AACAJ,QAAAA,IAAI,CAACI,YAAL,CAAkB,CAAlB,EAAqB,wBAArB;AACD,OALD,MAKO;AACLJ,QAAAA,IAAI,CAACI,YAAL,CAAkB,CAAlB,EAAqB,kBAArB;AACAJ,QAAAA,IAAI,CAACI,YAAL,CAAkB,GAAlB,EAAuB,kBAAvB;AACAJ,QAAAA,IAAI,CAACI,YAAL,CAAkB,IAAlB,EAAwB,wBAAxB;AACAJ,QAAAA,IAAI,CAACI,YAAL,CAAkB,CAAlB,EAAqB,wBAArB;AACD;;AACD/B,MAAAA,OAAO,CAACgC,SAAR,GAAoBL,IAApB;AACA3B,MAAAA,OAAO,CAACiC,QAAR,CAAiB,CAAjB,EAAoB,CAApB,EAAuB,GAAvB,EAA4B,GAA5B;AACAjC,MAAAA,OAAO,CAACyB,WAAR,GAAsB,OAAtB;AACD;;AAvBoB;;AA0BvB,QAAMS,KAAK,GAAG,2BAAd;;AACA,QAAMC,QAAN,SAAuBrC,GAAvB,CAA2B;AACzBgB,IAAAA,WAAW,GAAG;AACZ;AACA,WAAKX,IAAL,GAAYlB,aAAZ;AACA,WAAKmD,OAAL;AACD;;AAEDA,IAAAA,OAAO,GAAG;AACR,WAAK7B,QAAL,GAAgB4B,QAAQ,CAACE,cAAT,EAAhB;AACA,WAAKC,YAAL,GAAoB,KAAK/B,QAAzB;AACA,WAAKgC,eAAL,GAAuB,KAAKhC,QAA5B;AACA,WAAKC,KAAL,GAAaZ,IAAI,CAAC4C,MAAL,EAAb;AACA,WAAKC,SAAL,GAAiB,KAAKjC,KAAtB;AACA,WAAKkC,YAAL,GAAoB,KAAKlC,KAAzB;AACA,WAAKmC,WAAL,GAAmB,IAAnB;AACA,WAAKC,QAAL,GAAgBf,UAAU,CAACC,WAA3B;AACA,WAAKe,IAAL,GAAYX,KAAK,CAACtC,IAAI,CAACkD,KAAL,CAAWlD,IAAI,CAAC4C,MAAL,KAAgBN,KAAK,CAACa,MAAjC,CAAD,CAAjB;AACA,WAAKC,MAAL,GAAcC,KAAK,CAACC,WAAN,OAAwB,KAAtC;AACD;;AAEoB,WAAdb,cAAc,GAAG;AACtB,aAAOR,UAAU,CAACC,WAAX,GACH,CAAC,OAAOlC,IAAI,CAAC4C,MAAL,EAAP,GAAuB,IAAxB,IAAgCnD,QAD7B,GAEHA,QAAQ,GAAG,MAAMF,cAAN,GAAuBS,IAAI,CAAC4C,MAAL,EAAvB,IAAwCW,SAAS,CAAC,CAAD,CAAT,CAAaC,QAAb,GAAwB,CAAxB,GAA4B,CAApE,CAFf;AAGD;;AAEDrC,IAAAA,MAAM,CAACsC,KAAD,EAAQC,cAAR,EAAwB;AAC5B,YAAMC,SAAS,GAAG,GAAlB;AACA,YAAMC,WAAW,GAAG5D,IAAI,CAAC6D,GAAL,CAAS7D,IAAI,CAAC0B,GAAL,CAAS1B,IAAI,CAAC8D,GAAL,CAASJ,cAAT,EAAyB,CAAzB,IAA8B,CAAvC,EAA0C,CAA1C,CAAT,EAAuD,CAAvD,CAApB;AACA,YAAMK,aAAa,GAAGJ,SAAS,GAAGC,WAAZ,GAA0B5D,IAAI,CAAC6D,GAAL,CAASJ,KAAT,EAAgB,EAAhB,CAA1B,GAAgD,IAAtE;;AAEA,UAAI,CAAC,KAAKT,QAAV,EAAoB;AAClB,aAAKF,YAAL,GAAoB,KAAKD,SAAzB;AACA,aAAKA,SAAL,GAAiB,KAAKjC,KAAtB;AACA,aAAKA,KAAL,GAAa,CAAC,KAAKA,KAAL,GAAa,KAAKmD,aAAL,GAAqB/D,IAAI,CAACc,EAA1B,GAA+Bd,IAAI,CAAC0B,GAAL,CAAS,KAAKf,QAAd,EAAwB,CAAC,GAAzB,CAA7C,IAA8E,CAA3F;AACD;;AAED,WAAKgC,eAAL,GAAuB,KAAKD,YAA5B;AACA,WAAKA,YAAL,GAAoB,KAAK/B,QAAzB;AACA,YAAMqD,UAAU,GAAG,IAAI,MAAMD,aAAN,GAAsB/D,IAAI,CAAC0B,GAAL,CAAS,KAAKf,QAAL,GAAgBlB,QAAzB,EAAmC,CAAC,CAApC,CAA7C;;AACA,UAAIwC,UAAU,CAACC,WAAf,EAA4B;AAC1B,aAAKvB,QAAL,IAAiBqD,UAAjB;AACD,OAFD,MAEO;AACL,aAAKrD,QAAL,IAAiBqD,UAAjB;AACD,OAlB2B,CAoB5B;AACA;AACA;AACA;;;AACA,UAAI,KAAKrD,QAAL,GAAgB,UAAUlB,QAA1B,IAAsCwC,UAAU,CAACC,WAArD,EAAkE;AAChE,aAAKM,OAAL;AACD,OAFD,MAEO,IAAI,KAAK7B,QAAL,GAAgB,OAAOlB,QAAvB,IAAmC,CAACwC,UAAU,CAACC,WAAnD,EAAgE;AACrE,aAAKM,OAAL;AACA;AACD;;AAED,WAAKQ,QAAL,GAAgB,KAAKrC,QAAL,IAAiBlB,QAAQ,GAAG,KAA5C;AACA,WAAKsD,WAAL,GAAmB,KAAnB;AACD;;AAEDvC,IAAAA,WAAW,CAACJ,OAAD,EAAU;AACnB,WAAK6D,SAAL,CAAe7D,OAAf;;AAEA,UAAI,CAACmD,SAAS,CAAC,CAAD,CAAT,CAAaC,QAAlB,EAA4B;AAC1BpD,QAAAA,OAAO,CAACyB,WAAR,GAAsB,oBAAtB;AACA;AACD;;AAED,YAAM;AAAElB,QAAAA;AAAF,UAAe,IAArB;;AAEA,UAAIA,QAAQ,GAAGlB,QAAf,EAAyB;AACvB;AACA,cAAMyE,IAAI,GAAGlE,IAAI,CAACkD,KAAL,CAAW,OAAOvC,QAAQ,GAAGlB,QAAlB,IAA8BF,cAAzC,CAAb;AACAa,QAAAA,OAAO,CAACyB,WAAR,GAAuB,OAAM,MAAMqC,IAAK,KAAIA,IAAK,KAAIA,IAAK,GAA1D;AACD;;AAED,UAAIvD,QAAQ,IAAIlB,QAAhB,EAA0B;AACxB;AACA,cAAMyE,IAAI,GAAGlE,IAAI,CAACkD,KAAL,CAAW,MAAMlD,IAAI,CAACyB,IAAL,CAAUd,QAAQ,GAAGlB,QAArB,CAAjB,CAAb;AACAW,QAAAA,OAAO,CAACyB,WAAR,GAAuB,OAAMqC,IAAK,SAAlC;AACD;AACF;;AAEDD,IAAAA,SAAS,CAAC7D,OAAD,EAAU;AACjB,UAAI,KAAK4C,QAAL,IAAiB,CAACO,SAAS,CAAC,CAAD,CAAT,CAAaC,QAAnC,EAA6C;AAC3C;AACD;;AACD,YAAM;AAAE3C,QAAAA,CAAF;AAAKE,QAAAA;AAAL,UAAWb,GAAG,CAACQ,iBAAJ,CAAsB,KAAKC,QAA3B,EAAqC,KAAKC,KAA1C,CAAjB;;AACA,UAAI,KAAKmC,WAAL,IAAoB,CAACQ,SAAS,CAAC,CAAD,CAAT,CAAaC,QAAtC,EAAgD;AAC9CpD,QAAAA,OAAO,CAACwB,GAAR,CAAYf,CAAC,GAAG,GAAhB,EAAqBE,CAAC,GAAG,GAAzB,EAA8B,KAAKR,IAAnC,EAAyC,CAAzC,EAA4C,IAAIP,IAAI,CAACc,EAArD;AACA,YAAI,KAAKsC,MAAT,EAAiB,KAAKe,iBAAL,CAAuB/D,OAAvB,EAAgCS,CAAhC,EAAmCE,CAAnC;AACjB;AACD;;AACD,YAAMH,KAAK,GAAG,KAAKoC,QAAL,GAAgB,KAAKpC,KAArB,GAA6B,KAAKkC,YAAhD;AACA,YAAM;AAAEjC,QAAAA,CAAC,EAAEuD,KAAL;AAAYrD,QAAAA,CAAC,EAAEsD;AAAf,UAAyBnE,GAAG,CAACQ,iBAAJ,CAAsB,KAAKiC,eAA3B,EAA4C/B,KAA5C,CAA/B;AACAR,MAAAA,OAAO,CAACkE,OAAR,GAAkB,OAAlB;;AAEA,UAAI,KAAKlB,MAAT,EAAiB;AACf,aAAKe,iBAAL,CAAuB/D,OAAvB,EAAgCS,CAAhC,EAAmCE,CAAnC;AACD,OAFD,MAEO;AACLX,QAAAA,OAAO,CAACE,SAAR,IAAqB,CAArB;AACAF,QAAAA,OAAO,CAACmE,MAAR,CAAe1D,CAAC,GAAG,GAAnB,EAAwBE,CAAC,GAAG,GAA5B;AACAX,QAAAA,OAAO,CAACoE,MAAR,CAAeJ,KAAK,GAAG,GAAvB,EAA4BC,KAAK,GAAG,GAApC;AACD;AACF;;AAEDF,IAAAA,iBAAiB,CAAC/D,OAAD,EAAUS,CAAV,EAAaE,CAAb,EAAgB;AAC/B,YAAM0D,SAAS,GAAG,EAAlB;AACArE,MAAAA,OAAO,CAACsE,SAAR,GAAoB,QAApB;AACAtE,MAAAA,OAAO,CAACgC,SAAR,GAAoB,QAApB;;AAEA,UAAI,KAAKzB,QAAL,IAAiBlB,QAArB,EAA+B;AAC7B,cAAMkF,KAAK,GAAG,KAAKhE,QAAL,GAAgBlB,QAA9B;AACA,cAAMmF,EAAE,GAAGH,SAAS,GAAGzE,IAAI,CAACyB,IAAL,CAAUkD,KAAV,CAAvB;AACA,cAAME,KAAK,GAAG,MAAMF,KAAK,IAAI,CAA7B;AAEAvE,QAAAA,OAAO,CAACgC,SAAR,GAAqB,aAAYyC,KAAM,QAAOF,KAAK,GAAG,CAAE,GAAxD;AACAvE,QAAAA,OAAO,CAAC0E,IAAR,GAAgB,GAAEF,EAAG,eAArB;AACD,OAPD,MAOO;AACLxE,QAAAA,OAAO,CAAC0E,IAAR,GAAgB,GAAEL,SAAU,eAA5B;AACD;;AAEDrE,MAAAA,OAAO,CAAC2E,IAAR;AACA3E,MAAAA,OAAO,CAAC4E,SAAR,CAAkBnE,CAAC,GAAG,GAAtB,EAA2BE,CAAC,GAAG,GAA/B;AACAX,MAAAA,OAAO,CAAC6E,MAAR,CAAe,CAAC,KAAKrE,KAAN,GAAcZ,IAAI,CAACc,EAAnB,GAAwB,CAAxB,GAA4Bd,IAAI,CAACc,EAAhD;AACAV,MAAAA,OAAO,CAAC8E,QAAR,CAAiB,KAAKjC,IAAtB,EAA4B,CAA5B,EAA+B,CAA/B;AACA7C,MAAAA,OAAO,CAAC+E,OAAR;AACD;;AAhIwB;;AAmI3B,SAAO,MAAMC,SAAN,CAAgB;AACrBlE,IAAAA,WAAW,CAACd,OAAD,EAAU;AACnB,WAAKA,OAAL,GAAeA,OAAf;AACA,WAAKiF,MAAL,GAAc,IAAIpE,MAAJ,EAAd,CAFmB,CAInB;;AACA,WAAKI,MAAL,GAAckC,SAAS,CAAC,CAAD,CAAT,CAAa+B,WAA3B,CALmB,CAMnB;;AACA,YAAMvE,CAAC,GAAG,CAAC,IAAIf,IAAI,CAAC0B,GAAL,CAASlC,gBAAT,EAA2B,CAAC,CAA5B,CAAL,KAAwC,IAAIQ,IAAI,CAAC0B,GAAL,CAAS6B,SAAS,CAAC,CAAD,CAAT,CAAagC,KAAtB,EAA6B,CAAC,CAA9B,CAA5C,CAAV;AACA,UAAI5F,YAAY,GAAG,GAAnB;AACA,YAAMG,OAAO,GAAG,IAAhB;AACA,YAAMF,WAAW,GAAG,IAAII,IAAI,CAACc,EAAT,GAAcd,IAAI,CAAC6D,GAAL,CAAS,GAAT,EAAcN,SAAS,CAAC,CAAD,CAAT,CAAaiC,QAAb,GAAwB,KAAKnE,MAA3C,CAAlC;;AACA,WAAK,IAAItB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,OAApB,EAA6BC,CAAC,EAA9B,EAAkC;AAChC,cAAMF,EAAE,GAAGH,gBAAgB,CAACC,YAAD,EAAeC,WAAf,CAA3B;AACAD,QAAAA,YAAY,GAAG,CAACoB,CAAC,GAAG,CAAL,KAAWA,CAAC,GAAGf,IAAI,CAACgB,GAAL,CAASnB,EAAT,CAAJ,GAAmB,CAA9B,CAAf;AACD;;AACD,WAAKF,YAAL,GAAoBA,YAApB,CAfmB,CAiBnB;;AACAF,MAAAA,QAAQ,GAAGF,cAAc,IAAI,IAAII,YAAR,CAAd,IAAuC,IAAIK,IAAI,CAAC0B,GAAL,CAAS6B,SAAS,CAAC,CAAD,CAAT,CAAagC,KAAtB,EAA6B,CAAC,CAA9B,CAA3C,CAAX,CAlBmB,CAmBnB;;AACA,WAAKE,IAAL,GAAY,IAAI3D,IAAJ,CAAS,CAACrC,QAAQ,GAAGL,WAAZ,IAA2B,CAApC,CAAZ,CApBmB,CAsBnB;;AACA,WAAKsG,SAAL,GAAiBC,KAAK,CAACC,KAAN,CAAY,CAAZ,EAAetG,cAAf,EAA+BuG,GAA/B,CAAmC,MAAM,IAAItD,QAAJ,EAAzC,CAAjB;AACA,WAAKuD,YAAL,GAAoBC,qBAAqB,CAACC,IAAI,IAAI,KAAK7E,MAAL,CAAY6E,IAAZ,CAAT,CAAzC;AACD;;AAED7E,IAAAA,MAAM,CAAC6E,IAAD,EAAO;AACX,WAAKF,YAAL,GAAoBC,qBAAqB,CAACE,CAAC,IAAI,KAAK9E,MAAL,CAAY8E,CAAZ,CAAN,CAAzC;;AACA,UAAID,IAAI,KAAKE,SAAT,IAAsB,KAAKC,SAAL,KAAmBD,SAA7C,EAAwD;AACtD,aAAKC,SAAL,GAAiBH,IAAjB;AACA;AACD;;AACD,YAAMvC,KAAK,GAAGuC,IAAI,GAAG,KAAKG,SAA1B;AACA,WAAKA,SAAL,GAAiBH,IAAjB;AAEA,WAAKX,MAAL,CAAYlE,MAAZ,CAAmB,KAAKC,UAAL,EAAnB,EAAsC,KAAKzB,YAA3C,EAAyD,KAAK0B,MAA9D;AAEA,WAAKjB,OAAL,CAAagG,SAAb,CAAuB,CAAvB,EAA0B,CAA1B,EAA6B,GAA7B,EAAkC,GAAlC;AACA,WAAKX,IAAL,CAAUtF,IAAV,CAAe,KAAKC,OAApB;;AACA,WAAK,MAAMiG,QAAX,IAAuB,KAAKX,SAA5B,EAAuC;AACrCW,QAAAA,QAAQ,CAAClG,IAAT,CAAc,KAAKC,OAAnB;AACD;;AAED,UAAI6B,UAAU,CAACqE,SAAX,IAAwB,CAACrE,UAAU,CAACC,WAAxC,EAAqD,OAjB1C,CAoBX;;AACA,YAAMwB,cAAc,GAAG,IAAI1D,IAAI,CAACyB,IAAL,CAAU,IAAIhC,QAAQ,GAAG,KAAK4F,MAAL,CAAY1E,QAArC,CAA3B;;AACA,WAAK,MAAM0F,QAAX,IAAuB,KAAKX,SAA5B,EAAuC;AACrCW,QAAAA,QAAQ,CAAClF,MAAT,CAAgBsC,KAAhB,EAAuBC,cAAvB;AACD;AACF,KArDoB,CAuDrB;AACA;AACA;AACA;;;AACAtC,IAAAA,UAAU,GAAG;AACX,YAAMmF,SAAS,GAAGhD,SAAS,CAAC,CAAD,CAA3B;;AACA,UAAIgD,SAAS,CAAC/C,QAAd,EAAwB;AACtB,eAAO,CAAC+C,SAAS,CAACC,KAAV,GAAkBD,SAAS,CAACf,QAAV,GAAqB,CAAvC,GAA2C,KAAKnE,MAAjD,IAA2D,KAAKA,MAAvE;AACD;;AAED,aAAOkF,SAAS,CAACC,KAAV,GAAkBD,SAAS,CAACf,QAAV,GAAqB,CAA9C;AACD;;AAEDiB,IAAAA,OAAO,GAAG;AACRC,MAAAA,oBAAoB,CAAC,KAAKZ,YAAN,CAApB;AACD;;AAtEoB,GAAvB;AAwED,CA9SkC,EAA5B","sourcesContent":["export const BlackHoleAnimation = (function() {\r\n  const PLANET_SIZE = 1.5;\r\n  const PARTICLE_SIZE = 0.5;\r\n  const PARTICLE_COUNT = 120;\r\n  // Basically orbit size in pixels\r\n  const SEMIMAJOR_AXIS = 100;\r\n  // Black Hole active time approximately corresponds to time with >2x\r\n  const ACTIVE_THRESHOLD = 2;\r\n\r\n  let holeSize;\r\n\r\n  // Calculates \"eccentric anomaly\" from \"mean anomaly\",\r\n  // see https://en.wikipedia.org/wiki/Kepler%27s_equation#Numerical_approximation_of_inverse_problem\r\n  // Needed for accurate Keplerian orbit shape and velocity, apparently math is hard\r\n  function eccentricAnomaly(eccentricity, meanAnomaly) {\r\n    let E0 = meanAnomaly;\r\n    // I hope 20 is enough to converge\r\n    const maxIter = 20;\r\n    for (let k = 0; k < maxIter; k++) {\r\n      E0 = meanAnomaly + eccentricity * Math.sin(E0);\r\n    }\r\n    return E0;\r\n  }\r\n\r\n  class Dot {\r\n    draw(context) {\r\n      context.beginPath();\r\n      context.lineWidth = 2 * this.size;\r\n      this.performDraw(context);\r\n      context.stroke();\r\n    }\r\n\r\n    /**\r\n     * @abstract\r\n     */\r\n    // eslint-disable-next-line no-empty-function, no-unused-vars\r\n    performDraw(context) { }\r\n\r\n    static calculatePosition(distance, angle) {\r\n      return {\r\n        x: distance * Math.sin(2 * Math.PI * angle),\r\n        y: distance * Math.cos(2 * Math.PI * angle)\r\n      };\r\n    }\r\n  }\r\n\r\n  class Planet extends Dot {\r\n    constructor() {\r\n      super();\r\n      this.angle = 0;\r\n      this.distance = 0;\r\n      this.size = PLANET_SIZE;\r\n    }\r\n\r\n    update(totalPhase, eccentricity, period) {\r\n      // Update orbital position parameters (polar coordinates centered on hole,\r\n      // theta goes 0 to 1 because I'm apparently stupid)\r\n      const E0 = eccentricAnomaly(eccentricity, 2 * Math.PI * totalPhase / period);\r\n      const r = SEMIMAJOR_AXIS * (1 - eccentricity * Math.cos(E0));\r\n      let theta = 2 * Math.atan(Math.sqrt((1 + eccentricity) / (1 - eccentricity) * Math.pow(Math.tan(E0 / 2), 2)));\r\n      if (Math.tan(E0 / 2) < 0) theta *= -1;\r\n      this.distance = r;\r\n      this.angle = theta / (2 * Math.PI);\r\n    }\r\n\r\n    performDraw(context) {\r\n      const { x, y } = Dot.calculatePosition(this.distance, this.angle);\r\n      context.arc(x + 200, y + 200, PLANET_SIZE, 0, 2 * Math.PI);\r\n      context.strokeStyle = \"rgb(0, 0, 255)\";\r\n    }\r\n  }\r\n\r\n  class Hole extends Dot {\r\n    constructor(size) {\r\n      super();\r\n      this.size = size;\r\n    }\r\n\r\n    performDraw(context) {\r\n      // Glowing effect to make the hole more visible on dark themes\r\n      const glow = context.createRadialGradient(200, 200, 0, 200, 200, this.size * 2);\r\n      if (BlackHoles.areNegative) {\r\n        glow.addColorStop(0, \"rgba(255, 255, 255, 1)\");\r\n        glow.addColorStop(0.85, \"rgba(190, 190, 190, 1)\");\r\n        glow.addColorStop(0.87, \"rgba(170, 170, 170, 1)\");\r\n        glow.addColorStop(1, \"rgba(135, 135, 135, 0)\");\r\n      } else {\r\n        glow.addColorStop(0, \"rgba(0, 0, 0, 1)\");\r\n        glow.addColorStop(0.9, \"rgba(0, 0, 0, 1)\");\r\n        glow.addColorStop(0.92, \"rgba(100, 100, 100, 1)\");\r\n        glow.addColorStop(1, \"rgba(100, 100, 100, 0)\");\r\n      }\r\n      context.fillStyle = glow;\r\n      context.fillRect(0, 0, 400, 400);\r\n      context.strokeStyle = \"black\";\r\n    }\r\n  }\r\n\r\n  const blobs = \"\";\r\n  class Particle extends Dot {\r\n    constructor() {\r\n      super();\r\n      this.size = PARTICLE_SIZE;\r\n      this.respawn();\r\n    }\r\n\r\n    respawn() {\r\n      this.distance = Particle.randomDistance();\r\n      this.lastDistance = this.distance;\r\n      this.preLastDistance = this.distance;\r\n      this.angle = Math.random();\r\n      this.lastAngle = this.angle;\r\n      this.preLastAngle = this.angle;\r\n      this.respawnTick = true;\r\n      this.isInside = BlackHoles.areNegative;\r\n      this.blob = blobs[Math.floor(Math.random() * blobs.length)];\r\n      this.isBlob = Theme.currentName() === \"S11\";\r\n    }\r\n\r\n    static randomDistance() {\r\n      return BlackHoles.areNegative\r\n        ? (1.97 * Math.random() + 0.03) * holeSize\r\n        : holeSize + 0.5 * SEMIMAJOR_AXIS * Math.random() * (BlackHole(1).isActive ? 2 : 1);\r\n    }\r\n\r\n    update(delta, dilationFactor) {\r\n      const baseSpeed = 1.5;\r\n      const speedFactor = Math.min(Math.pow(Math.max(dilationFactor, 2) / 2, 3), 5);\r\n      const particleSpeed = baseSpeed * speedFactor * Math.min(delta, 16) / 1000;\r\n\r\n      if (!this.isInside) {\r\n        this.preLastAngle = this.lastAngle;\r\n        this.lastAngle = this.angle;\r\n        this.angle = (this.angle + 20 * particleSpeed * Math.PI * Math.pow(this.distance, -1.5)) % 1;\r\n      }\r\n\r\n      this.preLastDistance = this.lastDistance;\r\n      this.lastDistance = this.distance;\r\n      const distFactor = 1 + 0.3 * particleSpeed * Math.pow(this.distance / holeSize, -2);\r\n      if (BlackHoles.areNegative) {\r\n        this.distance *= distFactor;\r\n      } else {\r\n        this.distance /= distFactor;\r\n      }\r\n\r\n      // This magic number is a numerical result from the arcane (and probably now-unneeded) math below\r\n      // in the Animation constructor, assuming reasonable values for the game state at the point when\r\n      // inverting is unlocked. The end result is that particles despawn in the inverted animation at\r\n      // roughly the maximum spawning distance as the forward animation\r\n      if (this.distance > 2.74645 * holeSize && BlackHoles.areNegative) {\r\n        this.respawn();\r\n      } else if (this.distance < 0.01 * holeSize && !BlackHoles.areNegative) {\r\n        this.respawn();\r\n        return;\r\n      }\r\n\r\n      this.isInside = this.distance <= holeSize * 0.865;\r\n      this.respawnTick = false;\r\n    }\r\n\r\n    performDraw(context) {\r\n      this.drawTrail(context);\r\n\r\n      if (!BlackHole(1).isActive) {\r\n        context.strokeStyle = \"rgb(127, 127, 127)\";\r\n        return;\r\n      }\r\n\r\n      const { distance } = this;\r\n\r\n      if (distance > holeSize) {\r\n        // Trails outside black hole\r\n        const dist = Math.floor(127 * (distance - holeSize) / SEMIMAJOR_AXIS);\r\n        context.strokeStyle = `rgb(${135 - dist}, ${dist}, ${dist})`;\r\n      }\r\n\r\n      if (distance <= holeSize) {\r\n        // Trails inside black hole\r\n        const dist = Math.floor(255 * Math.sqrt(distance / holeSize));\r\n        context.strokeStyle = `rgb(${dist}, 0, 0)`;\r\n      }\r\n    }\r\n\r\n    drawTrail(context) {\r\n      if (this.isInside && !BlackHole(2).isActive) {\r\n        return;\r\n      }\r\n      const { x, y } = Dot.calculatePosition(this.distance, this.angle);\r\n      if (this.respawnTick || !BlackHole(1).isActive) {\r\n        context.arc(x + 200, y + 200, this.size, 0, 2 * Math.PI);\r\n        if (this.isBlob) this.drawAndRotateBlob(context, x, y);\r\n        return;\r\n      }\r\n      const angle = this.isInside ? this.angle : this.preLastAngle;\r\n      const { x: lastX, y: lastY } = Dot.calculatePosition(this.preLastDistance, angle);\r\n      context.lineCap = \"round\";\r\n\r\n      if (this.isBlob) {\r\n        this.drawAndRotateBlob(context, x, y);\r\n      } else {\r\n        context.lineWidth *= 1;\r\n        context.moveTo(x + 200, y + 200);\r\n        context.lineTo(lastX + 200, lastY + 200);\r\n      }\r\n    }\r\n\r\n    drawAndRotateBlob(context, x, y) {\r\n      const FONT_SIZE = 18;\r\n      context.textAlign = \"center\";\r\n      context.fillStyle = \"orange\";\r\n\r\n      if (this.distance <= holeSize) {\r\n        const scale = this.distance / holeSize;\r\n        const px = FONT_SIZE * Math.sqrt(scale);\r\n        const green = 165 * scale ** 2;\r\n\r\n        context.fillStyle = `rgba(255, ${green}, 0, ${scale * 2})`;\r\n        context.font = `${px}px Typewriter`;\r\n      } else {\r\n        context.font = `${FONT_SIZE}px Typewriter`;\r\n      }\r\n\r\n      context.save();\r\n      context.translate(x + 200, y + 200);\r\n      context.rotate(-this.angle * Math.PI * 2 + Math.PI);\r\n      context.fillText(this.blob, 0, 0);\r\n      context.restore();\r\n    }\r\n  }\r\n\r\n  return class Animation {\r\n    constructor(context) {\r\n      this.context = context;\r\n      this.planet = new Planet();\r\n\r\n      // Time taken for one orbit (in seconds)\r\n      this.period = BlackHole(1).cycleLength;\r\n      // Fixed-point iteration for eccentricity (I'm really hoping this always converges)\r\n      const y = (1 - Math.pow(ACTIVE_THRESHOLD, -2)) / (1 - Math.pow(BlackHole(1).power, -2));\r\n      let eccentricity = 0.5;\r\n      const maxIter = 1000;\r\n      const meanAnomaly = 2 * Math.PI * Math.min(0.9, BlackHole(1).duration / this.period);\r\n      for (let k = 0; k < maxIter; k++) {\r\n        const E0 = eccentricAnomaly(eccentricity, meanAnomaly);\r\n        eccentricity = (y - 1) / (y * Math.cos(E0) - 1);\r\n      }\r\n      this.eccentricity = eccentricity;\r\n\r\n      // Black Hole size, calculated from orbit shape in order to give the right max boost\r\n      holeSize = SEMIMAJOR_AXIS * (1 - eccentricity) * (1 - Math.pow(BlackHole(1).power, -2));\r\n      // Prevent planet + hole overlapping\r\n      this.hole = new Hole((holeSize - PLANET_SIZE) / 2);\r\n\r\n      // Particles (scaled to take the same range as the orbit)\r\n      this.particles = Array.range(0, PARTICLE_COUNT).map(() => new Particle());\r\n      this.frameRequest = requestAnimationFrame(time => this.update(time));\r\n    }\r\n\r\n    update(time) {\r\n      this.frameRequest = requestAnimationFrame(t => this.update(t));\r\n      if (time === undefined || this.lastFrame === undefined) {\r\n        this.lastFrame = time;\r\n        return;\r\n      }\r\n      const delta = time - this.lastFrame;\r\n      this.lastFrame = time;\r\n\r\n      this.planet.update(this.totalPhase(), this.eccentricity, this.period);\r\n\r\n      this.context.clearRect(0, 0, 400, 400);\r\n      this.hole.draw(this.context);\r\n      for (const particle of this.particles) {\r\n        particle.draw(this.context);\r\n      }\r\n\r\n      if (BlackHoles.arePaused && !BlackHoles.areNegative) return;\r\n\r\n\r\n      // Time dilation factor (Realistic formula, but only actually used for particle speed)\r\n      const dilationFactor = 1 / Math.sqrt(1 - holeSize / this.planet.distance);\r\n      for (const particle of this.particles) {\r\n        particle.update(delta, dilationFactor);\r\n      }\r\n    }\r\n\r\n    // Code was originally written to use phase over a cycle of active+inactive time and\r\n    // would be really difficult to rewrite to use the current black hole phase\r\n    // Example on what this is: if the black hole has intervals of 100+10 then this ranges\r\n    // from 0 to 110 and is active when less than 5 or more than 105\r\n    totalPhase() {\r\n      const blackHole = BlackHole(1);\r\n      if (blackHole.isActive) {\r\n        return (blackHole.phase - blackHole.duration / 2 + this.period) % this.period;\r\n      }\r\n\r\n      return blackHole.phase + blackHole.duration / 2;\r\n    }\r\n\r\n    unmount() {\r\n      cancelAnimationFrame(this.frameRequest);\r\n    }\r\n  };\r\n}());\r\n"]},"metadata":{},"sourceType":"module"}