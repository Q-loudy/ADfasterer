{"ast":null,"code":"import { AutobuyerState } from \"./autobuyer\";\nexport class RealityAutobuyerState extends AutobuyerState {\n  get data() {\n    return player.auto.reality;\n  }\n\n  get name() {\n    return `Reality`;\n  }\n\n  get isUnlocked() {\n    return RealityUpgrade(25).isBought;\n  }\n\n  get canTick() {\n    return super.canTick && !GlyphSelection.active;\n  }\n\n  get mode() {\n    return this.data.mode;\n  }\n\n  set mode(value) {\n    this.data.mode = value;\n  }\n\n  get rm() {\n    return this.data.rm;\n  }\n\n  set rm(value) {\n    this.data.rm = value;\n  }\n\n  get glyph() {\n    return this.data.glyph;\n  }\n\n  set glyph(value) {\n    this.data.glyph = value;\n  }\n\n  get time() {\n    return this.data.time;\n  }\n\n  set time(value) {\n    this.data.time = value;\n  }\n\n  get shard() {\n    return this.data.shard;\n  } // This only gets set via functions in AutobuyerInput.vue; we want to take advantage of auto-formatting when the input\n  // is for a Decimal prop, but the actual value needs to be clamped to fit within a Number\n\n\n  set shard(value) {\n    this.data.shard = value.clamp(0, Number.MAX_VALUE).toNumber();\n  }\n\n  toggleMode() {\n    this.mode = [AUTO_REALITY_MODE.RM, AUTO_REALITY_MODE.GLYPH, AUTO_REALITY_MODE.EITHER, AUTO_REALITY_MODE.BOTH, AUTO_REALITY_MODE.TIME, AUTO_REALITY_MODE.RELIC_SHARD].nextSibling(this.mode);\n  }\n\n  bumpAmount(mult) {\n    if (this.isUnlocked) {\n      this.rm = this.rm.times(mult);\n    }\n  }\n\n  tick() {\n    // Checking if auto-reality should trigger immediately due to bad glyph options happens at a higher priority\n    // than everything else, preempting other settings and only checking them if it fails\n    // In order to reduce excessive computational load, this only ever gets checked once per reality unless filter\n    // settings are changed (which causes it to check again); otherwise, glyph choices would be generated every tick\n    const dontCheckModes = [AUTO_GLYPH_SCORE.LOWEST_SACRIFICE, AUTO_GLYPH_SCORE.LOWEST_ALCHEMY, AUTO_GLYPH_SCORE.ALCHEMY_VALUE];\n    const shouldCheckFilter = EffarigUnlock.glyphFilter.isUnlocked && !player.reality.hasCheckedFilter && !dontCheckModes.includes(AutoGlyphProcessor.scoreMode);\n\n    if (isRealityAvailable() && player.options.autoRealityForFilter && shouldCheckFilter) {\n      const gainedLevel = gainedGlyphLevel();\n      const checkModes = [AUTO_REALITY_MODE.GLYPH, AUTO_REALITY_MODE.EITHER, AUTO_REALITY_MODE.BOTH];\n      const levelToCheck = checkModes.includes(this.mode) ? {\n        actualLevel: Math.min(this.glyph, Glyphs.levelCap),\n        rawLevel: 1\n      } : gainedLevel;\n      const choices = GlyphSelection.glyphList(GlyphSelection.choiceCount, levelToCheck, {\n        isChoosingGlyph: false\n      });\n      const bestGlyph = AutoGlyphProcessor.pick(choices);\n      player.reality.hasCheckedFilter = true;\n\n      if (!AutoGlyphProcessor.wouldKeep(bestGlyph)) {\n        autoReality();\n        return;\n      }\n    }\n\n    let proc = false; // The game generally displays amplified values, so we want to adjust the thresholds to\n    // account for that and make the automation trigger based on the actual displayed values\n\n    const ampFactor = simulatedRealityCount(false) + 1;\n    const rmProc = MachineHandler.gainedRealityMachines.times(ampFactor).gte(this.rm);\n    const glyphProc = gainedGlyphLevel().actualLevel >= Math.min(this.glyph, Glyphs.levelCap);\n\n    switch (this.mode) {\n      case AUTO_REALITY_MODE.RM:\n        proc = rmProc;\n        break;\n\n      case AUTO_REALITY_MODE.GLYPH:\n        proc = glyphProc;\n        break;\n\n      case AUTO_REALITY_MODE.EITHER:\n        proc = rmProc || glyphProc;\n        break;\n\n      case AUTO_REALITY_MODE.BOTH:\n        proc = rmProc && glyphProc;\n        break;\n\n      case AUTO_REALITY_MODE.TIME:\n        proc = player.records.thisReality.realTime / 1000 > this.time;\n        break;\n\n      case AUTO_REALITY_MODE.RELIC_SHARD:\n        proc = Effarig.shardsGained * ampFactor > this.shard;\n        break;\n    }\n\n    if (proc) autoReality();\n  }\n\n}","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/autobuyers/reality-autobuyer.js"],"names":["AutobuyerState","RealityAutobuyerState","data","player","auto","reality","name","isUnlocked","RealityUpgrade","isBought","canTick","GlyphSelection","active","mode","value","rm","glyph","time","shard","clamp","Number","MAX_VALUE","toNumber","toggleMode","AUTO_REALITY_MODE","RM","GLYPH","EITHER","BOTH","TIME","RELIC_SHARD","nextSibling","bumpAmount","mult","times","tick","dontCheckModes","AUTO_GLYPH_SCORE","LOWEST_SACRIFICE","LOWEST_ALCHEMY","ALCHEMY_VALUE","shouldCheckFilter","EffarigUnlock","glyphFilter","hasCheckedFilter","includes","AutoGlyphProcessor","scoreMode","isRealityAvailable","options","autoRealityForFilter","gainedLevel","gainedGlyphLevel","checkModes","levelToCheck","actualLevel","Math","min","Glyphs","levelCap","rawLevel","choices","glyphList","choiceCount","isChoosingGlyph","bestGlyph","pick","wouldKeep","autoReality","proc","ampFactor","simulatedRealityCount","rmProc","MachineHandler","gainedRealityMachines","gte","glyphProc","records","thisReality","realTime","Effarig","shardsGained"],"mappings":"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","sourcesContent":["import { AutobuyerState } from \"./autobuyer\";\r\n\r\nexport class RealityAutobuyerState extends AutobuyerState {\r\n  get data() {\r\n    return player.auto.reality;\r\n  }\r\n\r\n  get name() {\r\n    return `Reality`;\r\n  }\r\n\r\n  get isUnlocked() {\r\n    return RealityUpgrade(25).isBought;\r\n  }\r\n\r\n  get canTick() {\r\n    return super.canTick && !GlyphSelection.active;\r\n  }\r\n\r\n  get mode() {\r\n    return this.data.mode;\r\n  }\r\n\r\n  set mode(value) {\r\n    this.data.mode = value;\r\n  }\r\n\r\n  get rm() {\r\n    return this.data.rm;\r\n  }\r\n\r\n  set rm(value) {\r\n    this.data.rm = value;\r\n  }\r\n\r\n  get glyph() {\r\n    return this.data.glyph;\r\n  }\r\n\r\n  set glyph(value) {\r\n    this.data.glyph = value;\r\n  }\r\n\r\n  get time() {\r\n    return this.data.time;\r\n  }\r\n\r\n  set time(value) {\r\n    this.data.time = value;\r\n  }\r\n\r\n  get shard() {\r\n    return this.data.shard;\r\n  }\r\n\r\n  // This only gets set via functions in AutobuyerInput.vue; we want to take advantage of auto-formatting when the input\r\n  // is for a Decimal prop, but the actual value needs to be clamped to fit within a Number\r\n  set shard(value) {\r\n    this.data.shard = value.clamp(0, Number.MAX_VALUE).toNumber();\r\n  }\r\n\r\n  toggleMode() {\r\n    this.mode = [\r\n      AUTO_REALITY_MODE.RM,\r\n      AUTO_REALITY_MODE.GLYPH,\r\n      AUTO_REALITY_MODE.EITHER,\r\n      AUTO_REALITY_MODE.BOTH,\r\n      AUTO_REALITY_MODE.TIME,\r\n      AUTO_REALITY_MODE.RELIC_SHARD\r\n    ]\r\n      .nextSibling(this.mode);\r\n  }\r\n\r\n  bumpAmount(mult) {\r\n    if (this.isUnlocked) {\r\n      this.rm = this.rm.times(mult);\r\n    }\r\n  }\r\n\r\n  tick() {\r\n    // Checking if auto-reality should trigger immediately due to bad glyph options happens at a higher priority\r\n    // than everything else, preempting other settings and only checking them if it fails\r\n    // In order to reduce excessive computational load, this only ever gets checked once per reality unless filter\r\n    // settings are changed (which causes it to check again); otherwise, glyph choices would be generated every tick\r\n    const dontCheckModes = [AUTO_GLYPH_SCORE.LOWEST_SACRIFICE, AUTO_GLYPH_SCORE.LOWEST_ALCHEMY,\r\n      AUTO_GLYPH_SCORE.ALCHEMY_VALUE];\r\n    const shouldCheckFilter = EffarigUnlock.glyphFilter.isUnlocked && !player.reality.hasCheckedFilter &&\r\n      !dontCheckModes.includes(AutoGlyphProcessor.scoreMode);\r\n    if (isRealityAvailable() && player.options.autoRealityForFilter && shouldCheckFilter) {\r\n      const gainedLevel = gainedGlyphLevel();\r\n      const checkModes = [AUTO_REALITY_MODE.GLYPH, AUTO_REALITY_MODE.EITHER, AUTO_REALITY_MODE.BOTH];\r\n      const levelToCheck = (checkModes.includes(this.mode))\r\n        ? { actualLevel: Math.min(this.glyph, Glyphs.levelCap), rawLevel: 1 }\r\n        : gainedLevel;\r\n      const choices = GlyphSelection.glyphList(GlyphSelection.choiceCount, levelToCheck,\r\n        { isChoosingGlyph: false });\r\n      const bestGlyph = AutoGlyphProcessor.pick(choices);\r\n      player.reality.hasCheckedFilter = true;\r\n      if (!AutoGlyphProcessor.wouldKeep(bestGlyph)) {\r\n        autoReality();\r\n        return;\r\n      }\r\n    }\r\n\r\n    let proc = false;\r\n    // The game generally displays amplified values, so we want to adjust the thresholds to\r\n    // account for that and make the automation trigger based on the actual displayed values\r\n    const ampFactor = simulatedRealityCount(false) + 1;\r\n    const rmProc = MachineHandler.gainedRealityMachines.times(ampFactor).gte(this.rm);\r\n    const glyphProc = gainedGlyphLevel().actualLevel >= Math.min(this.glyph, Glyphs.levelCap);\r\n    switch (this.mode) {\r\n      case AUTO_REALITY_MODE.RM:\r\n        proc = rmProc;\r\n        break;\r\n      case AUTO_REALITY_MODE.GLYPH:\r\n        proc = glyphProc;\r\n        break;\r\n      case AUTO_REALITY_MODE.EITHER:\r\n        proc = rmProc || glyphProc;\r\n        break;\r\n      case AUTO_REALITY_MODE.BOTH:\r\n        proc = rmProc && glyphProc;\r\n        break;\r\n      case AUTO_REALITY_MODE.TIME:\r\n        proc = player.records.thisReality.realTime / 1000 > this.time;\r\n        break;\r\n      case AUTO_REALITY_MODE.RELIC_SHARD:\r\n        proc = Effarig.shardsGained * ampFactor > this.shard;\r\n        break;\r\n    }\r\n    if (proc) autoReality();\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}