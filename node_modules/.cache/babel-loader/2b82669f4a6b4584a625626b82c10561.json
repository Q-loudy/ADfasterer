{"ast":null,"code":"import \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport draggable from \"vuedraggable\";\nimport AutomatorBlockSingleRow from \"./AutomatorBlockSingleRow\";\nimport { blockifyTextAutomator } from \"@/core/automator\";\nexport default {\n  name: \"AutomatorBlockEditor\",\n  components: {\n    AutomatorBlockSingleRow,\n    draggable\n  },\n  computed: {\n    lines: {\n      get() {\n        return this.$viewModel.tabs.reality.automator.lines;\n      },\n\n      set(value) {\n        this.$viewModel.tabs.reality.automator.lines = value;\n      }\n\n    },\n\n    numberOfLines() {\n      return this.lines.reduce((a, l) => a + BlockAutomator.numberOfLinesInBlock(l), 0);\n    }\n\n  },\n\n  mounted() {\n    BlockAutomator.initialize();\n    AutomatorData.recalculateErrors();\n    BlockAutomator.editor.scrollTo(0, BlockAutomator.previousScrollPosition);\n    BlockAutomator.gutter.style.bottom = `${BlockAutomator.editor.scrollTop}px`;\n  },\n\n  methods: {\n    update() {\n      if (AutomatorBackend.state.followExecution) AutomatorBackend.jumpToActiveLine();\n      const targetLine = AutomatorBackend.isOn ? BlockAutomator.lineNumberFromBlockID(BlockAutomator.currentBlockId) : -1;\n      AutomatorHighlighter.updateHighlightedLine(targetLine, LineEnum.Active);\n    },\n\n    setPreviousScroll() {\n      BlockAutomator.previousScrollPosition = this.$refs.blockEditorElement.scrollTop;\n      BlockAutomator.gutter.style.bottom = `${BlockAutomator.editor.scrollTop}px`;\n    },\n\n    parseRequest() {\n      BlockAutomator.updateIdArray();\n      AutomatorData.recalculateErrors();\n      BlockAutomator.parseTextFromBlocks();\n    },\n\n    updateBlock(block, id) {\n      this.lines[this.lines.findIndex(x => x.id === id)] = block;\n      this.parseRequest();\n    },\n\n    deleteBlock(id) {\n      const idx = this.lines.findIndex(x => x.id === id);\n      this.lines.splice(idx, 1);\n      this.parseRequest();\n    }\n\n  }\n};\nexport const BlockAutomator = {\n  editor: null,\n  gutter: null,\n  _idArray: [],\n\n  initialize() {\n    this.editor = document.getElementsByClassName(\"c-automator-block-editor\")[0];\n    this.gutter = document.getElementsByClassName(\"c-automator-block-editor--gutter\")[0];\n  },\n\n  get lines() {\n    return ui.view.tabs.reality.automator.lines;\n  },\n\n  set lines(arr) {\n    ui.view.tabs.reality.automator.lines = arr;\n    this.updateIdArray();\n  },\n\n  get currentBlockId() {\n    if (AutomatorBackend.stack.isEmpty) return false;\n    return this._idArray[AutomatorBackend.stack.top.lineNumber - 1];\n  },\n\n  // _idArray contains a mapping from all text lines to block IDs in the blockmato, where only lines with\n  // actual commands have defined values. This means that every time a closing curly brace } occurs, all further\n  // line numbers between on block will be one less than the corresponding text line number\n  lineNumber(textLine) {\n    const skipLines = this._idArray.map((id, index) => id ? -1 : index + 1).filter(v => v !== -1);\n\n    return textLine - skipLines.countWhere(line => line <= textLine);\n  },\n\n  lineNumberFromBlockID(id) {\n    return this.lineNumber(this._idArray.indexOf(id) + 1);\n  },\n\n  // This gets called from many places which do block editor error checking for the purpose of a responsive UI, so\n  // we use checkID to distinguish between scripts to check. When not given, we assume it's the currently-displayed\n  // script; otherwise we need to be careful because we're in the process of changing scripts\n  parseTextFromBlocks(checkID) {\n    const content = this.parseLines(BlockAutomator.lines).join(\"\\n\");\n    const automatorID = checkID !== null && checkID !== void 0 ? checkID : ui.view.tabs.reality.automator.editorScriptID;\n    AutomatorData.recalculateErrors();\n    AutomatorBackend.saveScript(automatorID, content);\n  },\n\n  updateEditor(scriptText) {\n    const lines = blockifyTextAutomator(scriptText).blocks;\n    this.lines = lines;\n    return lines;\n  },\n\n  hasUnparsableCommands(text) {\n    const blockified = blockifyTextAutomator(text);\n    return blockified.validatedBlocks !== blockified.visitedBlocks;\n  },\n\n  generateText(block, indentation = 0) {\n    // We add an extra trailing space here and remove double-spaces at the end because this makes some conversion\n    // errors slightly less harsh; some errors which wiped entire lines now just fail to parse arguments instead\n    let parsed = `${\"\\t\".repeat(indentation)}${block.cmd} `;\n    parsed = parsed.replace(\"COMMENT\", \"//\").replace(\"BLOB\", \"blob  \");\n\n    if (block.canWait && block.nowait) {\n      parsed = parsed.replace(/((?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+)/, \"$1 NOWAIT\");\n    }\n\n    if (block.respec) parsed += ` RESPEC`;\n    const propsToCheck = [\"genericInput1\", \"compOperator\", \"genericInput2\", \"singleSelectionInput\", \"singleTextInput\"];\n\n    for (const prop of propsToCheck) {\n      if (block[prop]) parsed += ` ${block[prop]}`;\n    }\n\n    if (block.cmd === \"IF\" || block.cmd === \"WHILE\" || block.cmd === \"UNTIL\") parsed += \" {\";\n    return parsed.replace(\"  \", \" \");\n  },\n\n  parseLines(l, indentation = 0) {\n    const lines = [];\n\n    for (let i = 0; i < l.length; i++) {\n      lines.push(this.generateText(l[i], indentation));\n\n      if (l[i].cmd === \"IF\" || l[i].cmd === \"WHILE\" || l[i].cmd === \"UNTIL\") {\n        lines.push(...this.parseLines(l[i].nest, indentation + 1));\n        lines.push(`${\"\\t\".repeat(indentation)}}`);\n      }\n    }\n\n    return lines;\n  },\n\n  blockIdArray(blocks) {\n    const output = [];\n\n    for (let i = 0; i < blocks.length; i++) {\n      const b = blocks[i];\n      output.push(b.id);\n      if (b.nested) output.push(...this.blockIdArray(b.nest), undefined);\n    }\n\n    return output;\n  },\n\n  updateIdArray() {\n    this._idArray = this.blockIdArray(this.lines);\n  },\n\n  numberOfLinesInBlock(block) {\n    return block.nested ? Math.max(block.nest.reduce((v, b) => v + this.numberOfLinesInBlock(b), 1), 2) : 1;\n  },\n\n  clearEditor() {\n    // I genuinely don't understand why this needs to be done asynchronously, but removing the setTimeout makes this\n    // method not do anything at all. Even setting the array in the console without the setTimeout works fine.\n    setTimeout(() => this.lines = [], 0);\n  },\n\n  previousScrollPosition: 0\n};","map":{"version":3,"sources":["AutomatorBlockEditor.vue"],"names":[],"mappings":"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","sourcesContent":["<script>\r\nimport draggable from \"vuedraggable\";\r\n\r\nimport AutomatorBlockSingleRow from \"./AutomatorBlockSingleRow\";\r\nimport { blockifyTextAutomator } from \"@/core/automator\";\r\n\r\nexport default {\r\n  name: \"AutomatorBlockEditor\",\r\n  components: {\r\n    AutomatorBlockSingleRow,\r\n    draggable\r\n  },\r\n  computed: {\r\n    lines: {\r\n      get() {\r\n        return this.$viewModel.tabs.reality.automator.lines;\r\n      },\r\n      set(value) {\r\n        this.$viewModel.tabs.reality.automator.lines = value;\r\n      }\r\n    },\r\n    numberOfLines() {\r\n      return this.lines.reduce((a, l) => a + BlockAutomator.numberOfLinesInBlock(l), 0);\r\n    },\r\n  },\r\n  mounted() {\r\n    BlockAutomator.initialize();\r\n    AutomatorData.recalculateErrors();\r\n    BlockAutomator.editor.scrollTo(0, BlockAutomator.previousScrollPosition);\r\n    BlockAutomator.gutter.style.bottom = `${BlockAutomator.editor.scrollTop}px`;\r\n  },\r\n  methods: {\r\n    update() {\r\n      if (AutomatorBackend.state.followExecution) AutomatorBackend.jumpToActiveLine();\r\n      const targetLine = AutomatorBackend.isOn\r\n        ? BlockAutomator.lineNumberFromBlockID(BlockAutomator.currentBlockId)\r\n        : -1;\r\n      AutomatorHighlighter.updateHighlightedLine(targetLine, LineEnum.Active);\r\n    },\r\n    setPreviousScroll() {\r\n      BlockAutomator.previousScrollPosition = this.$refs.blockEditorElement.scrollTop;\r\n      BlockAutomator.gutter.style.bottom = `${BlockAutomator.editor.scrollTop}px`;\r\n    },\r\n    parseRequest() {\r\n      BlockAutomator.updateIdArray();\r\n      AutomatorData.recalculateErrors();\r\n      BlockAutomator.parseTextFromBlocks();\r\n    },\r\n    updateBlock(block, id) {\r\n      this.lines[this.lines.findIndex(x => x.id === id)] = block;\r\n      this.parseRequest();\r\n    },\r\n    deleteBlock(id) {\r\n      const idx = this.lines.findIndex(x => x.id === id);\r\n      this.lines.splice(idx, 1);\r\n      this.parseRequest();\r\n    },\r\n  }\r\n};\r\n\r\nexport const BlockAutomator = {\r\n  editor: null,\r\n  gutter: null,\r\n  _idArray: [],\r\n\r\n  initialize() {\r\n    this.editor = document.getElementsByClassName(\"c-automator-block-editor\")[0];\r\n    this.gutter = document.getElementsByClassName(\"c-automator-block-editor--gutter\")[0];\r\n  },\r\n\r\n  get lines() {\r\n    return ui.view.tabs.reality.automator.lines;\r\n  },\r\n\r\n  set lines(arr) {\r\n    ui.view.tabs.reality.automator.lines = arr;\r\n    this.updateIdArray();\r\n  },\r\n\r\n  get currentBlockId() {\r\n    if (AutomatorBackend.stack.isEmpty) return false;\r\n    return this._idArray[AutomatorBackend.stack.top.lineNumber - 1];\r\n  },\r\n\r\n  // _idArray contains a mapping from all text lines to block IDs in the blockmato, where only lines with\r\n  // actual commands have defined values. This means that every time a closing curly brace } occurs, all further\r\n  // line numbers between on block will be one less than the corresponding text line number\r\n  lineNumber(textLine) {\r\n    const skipLines = this._idArray.map((id, index) => (id ? -1 : index + 1)).filter(v => v !== -1);\r\n    return textLine - skipLines.countWhere(line => line <= textLine);\r\n  },\r\n\r\n  lineNumberFromBlockID(id) {\r\n    return this.lineNumber(this._idArray.indexOf(id) + 1);\r\n  },\r\n\r\n  // This gets called from many places which do block editor error checking for the purpose of a responsive UI, so\r\n  // we use checkID to distinguish between scripts to check. When not given, we assume it's the currently-displayed\r\n  // script; otherwise we need to be careful because we're in the process of changing scripts\r\n  parseTextFromBlocks(checkID) {\r\n    const content = this.parseLines(BlockAutomator.lines).join(\"\\n\");\r\n    const automatorID = checkID ?? ui.view.tabs.reality.automator.editorScriptID;\r\n    AutomatorData.recalculateErrors();\r\n    AutomatorBackend.saveScript(automatorID, content);\r\n  },\r\n\r\n  updateEditor(scriptText) {\r\n    const lines = blockifyTextAutomator(scriptText).blocks;\r\n    this.lines = lines;\r\n    return lines;\r\n  },\r\n\r\n  hasUnparsableCommands(text) {\r\n    const blockified = blockifyTextAutomator(text);\r\n    return blockified.validatedBlocks !== blockified.visitedBlocks;\r\n  },\r\n\r\n  generateText(block, indentation = 0) {\r\n    // We add an extra trailing space here and remove double-spaces at the end because this makes some conversion\r\n    // errors slightly less harsh; some errors which wiped entire lines now just fail to parse arguments instead\r\n    let parsed = `${\"\\t\".repeat(indentation)}${block.cmd} `;\r\n\r\n    parsed = parsed\r\n      .replace(\"COMMENT\", \"//\")\r\n      .replace(\"BLOB\", \"blob  \");\r\n\r\n    if (block.canWait && block.nowait) {\r\n      parsed = parsed.replace(/(\\S+)/u, \"$1 NOWAIT\");\r\n    }\r\n    if (block.respec) parsed += ` RESPEC`;\r\n\r\n    const propsToCheck = [\"genericInput1\", \"compOperator\", \"genericInput2\", \"singleSelectionInput\", \"singleTextInput\"];\r\n    for (const prop of propsToCheck) {\r\n      if (block[prop]) parsed += ` ${block[prop]}`;\r\n    }\r\n\r\n    if (block.cmd === \"IF\" || block.cmd === \"WHILE\" || block.cmd === \"UNTIL\") parsed += \" {\";\r\n\r\n    return parsed.replace(\"  \", \" \");\r\n  },\r\n\r\n  parseLines(l, indentation = 0) {\r\n    const lines = [];\r\n    for (let i = 0; i < l.length; i++) {\r\n      lines.push(this.generateText(l[i], indentation));\r\n      if (l[i].cmd === \"IF\" || l[i].cmd === \"WHILE\" || l[i].cmd === \"UNTIL\") {\r\n        lines.push(...this.parseLines(l[i].nest, indentation + 1));\r\n        lines.push(`${\"\\t\".repeat(indentation)}}`);\r\n      }\r\n    }\r\n\r\n    return lines;\r\n  },\r\n\r\n  blockIdArray(blocks) {\r\n    const output = [];\r\n    for (let i = 0; i < blocks.length; i++) {\r\n      const b = blocks[i];\r\n      output.push(b.id);\r\n      if (b.nested) output.push(...this.blockIdArray(b.nest), undefined);\r\n    }\r\n    return output;\r\n  },\r\n\r\n  updateIdArray() {\r\n    this._idArray = this.blockIdArray(this.lines);\r\n  },\r\n\r\n  numberOfLinesInBlock(block) {\r\n    return block.nested ? Math.max(block.nest.reduce((v, b) => v + this.numberOfLinesInBlock(b), 1), 2) : 1;\r\n  },\r\n\r\n  clearEditor() {\r\n    // I genuinely don't understand why this needs to be done asynchronously, but removing the setTimeout makes this\r\n    // method not do anything at all. Even setting the array in the console without the setTimeout works fine.\r\n    setTimeout(() => this.lines = [], 0);\r\n  },\r\n\r\n  previousScrollPosition: 0,\r\n};\r\n</script>\r\n\r\n<template>\r\n  <div class=\"c-automator-block-editor--container\">\r\n    <div\r\n      ref=\"editorGutter\"\r\n      class=\"c-automator-block-editor--gutter\"\r\n    >\r\n      <div\r\n        v-for=\"i in numberOfLines\"\r\n        :key=\"i\"\r\n        class=\"c-automator-block-line-number\"\r\n        :style=\"{\r\n          top: `${(i - 1) * 3.45}rem`\r\n        }\"\r\n      >\r\n        {{ i }}\r\n      </div>\r\n    </div>\r\n    <div\r\n      ref=\"blockEditorElement\"\r\n      class=\"c-automator-block-editor\"\r\n      @scroll=\"setPreviousScroll()\"\r\n    >\r\n      <draggable\r\n        v-model=\"lines\"\r\n        group=\"code-blocks\"\r\n        class=\"c-automator-blocks\"\r\n        ghost-class=\"c-automator-block-row-ghost\"\r\n        @end=\"parseRequest\"\r\n      >\r\n        <AutomatorBlockSingleRow\r\n          v-for=\"(block, lineNum) in lines\"\r\n          :key=\"block.id + 10000 * lineNum\"\r\n          :block=\"block\"\r\n          :update-block=\"updateBlock\"\r\n          :delete-block=\"deleteBlock\"\r\n        />\r\n      </draggable>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<style scoped>\r\n.c-automator-block-editor {\r\n  display: flex;\r\n  overflow-y: auto;\r\n  tab-size: 1.5rem;\r\n  width: 100%;\r\n  background-color: var(--color-blockmator-editor-background);\r\n  box-sizing: content-box;\r\n}\r\n\r\n.c-automator-block-editor--container {\r\n  display: flex;\r\n  overflow-y: hidden;\r\n  height: 100%;\r\n  position: relative;\r\n  box-sizing: border-box;\r\n}\r\n\r\n.c-automator-blocks {\r\n  width: 100%;\r\n  height: max-content;\r\n  padding: 0.3rem 0.6rem 5rem;\r\n}\r\n\r\n.c-automator-block-editor--gutter {\r\n  height: max-content;\r\n  min-height: 100%;\r\n  position: relative;\r\n  background-color: var(--color-automator-controls-background);\r\n  border-right: 0.1rem solid #505050;\r\n  /* left and right paddings are 1 to make space for text, bottom padding is 20 to make for a buffer */\r\n  padding: 0.3rem 1rem 20rem;\r\n}\r\n\r\n.c-automator-block-line-number {\r\n  display: flex;\r\n  height: 3.45rem;\r\n  justify-content: flex-end;\r\n  align-items: center;\r\n  font-size: 1.4rem;\r\n  color: var(--color-automator-docs-font);\r\n}\r\n\r\n.null-block {\r\n  display: none;\r\n  visibility: hidden;\r\n}\r\n</style>\r\n"],"sourceRoot":"src/components/tabs/automator"},"metadata":{},"sourceType":"module"}