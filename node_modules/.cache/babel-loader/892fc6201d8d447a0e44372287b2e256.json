{"ast":null,"code":"import \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.array.sort.js\";\n\n/**\r\n * It turns out reading and writing the RNG state from player is really slow, for\r\n * some reason. Thus, it's very advantageous to get an RNG as a local variable, and only\r\n * write the state back out to player when we are done with it.\r\n * So, this interface is implemented by a real and fake RNG class; after creating one and\r\n * using it, call finalize on it to write the seed out.\r\n */\nimport { deepmerge } from \"@/utility/deepmerge\";\n\nclass GlyphRNG {\n  static get SECOND_GAUSSIAN_DEFAULT_VALUE() {\n    return 1e6;\n  }\n\n  constructor(seed, secondGaussian) {\n    this.seed = seed;\n    this.secondGaussian = secondGaussian;\n  }\n\n  uniform() {\n    const state = xorshift32Update(this.seed);\n    this.seed = state;\n    return state * 2.3283064365386963e-10 + 0.5;\n  }\n\n  normal() {\n    if (this.secondGaussian !== GlyphRNG.SECOND_GAUSSIAN_DEFAULT_VALUE) {\n      const toReturn = this.secondGaussian;\n      this.secondGaussian = GlyphRNG.SECOND_GAUSSIAN_DEFAULT_VALUE;\n      return toReturn;\n    }\n\n    let u = 0,\n        v = 0,\n        s = 0;\n\n    do {\n      u = this.uniform() * 2 - 1;\n      v = this.uniform() * 2 - 1;\n      s = u * u + v * v;\n    } while (s >= 1 || s === 0);\n\n    s = Math.sqrt(-2 * Math.log(s) / s);\n    this.secondGaussian = v * s;\n    return u * s;\n  }\n  /**\r\n   * Write the seed out to where it can be restored\r\n   * @abstract\r\n   */\n\n\n  finalize() {\n    throw new NotImplementedError();\n  }\n  /**\r\n   * @abstract\r\n   */\n\n\n  get isFake() {\n    throw new NotImplementedError();\n  }\n\n}\n\nexport const GlyphGenerator = {\n  // Glyph choices will have more uniformly-distributed properties up for this many groups\n  // of uniform glyphs. The size of a uniformity group is 5, so this gives uniformly-distributed\n  // properties up to a reality count one more than 5x this value; the modified RNG for uniform\n  // glyphs excludes the first fixed glyph and only starts from the 2nd one onward\n  uniformityGroups: 4,\n\n  get isUniformityActive() {\n    return player.realities <= 5 * this.uniformityGroups;\n  },\n\n  fakeSeed: Date.now() % Math.pow(2, 32),\n  fakeSecondGaussian: null,\n\n  /* eslint-disable lines-between-class-members */\n  RealGlyphRNG: class extends GlyphRNG {\n    constructor() {\n      super(player.reality.seed, player.reality.secondGaussian);\n    }\n\n    finalize() {\n      player.reality.seed = this.seed;\n      player.reality.secondGaussian = this.secondGaussian;\n    }\n\n    get isFake() {\n      return false;\n    }\n\n  },\n  FakeGlyphRNG: class extends GlyphRNG {\n    constructor() {\n      super(GlyphGenerator.fakeSeed, GlyphGenerator.fakeSecondGaussian);\n    }\n\n    finalize() {\n      GlyphGenerator.fakeSeed = this.seed;\n      GlyphGenerator.fakeSecondGaussian = this.secondGaussian;\n    }\n\n    get isFake() {\n      return true;\n    }\n\n  },\n  MusicGlyphRNG: class extends GlyphRNG {\n    constructor() {\n      super(player.reality.musicSeed, player.reality.musicSecondGaussian);\n    }\n\n    finalize() {\n      player.reality.musicSeed = this.seed;\n      player.reality.musicSecondGaussian = this.secondGaussian;\n    }\n\n    get isFake() {\n      return false;\n    }\n\n  },\n\n  /* eslint-enable lines-between-class-members */\n  startingGlyph(level) {\n    const initialStrength = 1.5;\n    return {\n      id: undefined,\n      idx: null,\n      type: \"power\",\n      // The initial strength is very slightly above average.\n      strength: initialStrength,\n      level: level.actualLevel,\n      rawLevel: level.rawLevel,\n      effects: makeGlyphEffectBitmask([\"powerpow\"])\n    };\n  },\n\n  randomGlyph(level, rngIn, typeIn = null) {\n    const rng = rngIn || new GlyphGenerator.RealGlyphRNG();\n    const strength = this.randomStrength(rng);\n    const type = typeIn || this.randomType(rng);\n    let numEffects = this.randomNumberOfEffects(type, strength, level.actualLevel, rng);\n    if (type !== \"effarig\" && numEffects > 4) numEffects = 4;\n    const effectBitmask = this.generateEffects(type, numEffects, rng);\n    if (rngIn === undefined) rng.finalize();\n    return {\n      id: undefined,\n      idx: null,\n      type,\n      strength,\n      level: level.actualLevel,\n      rawLevel: level.rawLevel,\n      effects: effectBitmask\n    };\n  },\n\n  realityGlyph(level) {\n    const str = rarityToStrength(100);\n    const effects = this.generateRealityEffects(level);\n    const effectBitmask = makeGlyphEffectBitmask(effects);\n    return {\n      id: undefined,\n      idx: null,\n      type: \"reality\",\n      strength: str,\n      level,\n      rawLevel: level,\n      effects: effectBitmask\n    };\n  },\n\n  cursedGlyph() {\n    const str = rarityToStrength(100);\n    const effectBitmask = makeGlyphEffectBitmask(orderedEffectList.filter(effect => effect.match(\"cursed*\")));\n    return {\n      id: undefined,\n      idx: null,\n      type: \"cursed\",\n      strength: str,\n      level: 6666,\n      rawLevel: 6666,\n      effects: effectBitmask\n    };\n  },\n\n  // These Glyphs are given on entering Doomed to prevent the player\n  // from having none of each basic glyphs which are requied to beat pelle\n  doomedGlyph(type) {\n    const effectList = GlyphEffects.all.filter(e => e.id.startsWith(type));\n    effectList.push(GlyphEffects.timespeed);\n    let bitmask = 0;\n\n    for (const effect of effectList) bitmask |= 1 << effect.bitmaskIndex;\n\n    const glyphLevel = Math.max(player.records.bestReality.glyphLevel, 5000);\n    return {\n      id: undefined,\n      idx: null,\n      type,\n      strength: 3.5,\n      level: glyphLevel,\n      rawLevel: glyphLevel,\n      effects: bitmask\n    };\n  },\n\n  companionGlyph(eternityPoints) {\n    // Store the pre-Reality EP value in the glyph's rarity\n    const str = rarityToStrength(eternityPoints.log10() / 1e6);\n    const effects = orderedEffectList.filter(effect => effect.match(\"companion*\"));\n    const effectBitmask = makeGlyphEffectBitmask(effects);\n    return {\n      id: undefined,\n      idx: null,\n      type: \"companion\",\n      strength: str,\n      level: 1,\n      rawLevel: 1,\n      effects: effectBitmask\n    };\n  },\n\n  musicGlyph() {\n    const rng = new GlyphGenerator.MusicGlyphRNG();\n    const glyph = this.randomGlyph({\n      actualLevel: Math.floor(player.records.bestReality.glyphLevel * 0.8),\n      rawLevel: 1\n    }, rng);\n    rng.finalize();\n    glyph.cosmetic = \"music\";\n    glyph.fixedCosmetic = \"music\";\n    return glyph;\n  },\n\n  // Generates a unique ID for glyphs, used for deletion and drag-and-drop.  Non-unique IDs can cause buggy behavior.\n  makeID() {\n    return this.maxID + 1;\n  },\n\n  get maxID() {\n    return player.reality.glyphs.active.concat(player.reality.glyphs.inventory).reduce((max, glyph) => Math.max(max, glyph.id), 0);\n  },\n\n  get strengthMultiplier() {\n    return Effects.max(1, RealityUpgrade(16));\n  },\n\n  randomStrength(rng) {\n    // Technically getting this upgrade really changes glyph gen but at this point almost all\n    // the RNG is gone anyway.\n    if (Ra.unlocks.maxGlyphRarityAndShardSacrificeBoost.canBeApplied) return rarityToStrength(100);\n    let result = GlyphGenerator.gaussianBellCurve(rng) * GlyphGenerator.strengthMultiplier;\n    const relicShardFactor = Ra.unlocks.extraGlyphChoicesAndRelicShardRarityAlwaysMax.canBeApplied ? 1 : rng.uniform();\n    const increasedRarity = relicShardFactor * Effarig.maxRarityBoost + Effects.sum(Achievement(146), GlyphSacrifice.effarig); // Each rarity% is 0.025 strength.\n\n    result += increasedRarity / 40; // Raise the result to the next-highest 0.1% rarity.\n\n    result = Math.ceil(result * 400) / 400;\n    return Math.min(result, rarityToStrength(100));\n  },\n\n  // eslint-disable-next-line max-params\n  randomNumberOfEffects(type, strength, level, rng) {\n    // Call the RNG twice before anything else to advance the RNG seed properly, even if the whole method returns early.\n    // This prevents the position of effarig glyphs in the choice list from affecting the choices themselves, as well\n    // as preventing all of the glyphs changing drastically when RU17 is purchased.\n    const random1 = rng.uniform();\n    const random2 = rng.uniform();\n    if (type !== \"effarig\" && Ra.unlocks.glyphEffectCount.canBeApplied) return 4;\n    const maxEffects = Ra.unlocks.glyphEffectCount.canBeApplied ? 7 : 4;\n    let num = Math.min(maxEffects, Math.floor(Math.pow(random1, 1 - Math.pow(level * strength, 0.5) / 100) * 1.5 + 1)); // If we do decide to add anything else that boosts chance of an extra effect, keeping the code like this\n    // makes it easier to do (add it to the Effects.max).\n\n    if (RealityUpgrade(17).isBought && random2 < Effects.max(0, RealityUpgrade(17))) {\n      num = Math.min(num + 1, maxEffects);\n    }\n\n    return Ra.unlocks.glyphEffectCount.canBeApplied ? Math.max(num, 4) : num;\n  },\n\n  // Populate a list of reality glyph effects based on level\n  generateRealityEffects(level) {\n    const numberOfEffects = realityGlyphEffectLevelThresholds.filter(lv => lv <= level).length;\n    const sortedRealityEffects = GlyphEffects.all.filter(eff => eff.glyphTypes.includes(\"reality\")).sort((a, b) => a.bitmaskIndex - b.bitmaskIndex).map(eff => eff.id);\n    return sortedRealityEffects.slice(0, numberOfEffects);\n  },\n\n  generateEffects(type, count, rng) {\n    const effectValues = GlyphTypes[type].effects.mapToObject(x => x.bitmaskIndex, () => rng.uniform()); // Get a bunch of random numbers so that we always use 7 here.\n\n    Array.range(0, 7 - GlyphTypes[type].effects.length).forEach(() => rng.uniform());\n\n    if (type === \"effarig\") {\n      // This is effarigrm/effarigglyph\n      const unincluded = effectValues[20] < effectValues[21] ? 20 : 21;\n      effectValues[unincluded] = -1;\n    } // This is timepow/infinitypow/powerpow\n\n\n    for (const i of [0, 12, 16]) {\n      if (i in effectValues) {\n        effectValues[i] = 2;\n      }\n    } // Sort from highest to lowest value.\n\n\n    const effects = Object.keys(effectValues).sort((a, b) => effectValues[b] - effectValues[a]).slice(0, count);\n    return effects.map(Number).toBitmask();\n  },\n\n  randomType(rng, typesSoFar = []) {\n    const generatable = generatedTypes.filter(x => EffarigUnlock.reality.isUnlocked || x !== \"effarig\");\n    const maxOfSameTypeSoFar = generatable.map(x => typesSoFar.countWhere(y => y === x)).max();\n    const blacklisted = typesSoFar.length === 0 ? [] : generatable.filter(x => typesSoFar.countWhere(y => y === x) === maxOfSameTypeSoFar);\n    return GlyphTypes.random(rng, blacklisted);\n  },\n\n  /**\r\n   * To generate glyphs with a \"uniformly random\" effect spread, we effectively need to generate all the glyphs in\r\n   *  uniform groups of some size at once, and then select from that generated group. In this case, we've decided\r\n   *  that a group which satisfies uniformity is that of 5 realities, such that all 20 choices amongst the group\r\n   *  must contain each individual glyph effect at least once. This makes types more \"uniform\" by ensuring that\r\n   *  any individual glyph type is never *repeatedly* absent for more than 2 realities in a row (which can only\r\n   *  happen between groups), as well as ensuring that trends of long-term type/effect absences never happen\r\n   * Note: At this point, realityCount should be the number of realities BEFORE processing completes (ie. the first\r\n   *  random generated set begins at a parameter of 1)\r\n   */\n  uniformGlyphs(level, rng, realityCount) {\n    // Reality count divided by 5 determines which group of 5 we're in, while count mod 5 determines the index\n    // within that block. Note that we have a minus 1 because we want to exclude the first fixed glyph\n    const groupNum = Math.floor((realityCount - 1) / 5);\n    const groupIndex = (realityCount - 1) % 5; // The usage of the initial seed is complicated in order to prevent future prediction without using information\n    // not normally available in-game (ie. the console). This makes it appear less predictable overall\n\n    const initSeed = player.reality.initialSeed;\n    const typePerm = permutationIndex(5, (31 + initSeed % 7) * groupNum + initSeed % 1123); // Figure out a permutation index for each generated glyph type this reality by counting through the sets\n    // for choices which have already been generated for options in previous realities for this group\n\n    const typePermIndex = Array.repeat(0, 5);\n\n    for (let i = 0; i < groupIndex; i++) {\n      for (let type = 0; type < 5; type++) {\n        if (type !== typePerm[i]) typePermIndex[type]++;\n      }\n    } // Determine which effect needs to be added for uniformity (startID is a hardcoded array of the lowest ID glyph\n    // effect of each type, in the same type order as BASIC_GLYPH_TYPES). We use type, initial seed, and group index\n    // to pick a random permutation, again to make it less predictable and to make sure they're generally different\n\n\n    const uniformEffects = [];\n    const startID = [16, 12, 8, 0, 4];\n    const typesThisReality = Array.range(0, 5);\n    typesThisReality.splice(typePerm[groupIndex], 1);\n\n    for (let i = 0; i < 4; i++) {\n      const type = typesThisReality[i];\n      const effectPerm = permutationIndex(4, 5 * type + (7 + initSeed % 5) * groupNum + initSeed % 11);\n      uniformEffects.push(startID[type] + effectPerm[typePermIndex[type]]);\n    } // Generate the glyphs without uniformity applied first, assuming 4 glyph choices early on, then fix it to contain\n    // the new effect. This fixing process is a 50% chance to add to existing effects and 50% to replace them instead.\n    // Note that if this would give us \"too many\" effects, we remove one of the existing ones, and the threshold for\n    // having \"too many\" depends on if the player has the upgrade that improves effect count - we don't want the\n    // uniformity code to make glyph generation disproportionately worse in that case\n\n\n    const glyphs = [];\n\n    for (let i = 0; i < 4; ++i) {\n      const newGlyph = GlyphGenerator.randomGlyph(level, rng, BASIC_GLYPH_TYPES[typesThisReality[i]]);\n      const newMask = (initSeed + realityCount + i) % 2 === 0 ? 1 << uniformEffects[i] : newGlyph.effects | 1 << uniformEffects[i];\n      const maxEffects = RealityUpgrade(17).isBought ? 3 : 2;\n\n      if (countValuesFromBitmask(newMask) > maxEffects) {\n        // Turn the old effect bitmask into an array of removable effects and then deterministically remove one\n        // of the non-power effects based on seed and reality count\n        const replacable = getGlyphEffectsFromBitmask(newGlyph.effects).filter(eff => eff.isGenerated).map(eff => eff.bitmaskIndex).filter(eff => ![0, 12, 16].includes(eff));\n        const toRemove = replacable[Math.abs(initSeed + realityCount) % replacable.length];\n        newGlyph.effects = newMask & ~(1 << toRemove);\n      } else {\n        newGlyph.effects = newMask;\n      } // Add the power effects on power/infinity/time, since the initial setting of newMask removes them half the time\n\n\n      const dimPowers = {\n        power: 16,\n        infinity: 12,\n        time: 0\n      };\n\n      if (dimPowers[newGlyph.type] !== undefined) {\n        newGlyph.effects |= 1 << dimPowers[newGlyph.type];\n      }\n\n      glyphs.push(newGlyph);\n    }\n\n    return glyphs;\n  },\n\n  getRNG(fake) {\n    return fake ? new GlyphGenerator.FakeGlyphRNG() : new GlyphGenerator.RealGlyphRNG();\n  },\n\n  /**\r\n   * More than 3 approx 0.001%\r\n   * More than 2.5 approx 0.2%\r\n   * More than 2 approx 6%\r\n   * More than 1.5 approx 38.43%\r\n   */\n  gaussianBellCurve(rng) {\n    // Old code used max, instead of abs -- but we rejected any samples that were\n    // at the boundary anyways. Might as well use abs, and not cycle as many times.\n    // The function here is an approximation of ^0.65, here is the old code:\n    //     return Math.pow(Math.max(rng.normal() + 1, 1), 0.65);\n    const x = Math.sqrt(Math.abs(rng.normal(), 0) + 1);\n    return -0.111749606737000 + x * (0.900603878243551 + x * (0.229108274476697 + x * -0.017962545983249));\n  },\n\n  copy(glyph) {\n    return glyph ? deepmerge({}, glyph) : glyph;\n  }\n\n};","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/glyphs/glyph-generator.js"],"names":["deepmerge","GlyphRNG","SECOND_GAUSSIAN_DEFAULT_VALUE","constructor","seed","secondGaussian","uniform","state","xorshift32Update","normal","toReturn","u","v","s","Math","sqrt","log","finalize","NotImplementedError","isFake","GlyphGenerator","uniformityGroups","isUniformityActive","player","realities","fakeSeed","Date","now","pow","fakeSecondGaussian","RealGlyphRNG","reality","FakeGlyphRNG","MusicGlyphRNG","musicSeed","musicSecondGaussian","startingGlyph","level","initialStrength","id","undefined","idx","type","strength","actualLevel","rawLevel","effects","makeGlyphEffectBitmask","randomGlyph","rngIn","typeIn","rng","randomStrength","randomType","numEffects","randomNumberOfEffects","effectBitmask","generateEffects","realityGlyph","str","rarityToStrength","generateRealityEffects","cursedGlyph","orderedEffectList","filter","effect","match","doomedGlyph","effectList","GlyphEffects","all","e","startsWith","push","timespeed","bitmask","bitmaskIndex","glyphLevel","max","records","bestReality","companionGlyph","eternityPoints","log10","musicGlyph","glyph","floor","cosmetic","fixedCosmetic","makeID","maxID","glyphs","active","concat","inventory","reduce","strengthMultiplier","Effects","RealityUpgrade","Ra","unlocks","maxGlyphRarityAndShardSacrificeBoost","canBeApplied","result","gaussianBellCurve","relicShardFactor","extraGlyphChoicesAndRelicShardRarityAlwaysMax","increasedRarity","Effarig","maxRarityBoost","sum","Achievement","GlyphSacrifice","effarig","ceil","min","random1","random2","glyphEffectCount","maxEffects","num","isBought","numberOfEffects","realityGlyphEffectLevelThresholds","lv","length","sortedRealityEffects","eff","glyphTypes","includes","sort","a","b","map","slice","count","effectValues","GlyphTypes","mapToObject","x","Array","range","forEach","unincluded","i","Object","keys","Number","toBitmask","typesSoFar","generatable","generatedTypes","EffarigUnlock","isUnlocked","maxOfSameTypeSoFar","countWhere","y","blacklisted","random","uniformGlyphs","realityCount","groupNum","groupIndex","initSeed","initialSeed","typePerm","permutationIndex","typePermIndex","repeat","uniformEffects","startID","typesThisReality","splice","effectPerm","newGlyph","BASIC_GLYPH_TYPES","newMask","countValuesFromBitmask","replacable","getGlyphEffectsFromBitmask","isGenerated","toRemove","abs","dimPowers","power","infinity","time","getRNG","fake","copy"],"mappings":";;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,SAAT,QAA0B,qBAA1B;;AAEA,MAAMC,QAAN,CAAe;AAC2B,aAA7BC,6BAA6B,GAAG;AACzC,WAAO,GAAP;AACD;;AAEDC,EAAAA,WAAW,CAACC,IAAD,EAAOC,cAAP,EAAuB;AAChC,SAAKD,IAAL,GAAYA,IAAZ;AACA,SAAKC,cAAL,GAAsBA,cAAtB;AACD;;AAEDC,EAAAA,OAAO,GAAG;AACR,UAAMC,KAAK,GAAGC,gBAAgB,CAAC,KAAKJ,IAAN,CAA9B;AACA,SAAKA,IAAL,GAAYG,KAAZ;AACA,WAAOA,KAAK,GAAG,sBAAR,GAAiC,GAAxC;AACD;;AAEDE,EAAAA,MAAM,GAAG;AACP,QAAI,KAAKJ,cAAL,KAAwBJ,QAAQ,CAACC,6BAArC,EAAoE;AAClE,YAAMQ,QAAQ,GAAG,KAAKL,cAAtB;AACA,WAAKA,cAAL,GAAsBJ,QAAQ,CAACC,6BAA/B;AACA,aAAOQ,QAAP;AACD;;AACD,QAAIC,CAAC,GAAG,CAAR;AAAA,QAAWC,CAAC,GAAG,CAAf;AAAA,QAAkBC,CAAC,GAAG,CAAtB;;AACA,OAAG;AACDF,MAAAA,CAAC,GAAG,KAAKL,OAAL,KAAiB,CAAjB,GAAqB,CAAzB;AACAM,MAAAA,CAAC,GAAG,KAAKN,OAAL,KAAiB,CAAjB,GAAqB,CAAzB;AACAO,MAAAA,CAAC,GAAGF,CAAC,GAAGA,CAAJ,GAAQC,CAAC,GAAGA,CAAhB;AACD,KAJD,QAISC,CAAC,IAAI,CAAL,IAAUA,CAAC,KAAK,CAJzB;;AAKAA,IAAAA,CAAC,GAAGC,IAAI,CAACC,IAAL,CAAU,CAAC,CAAD,GAAKD,IAAI,CAACE,GAAL,CAASH,CAAT,CAAL,GAAmBA,CAA7B,CAAJ;AACA,SAAKR,cAAL,GAAsBO,CAAC,GAAGC,CAA1B;AACA,WAAOF,CAAC,GAAGE,CAAX;AACD;AAED;AACF;AACA;AACA;;;AACEI,EAAAA,QAAQ,GAAG;AAAE,UAAM,IAAIC,mBAAJ,EAAN;AAAkC;AAE/C;AACF;AACA;;;AACY,MAANC,MAAM,GAAG;AAAE,UAAM,IAAID,mBAAJ,EAAN;AAAkC;;AA1CpC;;AA6Cf,OAAO,MAAME,cAAc,GAAG;AAC5B;AACA;AACA;AACA;AACAC,EAAAA,gBAAgB,EAAE,CALU;;AAM5B,MAAIC,kBAAJ,GAAyB;AACvB,WAAOC,MAAM,CAACC,SAAP,IAAoB,IAAI,KAAKH,gBAApC;AACD,GAR2B;;AAU5BI,EAAAA,QAAQ,EAAEC,IAAI,CAACC,GAAL,KAAab,IAAI,CAACc,GAAL,CAAS,CAAT,EAAY,EAAZ,CAVK;AAW5BC,EAAAA,kBAAkB,EAAE,IAXQ;;AAY5B;AACAC,EAAAA,YAAY,EAAE,cAAc7B,QAAd,CAAuB;AACnCE,IAAAA,WAAW,GAAG;AAAE,YAAMoB,MAAM,CAACQ,OAAP,CAAe3B,IAArB,EAA2BmB,MAAM,CAACQ,OAAP,CAAe1B,cAA1C;AAA4D;;AAC5EY,IAAAA,QAAQ,GAAG;AACTM,MAAAA,MAAM,CAACQ,OAAP,CAAe3B,IAAf,GAAsB,KAAKA,IAA3B;AACAmB,MAAAA,MAAM,CAACQ,OAAP,CAAe1B,cAAf,GAAgC,KAAKA,cAArC;AACD;;AACS,QAANc,MAAM,GAAG;AAAE,aAAO,KAAP;AAAe;;AANK,GAbT;AAsB5Ba,EAAAA,YAAY,EAAE,cAAc/B,QAAd,CAAuB;AACnCE,IAAAA,WAAW,GAAG;AAAE,YAAMiB,cAAc,CAACK,QAArB,EAA+BL,cAAc,CAACS,kBAA9C;AAAoE;;AACpFZ,IAAAA,QAAQ,GAAG;AACTG,MAAAA,cAAc,CAACK,QAAf,GAA0B,KAAKrB,IAA/B;AACAgB,MAAAA,cAAc,CAACS,kBAAf,GAAoC,KAAKxB,cAAzC;AACD;;AACS,QAANc,MAAM,GAAG;AAAE,aAAO,IAAP;AAAc;;AANM,GAtBT;AA+B5Bc,EAAAA,aAAa,EAAE,cAAchC,QAAd,CAAuB;AACpCE,IAAAA,WAAW,GAAG;AAAE,YAAMoB,MAAM,CAACQ,OAAP,CAAeG,SAArB,EAAgCX,MAAM,CAACQ,OAAP,CAAeI,mBAA/C;AAAsE;;AACtFlB,IAAAA,QAAQ,GAAG;AACTM,MAAAA,MAAM,CAACQ,OAAP,CAAeG,SAAf,GAA2B,KAAK9B,IAAhC;AACAmB,MAAAA,MAAM,CAACQ,OAAP,CAAeI,mBAAf,GAAqC,KAAK9B,cAA1C;AACD;;AACS,QAANc,MAAM,GAAG;AAAE,aAAO,KAAP;AAAe;;AANM,GA/BV;;AAuC5B;AAEAiB,EAAAA,aAAa,CAACC,KAAD,EAAQ;AACnB,UAAMC,eAAe,GAAG,GAAxB;AACA,WAAO;AACLC,MAAAA,EAAE,EAAEC,SADC;AAELC,MAAAA,GAAG,EAAE,IAFA;AAGLC,MAAAA,IAAI,EAAE,OAHD;AAIL;AACAC,MAAAA,QAAQ,EAAEL,eALL;AAMLD,MAAAA,KAAK,EAAEA,KAAK,CAACO,WANR;AAOLC,MAAAA,QAAQ,EAAER,KAAK,CAACQ,QAPX;AAQLC,MAAAA,OAAO,EAAEC,sBAAsB,CAAC,CAAC,UAAD,CAAD;AAR1B,KAAP;AAUD,GArD2B;;AAuD5BC,EAAAA,WAAW,CAACX,KAAD,EAAQY,KAAR,EAAeC,MAAM,GAAG,IAAxB,EAA8B;AACvC,UAAMC,GAAG,GAAGF,KAAK,IAAI,IAAI7B,cAAc,CAACU,YAAnB,EAArB;AACA,UAAMa,QAAQ,GAAG,KAAKS,cAAL,CAAoBD,GAApB,CAAjB;AACA,UAAMT,IAAI,GAAGQ,MAAM,IAAI,KAAKG,UAAL,CAAgBF,GAAhB,CAAvB;AACA,QAAIG,UAAU,GAAG,KAAKC,qBAAL,CAA2Bb,IAA3B,EAAiCC,QAAjC,EAA2CN,KAAK,CAACO,WAAjD,EAA8DO,GAA9D,CAAjB;AACA,QAAIT,IAAI,KAAK,SAAT,IAAsBY,UAAU,GAAG,CAAvC,EAA0CA,UAAU,GAAG,CAAb;AAC1C,UAAME,aAAa,GAAG,KAAKC,eAAL,CAAqBf,IAArB,EAA2BY,UAA3B,EAAuCH,GAAvC,CAAtB;AACA,QAAIF,KAAK,KAAKT,SAAd,EAAyBW,GAAG,CAAClC,QAAJ;AACzB,WAAO;AACLsB,MAAAA,EAAE,EAAEC,SADC;AAELC,MAAAA,GAAG,EAAE,IAFA;AAGLC,MAAAA,IAHK;AAILC,MAAAA,QAJK;AAKLN,MAAAA,KAAK,EAAEA,KAAK,CAACO,WALR;AAMLC,MAAAA,QAAQ,EAAER,KAAK,CAACQ,QANX;AAOLC,MAAAA,OAAO,EAAEU;AAPJ,KAAP;AASD,GAxE2B;;AA0E5BE,EAAAA,YAAY,CAACrB,KAAD,EAAQ;AAClB,UAAMsB,GAAG,GAAGC,gBAAgB,CAAC,GAAD,CAA5B;AACA,UAAMd,OAAO,GAAG,KAAKe,sBAAL,CAA4BxB,KAA5B,CAAhB;AACA,UAAMmB,aAAa,GAAGT,sBAAsB,CAACD,OAAD,CAA5C;AACA,WAAO;AACLP,MAAAA,EAAE,EAAEC,SADC;AAELC,MAAAA,GAAG,EAAE,IAFA;AAGLC,MAAAA,IAAI,EAAE,SAHD;AAILC,MAAAA,QAAQ,EAAEgB,GAJL;AAKLtB,MAAAA,KALK;AAMLQ,MAAAA,QAAQ,EAAER,KANL;AAOLS,MAAAA,OAAO,EAAEU;AAPJ,KAAP;AASD,GAvF2B;;AAyF5BM,EAAAA,WAAW,GAAG;AACZ,UAAMH,GAAG,GAAGC,gBAAgB,CAAC,GAAD,CAA5B;AACA,UAAMJ,aAAa,GAAGT,sBAAsB,CAC1CgB,iBAAiB,CAACC,MAAlB,CAAyBC,MAAM,IAAIA,MAAM,CAACC,KAAP,CAAa,SAAb,CAAnC,CAD0C,CAA5C;AAGA,WAAO;AACL3B,MAAAA,EAAE,EAAEC,SADC;AAELC,MAAAA,GAAG,EAAE,IAFA;AAGLC,MAAAA,IAAI,EAAE,QAHD;AAILC,MAAAA,QAAQ,EAAEgB,GAJL;AAKLtB,MAAAA,KAAK,EAAE,IALF;AAMLQ,MAAAA,QAAQ,EAAE,IANL;AAOLC,MAAAA,OAAO,EAAEU;AAPJ,KAAP;AASD,GAvG2B;;AAyG5B;AACA;AACAW,EAAAA,WAAW,CAACzB,IAAD,EAAO;AAChB,UAAM0B,UAAU,GAAGC,YAAY,CAACC,GAAb,CAAiBN,MAAjB,CAAwBO,CAAC,IAAIA,CAAC,CAAChC,EAAF,CAAKiC,UAAL,CAAgB9B,IAAhB,CAA7B,CAAnB;AACA0B,IAAAA,UAAU,CAACK,IAAX,CAAgBJ,YAAY,CAACK,SAA7B;AACA,QAAIC,OAAO,GAAG,CAAd;;AACA,SAAK,MAAMV,MAAX,IAAqBG,UAArB,EAAiCO,OAAO,IAAI,KAAKV,MAAM,CAACW,YAAvB;;AACjC,UAAMC,UAAU,GAAG/D,IAAI,CAACgE,GAAL,CAASvD,MAAM,CAACwD,OAAP,CAAeC,WAAf,CAA2BH,UAApC,EAAgD,IAAhD,CAAnB;AACA,WAAO;AACLtC,MAAAA,EAAE,EAAEC,SADC;AAELC,MAAAA,GAAG,EAAE,IAFA;AAGLC,MAAAA,IAHK;AAILC,MAAAA,QAAQ,EAAE,GAJL;AAKLN,MAAAA,KAAK,EAAEwC,UALF;AAMLhC,MAAAA,QAAQ,EAAEgC,UANL;AAOL/B,MAAAA,OAAO,EAAE6B;AAPJ,KAAP;AASD,GA1H2B;;AA4H5BM,EAAAA,cAAc,CAACC,cAAD,EAAiB;AAC7B;AACA,UAAMvB,GAAG,GAAGC,gBAAgB,CAACsB,cAAc,CAACC,KAAf,KAAyB,GAA1B,CAA5B;AACA,UAAMrC,OAAO,GAAGiB,iBAAiB,CAACC,MAAlB,CAAyBC,MAAM,IAAIA,MAAM,CAACC,KAAP,CAAa,YAAb,CAAnC,CAAhB;AACA,UAAMV,aAAa,GAAGT,sBAAsB,CAACD,OAAD,CAA5C;AACA,WAAO;AACLP,MAAAA,EAAE,EAAEC,SADC;AAELC,MAAAA,GAAG,EAAE,IAFA;AAGLC,MAAAA,IAAI,EAAE,WAHD;AAILC,MAAAA,QAAQ,EAAEgB,GAJL;AAKLtB,MAAAA,KAAK,EAAE,CALF;AAMLQ,MAAAA,QAAQ,EAAE,CANL;AAOLC,MAAAA,OAAO,EAAEU;AAPJ,KAAP;AASD,GA1I2B;;AA4I5B4B,EAAAA,UAAU,GAAG;AACX,UAAMjC,GAAG,GAAG,IAAI/B,cAAc,CAACa,aAAnB,EAAZ;AACA,UAAMoD,KAAK,GACT,KAAKrC,WAAL,CAAiB;AAAEJ,MAAAA,WAAW,EAAE9B,IAAI,CAACwE,KAAL,CAAW/D,MAAM,CAACwD,OAAP,CAAeC,WAAf,CAA2BH,UAA3B,GAAwC,GAAnD,CAAf;AAAwEhC,MAAAA,QAAQ,EAAE;AAAlF,KAAjB,EAAwGM,GAAxG,CADF;AAEAA,IAAAA,GAAG,CAAClC,QAAJ;AACAoE,IAAAA,KAAK,CAACE,QAAN,GAAiB,OAAjB;AACAF,IAAAA,KAAK,CAACG,aAAN,GAAsB,OAAtB;AACA,WAAOH,KAAP;AACD,GApJ2B;;AAsJ5B;AACAI,EAAAA,MAAM,GAAG;AACP,WAAO,KAAKC,KAAL,GAAa,CAApB;AACD,GAzJ2B;;AA2J5B,MAAIA,KAAJ,GAAY;AACV,WAAOnE,MAAM,CAACQ,OAAP,CAAe4D,MAAf,CAAsBC,MAAtB,CACJC,MADI,CACGtE,MAAM,CAACQ,OAAP,CAAe4D,MAAf,CAAsBG,SADzB,EAEJC,MAFI,CAEG,CAACjB,GAAD,EAAMO,KAAN,KAAgBvE,IAAI,CAACgE,GAAL,CAASA,GAAT,EAAcO,KAAK,CAAC9C,EAApB,CAFnB,EAE4C,CAF5C,CAAP;AAGD,GA/J2B;;AAiK5B,MAAIyD,kBAAJ,GAAyB;AACvB,WAAOC,OAAO,CAACnB,GAAR,CAAY,CAAZ,EAAeoB,cAAc,CAAC,EAAD,CAA7B,CAAP;AACD,GAnK2B;;AAqK5B9C,EAAAA,cAAc,CAACD,GAAD,EAAM;AAClB;AACA;AACA,QAAIgD,EAAE,CAACC,OAAH,CAAWC,oCAAX,CAAgDC,YAApD,EAAkE,OAAO1C,gBAAgB,CAAC,GAAD,CAAvB;AAClE,QAAI2C,MAAM,GAAGnF,cAAc,CAACoF,iBAAf,CAAiCrD,GAAjC,IAAwC/B,cAAc,CAAC4E,kBAApE;AACA,UAAMS,gBAAgB,GAAGN,EAAE,CAACC,OAAH,CAAWM,6CAAX,CAAyDJ,YAAzD,GAAwE,CAAxE,GAA4EnD,GAAG,CAAC7C,OAAJ,EAArG;AACA,UAAMqG,eAAe,GAAGF,gBAAgB,GAAGG,OAAO,CAACC,cAA3B,GACtBZ,OAAO,CAACa,GAAR,CAAYC,WAAW,CAAC,GAAD,CAAvB,EAA8BC,cAAc,CAACC,OAA7C,CADF,CANkB,CAQlB;;AACAV,IAAAA,MAAM,IAAII,eAAe,GAAG,EAA5B,CATkB,CAUlB;;AACAJ,IAAAA,MAAM,GAAGzF,IAAI,CAACoG,IAAL,CAAUX,MAAM,GAAG,GAAnB,IAA0B,GAAnC;AACA,WAAOzF,IAAI,CAACqG,GAAL,CAASZ,MAAT,EAAiB3C,gBAAgB,CAAC,GAAD,CAAjC,CAAP;AACD,GAlL2B;;AAoL5B;AACAL,EAAAA,qBAAqB,CAACb,IAAD,EAAOC,QAAP,EAAiBN,KAAjB,EAAwBc,GAAxB,EAA6B;AAChD;AACA;AACA;AACA,UAAMiE,OAAO,GAAGjE,GAAG,CAAC7C,OAAJ,EAAhB;AACA,UAAM+G,OAAO,GAAGlE,GAAG,CAAC7C,OAAJ,EAAhB;AACA,QAAIoC,IAAI,KAAK,SAAT,IAAsByD,EAAE,CAACC,OAAH,CAAWkB,gBAAX,CAA4BhB,YAAtD,EAAoE,OAAO,CAAP;AACpE,UAAMiB,UAAU,GAAGpB,EAAE,CAACC,OAAH,CAAWkB,gBAAX,CAA4BhB,YAA5B,GAA2C,CAA3C,GAA+C,CAAlE;AACA,QAAIkB,GAAG,GAAG1G,IAAI,CAACqG,GAAL,CACRI,UADQ,EAERzG,IAAI,CAACwE,KAAL,CAAWxE,IAAI,CAACc,GAAL,CAASwF,OAAT,EAAkB,IAAKtG,IAAI,CAACc,GAAL,CAASS,KAAK,GAAGM,QAAjB,EAA2B,GAA3B,CAAD,GAAoC,GAA1D,IAAiE,GAAjE,GAAuE,CAAlF,CAFQ,CAAV,CARgD,CAYhD;AACA;;AACA,QAAIuD,cAAc,CAAC,EAAD,CAAd,CAAmBuB,QAAnB,IAA+BJ,OAAO,GAAGpB,OAAO,CAACnB,GAAR,CAAY,CAAZ,EAAeoB,cAAc,CAAC,EAAD,CAA7B,CAA7C,EAAiF;AAC/EsB,MAAAA,GAAG,GAAG1G,IAAI,CAACqG,GAAL,CAASK,GAAG,GAAG,CAAf,EAAkBD,UAAlB,CAAN;AACD;;AACD,WAAOpB,EAAE,CAACC,OAAH,CAAWkB,gBAAX,CAA4BhB,YAA5B,GAA2CxF,IAAI,CAACgE,GAAL,CAAS0C,GAAT,EAAc,CAAd,CAA3C,GAA8DA,GAArE;AACD,GAvM2B;;AAyM5B;AACA3D,EAAAA,sBAAsB,CAACxB,KAAD,EAAQ;AAC5B,UAAMqF,eAAe,GAAGC,iCAAiC,CAAC3D,MAAlC,CAAyC4D,EAAE,IAAIA,EAAE,IAAIvF,KAArD,EAA4DwF,MAApF;AACA,UAAMC,oBAAoB,GAAGzD,YAAY,CAACC,GAAb,CAC1BN,MAD0B,CACnB+D,GAAG,IAAIA,GAAG,CAACC,UAAJ,CAAeC,QAAf,CAAwB,SAAxB,CADY,EAE1BC,IAF0B,CAErB,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,CAACvD,YAAF,GAAiBwD,CAAC,CAACxD,YAFR,EAG1ByD,GAH0B,CAGtBN,GAAG,IAAIA,GAAG,CAACxF,EAHW,CAA7B;AAIA,WAAOuF,oBAAoB,CAACQ,KAArB,CAA2B,CAA3B,EAA8BZ,eAA9B,CAAP;AACD,GAjN2B;;AAmN5BjE,EAAAA,eAAe,CAACf,IAAD,EAAO6F,KAAP,EAAcpF,GAAd,EAAmB;AAChC,UAAMqF,YAAY,GAAGC,UAAU,CAAC/F,IAAD,CAAV,CAAiBI,OAAjB,CAAyB4F,WAAzB,CAAqCC,CAAC,IAAIA,CAAC,CAAC/D,YAA5C,EAA0D,MAAMzB,GAAG,CAAC7C,OAAJ,EAAhE,CAArB,CADgC,CAEhC;;AACAsI,IAAAA,KAAK,CAACC,KAAN,CAAY,CAAZ,EAAe,IAAIJ,UAAU,CAAC/F,IAAD,CAAV,CAAiBI,OAAjB,CAAyB+E,MAA5C,EAAoDiB,OAApD,CAA4D,MAAM3F,GAAG,CAAC7C,OAAJ,EAAlE;;AACA,QAAIoC,IAAI,KAAK,SAAb,EAAwB;AACtB;AACA,YAAMqG,UAAU,GAAGP,YAAY,CAAC,EAAD,CAAZ,GAAmBA,YAAY,CAAC,EAAD,CAA/B,GAAsC,EAAtC,GAA2C,EAA9D;AACAA,MAAAA,YAAY,CAACO,UAAD,CAAZ,GAA2B,CAAC,CAA5B;AACD,KAR+B,CAShC;;;AACA,SAAK,MAAMC,CAAX,IAAgB,CAAC,CAAD,EAAI,EAAJ,EAAQ,EAAR,CAAhB,EAA6B;AAC3B,UAAIA,CAAC,IAAIR,YAAT,EAAuB;AACrBA,QAAAA,YAAY,CAACQ,CAAD,CAAZ,GAAkB,CAAlB;AACD;AACF,KAd+B,CAehC;;;AACA,UAAMlG,OAAO,GAAGmG,MAAM,CAACC,IAAP,CAAYV,YAAZ,EAA0BN,IAA1B,CAA+B,CAACC,CAAD,EAAIC,CAAJ,KAAUI,YAAY,CAACJ,CAAD,CAAZ,GAAkBI,YAAY,CAACL,CAAD,CAAvE,EAA4EG,KAA5E,CAAkF,CAAlF,EAAqFC,KAArF,CAAhB;AACA,WAAOzF,OAAO,CAACuF,GAAR,CAAYc,MAAZ,EAAoBC,SAApB,EAAP;AACD,GArO2B;;AAuO5B/F,EAAAA,UAAU,CAACF,GAAD,EAAMkG,UAAU,GAAG,EAAnB,EAAuB;AAC/B,UAAMC,WAAW,GAAGC,cAAc,CAACvF,MAAf,CAAsB2E,CAAC,IAAIa,aAAa,CAACzH,OAAd,CAAsB0H,UAAtB,IAAoCd,CAAC,KAAK,SAArE,CAApB;AACA,UAAMe,kBAAkB,GAAGJ,WAAW,CAACjB,GAAZ,CAAgBM,CAAC,IAAIU,UAAU,CAACM,UAAX,CAAsBC,CAAC,IAAIA,CAAC,KAAKjB,CAAjC,CAArB,EAA0D7D,GAA1D,EAA3B;AACA,UAAM+E,WAAW,GAAGR,UAAU,CAACxB,MAAX,KAAsB,CAAtB,GAChB,EADgB,GACXyB,WAAW,CAACtF,MAAZ,CAAmB2E,CAAC,IAAIU,UAAU,CAACM,UAAX,CAAsBC,CAAC,IAAIA,CAAC,KAAKjB,CAAjC,MAAwCe,kBAAhE,CADT;AAEA,WAAOjB,UAAU,CAACqB,MAAX,CAAkB3G,GAAlB,EAAuB0G,WAAvB,CAAP;AACD,GA7O2B;;AA+O5B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEE,EAAAA,aAAa,CAAC1H,KAAD,EAAQc,GAAR,EAAa6G,YAAb,EAA2B;AACtC;AACA;AACA,UAAMC,QAAQ,GAAGnJ,IAAI,CAACwE,KAAL,CAAW,CAAC0E,YAAY,GAAG,CAAhB,IAAqB,CAAhC,CAAjB;AACA,UAAME,UAAU,GAAG,CAACF,YAAY,GAAG,CAAhB,IAAqB,CAAxC,CAJsC,CAMtC;AACA;;AACA,UAAMG,QAAQ,GAAG5I,MAAM,CAACQ,OAAP,CAAeqI,WAAhC;AACA,UAAMC,QAAQ,GAAGC,gBAAgB,CAAC,CAAD,EAAI,CAAC,KAAKH,QAAQ,GAAG,CAAjB,IAAsBF,QAAtB,GAAiCE,QAAQ,GAAG,IAAhD,CAAjC,CATsC,CAWtC;AACA;;AACA,UAAMI,aAAa,GAAG3B,KAAK,CAAC4B,MAAN,CAAa,CAAb,EAAgB,CAAhB,CAAtB;;AACA,SAAK,IAAIxB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGkB,UAApB,EAAgClB,CAAC,EAAjC,EAAqC;AACnC,WAAK,IAAItG,IAAI,GAAG,CAAhB,EAAmBA,IAAI,GAAG,CAA1B,EAA6BA,IAAI,EAAjC,EAAqC;AACnC,YAAIA,IAAI,KAAK2H,QAAQ,CAACrB,CAAD,CAArB,EAA0BuB,aAAa,CAAC7H,IAAD,CAAb;AAC3B;AACF,KAlBqC,CAoBtC;AACA;AACA;;;AACA,UAAM+H,cAAc,GAAG,EAAvB;AACA,UAAMC,OAAO,GAAG,CAAC,EAAD,EAAK,EAAL,EAAS,CAAT,EAAY,CAAZ,EAAe,CAAf,CAAhB;AACA,UAAMC,gBAAgB,GAAG/B,KAAK,CAACC,KAAN,CAAY,CAAZ,EAAe,CAAf,CAAzB;AACA8B,IAAAA,gBAAgB,CAACC,MAAjB,CAAwBP,QAAQ,CAACH,UAAD,CAAhC,EAA8C,CAA9C;;AACA,SAAK,IAAIlB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;AAC1B,YAAMtG,IAAI,GAAGiI,gBAAgB,CAAC3B,CAAD,CAA7B;AACA,YAAM6B,UAAU,GAAGP,gBAAgB,CAAC,CAAD,EAAI,IAAI5H,IAAJ,GAAW,CAAC,IAAIyH,QAAQ,GAAG,CAAhB,IAAqBF,QAAhC,GAA2CE,QAAQ,GAAG,EAA1D,CAAnC;AACAM,MAAAA,cAAc,CAAChG,IAAf,CAAoBiG,OAAO,CAAChI,IAAD,CAAP,GAAgBmI,UAAU,CAACN,aAAa,CAAC7H,IAAD,CAAd,CAA9C;AACD,KA/BqC,CAiCtC;AACA;AACA;AACA;AACA;;;AACA,UAAMiD,MAAM,GAAG,EAAf;;AACA,SAAK,IAAIqD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuB,EAAEA,CAAzB,EAA4B;AAC1B,YAAM8B,QAAQ,GAAG1J,cAAc,CAAC4B,WAAf,CAA2BX,KAA3B,EAAkCc,GAAlC,EAAuC4H,iBAAiB,CAACJ,gBAAgB,CAAC3B,CAAD,CAAjB,CAAxD,CAAjB;AACA,YAAMgC,OAAO,GAAG,CAACb,QAAQ,GAAGH,YAAX,GAA0BhB,CAA3B,IAAgC,CAAhC,KAAsC,CAAtC,GACX,KAAKyB,cAAc,CAACzB,CAAD,CADR,GAEZ8B,QAAQ,CAAChI,OAAT,GAAoB,KAAK2H,cAAc,CAACzB,CAAD,CAF3C;AAGA,YAAMzB,UAAU,GAAGrB,cAAc,CAAC,EAAD,CAAd,CAAmBuB,QAAnB,GAA8B,CAA9B,GAAkC,CAArD;;AACA,UAAIwD,sBAAsB,CAACD,OAAD,CAAtB,GAAkCzD,UAAtC,EAAkD;AAChD;AACA;AACA,cAAM2D,UAAU,GAAGC,0BAA0B,CAACL,QAAQ,CAAChI,OAAV,CAA1B,CAChBkB,MADgB,CACT+D,GAAG,IAAIA,GAAG,CAACqD,WADF,EAEhB/C,GAFgB,CAEZN,GAAG,IAAIA,GAAG,CAACnD,YAFC,EAGhBZ,MAHgB,CAGT+D,GAAG,IAAI,CAAC,CAAC,CAAD,EAAI,EAAJ,EAAQ,EAAR,EAAYE,QAAZ,CAAqBF,GAArB,CAHC,CAAnB;AAIA,cAAMsD,QAAQ,GAAGH,UAAU,CAACpK,IAAI,CAACwK,GAAL,CAASnB,QAAQ,GAAGH,YAApB,IAAoCkB,UAAU,CAACrD,MAAhD,CAA3B;AACAiD,QAAAA,QAAQ,CAAChI,OAAT,GAAmBkI,OAAO,GAAG,EAAE,KAAKK,QAAP,CAA7B;AACD,OATD,MASO;AACLP,QAAAA,QAAQ,CAAChI,OAAT,GAAmBkI,OAAnB;AACD,OAjByB,CAmB1B;;;AACA,YAAMO,SAAS,GAAG;AAAEC,QAAAA,KAAK,EAAE,EAAT;AAAaC,QAAAA,QAAQ,EAAE,EAAvB;AAA2BC,QAAAA,IAAI,EAAE;AAAjC,OAAlB;;AACA,UAAIH,SAAS,CAACT,QAAQ,CAACpI,IAAV,CAAT,KAA6BF,SAAjC,EAA4C;AAC1CsI,QAAAA,QAAQ,CAAChI,OAAT,IAAoB,KAAKyI,SAAS,CAACT,QAAQ,CAACpI,IAAV,CAAlC;AACD;;AAEDiD,MAAAA,MAAM,CAAClB,IAAP,CAAYqG,QAAZ;AACD;;AAED,WAAOnF,MAAP;AACD,GA7T2B;;AA+T5BgG,EAAAA,MAAM,CAACC,IAAD,EAAO;AACX,WAAOA,IAAI,GAAG,IAAIxK,cAAc,CAACY,YAAnB,EAAH,GAAuC,IAAIZ,cAAc,CAACU,YAAnB,EAAlD;AACD,GAjU2B;;AAmU5B;AACF;AACA;AACA;AACA;AACA;AACE0E,EAAAA,iBAAiB,CAACrD,GAAD,EAAM;AACrB;AACA;AACA;AACA;AACA,UAAMwF,CAAC,GAAG7H,IAAI,CAACC,IAAL,CAAUD,IAAI,CAACwK,GAAL,CAASnI,GAAG,CAAC1C,MAAJ,EAAT,EAAuB,CAAvB,IAA4B,CAAtC,CAAV;AACA,WAAO,CAAC,iBAAD,GAAqBkI,CAAC,IAAI,oBAAoBA,CAAC,IAAI,oBAAoBA,CAAC,GAAG,CAAC,iBAA7B,CAAzB,CAA7B;AACD,GAhV2B;;AAkV5BkD,EAAAA,IAAI,CAACxG,KAAD,EAAQ;AACV,WAAOA,KAAK,GAAGrF,SAAS,CAAC,EAAD,EAAKqF,KAAL,CAAZ,GAA0BA,KAAtC;AACD;;AApV2B,CAAvB","sourcesContent":["/**\r\n * It turns out reading and writing the RNG state from player is really slow, for\r\n * some reason. Thus, it's very advantageous to get an RNG as a local variable, and only\r\n * write the state back out to player when we are done with it.\r\n * So, this interface is implemented by a real and fake RNG class; after creating one and\r\n * using it, call finalize on it to write the seed out.\r\n */\r\nimport { deepmerge } from \"@/utility/deepmerge\";\r\n\r\nclass GlyphRNG {\r\n  static get SECOND_GAUSSIAN_DEFAULT_VALUE() {\r\n    return 1e6;\r\n  }\r\n\r\n  constructor(seed, secondGaussian) {\r\n    this.seed = seed;\r\n    this.secondGaussian = secondGaussian;\r\n  }\r\n\r\n  uniform() {\r\n    const state = xorshift32Update(this.seed);\r\n    this.seed = state;\r\n    return state * 2.3283064365386963e-10 + 0.5;\r\n  }\r\n\r\n  normal() {\r\n    if (this.secondGaussian !== GlyphRNG.SECOND_GAUSSIAN_DEFAULT_VALUE) {\r\n      const toReturn = this.secondGaussian;\r\n      this.secondGaussian = GlyphRNG.SECOND_GAUSSIAN_DEFAULT_VALUE;\r\n      return toReturn;\r\n    }\r\n    let u = 0, v = 0, s = 0;\r\n    do {\r\n      u = this.uniform() * 2 - 1;\r\n      v = this.uniform() * 2 - 1;\r\n      s = u * u + v * v;\r\n    } while (s >= 1 || s === 0);\r\n    s = Math.sqrt(-2 * Math.log(s) / s);\r\n    this.secondGaussian = v * s;\r\n    return u * s;\r\n  }\r\n\r\n  /**\r\n   * Write the seed out to where it can be restored\r\n   * @abstract\r\n   */\r\n  finalize() { throw new NotImplementedError(); }\r\n\r\n  /**\r\n   * @abstract\r\n   */\r\n  get isFake() { throw new NotImplementedError(); }\r\n}\r\n\r\nexport const GlyphGenerator = {\r\n  // Glyph choices will have more uniformly-distributed properties up for this many groups\r\n  // of uniform glyphs. The size of a uniformity group is 5, so this gives uniformly-distributed\r\n  // properties up to a reality count one more than 5x this value; the modified RNG for uniform\r\n  // glyphs excludes the first fixed glyph and only starts from the 2nd one onward\r\n  uniformityGroups: 4,\r\n  get isUniformityActive() {\r\n    return player.realities <= 5 * this.uniformityGroups;\r\n  },\r\n\r\n  fakeSeed: Date.now() % Math.pow(2, 32),\r\n  fakeSecondGaussian: null,\r\n  /* eslint-disable lines-between-class-members */\r\n  RealGlyphRNG: class extends GlyphRNG {\r\n    constructor() { super(player.reality.seed, player.reality.secondGaussian); }\r\n    finalize() {\r\n      player.reality.seed = this.seed;\r\n      player.reality.secondGaussian = this.secondGaussian;\r\n    }\r\n    get isFake() { return false; }\r\n  },\r\n\r\n  FakeGlyphRNG: class extends GlyphRNG {\r\n    constructor() { super(GlyphGenerator.fakeSeed, GlyphGenerator.fakeSecondGaussian); }\r\n    finalize() {\r\n      GlyphGenerator.fakeSeed = this.seed;\r\n      GlyphGenerator.fakeSecondGaussian = this.secondGaussian;\r\n    }\r\n    get isFake() { return true; }\r\n  },\r\n\r\n  MusicGlyphRNG: class extends GlyphRNG {\r\n    constructor() { super(player.reality.musicSeed, player.reality.musicSecondGaussian); }\r\n    finalize() {\r\n      player.reality.musicSeed = this.seed;\r\n      player.reality.musicSecondGaussian = this.secondGaussian;\r\n    }\r\n    get isFake() { return false; }\r\n  },\r\n  /* eslint-enable lines-between-class-members */\r\n\r\n  startingGlyph(level) {\r\n    const initialStrength = 1.5;\r\n    return {\r\n      id: undefined,\r\n      idx: null,\r\n      type: \"power\",\r\n      // The initial strength is very slightly above average.\r\n      strength: initialStrength,\r\n      level: level.actualLevel,\r\n      rawLevel: level.rawLevel,\r\n      effects: makeGlyphEffectBitmask([\"powerpow\"]),\r\n    };\r\n  },\r\n\r\n  randomGlyph(level, rngIn, typeIn = null) {\r\n    const rng = rngIn || new GlyphGenerator.RealGlyphRNG();\r\n    const strength = this.randomStrength(rng);\r\n    const type = typeIn || this.randomType(rng);\r\n    let numEffects = this.randomNumberOfEffects(type, strength, level.actualLevel, rng);\r\n    if (type !== \"effarig\" && numEffects > 4) numEffects = 4;\r\n    const effectBitmask = this.generateEffects(type, numEffects, rng);\r\n    if (rngIn === undefined) rng.finalize();\r\n    return {\r\n      id: undefined,\r\n      idx: null,\r\n      type,\r\n      strength,\r\n      level: level.actualLevel,\r\n      rawLevel: level.rawLevel,\r\n      effects: effectBitmask,\r\n    };\r\n  },\r\n\r\n  realityGlyph(level) {\r\n    const str = rarityToStrength(100);\r\n    const effects = this.generateRealityEffects(level);\r\n    const effectBitmask = makeGlyphEffectBitmask(effects);\r\n    return {\r\n      id: undefined,\r\n      idx: null,\r\n      type: \"reality\",\r\n      strength: str,\r\n      level,\r\n      rawLevel: level,\r\n      effects: effectBitmask,\r\n    };\r\n  },\r\n\r\n  cursedGlyph() {\r\n    const str = rarityToStrength(100);\r\n    const effectBitmask = makeGlyphEffectBitmask(\r\n      orderedEffectList.filter(effect => effect.match(\"cursed*\"))\r\n    );\r\n    return {\r\n      id: undefined,\r\n      idx: null,\r\n      type: \"cursed\",\r\n      strength: str,\r\n      level: 6666,\r\n      rawLevel: 6666,\r\n      effects: effectBitmask,\r\n    };\r\n  },\r\n\r\n  // These Glyphs are given on entering Doomed to prevent the player\r\n  // from having none of each basic glyphs which are requied to beat pelle\r\n  doomedGlyph(type) {\r\n    const effectList = GlyphEffects.all.filter(e => e.id.startsWith(type));\r\n    effectList.push(GlyphEffects.timespeed);\r\n    let bitmask = 0;\r\n    for (const effect of effectList) bitmask |= 1 << effect.bitmaskIndex;\r\n    const glyphLevel = Math.max(player.records.bestReality.glyphLevel, 5000);\r\n    return {\r\n      id: undefined,\r\n      idx: null,\r\n      type,\r\n      strength: 3.5,\r\n      level: glyphLevel,\r\n      rawLevel: glyphLevel,\r\n      effects: bitmask,\r\n    };\r\n  },\r\n\r\n  companionGlyph(eternityPoints) {\r\n    // Store the pre-Reality EP value in the glyph's rarity\r\n    const str = rarityToStrength(eternityPoints.log10() / 1e6);\r\n    const effects = orderedEffectList.filter(effect => effect.match(\"companion*\"));\r\n    const effectBitmask = makeGlyphEffectBitmask(effects);\r\n    return {\r\n      id: undefined,\r\n      idx: null,\r\n      type: \"companion\",\r\n      strength: str,\r\n      level: 1,\r\n      rawLevel: 1,\r\n      effects: effectBitmask,\r\n    };\r\n  },\r\n\r\n  musicGlyph() {\r\n    const rng = new GlyphGenerator.MusicGlyphRNG();\r\n    const glyph =\r\n      this.randomGlyph({ actualLevel: Math.floor(player.records.bestReality.glyphLevel * 0.8), rawLevel: 1 }, rng);\r\n    rng.finalize();\r\n    glyph.cosmetic = \"music\";\r\n    glyph.fixedCosmetic = \"music\";\r\n    return glyph;\r\n  },\r\n\r\n  // Generates a unique ID for glyphs, used for deletion and drag-and-drop.  Non-unique IDs can cause buggy behavior.\r\n  makeID() {\r\n    return this.maxID + 1;\r\n  },\r\n\r\n  get maxID() {\r\n    return player.reality.glyphs.active\r\n      .concat(player.reality.glyphs.inventory)\r\n      .reduce((max, glyph) => Math.max(max, glyph.id), 0);\r\n  },\r\n\r\n  get strengthMultiplier() {\r\n    return Effects.max(1, RealityUpgrade(16));\r\n  },\r\n\r\n  randomStrength(rng) {\r\n    // Technically getting this upgrade really changes glyph gen but at this point almost all\r\n    // the RNG is gone anyway.\r\n    if (Ra.unlocks.maxGlyphRarityAndShardSacrificeBoost.canBeApplied) return rarityToStrength(100);\r\n    let result = GlyphGenerator.gaussianBellCurve(rng) * GlyphGenerator.strengthMultiplier;\r\n    const relicShardFactor = Ra.unlocks.extraGlyphChoicesAndRelicShardRarityAlwaysMax.canBeApplied ? 1 : rng.uniform();\r\n    const increasedRarity = relicShardFactor * Effarig.maxRarityBoost +\r\n      Effects.sum(Achievement(146), GlyphSacrifice.effarig);\r\n    // Each rarity% is 0.025 strength.\r\n    result += increasedRarity / 40;\r\n    // Raise the result to the next-highest 0.1% rarity.\r\n    result = Math.ceil(result * 400) / 400;\r\n    return Math.min(result, rarityToStrength(100));\r\n  },\r\n\r\n  // eslint-disable-next-line max-params\r\n  randomNumberOfEffects(type, strength, level, rng) {\r\n    // Call the RNG twice before anything else to advance the RNG seed properly, even if the whole method returns early.\r\n    // This prevents the position of effarig glyphs in the choice list from affecting the choices themselves, as well\r\n    // as preventing all of the glyphs changing drastically when RU17 is purchased.\r\n    const random1 = rng.uniform();\r\n    const random2 = rng.uniform();\r\n    if (type !== \"effarig\" && Ra.unlocks.glyphEffectCount.canBeApplied) return 4;\r\n    const maxEffects = Ra.unlocks.glyphEffectCount.canBeApplied ? 7 : 4;\r\n    let num = Math.min(\r\n      maxEffects,\r\n      Math.floor(Math.pow(random1, 1 - (Math.pow(level * strength, 0.5)) / 100) * 1.5 + 1)\r\n    );\r\n    // If we do decide to add anything else that boosts chance of an extra effect, keeping the code like this\r\n    // makes it easier to do (add it to the Effects.max).\r\n    if (RealityUpgrade(17).isBought && random2 < Effects.max(0, RealityUpgrade(17))) {\r\n      num = Math.min(num + 1, maxEffects);\r\n    }\r\n    return Ra.unlocks.glyphEffectCount.canBeApplied ? Math.max(num, 4) : num;\r\n  },\r\n\r\n  // Populate a list of reality glyph effects based on level\r\n  generateRealityEffects(level) {\r\n    const numberOfEffects = realityGlyphEffectLevelThresholds.filter(lv => lv <= level).length;\r\n    const sortedRealityEffects = GlyphEffects.all\r\n      .filter(eff => eff.glyphTypes.includes(\"reality\"))\r\n      .sort((a, b) => a.bitmaskIndex - b.bitmaskIndex)\r\n      .map(eff => eff.id);\r\n    return sortedRealityEffects.slice(0, numberOfEffects);\r\n  },\r\n\r\n  generateEffects(type, count, rng) {\r\n    const effectValues = GlyphTypes[type].effects.mapToObject(x => x.bitmaskIndex, () => rng.uniform());\r\n    // Get a bunch of random numbers so that we always use 7 here.\r\n    Array.range(0, 7 - GlyphTypes[type].effects.length).forEach(() => rng.uniform());\r\n    if (type === \"effarig\") {\r\n      // This is effarigrm/effarigglyph\r\n      const unincluded = effectValues[20] < effectValues[21] ? 20 : 21;\r\n      effectValues[unincluded] = -1;\r\n    }\r\n    // This is timepow/infinitypow/powerpow\r\n    for (const i of [0, 12, 16]) {\r\n      if (i in effectValues) {\r\n        effectValues[i] = 2;\r\n      }\r\n    }\r\n    // Sort from highest to lowest value.\r\n    const effects = Object.keys(effectValues).sort((a, b) => effectValues[b] - effectValues[a]).slice(0, count);\r\n    return effects.map(Number).toBitmask();\r\n  },\r\n\r\n  randomType(rng, typesSoFar = []) {\r\n    const generatable = generatedTypes.filter(x => EffarigUnlock.reality.isUnlocked || x !== \"effarig\");\r\n    const maxOfSameTypeSoFar = generatable.map(x => typesSoFar.countWhere(y => y === x)).max();\r\n    const blacklisted = typesSoFar.length === 0\r\n      ? [] : generatable.filter(x => typesSoFar.countWhere(y => y === x) === maxOfSameTypeSoFar);\r\n    return GlyphTypes.random(rng, blacklisted);\r\n  },\r\n\r\n  /**\r\n   * To generate glyphs with a \"uniformly random\" effect spread, we effectively need to generate all the glyphs in\r\n   *  uniform groups of some size at once, and then select from that generated group. In this case, we've decided\r\n   *  that a group which satisfies uniformity is that of 5 realities, such that all 20 choices amongst the group\r\n   *  must contain each individual glyph effect at least once. This makes types more \"uniform\" by ensuring that\r\n   *  any individual glyph type is never *repeatedly* absent for more than 2 realities in a row (which can only\r\n   *  happen between groups), as well as ensuring that trends of long-term type/effect absences never happen\r\n   * Note: At this point, realityCount should be the number of realities BEFORE processing completes (ie. the first\r\n   *  random generated set begins at a parameter of 1)\r\n   */\r\n  uniformGlyphs(level, rng, realityCount) {\r\n    // Reality count divided by 5 determines which group of 5 we're in, while count mod 5 determines the index\r\n    // within that block. Note that we have a minus 1 because we want to exclude the first fixed glyph\r\n    const groupNum = Math.floor((realityCount - 1) / 5);\r\n    const groupIndex = (realityCount - 1) % 5;\r\n\r\n    // The usage of the initial seed is complicated in order to prevent future prediction without using information\r\n    // not normally available in-game (ie. the console). This makes it appear less predictable overall\r\n    const initSeed = player.reality.initialSeed;\r\n    const typePerm = permutationIndex(5, (31 + initSeed % 7) * groupNum + initSeed % 1123);\r\n\r\n    // Figure out a permutation index for each generated glyph type this reality by counting through the sets\r\n    // for choices which have already been generated for options in previous realities for this group\r\n    const typePermIndex = Array.repeat(0, 5);\r\n    for (let i = 0; i < groupIndex; i++) {\r\n      for (let type = 0; type < 5; type++) {\r\n        if (type !== typePerm[i]) typePermIndex[type]++;\r\n      }\r\n    }\r\n\r\n    // Determine which effect needs to be added for uniformity (startID is a hardcoded array of the lowest ID glyph\r\n    // effect of each type, in the same type order as BASIC_GLYPH_TYPES). We use type, initial seed, and group index\r\n    // to pick a random permutation, again to make it less predictable and to make sure they're generally different\r\n    const uniformEffects = [];\r\n    const startID = [16, 12, 8, 0, 4];\r\n    const typesThisReality = Array.range(0, 5);\r\n    typesThisReality.splice(typePerm[groupIndex], 1);\r\n    for (let i = 0; i < 4; i++) {\r\n      const type = typesThisReality[i];\r\n      const effectPerm = permutationIndex(4, 5 * type + (7 + initSeed % 5) * groupNum + initSeed % 11);\r\n      uniformEffects.push(startID[type] + effectPerm[typePermIndex[type]]);\r\n    }\r\n\r\n    // Generate the glyphs without uniformity applied first, assuming 4 glyph choices early on, then fix it to contain\r\n    // the new effect. This fixing process is a 50% chance to add to existing effects and 50% to replace them instead.\r\n    // Note that if this would give us \"too many\" effects, we remove one of the existing ones, and the threshold for\r\n    // having \"too many\" depends on if the player has the upgrade that improves effect count - we don't want the\r\n    // uniformity code to make glyph generation disproportionately worse in that case\r\n    const glyphs = [];\r\n    for (let i = 0; i < 4; ++i) {\r\n      const newGlyph = GlyphGenerator.randomGlyph(level, rng, BASIC_GLYPH_TYPES[typesThisReality[i]]);\r\n      const newMask = (initSeed + realityCount + i) % 2 === 0\r\n        ? (1 << uniformEffects[i])\r\n        : newGlyph.effects | (1 << uniformEffects[i]);\r\n      const maxEffects = RealityUpgrade(17).isBought ? 3 : 2;\r\n      if (countValuesFromBitmask(newMask) > maxEffects) {\r\n        // Turn the old effect bitmask into an array of removable effects and then deterministically remove one\r\n        // of the non-power effects based on seed and reality count\r\n        const replacable = getGlyphEffectsFromBitmask(newGlyph.effects)\r\n          .filter(eff => eff.isGenerated)\r\n          .map(eff => eff.bitmaskIndex)\r\n          .filter(eff => ![0, 12, 16].includes(eff));\r\n        const toRemove = replacable[Math.abs(initSeed + realityCount) % replacable.length];\r\n        newGlyph.effects = newMask & ~(1 << toRemove);\r\n      } else {\r\n        newGlyph.effects = newMask;\r\n      }\r\n\r\n      // Add the power effects on power/infinity/time, since the initial setting of newMask removes them half the time\r\n      const dimPowers = { power: 16, infinity: 12, time: 0 };\r\n      if (dimPowers[newGlyph.type] !== undefined) {\r\n        newGlyph.effects |= 1 << dimPowers[newGlyph.type];\r\n      }\r\n\r\n      glyphs.push(newGlyph);\r\n    }\r\n\r\n    return glyphs;\r\n  },\r\n\r\n  getRNG(fake) {\r\n    return fake ? new GlyphGenerator.FakeGlyphRNG() : new GlyphGenerator.RealGlyphRNG();\r\n  },\r\n\r\n  /**\r\n   * More than 3 approx 0.001%\r\n   * More than 2.5 approx 0.2%\r\n   * More than 2 approx 6%\r\n   * More than 1.5 approx 38.43%\r\n   */\r\n  gaussianBellCurve(rng) {\r\n    // Old code used max, instead of abs -- but we rejected any samples that were\r\n    // at the boundary anyways. Might as well use abs, and not cycle as many times.\r\n    // The function here is an approximation of ^0.65, here is the old code:\r\n    //     return Math.pow(Math.max(rng.normal() + 1, 1), 0.65);\r\n    const x = Math.sqrt(Math.abs(rng.normal(), 0) + 1);\r\n    return -0.111749606737000 + x * (0.900603878243551 + x * (0.229108274476697 + x * -0.017962545983249));\r\n  },\r\n\r\n  copy(glyph) {\r\n    return glyph ? deepmerge({}, glyph) : glyph;\r\n  },\r\n};\r\n"]},"metadata":{},"sourceType":"module"}