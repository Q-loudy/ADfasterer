{"ast":null,"code":"import { isDecimal, isFunction, isNumber } from \"@/utility\";\n/* eslint-disable no-empty-function */\n\nexport default {\n  name: \"EffectDisplay\",\n  props: {\n    config: {\n      type: Object,\n      required: false,\n      default: undefined\n    },\n    br: {\n      type: Boolean,\n      required: false\n    },\n    label: {\n      type: String,\n      default: \"Currently\",\n      required: false\n    },\n    ignoreCapped: {\n      type: Boolean,\n      required: false,\n      default: false\n    }\n  },\n\n  data() {\n    return {\n      isVisible: false,\n      effectValue: 0,\n      // Number.MAX_VALUE doesn't really matter here, but we need it because\n      // undefined values are not allowed for data properties\n      cap: Number.MAX_VALUE,\n      hasCap: false\n    };\n  },\n\n  computed: {\n    reachedCap() {\n      return this.hasCap && this.reachedCapFunction();\n    },\n\n    labelDisplay() {\n      if (this.config.noLabel) {\n        return \"\";\n      }\n\n      return `${this.reachedCap && !this.ignoreCapped ? \"Capped\" : this.label}: `;\n    },\n\n    effectDisplay() {\n      return this.formatEffect(this.reachedCap ? this.cap : this.effectValue);\n    }\n\n  },\n  watch: {\n    config: {\n      immediate: true,\n\n      handler(config) {\n        this.updateEffect = () => {};\n\n        this.updateCap = () => {};\n\n        const effect = config === null || config === void 0 ? void 0 : config.effect;\n        const formatEffect = config === null || config === void 0 ? void 0 : config.formatEffect;\n        this.isVisible = effect !== undefined && formatEffect !== undefined;\n        if (!this.isVisible) return;\n        this.formatEffect = formatEffect;\n\n        if (isNumber(effect)) {\n          this.effectValue = effect;\n          return;\n        }\n\n        if (isDecimal(effect)) {\n          this.effectValue = Decimal.fromDecimal(effect);\n          return;\n        }\n\n        if (!isFunction(effect)) {\n          throw new Error(`EffectDisplay config.effect has ` + ` unsupported type \"${typeof effect}\"`);\n        }\n\n        const value = effect();\n\n        if (isNumber(value)) {\n          this.effectValue = value;\n\n          this.updateEffect = () => this.effectValue = effect();\n        } else if (isDecimal(value)) {\n          this.effectValue = Decimal.fromDecimal(value);\n\n          this.updateEffect = () => this.effectValue.copyFrom(effect());\n        } else {\n          throw new Error(`EffectDisplay config.effect is a function which returns` + ` unsupported type \"${typeof effect}\"`);\n        }\n\n        let cap = config.cap;\n\n        if (config.reachedCap !== undefined) {\n          // If the config has a reachedCap, we assume its effect value calculation\n          // takes account of the cap itself, so we don't have to.\n          cap = () => this.effectValue;\n\n          this.reachedCapFunction = config.reachedCap;\n        }\n\n        if (cap !== undefined) {\n          if (config.reachedCap === undefined) {\n            this.reachedCapFunction = isNumber(value) ? () => this.effectValue >= this.cap : () => this.effectValue.gte(this.cap);\n          }\n\n          if (isNumber(cap)) {\n            this.cap = cap;\n            this.hasCap = true;\n            return;\n          }\n\n          if (isDecimal(cap)) {\n            this.cap = Decimal.fromDecimal(cap);\n            this.hasCap = true;\n            return;\n          }\n\n          if (isFunction(cap)) {\n            this.updateCap = () => {\n              this.cap = cap();\n              this.hasCap = this.cap !== undefined;\n            };\n\n            this.updateCap();\n            return;\n          }\n\n          throw new Error(`EffectDisplay config.cap is a function which returns` + ` unsupported type \"${typeof effect}\"`);\n        }\n      }\n\n    }\n  },\n\n  beforeCreate() {\n    this.updateEffect = () => {};\n\n    this.updateCap = () => {};\n  },\n\n  methods: {\n    update() {\n      this.updateEffect();\n      this.updateCap();\n    }\n\n  }\n};","map":{"version":3,"sources":["EffectDisplay.vue"],"names":[],"mappings":"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","sourcesContent":["<script>\r\nimport { isDecimal, isFunction, isNumber } from \"@/utility\";\r\n\r\n/* eslint-disable no-empty-function */\r\nexport default {\r\n  name: \"EffectDisplay\",\r\n  props: {\r\n    config: {\r\n      type: Object,\r\n      required: false,\r\n      default: undefined\r\n    },\r\n    br: {\r\n      type: Boolean,\r\n      required: false\r\n    },\r\n    label: {\r\n      type: String,\r\n      default: \"Currently\",\r\n      required: false\r\n    },\r\n    ignoreCapped: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: false\r\n    },\r\n  },\r\n  data() {\r\n    return {\r\n      isVisible: false,\r\n      effectValue: 0,\r\n      // Number.MAX_VALUE doesn't really matter here, but we need it because\r\n      // undefined values are not allowed for data properties\r\n      cap: Number.MAX_VALUE,\r\n      hasCap: false\r\n    };\r\n  },\r\n  computed: {\r\n    reachedCap() {\r\n      return this.hasCap && this.reachedCapFunction();\r\n    },\r\n    labelDisplay() {\r\n      if (this.config.noLabel) {\r\n        return \"\";\r\n      }\r\n      return `${this.reachedCap && !this.ignoreCapped ? \"Capped\" : this.label}: `;\r\n    },\r\n    effectDisplay() {\r\n      return this.formatEffect(this.reachedCap ? this.cap : this.effectValue);\r\n    }\r\n  },\r\n  watch: {\r\n    config: {\r\n      immediate: true,\r\n      handler(config) {\r\n        this.updateEffect = () => { };\r\n        this.updateCap = () => { };\r\n        const effect = config?.effect;\r\n        const formatEffect = config?.formatEffect;\r\n        this.isVisible = effect !== undefined && formatEffect !== undefined;\r\n        if (!this.isVisible) return;\r\n        this.formatEffect = formatEffect;\r\n\r\n        if (isNumber(effect)) {\r\n          this.effectValue = effect;\r\n          return;\r\n        }\r\n\r\n        if (isDecimal(effect)) {\r\n          this.effectValue = Decimal.fromDecimal(effect);\r\n          return;\r\n        }\r\n\r\n        if (!isFunction(effect)) {\r\n          throw new Error(`EffectDisplay config.effect has ` +\r\n            ` unsupported type \"${typeof effect}\"`);\r\n        }\r\n\r\n        const value = effect();\r\n\r\n        if (isNumber(value)) {\r\n          this.effectValue = value;\r\n          this.updateEffect = () => this.effectValue = effect();\r\n        } else if (isDecimal(value)) {\r\n          this.effectValue = Decimal.fromDecimal(value);\r\n          this.updateEffect = () => this.effectValue.copyFrom(effect());\r\n        } else {\r\n          throw new Error(`EffectDisplay config.effect is a function which returns` +\r\n            ` unsupported type \"${typeof effect}\"`);\r\n        }\r\n\r\n        let cap = config.cap;\r\n        if (config.reachedCap !== undefined) {\r\n          // If the config has a reachedCap, we assume its effect value calculation\r\n          // takes account of the cap itself, so we don't have to.\r\n          cap = () => this.effectValue;\r\n          this.reachedCapFunction = config.reachedCap;\r\n        }\r\n\r\n        if (cap !== undefined) {\r\n          if (config.reachedCap === undefined) {\r\n            this.reachedCapFunction = isNumber(value)\r\n              ? () => this.effectValue >= this.cap\r\n              : () => this.effectValue.gte(this.cap);\r\n          }\r\n\r\n          if (isNumber(cap)) {\r\n            this.cap = cap;\r\n            this.hasCap = true;\r\n            return;\r\n          }\r\n\r\n          if (isDecimal(cap)) {\r\n            this.cap = Decimal.fromDecimal(cap);\r\n            this.hasCap = true;\r\n            return;\r\n          }\r\n\r\n          if (isFunction(cap)) {\r\n            this.updateCap = () => {\r\n              this.cap = cap();\r\n              this.hasCap = this.cap !== undefined;\r\n            };\r\n            this.updateCap();\r\n            return;\r\n          }\r\n\r\n          throw new Error(`EffectDisplay config.cap is a function which returns` +\r\n            ` unsupported type \"${typeof effect}\"`);\r\n        }\r\n      }\r\n    },\r\n  },\r\n  beforeCreate() {\r\n    this.updateEffect = () => { };\r\n    this.updateCap = () => { };\r\n  },\r\n  methods: {\r\n    update() {\r\n      this.updateEffect();\r\n      this.updateCap();\r\n    }\r\n  }\r\n};\r\n</script>\r\n\r\n<template>\r\n  <span v-if=\"isVisible && effectDisplay !== undefined\">\r\n    <br v-if=\"br\">\r\n    {{ labelDisplay }}{{ effectDisplay }}\r\n  </span>\r\n</template>\r\n"],"sourceRoot":"src/components"},"metadata":{},"sourceType":"module"}