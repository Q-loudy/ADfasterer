{"ast":null,"code":"import \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.string.replace-all.js\";\nimport { validateLine } from \"@/core/automator\";\nexport default {\n  name: \"AutomatorBlockSingleInput\",\n  props: {\n    constant: {\n      type: String,\n      required: false,\n      default: \"\"\n    },\n    block: {\n      type: Object,\n      required: true\n    },\n    blockTarget: {\n      type: String,\n      required: false,\n      default: \"\"\n    },\n    updateFunction: {\n      type: Function,\n      required: true\n    },\n    initialSelection: {\n      type: String,\n      required: false,\n      default: \"\"\n    },\n    patterns: {\n      type: Array,\n      required: false,\n      default: () => []\n    },\n    recursive: {\n      type: Boolean,\n      required: false,\n      default: false\n    },\n    currentPath: {\n      type: String,\n      required: false,\n      default: \"\"\n    }\n  },\n\n  data() {\n    return {\n      b: {},\n      suppressTooltip: false,\n      errors: [],\n      hasError: false,\n      isTextInput: false,\n      dropdownOptions: [],\n      dropdownSelection: \"\",\n      textContents: \"\",\n      pathRef: {},\n      currentNodeOnPath: \"\",\n      unknownNext: false,\n      nextNodeCount: 0,\n      lineNumber: 0,\n      // This is tracked here because switching scripts causes events to be fired in a weird order, often seemingly\n      // starting the creation of the new component before the UI's visible script ID is properly updated\n      scriptID: 0\n    };\n  },\n\n  computed: {\n    displayedConstant() {\n      if (this.constant) {\n        // \\uE010 is :blob:\n        return this.constant === \"BLOB\" ? \"\\uE010\" : this.constant;\n      }\n\n      return this.dropdownOptions.length === 1 && !this.isBoolTarget && !this.isTextInput ? this.dropdownOptions[0] : \"\";\n    },\n\n    isBoolTarget() {\n      return this.blockTarget === \"nowait\" || this.blockTarget === \"respec\";\n    },\n\n    nextInputKey() {\n      return this.block.targets[this.currentPath.length + 1];\n    },\n\n    nextInputValue() {\n      const targetList = this.block.targets;\n      const value = targetList ? this.block[this.nextInputKey] : \"\"; // Sometimes the target might be a Number or undefined but the prop type-checks for it to be a String\n\n      return value ? `${value}` : \"\";\n    },\n\n    // Most of the time the input is just a number or constant but these ones will typically lead to longer\n    // phrases in String format, so we want to give some extra room\n    hasLongTextInput() {\n      return this.block.cmd === \"NOTIFY\" || this.block.cmd === \"COMMENT\";\n    }\n\n  },\n\n  created() {\n    this.scriptID = player.reality.automator.state.editorScript;\n    this.b = this.block;\n    this.lineNumber = BlockAutomator.lineNumber(BlockAutomator._idArray.indexOf(this.block.id) + 1);\n    BlockAutomator.updateIdArray();\n    if (this.constant) return;\n\n    if (this.isBoolTarget) {\n      this.dropdownOptions = [this.blockTarget.toUpperCase()];\n      this.dropdownSelection = this.block[this.blockTarget] ? this.blockTarget.toUpperCase() : \"\";\n      return;\n    } // This is used for sequences of inputs, which are traversed by recursion\n\n\n    if (this.recursive) {\n      const availableOptions = this.patterns.filter(s => s.startsWith(this.currentPath) && s.length > this.currentPath.length).map(s => s.charAt(this.currentPath.length));\n\n      for (const node of availableOptions) {\n        if (this.pathRef[node]) continue;\n        const entries = this.block[node];\n        this.pathRef[node] = entries;\n        this.dropdownOptions.push(...entries);\n      }\n\n      this.calculatePath();\n    } // Set the initial display state properly\n\n\n    if (this.dropdownOptions.includes(this.initialSelection)) {\n      this.dropdownSelection = this.initialSelection;\n    } else if (this.initialSelection) {\n      this.isTextInput = true;\n      this.textContents = this.initialSelection;\n    } // Special handling for text-input-only fields, which will have single-element array specifications\n\n\n    if (this.dropdownOptions.length === 1 && this.dropdownOptions[0].startsWith(\"*\")) {\n      this.isTextInput = true;\n      this.textContents = this.initialSelection;\n    } // This forces errors to show up immediately when the block is created instead of requiring user interaction, but\n    // we also want to hide tooltips because this causes poor UI if there are a lot of nearby errors upon conversion\n\n\n    this.recalculateErrorCount();\n    this.suppressTooltip = true; // Force the editor to parse the script again after all the values have been filled in above, or else it'll create\n    // blocks which always have errors due to undefined props\n\n    BlockAutomator.parseTextFromBlocks();\n  },\n\n  // Destroying single inputs need to be handled carefully because there are three situations under which they will\n  // be removed, and they all require different behavior:\n  // * The player changes to the text editor or switches tabs/scripts, wiping the entire script (we do nothing here)\n  // * Blocks are dragged and reordered, causing a parent component to key-swap and force a rerender on this\n  //   component - in that case we need to remove the errors corresponding to the old line number\n  // * An earlier input in the command chain makes this input unnecessary (eg. changing \"unlock ec 8\" to\n  //   \"unlock dilation\" makes the 8 unnecessary) - this case is handled when the parent block calls changeBlock(),\n  //   but we still need to verify error count and parse the script again since we avoid doing that within\n  //   changeBlock() for performance reasons\n  destroyed() {\n    if (player.reality.automator.type === AUTOMATOR_TYPE.TEXT || Tabs.current._currentSubtab.key !== \"automator\" || this.scriptID !== player.reality.automator.state.editorScript) {\n      return;\n    }\n\n    this.recalculateErrorCount();\n    const newLineNum = BlockAutomator.lineNumber(BlockAutomator._idArray.indexOf(this.block.id) + 1);\n\n    if (this.lineNumber !== newLineNum) {\n      const newErrors = [];\n\n      for (const error of AutomatorData.cachedErrors) {\n        if (error.startLine !== this.lineNumber) newErrors.push(error);\n      }\n\n      newErrors.sort((a, b) => a.startLine - b.startLine);\n      AutomatorData.cachedErrors = newErrors;\n      return;\n    }\n\n    this.recalculateErrorCount();\n    BlockAutomator.parseTextFromBlocks();\n  },\n\n  methods: {\n    update() {\n      this.errors = AutomatorData.cachedErrors;\n      this.hasError = this.errors.some(e => e.startLine === this.lineNumber);\n      if (this.dropdownSelection.startsWith(\"*\")) this.isTextInput = true;\n      this.calculatePath();\n    },\n\n    calculatePath() {\n      this.currentNodeOnPath = \" \";\n\n      for (const node of Object.keys(this.pathRef)) {\n        const isValidText = this.pathRef[node].some(o => o.startsWith(\"*\")) && this.isTextInput;\n\n        if (this.pathRef[node].includes(this.dropdownSelection) || isValidText) {\n          this.currentNodeOnPath = node;\n        }\n      }\n\n      const fullPath = this.currentPath + this.currentNodeOnPath;\n      this.nextNodeCount = this.patterns.filter(p => p.length > fullPath.length && p.startsWith(fullPath)).length;\n      this.unknownNext = this.nextNodeCount > 1 || this.dropdownSelection === \"\" && !this.isTextInput;\n    },\n\n    validateInput() {\n      let validator, lines;\n\n      if (this.b.nest) {\n        const clone = Object.assign({}, this.b);\n        clone.nest = [];\n        lines = BlockAutomator.parseLines([clone]);\n        validator = validateLine(lines.join(\"\\n\"));\n      } else {\n        lines = BlockAutomator.parseLines([this.b]);\n        validator = validateLine(lines[0]);\n      } // Yes, the odd structure of this check is intentional. Something odd happens within parseLines under certain\n      // conditions which seem hard to pin down, which causes this evaluate to an array with the string \"undefined\"\n      // being its only element. These cases all seem to be false positives\n\n\n      if (lines[0] === \"undefined\") return; // We're actually validating only this single line, so we reconstruct the error list by removing everything on\n      // this line and adding anything new that was found. We only take the first error from this line (if there are\n      // any) because multiple errors on the same line are generally redundant, and sometimes the parser hiccups and\n      // duplicates errors onto the last line of the script (which we explicitly ignore)\n\n      const newErrors = [];\n\n      const lastLine = BlockAutomator._idArray.filter(id => id).length;\n\n      for (const error of AutomatorData.cachedErrors) {\n        if (error.startLine !== this.lineNumber && error.startLine < lastLine) {\n          newErrors.push(error);\n        }\n      }\n\n      if (validator.errors.length > 0) {\n        const error = validator.errors[0];\n        error.startLine = this.lineNumber;\n        newErrors.push(error);\n      }\n\n      newErrors.sort((a, b) => a.startLine - b.startLine);\n      AutomatorData.cachedErrors = newErrors;\n    },\n\n    handleFocus(focusState) {\n      this.suppressTooltip = !focusState;\n      this.changeBlock();\n    },\n\n    changeBlock() {\n      this.updateFunction(this.block, this.block.id);\n\n      if (this.blockTarget) {\n        let newValue;\n        if (this.isBoolTarget) newValue = this.dropdownSelection !== \"\";else if (this.isTextInput) newValue = this.textContents;else newValue = this.dropdownSelection; // eslint-disable-next-line vue/no-mutating-props\n\n        this.block[this.blockTarget] = newValue; // Sometimes changing a block value causes later blocks on the line to no longer exist due to a different\n        // command structure; we wipe the props related to those blocks here so that they don't cause parsing errors\n\n        this.calculatePath();\n\n        if (this.nextNodeCount === 0 && !this.isBoolTarget) {\n          const currIndex = this.block.targets.indexOf(this.blockTarget);\n\n          for (let toClear = currIndex + 1; toClear < this.block.targets.length; toClear++) {\n            // eslint-disable-next-line vue/no-mutating-props\n            this.block[this.block.targets[toClear]] = undefined;\n          }\n        }\n      }\n\n      this.recalculateErrorCount();\n    },\n\n    // This gets called whenever blocks are changed, but we also need to halt execution if the currently visible script\n    // is also the one being run\n    recalculateErrorCount() {\n      BlockAutomator.parseTextFromBlocks(this.scriptID);\n      this.validateInput();\n\n      if (AutomatorBackend.currentEditingScript.id === AutomatorBackend.currentRunningScript.id) {\n        AutomatorBackend.stop();\n      }\n    },\n\n    errorTooltip() {\n      if (!this.hasError || this.suppressTooltip) return undefined; // We want to keep the verbose error info for the error panel, but we need to shorten it for the tooltips here\n      // The problematic errors all seem to have the same format, which we can explicitly modify\n\n      let errorInfo = this.errors.find(e => e.startLine === this.lineNumber).info;\n      errorInfo = errorInfo.replaceAll(\"\\n\", \"\").replace(/Expecting: one of the[s\\u017F]e po[s\\u017F][s\\u017F]ible To[k\\u212A]en [s\\u017F]equence[s\\u017F]:(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*but found: ((?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*)/i, \"Unexpected input format: $1\");\n      return {\n        content: `<div class=\"c-block-automator-error\">\n          <div>${errorInfo}</div>\n        </div>`,\n        html: true,\n        trigger: \"manual\",\n        show: true,\n        classes: [\"c-block-automator-error-container\", \"general-tooltip\"]\n      };\n    },\n\n    textInputClassObject() {\n      return {\n        \"o-automator-block-input\": true,\n        \"o-long-text-input\": this.hasLongTextInput,\n        \"l-error-textbox\": this.hasError,\n        \"c-automator-input-required\": !this.hasError\n      };\n    },\n\n    dropdownClassObject() {\n      return {\n        \"o-automator-block-input\": true,\n        \"c-automator-input-required\": !this.isBoolTarget,\n        \"c-automator-input-optional\": this.isBoolTarget,\n        \"l-error-textbox\": this.hasError && !this.isBoolTarget && this.dropdownSelection === \"\"\n      };\n    },\n\n    revertToDropdown() {\n      this.isTextInput = false;\n      this.dropdownSelection = \"\";\n      this.textContents = \"\";\n    }\n\n  }\n};","map":{"version":3,"sources":["AutomatorBlockSingleInput.vue"],"names":[],"mappings":"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","sourcesContent":["<script>\r\nimport { validateLine } from \"@/core/automator\";\r\n\r\nexport default {\r\n  name: \"AutomatorBlockSingleInput\",\r\n  props: {\r\n    constant: {\r\n      type: String,\r\n      required: false,\r\n      default: \"\"\r\n    },\r\n    block: {\r\n      type: Object,\r\n      required: true\r\n    },\r\n    blockTarget: {\r\n      type: String,\r\n      required: false,\r\n      default: \"\"\r\n    },\r\n    updateFunction: {\r\n      type: Function,\r\n      required: true\r\n    },\r\n    initialSelection: {\r\n      type: String,\r\n      required: false,\r\n      default: \"\"\r\n    },\r\n    patterns: {\r\n      type: Array,\r\n      required: false,\r\n      default: () => []\r\n    },\r\n    recursive: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: false\r\n    },\r\n    currentPath: {\r\n      type: String,\r\n      required: false,\r\n      default: \"\"\r\n    }\r\n  },\r\n  data() {\r\n    return {\r\n      b: {},\r\n      suppressTooltip: false,\r\n      errors: [],\r\n      hasError: false,\r\n\r\n      isTextInput: false,\r\n      dropdownOptions: [],\r\n      dropdownSelection: \"\",\r\n      textContents: \"\",\r\n      pathRef: {},\r\n      currentNodeOnPath: \"\",\r\n      unknownNext: false,\r\n      nextNodeCount: 0,\r\n      lineNumber: 0,\r\n      // This is tracked here because switching scripts causes events to be fired in a weird order, often seemingly\r\n      // starting the creation of the new component before the UI's visible script ID is properly updated\r\n      scriptID: 0,\r\n    };\r\n  },\r\n  computed: {\r\n    displayedConstant() {\r\n      if (this.constant) {\r\n        // \\uE010 is :blob:\r\n        return this.constant === \"BLOB\" ? \"\\uE010\" : this.constant;\r\n      }\r\n      return (this.dropdownOptions.length === 1 && !this.isBoolTarget && !this.isTextInput)\r\n        ? this.dropdownOptions[0]\r\n        : \"\";\r\n    },\r\n    isBoolTarget() {\r\n      return this.blockTarget === \"nowait\" || this.blockTarget === \"respec\";\r\n    },\r\n    nextInputKey() {\r\n      return this.block.targets[this.currentPath.length + 1];\r\n    },\r\n    nextInputValue() {\r\n      const targetList = this.block.targets;\r\n      const value = targetList ? this.block[this.nextInputKey] : \"\";\r\n      // Sometimes the target might be a Number or undefined but the prop type-checks for it to be a String\r\n      return value ? `${value}` : \"\";\r\n    },\r\n    // Most of the time the input is just a number or constant but these ones will typically lead to longer\r\n    // phrases in String format, so we want to give some extra room\r\n    hasLongTextInput() {\r\n      return this.block.cmd === \"NOTIFY\" || this.block.cmd === \"COMMENT\";\r\n    }\r\n  },\r\n  created() {\r\n    this.scriptID = player.reality.automator.state.editorScript;\r\n    this.b = this.block;\r\n    this.lineNumber = BlockAutomator.lineNumber(BlockAutomator._idArray.indexOf(this.block.id) + 1);\r\n    BlockAutomator.updateIdArray();\r\n    if (this.constant) return;\r\n    if (this.isBoolTarget) {\r\n      this.dropdownOptions = [this.blockTarget.toUpperCase()];\r\n      this.dropdownSelection = this.block[this.blockTarget] ? this.blockTarget.toUpperCase() : \"\";\r\n      return;\r\n    }\r\n\r\n    // This is used for sequences of inputs, which are traversed by recursion\r\n    if (this.recursive) {\r\n      const availableOptions = this.patterns\r\n        .filter(s => s.startsWith(this.currentPath) && s.length > this.currentPath.length)\r\n        .map(s => s.charAt(this.currentPath.length));\r\n      for (const node of availableOptions) {\r\n        if (this.pathRef[node]) continue;\r\n        const entries = this.block[node];\r\n        this.pathRef[node] = entries;\r\n        this.dropdownOptions.push(...entries);\r\n      }\r\n      this.calculatePath();\r\n    }\r\n\r\n    // Set the initial display state properly\r\n    if (this.dropdownOptions.includes(this.initialSelection)) {\r\n      this.dropdownSelection = this.initialSelection;\r\n    } else if (this.initialSelection) {\r\n      this.isTextInput = true;\r\n      this.textContents = this.initialSelection;\r\n    }\r\n\r\n    // Special handling for text-input-only fields, which will have single-element array specifications\r\n    if (this.dropdownOptions.length === 1 && this.dropdownOptions[0].startsWith(\"*\")) {\r\n      this.isTextInput = true;\r\n      this.textContents = this.initialSelection;\r\n    }\r\n\r\n    // This forces errors to show up immediately when the block is created instead of requiring user interaction, but\r\n    // we also want to hide tooltips because this causes poor UI if there are a lot of nearby errors upon conversion\r\n    this.recalculateErrorCount();\r\n    this.suppressTooltip = true;\r\n\r\n    // Force the editor to parse the script again after all the values have been filled in above, or else it'll create\r\n    // blocks which always have errors due to undefined props\r\n    BlockAutomator.parseTextFromBlocks();\r\n  },\r\n  // Destroying single inputs need to be handled carefully because there are three situations under which they will\r\n  // be removed, and they all require different behavior:\r\n  // * The player changes to the text editor or switches tabs/scripts, wiping the entire script (we do nothing here)\r\n  // * Blocks are dragged and reordered, causing a parent component to key-swap and force a rerender on this\r\n  //   component - in that case we need to remove the errors corresponding to the old line number\r\n  // * An earlier input in the command chain makes this input unnecessary (eg. changing \"unlock ec 8\" to\r\n  //   \"unlock dilation\" makes the 8 unnecessary) - this case is handled when the parent block calls changeBlock(),\r\n  //   but we still need to verify error count and parse the script again since we avoid doing that within\r\n  //   changeBlock() for performance reasons\r\n  destroyed() {\r\n    if (player.reality.automator.type === AUTOMATOR_TYPE.TEXT || Tabs.current._currentSubtab.key !== \"automator\" ||\r\n      this.scriptID !== player.reality.automator.state.editorScript) {\r\n      return;\r\n    }\r\n\r\n    this.recalculateErrorCount();\r\n    const newLineNum = BlockAutomator.lineNumber(BlockAutomator._idArray.indexOf(this.block.id) + 1);\r\n    if (this.lineNumber !== newLineNum) {\r\n      const newErrors = [];\r\n      for (const error of AutomatorData.cachedErrors) {\r\n        if (error.startLine !== this.lineNumber) newErrors.push(error);\r\n      }\r\n      newErrors.sort((a, b) => a.startLine - b.startLine);\r\n      AutomatorData.cachedErrors = newErrors;\r\n      return;\r\n    }\r\n\r\n    this.recalculateErrorCount();\r\n    BlockAutomator.parseTextFromBlocks();\r\n  },\r\n  methods: {\r\n    update() {\r\n      this.errors = AutomatorData.cachedErrors;\r\n      this.hasError = this.errors.some(e => e.startLine === this.lineNumber);\r\n      if (this.dropdownSelection.startsWith(\"*\")) this.isTextInput = true;\r\n      this.calculatePath();\r\n    },\r\n    calculatePath() {\r\n      this.currentNodeOnPath = \" \";\r\n      for (const node of Object.keys(this.pathRef)) {\r\n        const isValidText = this.pathRef[node].some(o => o.startsWith(\"*\")) && this.isTextInput;\r\n        if (this.pathRef[node].includes(this.dropdownSelection) || isValidText) {\r\n          this.currentNodeOnPath = node;\r\n        }\r\n      }\r\n      const fullPath = this.currentPath + this.currentNodeOnPath;\r\n      this.nextNodeCount = this.patterns.filter(p => p.length > fullPath.length && p.startsWith(fullPath)).length;\r\n      this.unknownNext = this.nextNodeCount > 1 || (this.dropdownSelection === \"\" && !this.isTextInput);\r\n    },\r\n    validateInput() {\r\n      let validator, lines;\r\n      if (this.b.nest) {\r\n        const clone = Object.assign({}, this.b);\r\n        clone.nest = [];\r\n        lines = BlockAutomator.parseLines([clone]);\r\n        validator = validateLine(lines.join(\"\\n\"));\r\n      } else {\r\n        lines = BlockAutomator.parseLines([this.b]);\r\n        validator = validateLine(lines[0]);\r\n      }\r\n\r\n      // Yes, the odd structure of this check is intentional. Something odd happens within parseLines under certain\r\n      // conditions which seem hard to pin down, which causes this evaluate to an array with the string \"undefined\"\r\n      // being its only element. These cases all seem to be false positives\r\n      if (lines[0] === \"undefined\") return;\r\n\r\n      // We're actually validating only this single line, so we reconstruct the error list by removing everything on\r\n      // this line and adding anything new that was found. We only take the first error from this line (if there are\r\n      // any) because multiple errors on the same line are generally redundant, and sometimes the parser hiccups and\r\n      // duplicates errors onto the last line of the script (which we explicitly ignore)\r\n      const newErrors = [];\r\n      const lastLine = BlockAutomator._idArray.filter(id => id).length;\r\n      for (const error of AutomatorData.cachedErrors) {\r\n        if (error.startLine !== this.lineNumber && error.startLine < lastLine) {\r\n          newErrors.push(error);\r\n        }\r\n      }\r\n      if (validator.errors.length > 0) {\r\n        const error = validator.errors[0];\r\n        error.startLine = this.lineNumber;\r\n        newErrors.push(error);\r\n      }\r\n      newErrors.sort((a, b) => a.startLine - b.startLine);\r\n      AutomatorData.cachedErrors = newErrors;\r\n    },\r\n    handleFocus(focusState) {\r\n      this.suppressTooltip = !focusState;\r\n      this.changeBlock();\r\n    },\r\n    changeBlock() {\r\n      this.updateFunction(this.block, this.block.id);\r\n      if (this.blockTarget) {\r\n        let newValue;\r\n        if (this.isBoolTarget) newValue = this.dropdownSelection !== \"\";\r\n        else if (this.isTextInput) newValue = this.textContents;\r\n        else newValue = this.dropdownSelection;\r\n\r\n        // eslint-disable-next-line vue/no-mutating-props\r\n        this.block[this.blockTarget] = newValue;\r\n\r\n        // Sometimes changing a block value causes later blocks on the line to no longer exist due to a different\r\n        // command structure; we wipe the props related to those blocks here so that they don't cause parsing errors\r\n        this.calculatePath();\r\n        if (this.nextNodeCount === 0 && !this.isBoolTarget) {\r\n          const currIndex = this.block.targets.indexOf(this.blockTarget);\r\n          for (let toClear = currIndex + 1; toClear < this.block.targets.length; toClear++) {\r\n            // eslint-disable-next-line vue/no-mutating-props\r\n            this.block[this.block.targets[toClear]] = undefined;\r\n          }\r\n        }\r\n      }\r\n      this.recalculateErrorCount();\r\n    },\r\n    // This gets called whenever blocks are changed, but we also need to halt execution if the currently visible script\r\n    // is also the one being run\r\n    recalculateErrorCount() {\r\n      BlockAutomator.parseTextFromBlocks(this.scriptID);\r\n      this.validateInput();\r\n      if (AutomatorBackend.currentEditingScript.id === AutomatorBackend.currentRunningScript.id) {\r\n        AutomatorBackend.stop();\r\n      }\r\n    },\r\n    errorTooltip() {\r\n      if (!this.hasError || this.suppressTooltip) return undefined;\r\n\r\n      // We want to keep the verbose error info for the error panel, but we need to shorten it for the tooltips here\r\n      // The problematic errors all seem to have the same format, which we can explicitly modify\r\n      let errorInfo = this.errors.find(e => e.startLine === this.lineNumber).info;\r\n      errorInfo = errorInfo\r\n        .replaceAll(\"\\n\", \"\")\r\n        .replace(/Expecting: one of these possible Token sequences:.*but found: (.*)/ui, \"Unexpected input format: $1\");\r\n      return {\r\n        content:\r\n          `<div class=\"c-block-automator-error\">\r\n          <div>${errorInfo}</div>\r\n        </div>`,\r\n        html: true,\r\n        trigger: \"manual\",\r\n        show: true,\r\n        classes: [\"c-block-automator-error-container\", \"general-tooltip\"]\r\n      };\r\n    },\r\n    textInputClassObject() {\r\n      return {\r\n        \"o-automator-block-input\": true,\r\n        \"o-long-text-input\": this.hasLongTextInput,\r\n        \"l-error-textbox\": this.hasError,\r\n        \"c-automator-input-required\": !this.hasError,\r\n      };\r\n    },\r\n    dropdownClassObject() {\r\n      return {\r\n        \"o-automator-block-input\": true,\r\n        \"c-automator-input-required\": !this.isBoolTarget,\r\n        \"c-automator-input-optional\": this.isBoolTarget,\r\n        \"l-error-textbox\": this.hasError && !this.isBoolTarget && this.dropdownSelection === \"\",\r\n      };\r\n    },\r\n    revertToDropdown() {\r\n      this.isTextInput = false;\r\n      this.dropdownSelection = \"\";\r\n      this.textContents = \"\";\r\n    }\r\n  }\r\n};\r\n</script>\r\n\r\n<template>\r\n  <div class=\"c-automator-single-block\">\r\n    <div\r\n      v-if=\"displayedConstant\"\r\n      class=\"c-automator-single-block o-automator-command c-automator-constant-block\"\r\n      :class=\"{ 'l-blob' : constant === 'BLOB' }\"\r\n    >\r\n      {{ displayedConstant }}\r\n    </div>\r\n    <div\r\n      v-else-if=\"isTextInput\"\r\n      class=\"c-automator-text-input-container\"\r\n    >\r\n      <input\r\n        v-model=\"textContents\"\r\n        v-tooltip=\"errorTooltip()\"\r\n        :class=\"textInputClassObject()\"\r\n        @keyup=\"changeBlock()\"\r\n        @focusin=\"handleFocus(true)\"\r\n        @focusout=\"handleFocus(false)\"\r\n      >\r\n      <div\r\n        v-if=\"dropdownOptions.length > 1\"\r\n        class=\"c-automator-close-text-input fa-solid fa-circle-xmark\"\r\n        @click=\"revertToDropdown\"\r\n      />\r\n    </div>\r\n    <select\r\n      v-else\r\n      v-model=\"dropdownSelection\"\r\n      :class=\"dropdownClassObject()\"\r\n      @change=\"changeBlock()\"\r\n    >\r\n      <option\r\n        v-for=\"target in ['', ...dropdownOptions]\"\r\n        :key=\"target\"\r\n        :value=\"target\"\r\n      >\r\n        {{ target }}\r\n      </option>\r\n    </select>\r\n    <AutomatorBlockSingleInput\r\n      v-if=\"recursive && nextNodeCount > 0\"\r\n      :key=\"currentNodeOnPath\"\r\n      :constant=\"unknownNext ? '...' : ''\"\r\n      :block=\"block\"\r\n      :block-target=\"nextInputKey\"\r\n      :patterns=\"patterns\"\r\n      :initial-selection=\"nextInputValue\"\r\n      :update-function=\"updateFunction\"\r\n      :recursive=\"true\"\r\n      :current-path=\"currentPath + currentNodeOnPath\"\r\n    />\r\n  </div>\r\n</template>\r\n\r\n<style scoped>\r\n.c-automator-single-block {\r\n  display: flex;\r\n  flex-direction: row;\r\n  justify-content: center;\r\n  align-items: center;\r\n  height: 2.8rem;\r\n  white-space: nowrap;\r\n}\r\n\r\n.c-automator-constant-block {\r\n  background: var(--color-blockmator-block-command);\r\n  color: var(--color-blockmator-editor-background);\r\n}\r\n\r\n.c-automator-text-input-container {\r\n  position: relative;\r\n}\r\n\r\n.o-long-text-input {\r\n  width: 30rem;\r\n}\r\n\r\n.c-automator-close-text-input {\r\n  position: absolute;\r\n  color: var(--color-automator-error-outline);\r\n  font-size: 1.5rem;\r\n  z-index: 1;\r\n  right: 0.8rem;\r\n  top: 0.6rem;\r\n}\r\n\r\n.l-error-textbox {\r\n  background: var(--color-automator-error-background);\r\n  color: yellow;\r\n}\r\n\r\n.l-blob {\r\n  font-size: 1.8rem;\r\n  background: black;\r\n  color: #fc2;\r\n}\r\n</style>\r\n"],"sourceRoot":"src/components/tabs/automator"},"metadata":{},"sourceType":"module"}