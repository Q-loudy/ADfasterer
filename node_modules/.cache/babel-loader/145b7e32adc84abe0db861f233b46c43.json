{"ast":null,"code":"import \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport * as ADNotations from \"@antimatter-dimensions/notations\";\nimport { DEV } from \"@/env\";\nimport { devMigrations } from \"./dev-migrations\";\nimport { migrations } from \"./migrations\";\nimport { deepmergeAll } from \"@/utility/deepmerge\";\nexport const BACKUP_SLOT_TYPE = {\n  ONLINE: 0,\n  OFFLINE: 1,\n  RESERVE: 2\n}; // Note: interval is in seconds, and only the first RESERVE slot is ever used. Having intervalStr as a redundant\n// prop is necessary because using our TimeSpan formatting functions produces undesirable strings like \"1.00 minutes\"\n\nexport const AutoBackupSlots = [{\n  id: 1,\n  type: BACKUP_SLOT_TYPE.ONLINE,\n  intervalStr: () => `${formatInt(1)} minute`,\n  interval: 60\n}, {\n  id: 2,\n  type: BACKUP_SLOT_TYPE.ONLINE,\n  intervalStr: () => `${formatInt(5)} minutes`,\n  interval: 5 * 60\n}, {\n  id: 3,\n  type: BACKUP_SLOT_TYPE.ONLINE,\n  intervalStr: () => `${formatInt(20)} minutes`,\n  interval: 20 * 60\n}, {\n  id: 4,\n  type: BACKUP_SLOT_TYPE.ONLINE,\n  intervalStr: () => `${formatInt(1)} hour`,\n  interval: 3600\n}, {\n  id: 5,\n  type: BACKUP_SLOT_TYPE.OFFLINE,\n  intervalStr: () => `${formatInt(10)} minutes`,\n  interval: 10 * 60\n}, {\n  id: 6,\n  type: BACKUP_SLOT_TYPE.OFFLINE,\n  intervalStr: () => `${formatInt(1)} hour`,\n  interval: 3600\n}, {\n  id: 7,\n  type: BACKUP_SLOT_TYPE.OFFLINE,\n  intervalStr: () => `${formatInt(5)} hours`,\n  interval: 5 * 3600\n}, {\n  id: 8,\n  type: BACKUP_SLOT_TYPE.RESERVE\n}];\nexport const GameStorage = {\n  currentSlot: 0,\n  saves: {\n    0: undefined,\n    1: undefined,\n    2: undefined\n  },\n  saved: 0,\n  lastSaveTime: Date.now(),\n  lastCloudSave: Date.now(),\n  offlineEnabled: undefined,\n  offlineTicks: undefined,\n  lastUpdateOnLoad: 0,\n  lastBackupTimes: [],\n  oldBackupTimer: 0,\n  ignoreBackupTimer: true,\n\n  // Limit offline tick count using two conditions:\n  // - Ticks should never be shorter than 33ms (this would allow offline to exploit tick microstructure)\n  // - Count should be limited to 1e6 (the options UI doesn't allow for this to be set above this value)\n  maxOfflineTicks(simulatedMs, defaultTicks = this.offlineTicks) {\n    const tickLimit = Math.clampMax(Math.floor(simulatedMs / 33), 1e6);\n    return Math.clampMax(defaultTicks, tickLimit);\n  },\n\n  get localStorageKey() {\n    return DEV ? \"dimensionTestSave\" : \"dimensionSave\";\n  },\n\n  backupDataKey(saveSlot, backupSlot) {\n    return DEV ? `backupTestSave-${saveSlot}-${backupSlot}` : `backupSave-${saveSlot}-${backupSlot}`;\n  },\n\n  backupTimeKey(saveSlot) {\n    return DEV ? `backupTestTimes-${saveSlot}` : `backupTimes-${saveSlot}`;\n  },\n\n  load() {\n    const save = localStorage.getItem(this.localStorageKey);\n    const root = GameSaveSerializer.deserialize(save);\n    this.loadRoot(root);\n    Achievements.updateSteamStatus();\n  },\n\n  loadRoot(root) {\n    if (root === undefined) {\n      this.currentSlot = 0;\n      this.loadPlayerObject(Player.defaultStart);\n      return;\n    }\n\n    if (root.saves === undefined) {\n      // Migrate old format\n      this.saves = {\n        0: root,\n        1: undefined,\n        2: undefined\n      };\n      this.currentSlot = 0;\n      this.loadPlayerObject(root);\n      this.loadBackupTimes();\n      this.backupOfflineSlots();\n      this.save(true);\n      return;\n    }\n\n    this.saves = root.saves;\n    this.currentSlot = root.current;\n    this.loadPlayerObject(this.saves[this.currentSlot]);\n    this.loadBackupTimes();\n    this.backupOfflineSlots();\n  },\n\n  loadSlot(slot) {\n    var _this$saves$slot;\n\n    this.currentSlot = slot; // Save current slot to make sure no changes are lost\n\n    this.save(true);\n    this.loadPlayerObject((_this$saves$slot = this.saves[slot]) !== null && _this$saves$slot !== void 0 ? _this$saves$slot : Player.defaultStart);\n    this.loadBackupTimes();\n    this.backupOfflineSlots();\n    Tabs.all.find(t => t.id === player.options.lastOpenTab).show(false);\n    Modal.hideAll();\n    Cloud.resetTempState();\n    GameUI.notify.info(\"Game loaded\");\n    Achievements.updateSteamStatus();\n  },\n\n  import(saveData) {\n    var _player$speedrun;\n\n    if (tryImportSecret(saveData) || Theme.tryUnlock(saveData)) {\n      return;\n    }\n\n    const newPlayer = GameSaveSerializer.deserialize(saveData);\n\n    if (this.checkPlayerObject(newPlayer) !== \"\") {\n      Modal.message.show(\"Could not load the save (format unrecognized or invalid).\");\n      return;\n    }\n\n    this.oldBackupTimer = player.backupTimer;\n    Modal.hideAll();\n    Quote.clearAll();\n    AutomatorBackend.clearEditor();\n    this.loadPlayerObject(newPlayer);\n    GlyphAppearanceHandler.clearInvalidCosmetics();\n    if ((_player$speedrun = player.speedrun) !== null && _player$speedrun !== void 0 && _player$speedrun.isActive) Speedrun.setSegmented(true);\n    this.save(true);\n    Cloud.resetTempState();\n    this.resetBackupTimer(); // This is to fix a very specific exploit: When the game is ending, some tabs get hidden\n    // The options tab is the first one of those, which makes the player redirect to the Pelle tab\n    // You can doom your reality even if you haven't unlocked infinity yet if you import while the Pelle tab\n    // is showing\n\n    Tab.options.subtabs[0].show();\n    GameUI.notify.info(\"Game imported\");\n    Achievements.updateSteamStatus();\n  },\n\n  importAsFile() {\n    if (GameEnd.creditsEverClosed) return;\n    const reader = new FileReader();\n    const text = reader.readAsText(file);\n    this.import(text);\n  },\n\n  overwriteSlot(slot, saveData) {\n    this.saves[slot] = saveData;\n\n    if (slot === this.currentSlot) {\n      this.loadPlayerObject(saveData);\n    }\n\n    this.save(true);\n  },\n\n  // Some minimal save verification; if the save is valid then this returns an empty string, otherwise it returns a\n  // a string roughly stating what's wrong with the save. In order for importing to work properly, this must return\n  // an empty string.\n  checkPlayerObject(save) {\n    // Sometimes save is the output of GameSaveSerializer.deserialize, and if that function fails then it will result\n    // in the input parameter here being undefined\n    if (save === undefined || save === null) return \"Save decoding failed (invalid format)\"; // Right now all we do is check for the existence of an antimatter prop, but if we wanted to do further save\n    // verification then here's where we'd do it\n\n    if (save.money === undefined && save.antimatter === undefined) return \"Save does not have antimatter property\"; // Recursively check for any NaN props and add any we find to an array\n\n    const invalidProps = [];\n\n    function checkNaN(obj, path) {\n      let hasNaN = false;\n\n      for (const key in obj) {\n        const prop = obj[key];\n        let thisNaN;\n\n        switch (typeof prop) {\n          case \"object\":\n            thisNaN = checkNaN(prop, `${path}.${key}`);\n            hasNaN = hasNaN || thisNaN;\n            break;\n\n          case \"number\":\n            thisNaN = Number.isNaN(prop);\n            hasNaN = hasNaN || thisNaN;\n            if (thisNaN) invalidProps.push(`${path}.${key}`);\n            break;\n\n          case \"string\":\n            // If we're attempting to import, all NaN entries will still be strings\n            thisNaN = prop === \"NaN\";\n            hasNaN = hasNaN || thisNaN;\n            if (thisNaN) invalidProps.push(`${path}.${key}`);\n            break;\n        }\n      }\n\n      return hasNaN;\n    }\n\n    checkNaN(save, \"player\");\n    if (invalidProps.length === 0) return \"\";\n    return `${quantify(\"NaN player property\", invalidProps.length)} found:\n      ${invalidProps.join(\", \")}`;\n  },\n\n  // A few things in the current game state can prevent saving, which we want to do for all forms of saving\n  canSave(ignoreSimulation = false) {\n    const isSelectingGlyph = GlyphSelection.active;\n    const isSimulating = ui.$viewModel.modal.progressBar !== undefined && !ignoreSimulation;\n    const isEnd = GameEnd.endState >= END_STATE_MARKERS.SAVE_DISABLED && !GameEnd.removeAdditionalEnd || GameEnd.endState >= END_STATE_MARKERS.INTERACTIVITY_DISABLED;\n    return !isEnd && !(isSelectingGlyph || isSimulating);\n  },\n\n  save(silent = true, manual = false) {\n    if (!this.canSave()) return;\n    this.lastSaveTime = Date.now();\n    GameIntervals.save.restart();\n    if (manual && ++this.saved > 99) SecretAchievement(12).unlock();\n    const root = {\n      current: this.currentSlot,\n      saves: this.saves\n    };\n    localStorage.setItem(this.localStorageKey, GameSaveSerializer.serialize(root));\n    if (!silent) GameUI.notify.info(\"Game saved\");\n  },\n\n  // Saves a backup, updates save timers (this is called before nextBackup is updated), and then saves the timers too.\n  // When checking offline backups, this call typically resolves during offline progress simulation, so in this case\n  // we want to ignore that (which saves the game state pre-simulation). This is because it's messier and less useful\n  // to the player if we instead defer the call until after simulation\n  saveToBackup(backupSlot, backupTimer) {\n    if (!this.canSave(true)) return;\n    localStorage.setItem(this.backupDataKey(this.currentSlot, backupSlot), GameSaveSerializer.serialize(player));\n    this.lastBackupTimes[backupSlot] = {\n      backupTimer,\n      date: Date.now()\n    };\n    localStorage.setItem(this.backupTimeKey(this.currentSlot), GameSaveSerializer.serialize(this.lastBackupTimes));\n  },\n\n  // Does not actually load, but returns an object which is meant to be passed on to loadPlayerObject()\n  loadFromBackup(backupSlot) {\n    const data = localStorage.getItem(this.backupDataKey(this.currentSlot, backupSlot));\n    return GameSaveSerializer.deserialize(data);\n  },\n\n  // Check for the amount of time spent offline and perform an immediate backup for the longest applicable slot\n  // which has had more than its timer elapse since the last time the game was open and saved\n  backupOfflineSlots() {\n    const currentTime = Date.now();\n    const offlineTimeMs = currentTime - this.lastUpdateOnLoad;\n    const offlineSlots = AutoBackupSlots.filter(slot => slot.type === BACKUP_SLOT_TYPE.OFFLINE).sort((a, b) => b.interval - a.interval);\n\n    for (const backupInfo of offlineSlots) {\n      if (offlineTimeMs > 1000 * backupInfo.interval) {\n        this.saveToBackup(backupInfo.id, player.backupTimer);\n        break;\n      }\n    }\n  },\n\n  backupOnlineSlots(slotsToBackup) {\n    const currentTime = player.backupTimer;\n\n    for (const slot of slotsToBackup) this.saveToBackup(slot, currentTime);\n  },\n\n  // Loads in all the data from previous backup times in localStorage\n  loadBackupTimes() {\n    this.lastBackupTimes = GameSaveSerializer.deserialize(localStorage.getItem(this.backupTimeKey(this.currentSlot)));\n    if (!this.lastBackupTimes) this.lastBackupTimes = {};\n\n    for (const backupInfo of AutoBackupSlots) {\n      const key = backupInfo.id;\n\n      if (!this.lastBackupTimes[key]) {\n        this.lastBackupTimes[key] = {\n          backupTimer: 0,\n          date: 0\n        };\n      }\n    }\n  },\n\n  // This is checked in the checkEverySecond game interval. Determining which slots to save has a 800ms grace time to\n  // account for delays occurring from the saving operation itself; without this, the timer slips backwards by a second\n  // every time it saves\n  tryOnlineBackups() {\n    const toBackup = [];\n\n    for (const backupInfo of AutoBackupSlots.filter(slot => slot.type === BACKUP_SLOT_TYPE.ONLINE)) {\n      var _this$lastBackupTimes, _this$lastBackupTimes2;\n\n      const id = backupInfo.id;\n      const timeSinceLast = player.backupTimer - ((_this$lastBackupTimes = (_this$lastBackupTimes2 = this.lastBackupTimes[id]) === null || _this$lastBackupTimes2 === void 0 ? void 0 : _this$lastBackupTimes2.backupTimer) !== null && _this$lastBackupTimes !== void 0 ? _this$lastBackupTimes : 0);\n      if (1000 * backupInfo.interval - timeSinceLast <= 800) toBackup.push(id);\n    }\n\n    this.backupOnlineSlots(toBackup);\n  },\n\n  // Set the next backup time, but make sure to skip forward an appropriate amount if a load or import happened,\n  // since these may cause the backup timer to be significantly behind\n  resetBackupTimer() {\n    const latestBackupTime = Object.values(this.lastBackupTimes).map(t => t && t.backupTimer).max();\n    player.backupTimer = Math.max(this.oldBackupTimer, player.backupTimer, latestBackupTime);\n  },\n\n  // Saves the current game state to the first reserve slot it finds\n  saveToReserveSlot() {\n    const targetSlot = AutoBackupSlots.find(slot => slot.type === BACKUP_SLOT_TYPE.RESERVE).id;\n    this.saveToBackup(targetSlot, player.backupTimer);\n  },\n\n  export() {\n    copyToClipboard(this.exportModifiedSave());\n    GameUI.notify.info(\"Exported current savefile to your clipboard\");\n  },\n\n  get exportDateString() {\n    const dateObj = new Date();\n    const y = dateObj.getFullYear();\n    const m = dateObj.getMonth() + 1;\n    const d = dateObj.getDate();\n    return `${y}-${m}-${d}`;\n  },\n\n  exportAsFile() {\n    if (!this.canSave()) return;\n    player.options.exportedFileCount++;\n    this.save(true);\n    const saveFileName = player.options.saveFileName ? ` - ${player.options.saveFileName},` : \"\";\n    const save = this.exportModifiedSave();\n    download(`AD Save, Slot ${GameStorage.currentSlot + 1}${saveFileName} #${player.options.exportedFileCount} \\\n(${this.exportDateString}).txt`, save);\n    GameUI.notify.info(\"Successfully downloaded current save file to your computer\");\n  },\n\n  exportBackupsAsFile() {\n    player.options.exportedFileCount++;\n    const backupData = {};\n\n    for (const id of AutoBackupSlots.map(slot => slot.id)) {\n      const backup = this.loadFromBackup(id);\n      if (backup) backupData[id] = backup;\n    }\n\n    backupData.time = GameSaveSerializer.deserialize(localStorage.getItem(this.backupTimeKey(this.currentSlot)));\n    download(`AD Save Backups, Slot ${GameStorage.currentSlot + 1} #${player.options.exportedFileCount} \\\n(${this.exportDateString}).txt`, GameSaveSerializer.serialize(backupData));\n    GameUI.notify.info(\"Successfully downloaded save file backups to your computer\");\n  },\n\n  importBackupsFromFile(importText) {\n    const backupData = GameSaveSerializer.deserialize(importText);\n    localStorage.setItem(this.backupTimeKey(this.currentSlot), GameSaveSerializer.serialize(backupData.time));\n\n    for (const backupKey of Object.keys(backupData)) {\n      if (backupKey === \"time\") continue;\n      const id = Number(backupKey);\n      const storageKey = this.backupDataKey(this.currentSlot, id);\n      localStorage.setItem(storageKey, GameSaveSerializer.serialize(backupData[backupKey]));\n      this.backupTimeData[id] = {\n        backupTimer: backupData.time[id].backupTimer,\n        date: backupData.time[id].date\n      };\n    }\n\n    this.resetBackupTimer();\n    GameUI.notify.info(\"Successfully imported save file backups from file\");\n  },\n\n  // There are a couple props which may need to export with different values, so we handle that here\n  exportModifiedSave() {\n    // Speedrun segmented is exported as true\n    const segmented = player.speedrun.isSegmented;\n    Speedrun.setSegmented(true); // Serialize the altered data, then restore the old prop values afterwards and return\n\n    const save = GameSaveSerializer.serialize(player);\n    Speedrun.setSegmented(segmented);\n    return save;\n  },\n\n  hardReset() {\n    this.loadPlayerObject(Player.defaultStart);\n    this.save(true);\n    Tab.dimensions.antimatter.show();\n    Cloud.resetTempState();\n  },\n\n  loadPlayerObject(playerObject) {\n    var _this$offlineEnabled;\n\n    this.saved = 0;\n    const checkString = this.checkPlayerObject(playerObject);\n\n    if (playerObject === Player.defaultStart || checkString !== \"\") {\n      if (DEV && checkString !== \"\") {\n        // eslint-disable-next-line no-console\n        console.log(`Savefile was invalid and has been reset - ${checkString}`);\n      }\n\n      player = deepmergeAll([{}, Player.defaultStart]);\n      player.records.gameCreatedTime = Date.now();\n      player.lastUpdate = Date.now();\n\n      if (DEV) {\n        devMigrations.setLatestTestVersion(player);\n      }\n    } else {\n      // We want to support importing from versions much older than the newest pre-reality version, but we also want\n      // to support in-dev versions so we don't lose access to the large bank of in-dev saves we've accumulated. As\n      // a result, we need to be careful with what order we apply the dev/live migrations and the deepmerge with the\n      // default player object to fill in missing props.\n      // For pre-Reality versions, we additionally need to fire off an event to ensure certain achievements and\n      // notifications trigger properly. Missing props are filled in at this step via deepmerge\n      const isPreviousVersionSave = playerObject.version < migrations.firstRealityMigration;\n      player = migrations.patchPreReality(playerObject);\n\n      if (isPreviousVersionSave) {\n        if (DEV) devMigrations.setLatestTestVersion(player);\n        EventHub.dispatch(GAME_EVENT.SAVE_CONVERTED_FROM_PREVIOUS_VERSION);\n      } // All dev migrations are applied in-place, mutating the player object. Note that since we only want to apply dev\n      // migrations in a dev environment, this means that test saves may fail to migrate on the live version\n\n\n      if (DEV && player.options.testVersion !== undefined) {\n        devMigrations.patch(player);\n      } // Post-reality migrations are separated from pre-reality because they need to happen after any dev migrations,\n      // which themselves must happen after the deepmerge\n\n\n      player = migrations.patchPostReality(player);\n    }\n\n    this.saves[this.currentSlot] = player;\n    this.lastUpdateOnLoad = player.lastUpdate;\n\n    if (DEV) {\n      guardFromNaNValues(player);\n    }\n\n    ui.view.news = player.options.news.enabled;\n    ui.view.newUI = player.options.newUI;\n    ui.view.tutorialState = player.tutorialState;\n    ui.view.tutorialActive = player.tutorialActive;\n    ECTimeStudyState.invalidateCachedRequirements();\n    recalculateAllGlyphs();\n    checkPerkValidity();\n    V.updateTotalRunUnlocks();\n    Enslaved.boostReality = false;\n    GameEnd.additionalEnd = 0;\n    Theme.set(Theme.currentName());\n    Glyphs.unseen = [];\n    Glyphs.unequipped = [];\n    Notations.find(player.options.notation).setAsCurrent(true);\n    ADNotations.Settings.exponentCommas.min = 10 ** player.options.notationDigits.comma;\n    ADNotations.Settings.exponentCommas.max = 10 ** player.options.notationDigits.notation;\n    EventHub.dispatch(GAME_EVENT.GAME_LOAD);\n    AutomatorBackend.initializeFromSave();\n    Lazy.invalidateAll();\n    const rawDiff = Date.now() - player.lastUpdate; // We set offlineEnabled externally on importing or loading a backup; otherwise this is just a local load\n\n    const simulateOffline = (_this$offlineEnabled = this.offlineEnabled) !== null && _this$offlineEnabled !== void 0 ? _this$offlineEnabled : player.options.offlineProgress;\n\n    if (simulateOffline && !Speedrun.isPausedAtStart()) {\n      let diff = rawDiff;\n      player.speedrun.offlineTimeUsed += diff;\n\n      if (diff > 5 * 60 * 1000 && player.celestials.enslaved.autoStoreReal) {\n        diff = Enslaved.autoStoreRealTime(diff);\n      }\n\n      if (diff > 10000) {\n        // The third parameter is a `fast` parameter that we use to only\n        // simulate at most 50 ticks if the player was offline for less\n        // than 50 seconds.\n        simulateTime(diff / 1000, false, diff < 50 * 1000);\n      } else {\n        // This is ugly, should fix how we deal with it...\n        this.postLoadStuff();\n      }\n    } else {\n      // Try to unlock \"Don't you dare sleep\" (usually this check only happens\n      // during a game tick, which makes the achievement impossible to get\n      // with offline progress off)\n      if (!Speedrun.isPausedAtStart()) Achievement(35).tryUnlock();\n      player.lastUpdate = Date.now();\n      this.postLoadStuff();\n    } // 2-week threshold for showing the catchup modal. We want to show this even if offline progress is disabled\n    // because its presence and usefulness is tied to what the player experiences, not the game. setTimeout seems to be\n    // the only way to get this to display, as it won't display even if called after init() entirely nor is it getting\n    // actively hidden by Modal.hideAll(), so delaying it asynchronously gets past whatever is causing it to not appear.\n    // Delay time is relatively long to make it more likely to work on much slower computers.\n\n\n    if (rawDiff > 1000 * 86400 * 14) {\n      if ([\"S4\", \"S9\"].includes(Theme.current().name)) Theme.set(\"Normal\"); // Looks like the game takes too long to load so we need to setTimeout else it doesn't check for the notation.\n\n      setTimeout(() => {\n        if (Notations.current.isPainful) Notation.mixedScientific.setAsCurrent();\n      }, 2500);\n      setTimeout(() => Modal.catchup.show(rawDiff), 5000);\n    }\n  },\n\n  postLoadStuff() {\n    // This is called from simulateTime, if that's called; otherwise, it gets called\n    // manually above\n    GameIntervals.restart();\n    GameStorage.ignoreBackupTimer = false;\n    Enslaved.nextTickDiff = player.options.updateRate; // The condition for this secret achievement is only checked when the player is actively storing real time, either\n    // when online or simulating time. When only storing offline, the condition is never actually entered in the\n    // gameLoop due to the option technically being false, so we need to check it on-load too.\n\n    if (player.celestials.enslaved.storedReal > 24 * 60 * 60 * 1000) SecretAchievement(46).unlock();\n    GameUI.update();\n\n    for (const resource of AlchemyResources.all) {\n      resource.before = resource.amount;\n    }\n  }\n\n};\n\nfunction download(filename, text) {\n  const pom = document.createElement(\"a\");\n  pom.setAttribute(\"href\", `data:text/plain;charset=utf-8,${encodeURIComponent(text)}`);\n  pom.setAttribute(\"download\", filename);\n\n  if (document.createEvent) {\n    const event = document.createEvent(\"MouseEvents\");\n    event.initEvent(\"click\", true, true);\n    pom.dispatchEvent(event);\n  } else {\n    pom.click();\n  }\n}","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/storage/storage.js"],"names":["ADNotations","DEV","devMigrations","migrations","deepmergeAll","BACKUP_SLOT_TYPE","ONLINE","OFFLINE","RESERVE","AutoBackupSlots","id","type","intervalStr","formatInt","interval","GameStorage","currentSlot","saves","undefined","saved","lastSaveTime","Date","now","lastCloudSave","offlineEnabled","offlineTicks","lastUpdateOnLoad","lastBackupTimes","oldBackupTimer","ignoreBackupTimer","maxOfflineTicks","simulatedMs","defaultTicks","tickLimit","Math","clampMax","floor","localStorageKey","backupDataKey","saveSlot","backupSlot","backupTimeKey","load","save","localStorage","getItem","root","GameSaveSerializer","deserialize","loadRoot","Achievements","updateSteamStatus","loadPlayerObject","Player","defaultStart","loadBackupTimes","backupOfflineSlots","current","loadSlot","slot","Tabs","all","find","t","player","options","lastOpenTab","show","Modal","hideAll","Cloud","resetTempState","GameUI","notify","info","import","saveData","tryImportSecret","Theme","tryUnlock","newPlayer","checkPlayerObject","message","backupTimer","Quote","clearAll","AutomatorBackend","clearEditor","GlyphAppearanceHandler","clearInvalidCosmetics","speedrun","isActive","Speedrun","setSegmented","resetBackupTimer","Tab","subtabs","importAsFile","GameEnd","creditsEverClosed","reader","FileReader","text","readAsText","file","overwriteSlot","money","antimatter","invalidProps","checkNaN","obj","path","hasNaN","key","prop","thisNaN","Number","isNaN","push","length","quantify","join","canSave","ignoreSimulation","isSelectingGlyph","GlyphSelection","active","isSimulating","ui","$viewModel","modal","progressBar","isEnd","endState","END_STATE_MARKERS","SAVE_DISABLED","removeAdditionalEnd","INTERACTIVITY_DISABLED","silent","manual","GameIntervals","restart","SecretAchievement","unlock","setItem","serialize","saveToBackup","date","loadFromBackup","data","currentTime","offlineTimeMs","offlineSlots","filter","sort","a","b","backupInfo","backupOnlineSlots","slotsToBackup","tryOnlineBackups","toBackup","timeSinceLast","latestBackupTime","Object","values","map","max","saveToReserveSlot","targetSlot","export","copyToClipboard","exportModifiedSave","exportDateString","dateObj","y","getFullYear","m","getMonth","d","getDate","exportAsFile","exportedFileCount","saveFileName","download","exportBackupsAsFile","backupData","backup","time","importBackupsFromFile","importText","backupKey","keys","storageKey","backupTimeData","segmented","isSegmented","hardReset","dimensions","playerObject","checkString","console","log","records","gameCreatedTime","lastUpdate","setLatestTestVersion","isPreviousVersionSave","version","firstRealityMigration","patchPreReality","EventHub","dispatch","GAME_EVENT","SAVE_CONVERTED_FROM_PREVIOUS_VERSION","testVersion","patch","patchPostReality","guardFromNaNValues","view","news","enabled","newUI","tutorialState","tutorialActive","ECTimeStudyState","invalidateCachedRequirements","recalculateAllGlyphs","checkPerkValidity","V","updateTotalRunUnlocks","Enslaved","boostReality","additionalEnd","set","currentName","Glyphs","unseen","unequipped","Notations","notation","setAsCurrent","Settings","exponentCommas","min","notationDigits","comma","GAME_LOAD","initializeFromSave","Lazy","invalidateAll","rawDiff","simulateOffline","offlineProgress","isPausedAtStart","diff","offlineTimeUsed","celestials","enslaved","autoStoreReal","autoStoreRealTime","simulateTime","postLoadStuff","Achievement","includes","name","setTimeout","isPainful","Notation","mixedScientific","catchup","nextTickDiff","updateRate","storedReal","update","resource","AlchemyResources","before","amount","filename","pom","document","createElement","setAttribute","encodeURIComponent","createEvent","event","initEvent","dispatchEvent","click"],"mappings":"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","sourcesContent":["import * as ADNotations from \"@antimatter-dimensions/notations\";\r\n\r\nimport { DEV } from \"@/env\";\r\nimport { devMigrations } from \"./dev-migrations\";\r\nimport { migrations } from \"./migrations\";\r\n\r\nimport { deepmergeAll } from \"@/utility/deepmerge\";\r\n\r\nexport const BACKUP_SLOT_TYPE = {\r\n  ONLINE: 0,\r\n  OFFLINE: 1,\r\n  RESERVE: 2,\r\n};\r\n\r\n// Note: interval is in seconds, and only the first RESERVE slot is ever used. Having intervalStr as a redundant\r\n// prop is necessary because using our TimeSpan formatting functions produces undesirable strings like \"1.00 minutes\"\r\nexport const AutoBackupSlots = [\r\n  {\r\n    id: 1,\r\n    type: BACKUP_SLOT_TYPE.ONLINE,\r\n    intervalStr: () => `${formatInt(1)} minute`,\r\n    interval: 60,\r\n  },\r\n  {\r\n    id: 2,\r\n    type: BACKUP_SLOT_TYPE.ONLINE,\r\n    intervalStr: () => `${formatInt(5)} minutes`,\r\n    interval: 5 * 60,\r\n  },\r\n  {\r\n    id: 3,\r\n    type: BACKUP_SLOT_TYPE.ONLINE,\r\n    intervalStr: () => `${formatInt(20)} minutes`,\r\n    interval: 20 * 60,\r\n  },\r\n  {\r\n    id: 4,\r\n    type: BACKUP_SLOT_TYPE.ONLINE,\r\n    intervalStr: () => `${formatInt(1)} hour`,\r\n    interval: 3600,\r\n  },\r\n  {\r\n    id: 5,\r\n    type: BACKUP_SLOT_TYPE.OFFLINE,\r\n    intervalStr: () => `${formatInt(10)} minutes`,\r\n    interval: 10 * 60,\r\n  },\r\n  {\r\n    id: 6,\r\n    type: BACKUP_SLOT_TYPE.OFFLINE,\r\n    intervalStr: () => `${formatInt(1)} hour`,\r\n    interval: 3600,\r\n  },\r\n  {\r\n    id: 7,\r\n    type: BACKUP_SLOT_TYPE.OFFLINE,\r\n    intervalStr: () => `${formatInt(5)} hours`,\r\n    interval: 5 * 3600,\r\n  },\r\n  {\r\n    id: 8,\r\n    type: BACKUP_SLOT_TYPE.RESERVE,\r\n  },\r\n];\r\n\r\nexport const GameStorage = {\r\n  currentSlot: 0,\r\n  saves: {\r\n    0: undefined,\r\n    1: undefined,\r\n    2: undefined\r\n  },\r\n  saved: 0,\r\n  lastSaveTime: Date.now(),\r\n  lastCloudSave: Date.now(),\r\n  offlineEnabled: undefined,\r\n  offlineTicks: undefined,\r\n  lastUpdateOnLoad: 0,\r\n  lastBackupTimes: [],\r\n  oldBackupTimer: 0,\r\n  ignoreBackupTimer: true,\r\n\r\n  // Limit offline tick count using two conditions:\r\n  // - Ticks should never be shorter than 33ms (this would allow offline to exploit tick microstructure)\r\n  // - Count should be limited to 1e6 (the options UI doesn't allow for this to be set above this value)\r\n  maxOfflineTicks(simulatedMs, defaultTicks = this.offlineTicks) {\r\n    const tickLimit = Math.clampMax(Math.floor(simulatedMs / 33), 1e6);\r\n    return Math.clampMax(defaultTicks, tickLimit);\r\n  },\r\n\r\n  get localStorageKey() {\r\n    return DEV ? \"dimensionTestSave\" : \"dimensionSave\";\r\n  },\r\n\r\n  backupDataKey(saveSlot, backupSlot) {\r\n    return DEV ? `backupTestSave-${saveSlot}-${backupSlot}` : `backupSave-${saveSlot}-${backupSlot}`;\r\n  },\r\n\r\n  backupTimeKey(saveSlot) {\r\n    return DEV ? `backupTestTimes-${saveSlot}` : `backupTimes-${saveSlot}`;\r\n  },\r\n\r\n  load() {\r\n    const save = localStorage.getItem(this.localStorageKey);\r\n    const root = GameSaveSerializer.deserialize(save);\r\n\r\n    this.loadRoot(root);\r\n    Achievements.updateSteamStatus();\r\n  },\r\n\r\n  loadRoot(root) {\r\n    if (root === undefined) {\r\n      this.currentSlot = 0;\r\n      this.loadPlayerObject(Player.defaultStart);\r\n      return;\r\n    }\r\n\r\n    if (root.saves === undefined) {\r\n      // Migrate old format\r\n      this.saves = {\r\n        0: root,\r\n        1: undefined,\r\n        2: undefined\r\n      };\r\n      this.currentSlot = 0;\r\n      this.loadPlayerObject(root);\r\n      this.loadBackupTimes();\r\n      this.backupOfflineSlots();\r\n      this.save(true);\r\n      return;\r\n    }\r\n\r\n    this.saves = root.saves;\r\n    this.currentSlot = root.current;\r\n    this.loadPlayerObject(this.saves[this.currentSlot]);\r\n    this.loadBackupTimes();\r\n    this.backupOfflineSlots();\r\n  },\r\n\r\n  loadSlot(slot) {\r\n    this.currentSlot = slot;\r\n    // Save current slot to make sure no changes are lost\r\n    this.save(true);\r\n    this.loadPlayerObject(this.saves[slot] ?? Player.defaultStart);\r\n    this.loadBackupTimes();\r\n    this.backupOfflineSlots();\r\n    Tabs.all.find(t => t.id === player.options.lastOpenTab).show(false);\r\n    Modal.hideAll();\r\n    Cloud.resetTempState();\r\n    GameUI.notify.info(\"Game loaded\");\r\n    Achievements.updateSteamStatus();\r\n  },\r\n\r\n  import(saveData) {\r\n    if (tryImportSecret(saveData) || Theme.tryUnlock(saveData)) {\r\n      return;\r\n    }\r\n    const newPlayer = GameSaveSerializer.deserialize(saveData);\r\n    if (this.checkPlayerObject(newPlayer) !== \"\") {\r\n      Modal.message.show(\"Could not load the save (format unrecognized or invalid).\");\r\n      return;\r\n    }\r\n    this.oldBackupTimer = player.backupTimer;\r\n    Modal.hideAll();\r\n    Quote.clearAll();\r\n    AutomatorBackend.clearEditor();\r\n    this.loadPlayerObject(newPlayer);\r\n    GlyphAppearanceHandler.clearInvalidCosmetics();\r\n    if (player.speedrun?.isActive) Speedrun.setSegmented(true);\r\n    this.save(true);\r\n    Cloud.resetTempState();\r\n    this.resetBackupTimer();\r\n\r\n    // This is to fix a very specific exploit: When the game is ending, some tabs get hidden\r\n    // The options tab is the first one of those, which makes the player redirect to the Pelle tab\r\n    // You can doom your reality even if you haven't unlocked infinity yet if you import while the Pelle tab\r\n    // is showing\r\n    Tab.options.subtabs[0].show();\r\n    GameUI.notify.info(\"Game imported\");\r\n    Achievements.updateSteamStatus();\r\n  },\r\n\r\n  importAsFile() {\r\n    if (GameEnd.creditsEverClosed) return;\r\n    const reader = new FileReader();\r\n    const text = reader.readAsText(file);\r\n    this.import(text);\r\n  },\r\n\r\n  overwriteSlot(slot, saveData) {\r\n    this.saves[slot] = saveData;\r\n    if (slot === this.currentSlot) {\r\n      this.loadPlayerObject(saveData);\r\n    }\r\n\r\n    this.save(true);\r\n  },\r\n\r\n  // Some minimal save verification; if the save is valid then this returns an empty string, otherwise it returns a\r\n  // a string roughly stating what's wrong with the save. In order for importing to work properly, this must return\r\n  // an empty string.\r\n  checkPlayerObject(save) {\r\n    // Sometimes save is the output of GameSaveSerializer.deserialize, and if that function fails then it will result\r\n    // in the input parameter here being undefined\r\n    if (save === undefined || save === null) return \"Save decoding failed (invalid format)\";\r\n    // Right now all we do is check for the existence of an antimatter prop, but if we wanted to do further save\r\n    // verification then here's where we'd do it\r\n    if (save.money === undefined && save.antimatter === undefined) return \"Save does not have antimatter property\";\r\n\r\n    // Recursively check for any NaN props and add any we find to an array\r\n    const invalidProps = [];\r\n    function checkNaN(obj, path) {\r\n      let hasNaN = false;\r\n      for (const key in obj) {\r\n        const prop = obj[key];\r\n        let thisNaN;\r\n        switch (typeof prop) {\r\n          case \"object\":\r\n            thisNaN = checkNaN(prop, `${path}.${key}`);\r\n            hasNaN = hasNaN || thisNaN;\r\n            break;\r\n          case \"number\":\r\n            thisNaN = Number.isNaN(prop);\r\n            hasNaN = hasNaN || thisNaN;\r\n            if (thisNaN) invalidProps.push(`${path}.${key}`);\r\n            break;\r\n          case \"string\":\r\n            // If we're attempting to import, all NaN entries will still be strings\r\n            thisNaN = prop === \"NaN\";\r\n            hasNaN = hasNaN || thisNaN;\r\n            if (thisNaN) invalidProps.push(`${path}.${key}`);\r\n            break;\r\n        }\r\n      }\r\n      return hasNaN;\r\n    }\r\n    checkNaN(save, \"player\");\r\n\r\n    if (invalidProps.length === 0) return \"\";\r\n    return `${quantify(\"NaN player property\", invalidProps.length)} found:\r\n      ${invalidProps.join(\", \")}`;\r\n  },\r\n\r\n  // A few things in the current game state can prevent saving, which we want to do for all forms of saving\r\n  canSave(ignoreSimulation = false) {\r\n    const isSelectingGlyph = GlyphSelection.active;\r\n    const isSimulating = ui.$viewModel.modal.progressBar !== undefined && !ignoreSimulation;\r\n    const isEnd = (GameEnd.endState >= END_STATE_MARKERS.SAVE_DISABLED && !GameEnd.removeAdditionalEnd) ||\r\n      GameEnd.endState >= END_STATE_MARKERS.INTERACTIVITY_DISABLED;\r\n    return !isEnd && !(isSelectingGlyph || isSimulating);\r\n  },\r\n\r\n  save(silent = true, manual = false) {\r\n    if (!this.canSave()) return;\r\n    this.lastSaveTime = Date.now();\r\n    GameIntervals.save.restart();\r\n    if (manual && ++this.saved > 99) SecretAchievement(12).unlock();\r\n    const root = {\r\n      current: this.currentSlot,\r\n      saves: this.saves\r\n    };\r\n    localStorage.setItem(this.localStorageKey, GameSaveSerializer.serialize(root));\r\n    if (!silent) GameUI.notify.info(\"Game saved\");\r\n  },\r\n\r\n  // Saves a backup, updates save timers (this is called before nextBackup is updated), and then saves the timers too.\r\n  // When checking offline backups, this call typically resolves during offline progress simulation, so in this case\r\n  // we want to ignore that (which saves the game state pre-simulation). This is because it's messier and less useful\r\n  // to the player if we instead defer the call until after simulation\r\n  saveToBackup(backupSlot, backupTimer) {\r\n    if (!this.canSave(true)) return;\r\n    localStorage.setItem(this.backupDataKey(this.currentSlot, backupSlot), GameSaveSerializer.serialize(player));\r\n    this.lastBackupTimes[backupSlot] = {\r\n      backupTimer,\r\n      date: Date.now(),\r\n    };\r\n    localStorage.setItem(this.backupTimeKey(this.currentSlot), GameSaveSerializer.serialize(this.lastBackupTimes));\r\n  },\r\n\r\n  // Does not actually load, but returns an object which is meant to be passed on to loadPlayerObject()\r\n  loadFromBackup(backupSlot) {\r\n    const data = localStorage.getItem(this.backupDataKey(this.currentSlot, backupSlot));\r\n    return GameSaveSerializer.deserialize(data);\r\n  },\r\n\r\n  // Check for the amount of time spent offline and perform an immediate backup for the longest applicable slot\r\n  // which has had more than its timer elapse since the last time the game was open and saved\r\n  backupOfflineSlots() {\r\n    const currentTime = Date.now();\r\n    const offlineTimeMs = currentTime - this.lastUpdateOnLoad;\r\n    const offlineSlots = AutoBackupSlots\r\n      .filter(slot => slot.type === BACKUP_SLOT_TYPE.OFFLINE)\r\n      .sort((a, b) => b.interval - a.interval);\r\n    for (const backupInfo of offlineSlots) {\r\n      if (offlineTimeMs > 1000 * backupInfo.interval) {\r\n        this.saveToBackup(backupInfo.id, player.backupTimer);\r\n        break;\r\n      }\r\n    }\r\n  },\r\n\r\n  backupOnlineSlots(slotsToBackup) {\r\n    const currentTime = player.backupTimer;\r\n    for (const slot of slotsToBackup) this.saveToBackup(slot, currentTime);\r\n  },\r\n\r\n  // Loads in all the data from previous backup times in localStorage\r\n  loadBackupTimes() {\r\n    this.lastBackupTimes = GameSaveSerializer.deserialize(localStorage.getItem(this.backupTimeKey(this.currentSlot)));\r\n    if (!this.lastBackupTimes) this.lastBackupTimes = {};\r\n    for (const backupInfo of AutoBackupSlots) {\r\n      const key = backupInfo.id;\r\n      if (!this.lastBackupTimes[key]) {\r\n        this.lastBackupTimes[key] = {\r\n          backupTimer: 0,\r\n          date: 0,\r\n        };\r\n      }\r\n    }\r\n  },\r\n\r\n  // This is checked in the checkEverySecond game interval. Determining which slots to save has a 800ms grace time to\r\n  // account for delays occurring from the saving operation itself; without this, the timer slips backwards by a second\r\n  // every time it saves\r\n  tryOnlineBackups() {\r\n    const toBackup = [];\r\n    for (const backupInfo of AutoBackupSlots.filter(slot => slot.type === BACKUP_SLOT_TYPE.ONLINE)) {\r\n      const id = backupInfo.id;\r\n      const timeSinceLast = player.backupTimer - (this.lastBackupTimes[id]?.backupTimer ?? 0);\r\n      if (1000 * backupInfo.interval - timeSinceLast <= 800) toBackup.push(id);\r\n    }\r\n    this.backupOnlineSlots(toBackup);\r\n  },\r\n\r\n  // Set the next backup time, but make sure to skip forward an appropriate amount if a load or import happened,\r\n  // since these may cause the backup timer to be significantly behind\r\n  resetBackupTimer() {\r\n    const latestBackupTime = Object.values(this.lastBackupTimes).map(t => t && t.backupTimer).max();\r\n    player.backupTimer = Math.max(this.oldBackupTimer, player.backupTimer, latestBackupTime);\r\n  },\r\n\r\n  // Saves the current game state to the first reserve slot it finds\r\n  saveToReserveSlot() {\r\n    const targetSlot = AutoBackupSlots.find(slot => slot.type === BACKUP_SLOT_TYPE.RESERVE).id;\r\n    this.saveToBackup(targetSlot, player.backupTimer);\r\n  },\r\n\r\n  export() {\r\n    copyToClipboard(this.exportModifiedSave());\r\n    GameUI.notify.info(\"Exported current savefile to your clipboard\");\r\n  },\r\n\r\n  get exportDateString() {\r\n    const dateObj = new Date();\r\n    const y = dateObj.getFullYear();\r\n    const m = dateObj.getMonth() + 1;\r\n    const d = dateObj.getDate();\r\n    return `${y}-${m}-${d}`;\r\n  },\r\n\r\n  exportAsFile() {\r\n    if (!this.canSave()) return;\r\n    player.options.exportedFileCount++;\r\n    this.save(true);\r\n    const saveFileName = player.options.saveFileName ? ` - ${player.options.saveFileName},` : \"\";\r\n    const save = this.exportModifiedSave();\r\n    download(\r\n      `AD Save, Slot ${GameStorage.currentSlot + 1}${saveFileName} #${player.options.exportedFileCount} \\\r\n(${this.exportDateString}).txt`, save);\r\n    GameUI.notify.info(\"Successfully downloaded current save file to your computer\");\r\n  },\r\n\r\n  exportBackupsAsFile() {\r\n    player.options.exportedFileCount++;\r\n    const backupData = {};\r\n    for (const id of AutoBackupSlots.map(slot => slot.id)) {\r\n      const backup = this.loadFromBackup(id);\r\n      if (backup) backupData[id] = backup;\r\n    }\r\n    backupData.time = GameSaveSerializer.deserialize(localStorage.getItem(this.backupTimeKey(this.currentSlot)));\r\n    download(\r\n      `AD Save Backups, Slot ${GameStorage.currentSlot + 1} #${player.options.exportedFileCount} \\\r\n(${this.exportDateString}).txt`, GameSaveSerializer.serialize(backupData));\r\n    GameUI.notify.info(\"Successfully downloaded save file backups to your computer\");\r\n  },\r\n\r\n  importBackupsFromFile(importText) {\r\n    const backupData = GameSaveSerializer.deserialize(importText);\r\n    localStorage.setItem(this.backupTimeKey(this.currentSlot), GameSaveSerializer.serialize(backupData.time));\r\n    for (const backupKey of Object.keys(backupData)) {\r\n      if (backupKey === \"time\") continue;\r\n      const id = Number(backupKey);\r\n      const storageKey = this.backupDataKey(this.currentSlot, id);\r\n      localStorage.setItem(storageKey, GameSaveSerializer.serialize(backupData[backupKey]));\r\n      this.backupTimeData[id] = {\r\n        backupTimer: backupData.time[id].backupTimer,\r\n        date: backupData.time[id].date,\r\n      };\r\n    }\r\n    this.resetBackupTimer();\r\n    GameUI.notify.info(\"Successfully imported save file backups from file\");\r\n  },\r\n\r\n  // There are a couple props which may need to export with different values, so we handle that here\r\n  exportModifiedSave() {\r\n    // Speedrun segmented is exported as true\r\n    const segmented = player.speedrun.isSegmented;\r\n    Speedrun.setSegmented(true);\r\n\r\n    // Serialize the altered data, then restore the old prop values afterwards and return\r\n    const save = GameSaveSerializer.serialize(player);\r\n    Speedrun.setSegmented(segmented);\r\n    return save;\r\n  },\r\n\r\n  hardReset() {\r\n    this.loadPlayerObject(Player.defaultStart);\r\n    this.save(true);\r\n    Tab.dimensions.antimatter.show();\r\n    Cloud.resetTempState();\r\n  },\r\n\r\n  loadPlayerObject(playerObject) {\r\n    this.saved = 0;\r\n\r\n    const checkString = this.checkPlayerObject(playerObject);\r\n    if (playerObject === Player.defaultStart || checkString !== \"\") {\r\n      if (DEV && checkString !== \"\") {\r\n        // eslint-disable-next-line no-console\r\n        console.log(`Savefile was invalid and has been reset - ${checkString}`);\r\n      }\r\n      player = deepmergeAll([{}, Player.defaultStart]);\r\n      player.records.gameCreatedTime = Date.now();\r\n      player.lastUpdate = Date.now();\r\n      if (DEV) {\r\n        devMigrations.setLatestTestVersion(player);\r\n      }\r\n    } else {\r\n      // We want to support importing from versions much older than the newest pre-reality version, but we also want\r\n      // to support in-dev versions so we don't lose access to the large bank of in-dev saves we've accumulated. As\r\n      // a result, we need to be careful with what order we apply the dev/live migrations and the deepmerge with the\r\n      // default player object to fill in missing props.\r\n\r\n      // For pre-Reality versions, we additionally need to fire off an event to ensure certain achievements and\r\n      // notifications trigger properly. Missing props are filled in at this step via deepmerge\r\n      const isPreviousVersionSave = playerObject.version < migrations.firstRealityMigration;\r\n      player = migrations.patchPreReality(playerObject);\r\n      if (isPreviousVersionSave) {\r\n        if (DEV) devMigrations.setLatestTestVersion(player);\r\n        EventHub.dispatch(GAME_EVENT.SAVE_CONVERTED_FROM_PREVIOUS_VERSION);\r\n      }\r\n\r\n      // All dev migrations are applied in-place, mutating the player object. Note that since we only want to apply dev\r\n      // migrations in a dev environment, this means that test saves may fail to migrate on the live version\r\n      if (DEV && player.options.testVersion !== undefined) {\r\n        devMigrations.patch(player);\r\n      }\r\n\r\n      // Post-reality migrations are separated from pre-reality because they need to happen after any dev migrations,\r\n      // which themselves must happen after the deepmerge\r\n      player = migrations.patchPostReality(player);\r\n    }\r\n\r\n    this.saves[this.currentSlot] = player;\r\n    this.lastUpdateOnLoad = player.lastUpdate;\r\n\r\n    if (DEV) {\r\n      guardFromNaNValues(player);\r\n    }\r\n\r\n    ui.view.news = player.options.news.enabled;\r\n    ui.view.newUI = player.options.newUI;\r\n    ui.view.tutorialState = player.tutorialState;\r\n    ui.view.tutorialActive = player.tutorialActive;\r\n\r\n    ECTimeStudyState.invalidateCachedRequirements();\r\n    recalculateAllGlyphs();\r\n    checkPerkValidity();\r\n    V.updateTotalRunUnlocks();\r\n    Enslaved.boostReality = false;\r\n    GameEnd.additionalEnd = 0;\r\n    Theme.set(Theme.currentName());\r\n    Glyphs.unseen = [];\r\n    Glyphs.unequipped = [];\r\n    Notations.find(player.options.notation).setAsCurrent(true);\r\n    ADNotations.Settings.exponentCommas.min = 10 ** player.options.notationDigits.comma;\r\n    ADNotations.Settings.exponentCommas.max = 10 ** player.options.notationDigits.notation;\r\n\r\n    EventHub.dispatch(GAME_EVENT.GAME_LOAD);\r\n    AutomatorBackend.initializeFromSave();\r\n    Lazy.invalidateAll();\r\n\r\n    const rawDiff = Date.now() - player.lastUpdate;\r\n    // We set offlineEnabled externally on importing or loading a backup; otherwise this is just a local load\r\n    const simulateOffline = this.offlineEnabled ?? player.options.offlineProgress;\r\n    if (simulateOffline && !Speedrun.isPausedAtStart()) {\r\n      let diff = rawDiff;\r\n      player.speedrun.offlineTimeUsed += diff;\r\n      if (diff > 5 * 60 * 1000 && player.celestials.enslaved.autoStoreReal) {\r\n        diff = Enslaved.autoStoreRealTime(diff);\r\n      }\r\n      if (diff > 10000) {\r\n        // The third parameter is a `fast` parameter that we use to only\r\n        // simulate at most 50 ticks if the player was offline for less\r\n        // than 50 seconds.\r\n        simulateTime(diff / 1000, false, diff < 50 * 1000);\r\n      } else {\r\n        // This is ugly, should fix how we deal with it...\r\n        this.postLoadStuff();\r\n      }\r\n    } else {\r\n      // Try to unlock \"Don't you dare sleep\" (usually this check only happens\r\n      // during a game tick, which makes the achievement impossible to get\r\n      // with offline progress off)\r\n      if (!Speedrun.isPausedAtStart()) Achievement(35).tryUnlock();\r\n      player.lastUpdate = Date.now();\r\n      this.postLoadStuff();\r\n    }\r\n\r\n    // 2-week threshold for showing the catchup modal. We want to show this even if offline progress is disabled\r\n    // because its presence and usefulness is tied to what the player experiences, not the game. setTimeout seems to be\r\n    // the only way to get this to display, as it won't display even if called after init() entirely nor is it getting\r\n    // actively hidden by Modal.hideAll(), so delaying it asynchronously gets past whatever is causing it to not appear.\r\n    // Delay time is relatively long to make it more likely to work on much slower computers.\r\n    if (rawDiff > 1000 * 86400 * 14) {\r\n      if ([\"S4\", \"S9\"].includes(Theme.current().name)) Theme.set(\"Normal\");\r\n      // Looks like the game takes too long to load so we need to setTimeout else it doesn't check for the notation.\r\n      setTimeout(() => {\r\n        if (Notations.current.isPainful) Notation.mixedScientific.setAsCurrent();\r\n      }, 2500);\r\n      setTimeout(() => Modal.catchup.show(rawDiff), 5000);\r\n    }\r\n  },\r\n  postLoadStuff() {\r\n    // This is called from simulateTime, if that's called; otherwise, it gets called\r\n    // manually above\r\n    GameIntervals.restart();\r\n    GameStorage.ignoreBackupTimer = false;\r\n    Enslaved.nextTickDiff = player.options.updateRate;\r\n    // The condition for this secret achievement is only checked when the player is actively storing real time, either\r\n    // when online or simulating time. When only storing offline, the condition is never actually entered in the\r\n    // gameLoop due to the option technically being false, so we need to check it on-load too.\r\n    if (player.celestials.enslaved.storedReal > (24 * 60 * 60 * 1000)) SecretAchievement(46).unlock();\r\n    GameUI.update();\r\n\r\n    for (const resource of AlchemyResources.all) {\r\n      resource.before = resource.amount;\r\n    }\r\n  }\r\n};\r\n\r\nfunction download(filename, text) {\r\n  const pom = document.createElement(\"a\");\r\n  pom.setAttribute(\"href\", `data:text/plain;charset=utf-8,${encodeURIComponent(text)}`);\r\n  pom.setAttribute(\"download\", filename);\r\n\r\n  if (document.createEvent) {\r\n    const event = document.createEvent(\"MouseEvents\");\r\n    event.initEvent(\"click\", true, true);\r\n    pom.dispatchEvent(event);\r\n  } else {\r\n    pom.click();\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}