{"ast":null,"code":"require(\"core-js/modules/es.regexp.exec.js\");\n\nrequire(\"core-js/modules/es.string.replace.js\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\n\nfunction isEND() {\n  const threshold = GameEnd.endState > END_STATE_MARKERS.END_NUMBERS ? 1 : (GameEnd.endState - END_STATE_MARKERS.FADE_AWAY) / 2; // Using the Pelle.isDoomed getter here causes this to not update properly after a game restart\n\n  return player.celestials.pelle.doomed && Math.random() < threshold;\n}\n\nwindow.format = function format(value, places = 0, placesUnder1000 = 0) {\n  if (isEND()) return \"END\";\n  return Notations.current.format(value, places, placesUnder1000, 3);\n};\n\nwindow.formatInt = function formatInt(value) {\n  if (isEND()) return \"END\"; // Suppress painful formatting for Standard because it's the most commonly used and arguably \"least painful\"\n  // of the painful notations. Prevents numbers like 5004 from appearing imprecisely as \"5.00 K\" for example\n\n  if (Notations.current.isPainful && Notations.current.name !== \"Standard\") {\n    return format(value, 2);\n  }\n\n  return formatWithCommas(typeof value === \"number\" ? value.toFixed(0) : value.toNumber().toFixed(0));\n};\n\nwindow.formatFloat = function formatFloat(value, digits) {\n  if (isEND()) return \"END\";\n\n  if (Notations.current.isPainful) {\n    return format(value, Math.max(2, digits), digits);\n  }\n\n  return formatWithCommas(value.toFixed(digits));\n};\n\nwindow.formatPostBreak = function formatPostBreak(value, places, placesUnder1000) {\n  if (isEND()) return \"END\";\n  const notation = Notations.current; // This is basically just a copy of the format method from notations library,\n  // with the pre-break case removed.\n\n  if (typeof value === \"number\" && !Number.isFinite(value)) {\n    return notation.infinite;\n  }\n\n  const decimal = Decimal.fromValue_noAlloc(value);\n\n  if (decimal.exponent < -300) {\n    return decimal.sign() < 0 ? notation.formatVerySmallNegativeDecimal(decimal.abs(), placesUnder1000) : notation.formatVerySmallDecimal(decimal, placesUnder1000);\n  }\n\n  if (decimal.exponent < 3) {\n    const number = decimal.toNumber();\n    return number < 0 ? notation.formatNegativeUnder1000(Math.abs(number), placesUnder1000) : notation.formatUnder1000(number, placesUnder1000);\n  }\n\n  return decimal.sign() < 0 ? notation.formatNegativeDecimal(decimal.abs(), places) : notation.formatDecimal(decimal, places);\n};\n\nwindow.formatX = function formatX(value, places, placesUnder1000) {\n  return `×${format(value, places, placesUnder1000)}`;\n};\n\nwindow.formatPow = function formatPow(value, places, placesUnder1000) {\n  return `^${format(value, places, placesUnder1000)}`;\n};\n\nwindow.formatPercents = function formatPercents(value, places) {\n  return `${format(value * 100, 2, places)}%`;\n};\n\nwindow.formatRarity = function formatRarity(value) {\n  // We can, annoyingly, have rounding error here, so even though only rarities\n  // are passed in, we can't trust our input to always be some integer divided by 10.\n  const places = value.toFixed(1).endsWith(\".0\") ? 0 : 1;\n  return `${format(value, 2, places)}%`;\n}; // We assume 2/0, 2/2 decimal places to keep parameter count sensible; this is used very rarely\n\n\nwindow.formatMachines = function formatMachines(realPart, imagPart) {\n  if (isEND()) return \"END\";\n  const parts = [];\n  if (Decimal.neq(realPart, 0)) parts.push(format(realPart, 2));\n  if (Decimal.neq(imagPart, 0)) parts.push(`${format(imagPart, 2, 2)}i`); // This function is used for just RM and just iM in a few spots, so we have to push both parts conditionally\n  // Nonetheless, we also need to special-case both zero so that it doesn't end up displaying as an empty string\n\n  if (Decimal.eq(realPart, 0) && Decimal.eq(imagPart, 0)) return format(0);\n  return parts.join(\" + \");\n};\n\nwindow.timeDisplay = function timeDisplay(ms) {\n  return TimeSpan.fromMilliseconds(ms).toString();\n};\n\nwindow.timeDisplayNoDecimals = function timeDisplayNoDecimals(ms) {\n  return TimeSpan.fromMilliseconds(ms).toStringNoDecimals();\n};\n\nwindow.timeDisplayShort = function timeDisplayShort(ms) {\n  return TimeSpan.fromMilliseconds(ms).toStringShort();\n};\n\nconst commaRegexp = /\\B(?=([0-9]{3})+(?![0-9]))/g;\n\nwindow.formatWithCommas = function formatWithCommas(value) {\n  const decimalPointSplit = value.toString().split(\".\");\n  decimalPointSplit[0] = decimalPointSplit[0].replace(commaRegexp, \",\");\n  return decimalPointSplit.join(\".\");\n};\n/**\r\n * Check if a number or Decimal is equal to 1.\r\n * @param  {number|Decimal} amount\r\n * @return {Boolean} - if the {amount} was equal to 1.\r\n */\n\n\nwindow.isSingular = function isSingular(amount) {\n  if (typeof amount === \"number\") return amount === 1;\n  if (amount instanceof Decimal) return amount.eq(1);\n  throw `Amount must be either a number or Decimal. Instead, amount was ${amount}`;\n}; // Some letters in the english language pluralize in a different manner than simply adding an 's' to the end.\n// As such, the regex match should be placed in the first location, followed by the desired string it\n// should be replaced with. Note that $ refers to the EndOfLine for regex, and should be included if the plural occurs\n// at the end of the string provided, which will be 99% of times. Not including it is highly likely to cause mistakes,\n// as it will select the first instance that matches and replace that.\n\n\nconst PLURAL_HELPER = new Map([[/y$/, \"ies\"], [/x$/, \"xes\"], [/$/, \"s\"]]); // Some terms require specific (or no) handling when plural. These terms should be added, in Word Case, to this Map.\n// Words will be added to this Map when a valid plural for it is found on being run through the pluralize function.\n\nconst pluralDatabase = new Map([[\"Antimatter\", \"Antimatter\"], [\"Dilated Time\", \"Dilated Time\"]]);\n/**\r\n * A function that pluralizes a word based on a designated amount\r\n * @param  {string} word           - word to be pluralized\r\n * @param  {number|Decimal} amount - amount to be used to determine if the value is plural\r\n * @param  {string} [plural]       - if defined, a specific plural to override the generated plural\r\n * @return {string} - if the {amount} is anything other than one, return the {plural} provided or the\r\n *                    plural form of the input {word}. If the {amount} is singular, return {word}\r\n */\n\nwindow.pluralize = function pluralize(word, amount, plural) {\n  if (word === undefined || amount === undefined) throw \"Arguments must be defined\";\n  if (isSingular(amount)) return word;\n  const existingPlural = plural !== null && plural !== void 0 ? plural : pluralDatabase.get(word);\n  if (existingPlural !== undefined) return existingPlural;\n  const newWord = generatePlural(word);\n  pluralDatabase.set(word, newWord);\n  return newWord;\n};\n/**\r\n * Creates a new plural based on PLURAL_HELPER and adds it to pluralDatabase\r\n * @param  {string} word - a word to be pluralized using the regex in PLURAL_HELPER\r\n * @return {string} - returns the pluralized word. if no pluralized word is found, simply returns the word itself.\r\n */\n\n\nwindow.generatePlural = function generatePlural(word) {\n  for (const [match, replaceWith] of PLURAL_HELPER.entries()) {\n    const newWord = word.replace(match, replaceWith);\n    if (word !== newWord) return newWord;\n  }\n\n  return word;\n};\n/**\r\n * Returns the formatted value followed by a name, pluralized based on the value input.\r\n * @param  {string} name                  - name to pluralize and display after {value}\r\n * @param  {number|Decimal} value         - number to {format}\r\n * @param  {number} [places]              - number of places to display for the mantissa\r\n * @param  {number} [placesUnder1000]     - number of decimal places to display\r\n * @param  {function} [formatType=format] - how to format the {value}. defaults to format\r\n * @return {string} - the formatted {value} followed by the {name} after having been pluralized based on the {value}\r\n */\n// eslint-disable-next-line max-params\n\n\nwindow.quantify = function quantify(name, value, places, placesUnder1000, formatType = format) {\n  if (name === undefined || value === undefined) throw \"Arguments must be defined\";\n  const number = formatType(value, places, placesUnder1000);\n  const plural = pluralize(name, value);\n  return `${number} ${plural}`;\n};\n/**\r\n * Returns the value formatted to formatInt followed by a name, pluralized based on the value input.\r\n * @param  {string} name                  - name to pluralize and display after {value}\r\n * @param  {number|Decimal} value         - number to format\r\n * @return {string} - the formatted {value} followed by the {name} after having been pluralized based on the {value}\r\n */\n\n\nwindow.quantifyInt = function quantifyInt(name, value) {\n  if (name === undefined || value === undefined) throw \"Arguments must be defined\";\n  const number = formatInt(value);\n  const plural = pluralize(name, value);\n  return `${number} ${plural}`;\n};\n/**\r\n * Creates an enumated string, using the oxford comma, such that \"a\"; \"a and b\"; \"a, b, and c\"\r\n * @param  {string[]} items - an array of items to enumerate\r\n * @return {string} - a string of {items}, separated by commas and/or and as needed.\r\n */\n\n\nwindow.makeEnumeration = function makeEnumeration(items) {\n  if (items.length === 0) return \"\";\n  if (items.length === 1) return items[0];\n  if (items.length === 2) return `${items[0]} and ${items[1]}`;\n  const commaSeparated = items.slice(0, items.length - 1).join(\", \");\n  const last = items[items.length - 1];\n  return `${commaSeparated}, and ${last}`;\n};","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/format.js"],"names":["isEND","threshold","GameEnd","endState","END_STATE_MARKERS","END_NUMBERS","FADE_AWAY","player","celestials","pelle","doomed","Math","random","window","format","value","places","placesUnder1000","Notations","current","formatInt","isPainful","name","formatWithCommas","toFixed","toNumber","formatFloat","digits","max","formatPostBreak","notation","Number","isFinite","infinite","decimal","Decimal","fromValue_noAlloc","exponent","sign","formatVerySmallNegativeDecimal","abs","formatVerySmallDecimal","number","formatNegativeUnder1000","formatUnder1000","formatNegativeDecimal","formatDecimal","formatX","formatPow","formatPercents","formatRarity","endsWith","formatMachines","realPart","imagPart","parts","neq","push","eq","join","timeDisplay","ms","TimeSpan","fromMilliseconds","toString","timeDisplayNoDecimals","toStringNoDecimals","timeDisplayShort","toStringShort","commaRegexp","decimalPointSplit","split","replace","isSingular","amount","PLURAL_HELPER","Map","pluralDatabase","pluralize","word","plural","undefined","existingPlural","get","newWord","generatePlural","set","match","replaceWith","entries","quantify","formatType","quantifyInt","makeEnumeration","items","length","commaSeparated","slice","last"],"mappings":"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","sourcesContent":["function isEND() {\r\n  const threshold = GameEnd.endState > END_STATE_MARKERS.END_NUMBERS\r\n    ? 1\r\n    : (GameEnd.endState - END_STATE_MARKERS.FADE_AWAY) / 2;\r\n  // Using the Pelle.isDoomed getter here causes this to not update properly after a game restart\r\n  return player.celestials.pelle.doomed && Math.random() < threshold;\r\n}\r\n\r\nwindow.format = function format(value, places = 0, placesUnder1000 = 0) {\r\n  if (isEND()) return \"END\";\r\n  return Notations.current.format(value, places, placesUnder1000, 3);\r\n};\r\n\r\nwindow.formatInt = function formatInt(value) {\r\n  if (isEND()) return \"END\";\r\n  // Suppress painful formatting for Standard because it's the most commonly used and arguably \"least painful\"\r\n  // of the painful notations. Prevents numbers like 5004 from appearing imprecisely as \"5.00 K\" for example\r\n  if (Notations.current.isPainful && Notations.current.name !== \"Standard\") {\r\n    return format(value, 2);\r\n  }\r\n  return formatWithCommas(typeof value === \"number\" ? value.toFixed(0) : value.toNumber().toFixed(0));\r\n};\r\n\r\nwindow.formatFloat = function formatFloat(value, digits) {\r\n  if (isEND()) return \"END\";\r\n  if (Notations.current.isPainful) {\r\n    return format(value, Math.max(2, digits), digits);\r\n  }\r\n  return formatWithCommas(value.toFixed(digits));\r\n};\r\n\r\nwindow.formatPostBreak = function formatPostBreak(value, places, placesUnder1000) {\r\n  if (isEND()) return \"END\";\r\n  const notation = Notations.current;\r\n  // This is basically just a copy of the format method from notations library,\r\n  // with the pre-break case removed.\r\n  if (typeof value === \"number\" && !Number.isFinite(value)) {\r\n    return notation.infinite;\r\n  }\r\n\r\n  const decimal = Decimal.fromValue_noAlloc(value);\r\n\r\n  if (decimal.exponent < -300) {\r\n    return decimal.sign() < 0\r\n      ? notation.formatVerySmallNegativeDecimal(decimal.abs(), placesUnder1000)\r\n      : notation.formatVerySmallDecimal(decimal, placesUnder1000);\r\n  }\r\n\r\n  if (decimal.exponent < 3) {\r\n    const number = decimal.toNumber();\r\n    return number < 0\r\n      ? notation.formatNegativeUnder1000(Math.abs(number), placesUnder1000)\r\n      : notation.formatUnder1000(number, placesUnder1000);\r\n  }\r\n\r\n  return decimal.sign() < 0\r\n    ? notation.formatNegativeDecimal(decimal.abs(), places)\r\n    : notation.formatDecimal(decimal, places);\r\n};\r\n\r\nwindow.formatX = function formatX(value, places, placesUnder1000) {\r\n  return `×${format(value, places, placesUnder1000)}`;\r\n};\r\n\r\nwindow.formatPow = function formatPow(value, places, placesUnder1000) {\r\n  return `^${format(value, places, placesUnder1000)}`;\r\n};\r\n\r\nwindow.formatPercents = function formatPercents(value, places) {\r\n  return `${format(value * 100, 2, places)}%`;\r\n};\r\n\r\nwindow.formatRarity = function formatRarity(value) {\r\n  // We can, annoyingly, have rounding error here, so even though only rarities\r\n  // are passed in, we can't trust our input to always be some integer divided by 10.\r\n  const places = value.toFixed(1).endsWith(\".0\") ? 0 : 1;\r\n  return `${format(value, 2, places)}%`;\r\n};\r\n\r\n// We assume 2/0, 2/2 decimal places to keep parameter count sensible; this is used very rarely\r\nwindow.formatMachines = function formatMachines(realPart, imagPart) {\r\n  if (isEND()) return \"END\";\r\n  const parts = [];\r\n  if (Decimal.neq(realPart, 0)) parts.push(format(realPart, 2));\r\n  if (Decimal.neq(imagPart, 0)) parts.push(`${format(imagPart, 2, 2)}i`);\r\n  // This function is used for just RM and just iM in a few spots, so we have to push both parts conditionally\r\n  // Nonetheless, we also need to special-case both zero so that it doesn't end up displaying as an empty string\r\n  if (Decimal.eq(realPart, 0) && Decimal.eq(imagPart, 0)) return format(0);\r\n  return parts.join(\" + \");\r\n};\r\n\r\nwindow.timeDisplay = function timeDisplay(ms) {\r\n  return TimeSpan.fromMilliseconds(ms).toString();\r\n};\r\n\r\nwindow.timeDisplayNoDecimals = function timeDisplayNoDecimals(ms) {\r\n  return TimeSpan.fromMilliseconds(ms).toStringNoDecimals();\r\n};\r\n\r\nwindow.timeDisplayShort = function timeDisplayShort(ms) {\r\n  return TimeSpan.fromMilliseconds(ms).toStringShort();\r\n};\r\n\r\nconst commaRegexp = /\\B(?=(\\d{3})+(?!\\d))/gu;\r\nwindow.formatWithCommas = function formatWithCommas(value) {\r\n  const decimalPointSplit = value.toString().split(\".\");\r\n  decimalPointSplit[0] = decimalPointSplit[0].replace(commaRegexp, \",\");\r\n  return decimalPointSplit.join(\".\");\r\n};\r\n\r\n/**\r\n * Check if a number or Decimal is equal to 1.\r\n * @param  {number|Decimal} amount\r\n * @return {Boolean} - if the {amount} was equal to 1.\r\n */\r\nwindow.isSingular = function isSingular(amount) {\r\n  if (typeof amount === \"number\") return amount === 1;\r\n  if (amount instanceof Decimal) return amount.eq(1);\r\n  throw `Amount must be either a number or Decimal. Instead, amount was ${amount}`;\r\n};\r\n\r\n// Some letters in the english language pluralize in a different manner than simply adding an 's' to the end.\r\n// As such, the regex match should be placed in the first location, followed by the desired string it\r\n// should be replaced with. Note that $ refers to the EndOfLine for regex, and should be included if the plural occurs\r\n// at the end of the string provided, which will be 99% of times. Not including it is highly likely to cause mistakes,\r\n// as it will select the first instance that matches and replace that.\r\nconst PLURAL_HELPER = new Map([\r\n  [/y$/u, \"ies\"],\r\n  [/x$/u, \"xes\"],\r\n  [/$/u, \"s\"]\r\n]);\r\n\r\n// Some terms require specific (or no) handling when plural. These terms should be added, in Word Case, to this Map.\r\n// Words will be added to this Map when a valid plural for it is found on being run through the pluralize function.\r\nconst pluralDatabase = new Map([\r\n  [\"Antimatter\", \"Antimatter\"],\r\n  [\"Dilated Time\", \"Dilated Time\"],\r\n]);\r\n\r\n/**\r\n * A function that pluralizes a word based on a designated amount\r\n * @param  {string} word           - word to be pluralized\r\n * @param  {number|Decimal} amount - amount to be used to determine if the value is plural\r\n * @param  {string} [plural]       - if defined, a specific plural to override the generated plural\r\n * @return {string} - if the {amount} is anything other than one, return the {plural} provided or the\r\n *                    plural form of the input {word}. If the {amount} is singular, return {word}\r\n */\r\nwindow.pluralize = function pluralize(word, amount, plural) {\r\n  if (word === undefined || amount === undefined) throw \"Arguments must be defined\";\r\n\r\n  if (isSingular(amount)) return word;\r\n  const existingPlural = plural ?? pluralDatabase.get(word);\r\n  if (existingPlural !== undefined) return existingPlural;\r\n\r\n  const newWord = generatePlural(word);\r\n  pluralDatabase.set(word, newWord);\r\n  return newWord;\r\n};\r\n\r\n/**\r\n * Creates a new plural based on PLURAL_HELPER and adds it to pluralDatabase\r\n * @param  {string} word - a word to be pluralized using the regex in PLURAL_HELPER\r\n * @return {string} - returns the pluralized word. if no pluralized word is found, simply returns the word itself.\r\n */\r\nwindow.generatePlural = function generatePlural(word) {\r\n  for (const [match, replaceWith] of PLURAL_HELPER.entries()) {\r\n    const newWord = word.replace(match, replaceWith);\r\n    if (word !== newWord) return newWord;\r\n  }\r\n  return word;\r\n};\r\n\r\n/**\r\n * Returns the formatted value followed by a name, pluralized based on the value input.\r\n * @param  {string} name                  - name to pluralize and display after {value}\r\n * @param  {number|Decimal} value         - number to {format}\r\n * @param  {number} [places]              - number of places to display for the mantissa\r\n * @param  {number} [placesUnder1000]     - number of decimal places to display\r\n * @param  {function} [formatType=format] - how to format the {value}. defaults to format\r\n * @return {string} - the formatted {value} followed by the {name} after having been pluralized based on the {value}\r\n */\r\n// eslint-disable-next-line max-params\r\nwindow.quantify = function quantify(name, value, places, placesUnder1000, formatType = format) {\r\n  if (name === undefined || value === undefined) throw \"Arguments must be defined\";\r\n\r\n  const number = formatType(value, places, placesUnder1000);\r\n  const plural = pluralize(name, value);\r\n  return `${number} ${plural}`;\r\n};\r\n\r\n/**\r\n * Returns the value formatted to formatInt followed by a name, pluralized based on the value input.\r\n * @param  {string} name                  - name to pluralize and display after {value}\r\n * @param  {number|Decimal} value         - number to format\r\n * @return {string} - the formatted {value} followed by the {name} after having been pluralized based on the {value}\r\n */\r\nwindow.quantifyInt = function quantifyInt(name, value) {\r\n  if (name === undefined || value === undefined) throw \"Arguments must be defined\";\r\n\r\n  const number = formatInt(value);\r\n  const plural = pluralize(name, value);\r\n  return `${number} ${plural}`;\r\n};\r\n\r\n/**\r\n * Creates an enumated string, using the oxford comma, such that \"a\"; \"a and b\"; \"a, b, and c\"\r\n * @param  {string[]} items - an array of items to enumerate\r\n * @return {string} - a string of {items}, separated by commas and/or and as needed.\r\n */\r\nwindow.makeEnumeration = function makeEnumeration(items) {\r\n  if (items.length === 0) return \"\";\r\n  if (items.length === 1) return items[0];\r\n  if (items.length === 2) return `${items[0]} and ${items[1]}`;\r\n  const commaSeparated = items.slice(0, items.length - 1).join(\", \");\r\n  const last = items[items.length - 1];\r\n  return `${commaSeparated}, and ${last}`;\r\n};\r\n"]},"metadata":{},"sourceType":"script"}