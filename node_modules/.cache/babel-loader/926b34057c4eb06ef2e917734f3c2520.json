{"ast":null,"code":"import \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport GlyphSetPreview from \"@/components/GlyphSetPreview\";\nimport ToggleButton from \"@/components/ToggleButton\";\nexport default {\n  name: \"GlyphSetSavePanel\",\n  components: {\n    ToggleButton,\n    GlyphSetPreview\n  },\n\n  data() {\n    return {\n      hasEquipped: true,\n      glyphSets: [],\n      names: [],\n      effects: false,\n      rarity: false,\n      level: false\n    };\n  },\n\n  computed: {\n    questionmarkTooltip() {\n      return `Glyph Presets work like Time Study Loadouts, allowing you to equip a\n        full set of previously-saved Glyphs`;\n    },\n\n    noSet() {\n      return `No Glyph Preset saved in this slot`;\n    }\n\n  },\n  watch: {\n    effects(newValue) {\n      player.options.ignoreGlyphEffects = newValue;\n    },\n\n    rarity(newValue) {\n      player.options.ignoreGlyphRarity = newValue;\n    },\n\n    level(newValue) {\n      player.options.ignoreGlyphLevel = newValue;\n    }\n\n  },\n\n  created() {\n    this.on$(GAME_EVENT.GLYPHS_EQUIPPED_CHANGED, this.refreshGlyphSets);\n    this.on$(GAME_EVENT.GLYPH_SET_SAVE_CHANGE, this.refreshGlyphSets);\n    this.refreshGlyphSets();\n\n    for (let i = 0; i < player.reality.glyphs.sets.length; i++) {\n      this.names[i] = player.reality.glyphs.sets[i].name;\n    }\n  },\n\n  methods: {\n    update() {\n      this.hasEquipped = Glyphs.activeList.length > 0;\n      this.effects = player.options.ignoreGlyphEffects;\n      this.rarity = player.options.ignoreGlyphRarity;\n      this.level = player.options.ignoreGlyphLevel;\n    },\n\n    refreshGlyphSets() {\n      this.glyphSets = player.reality.glyphs.sets.map(g => Glyphs.copyForRecords(g.glyphs));\n    },\n\n    setName(id) {\n      const name = this.names[id] === \"\" ? \"\" : `: ${this.names[id]}`;\n      return `Glyph Preset #${id + 1}${name}`;\n    },\n\n    saveGlyphSet(id) {\n      if (!this.hasEquipped || player.reality.glyphs.sets[id].glyphs.length) return;\n      player.reality.glyphs.sets[id].glyphs = Glyphs.active.compact();\n      this.refreshGlyphSets();\n      EventHub.dispatch(GAME_EVENT.GLYPH_SET_SAVE_CHANGE);\n    },\n\n    // A proper full solution to this turns out to contain an NP-hard problem as a subproblem, so instead we do\n    // something which should work in most cases - we match greedily when it won't obviously lead to an incomplete\n    // preset match, and leniently when matching greedily may lead to an incomplete set being loaded\n    loadGlyphSet(set, id) {\n      if (!this.setLengthValid(set)) return;\n      let glyphsToLoad = [...set].sort((a, b) => -a.level * a.strength + b.level * b.strength);\n      const activeGlyphs = [...Glyphs.active.filter(g => g)]; // Create an array where each entry contains a single active glyph and all its matches in the preset which it\n      // could fill in for, based on the preset loading settings\n\n      const activeOptions = [];\n\n      for (const glyph of activeGlyphs) {\n        const options = Glyphs.findByValues(glyph, glyphsToLoad, {\n          level: this.level ? -1 : 0,\n          strength: this.rarity ? -1 : 0,\n          effects: this.effects ? -1 : 0\n        });\n        activeOptions.push({\n          glyph,\n          options\n        });\n      } // Using the active glyphs one by one, select matching to-be-loaded preset glyphs to be removed from the list.\n      // This makes sure the inventory doesn't attempt to match a glyph which is already satisfied by an equipped one\n\n\n      const selectedFromActive = this.findSelectedGlyphs(activeOptions, 5);\n\n      for (const glyph of selectedFromActive) glyphsToLoad = glyphsToLoad.filter(g => g !== glyph); // For the remaining glyphs to load from the preset, find all their appropriate matches within the inventory.\n      // This is largely the same as earlier with the equipped glyphs\n\n\n      const remainingOptions = [];\n\n      for (let index = 0; index < glyphsToLoad.length; index++) {\n        const glyph = glyphsToLoad[index];\n        const options = Glyphs.findByValues(glyph, Glyphs.sortedInventoryList, {\n          level: this.level ? 1 : 0,\n          strength: this.rarity ? 1 : 0,\n          effects: this.effects ? 1 : 0\n        });\n        remainingOptions[index] = {\n          glyph,\n          options\n        };\n      } // This is scanned through similarly to the active slot glyphs, except we need to make sure we don't try to\n      // match more glyphs than we have room for\n\n\n      const selectedFromInventory = this.findSelectedGlyphs(remainingOptions, Glyphs.active.countWhere(g => g === null));\n\n      for (const glyph of selectedFromInventory) glyphsToLoad = glyphsToLoad.filter(g => g !== glyph); // Actually equip the glyphs and then notify how successful (or not) the loading was\n\n\n      let missingGlyphs = glyphsToLoad.length;\n\n      for (const glyph of selectedFromInventory) {\n        const idx = Glyphs.active.indexOf(null);\n\n        if (idx !== -1) {\n          Glyphs.equip(glyph, idx);\n          missingGlyphs--;\n        }\n      }\n\n      if (missingGlyphs > 0) {\n        GameUI.notify.error(`Could not find or equip ${missingGlyphs} ${pluralize(\"Glyph\", missingGlyphs)} from\n          ${this.setName(id)}.`);\n      } else {\n        GameUI.notify.success(`Successfully loaded ${this.setName(id)}.`);\n      }\n    },\n\n    // Given a list of options for suitable matches to those glyphs and a maximum glyph count to match, returns the\n    // set of glyphs which should be loaded. This is a tricky matching process to do since on one hand we don't want\n    // early matches to prevent later ones, but on the other hand matching too leniently can cause any passed-on later\n    // requirements to be too strict (eg. preset 1234 and equipped 234 could match 123, leaving an unmatchable 4).\n    // The compromise solution here is to check how many choices the next-strictest option list has - if it only has\n    // one choice then we pick conservatively (the weakest glyph) - otherwise we pick greedily (the strongest glyph).\n    findSelectedGlyphs(optionList, maxGlyphs) {\n      // We do a weird composite function here in order to make sure that glyphs get treated by type individually; then\n      // within type they are generally ordered in strictest to most lenient in terms of matches. Note that the options\n      // are sorted internally starting with the strictest match first\n      const compFn = o => 1000 * (10 * o.glyph.type.length + o.glyph.type.codePointAt(0)) + o.options.length;\n\n      optionList.sort((a, b) => compFn(a) - compFn(b));\n      const toLoad = [];\n      let slotsLeft = maxGlyphs;\n\n      for (let index = 0; index < optionList.length; index++) {\n        if (slotsLeft === 0) break;\n        const entry = optionList[index];\n        const filteredOptions = entry.options.filter(g => !toLoad.includes(g));\n        if (filteredOptions.length === 0) continue;\n        const selectedGlyph = filteredOptions[filteredOptions.length - 1];\n        toLoad.push(selectedGlyph);\n        slotsLeft--;\n      }\n\n      return toLoad;\n    },\n\n    deleteGlyphSet(id) {\n      if (!player.reality.glyphs.sets[id].glyphs.length) return;\n      if (player.options.confirmations.deleteGlyphSetSave) Modal.glyphSetSaveDelete.show({\n        glyphSetId: id\n      });else {\n        player.reality.glyphs.sets[id].glyphs = [];\n        this.refreshGlyphSets();\n        EventHub.dispatch(GAME_EVENT.GLYPH_SET_SAVE_CHANGE);\n      }\n    },\n\n    nicknameBlur(event) {\n      player.reality.glyphs.sets[event.target.id].name = event.target.value.slice(0, 20);\n      this.names[event.target.id] = player.reality.glyphs.sets[event.target.id].name;\n      this.refreshGlyphSets();\n    },\n\n    setLengthValid(set) {\n      return set.length && set.length <= Glyphs.activeSlotCount;\n    },\n\n    loadingTooltip(set) {\n      return this.setLengthValid(set) && this.hasEquipped ? \"This set may not load properly because you already have some Glyphs equipped\" : null;\n    },\n\n    glyphSetKey(set, index) {\n      return `${index} ${Glyphs.hash(set)}`;\n    }\n\n  }\n};","map":{"version":3,"sources":["GlyphSetSavePanel.vue"],"names":[],"mappings":"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","sourcesContent":["<script>\r\nimport GlyphSetPreview from \"@/components/GlyphSetPreview\";\r\nimport ToggleButton from \"@/components/ToggleButton\";\r\n\r\nexport default {\r\n  name: \"GlyphSetSavePanel\",\r\n  components: {\r\n    ToggleButton,\r\n    GlyphSetPreview\r\n  },\r\n  data() {\r\n    return {\r\n      hasEquipped: true,\r\n      glyphSets: [],\r\n      names: [],\r\n      effects: false,\r\n      rarity: false,\r\n      level: false,\r\n    };\r\n  },\r\n  computed: {\r\n    questionmarkTooltip() {\r\n      return `Glyph Presets work like Time Study Loadouts, allowing you to equip a\r\n        full set of previously-saved Glyphs`;\r\n    },\r\n    noSet() {\r\n      return `No Glyph Preset saved in this slot`;\r\n    },\r\n  },\r\n  watch: {\r\n    effects(newValue) {\r\n      player.options.ignoreGlyphEffects = newValue;\r\n    },\r\n    rarity(newValue) {\r\n      player.options.ignoreGlyphRarity = newValue;\r\n    },\r\n    level(newValue) {\r\n      player.options.ignoreGlyphLevel = newValue;\r\n    },\r\n  },\r\n  created() {\r\n    this.on$(GAME_EVENT.GLYPHS_EQUIPPED_CHANGED, this.refreshGlyphSets);\r\n    this.on$(GAME_EVENT.GLYPH_SET_SAVE_CHANGE, this.refreshGlyphSets);\r\n    this.refreshGlyphSets();\r\n    for (let i = 0; i < player.reality.glyphs.sets.length; i++) {\r\n      this.names[i] = player.reality.glyphs.sets[i].name;\r\n    }\r\n  },\r\n  methods: {\r\n    update() {\r\n      this.hasEquipped = Glyphs.activeList.length > 0;\r\n      this.effects = player.options.ignoreGlyphEffects;\r\n      this.rarity = player.options.ignoreGlyphRarity;\r\n      this.level = player.options.ignoreGlyphLevel;\r\n    },\r\n    refreshGlyphSets() {\r\n      this.glyphSets = player.reality.glyphs.sets.map(g => Glyphs.copyForRecords(g.glyphs));\r\n    },\r\n    setName(id) {\r\n      const name = this.names[id] === \"\" ? \"\" : `: ${this.names[id]}`;\r\n      return `Glyph Preset #${id + 1}${name}`;\r\n    },\r\n    saveGlyphSet(id) {\r\n      if (!this.hasEquipped || player.reality.glyphs.sets[id].glyphs.length) return;\r\n      player.reality.glyphs.sets[id].glyphs = Glyphs.active.compact();\r\n      this.refreshGlyphSets();\r\n      EventHub.dispatch(GAME_EVENT.GLYPH_SET_SAVE_CHANGE);\r\n    },\r\n    // A proper full solution to this turns out to contain an NP-hard problem as a subproblem, so instead we do\r\n    // something which should work in most cases - we match greedily when it won't obviously lead to an incomplete\r\n    // preset match, and leniently when matching greedily may lead to an incomplete set being loaded\r\n    loadGlyphSet(set, id) {\r\n      if (!this.setLengthValid(set)) return;\r\n      let glyphsToLoad = [...set].sort((a, b) => -a.level * a.strength + b.level * b.strength);\r\n      const activeGlyphs = [...Glyphs.active.filter(g => g)];\r\n\r\n      // Create an array where each entry contains a single active glyph and all its matches in the preset which it\r\n      // could fill in for, based on the preset loading settings\r\n      const activeOptions = [];\r\n      for (const glyph of activeGlyphs) {\r\n        const options = Glyphs.findByValues(glyph, glyphsToLoad, {\r\n          level: this.level ? -1 : 0,\r\n          strength: this.rarity ? -1 : 0,\r\n          effects: this.effects ? -1 : 0\r\n        });\r\n        activeOptions.push({ glyph, options });\r\n      }\r\n\r\n      // Using the active glyphs one by one, select matching to-be-loaded preset glyphs to be removed from the list.\r\n      // This makes sure the inventory doesn't attempt to match a glyph which is already satisfied by an equipped one\r\n      const selectedFromActive = this.findSelectedGlyphs(activeOptions, 5);\r\n      for (const glyph of selectedFromActive) glyphsToLoad = glyphsToLoad.filter(g => g !== glyph);\r\n\r\n      // For the remaining glyphs to load from the preset, find all their appropriate matches within the inventory.\r\n      // This is largely the same as earlier with the equipped glyphs\r\n      const remainingOptions = [];\r\n      for (let index = 0; index < glyphsToLoad.length; index++) {\r\n        const glyph = glyphsToLoad[index];\r\n        const options = Glyphs.findByValues(glyph, Glyphs.sortedInventoryList, {\r\n          level: this.level ? 1 : 0,\r\n          strength: this.rarity ? 1 : 0,\r\n          effects: this.effects ? 1 : 0\r\n        });\r\n        remainingOptions[index] = { glyph, options };\r\n      }\r\n\r\n      // This is scanned through similarly to the active slot glyphs, except we need to make sure we don't try to\r\n      // match more glyphs than we have room for\r\n      const selectedFromInventory = this.findSelectedGlyphs(remainingOptions,\r\n        Glyphs.active.countWhere(g => g === null));\r\n      for (const glyph of selectedFromInventory) glyphsToLoad = glyphsToLoad.filter(g => g !== glyph);\r\n\r\n      // Actually equip the glyphs and then notify how successful (or not) the loading was\r\n      let missingGlyphs = glyphsToLoad.length;\r\n      for (const glyph of selectedFromInventory) {\r\n        const idx = Glyphs.active.indexOf(null);\r\n        if (idx !== -1) {\r\n          Glyphs.equip(glyph, idx);\r\n          missingGlyphs--;\r\n        }\r\n      }\r\n      if (missingGlyphs > 0) {\r\n        GameUI.notify.error(`Could not find or equip ${missingGlyphs} ${pluralize(\"Glyph\", missingGlyphs)} from\r\n          ${this.setName(id)}.`);\r\n      } else {\r\n        GameUI.notify.success(`Successfully loaded ${this.setName(id)}.`);\r\n      }\r\n    },\r\n    // Given a list of options for suitable matches to those glyphs and a maximum glyph count to match, returns the\r\n    // set of glyphs which should be loaded. This is a tricky matching process to do since on one hand we don't want\r\n    // early matches to prevent later ones, but on the other hand matching too leniently can cause any passed-on later\r\n    // requirements to be too strict (eg. preset 1234 and equipped 234 could match 123, leaving an unmatchable 4).\r\n    // The compromise solution here is to check how many choices the next-strictest option list has - if it only has\r\n    // one choice then we pick conservatively (the weakest glyph) - otherwise we pick greedily (the strongest glyph).\r\n    findSelectedGlyphs(optionList, maxGlyphs) {\r\n      // We do a weird composite function here in order to make sure that glyphs get treated by type individually; then\r\n      // within type they are generally ordered in strictest to most lenient in terms of matches. Note that the options\r\n      // are sorted internally starting with the strictest match first\r\n      const compFn = o => 1000 * (10 * o.glyph.type.length + o.glyph.type.codePointAt(0)) + o.options.length;\r\n      optionList.sort((a, b) => compFn(a) - compFn(b));\r\n\r\n      const toLoad = [];\r\n      let slotsLeft = maxGlyphs;\r\n      for (let index = 0; index < optionList.length; index++) {\r\n        if (slotsLeft === 0) break;\r\n        const entry = optionList[index];\r\n\r\n        const filteredOptions = entry.options.filter(g => !toLoad.includes(g));\r\n        if (filteredOptions.length === 0) continue;\r\n        const selectedGlyph = filteredOptions[filteredOptions.length - 1];\r\n        toLoad.push(selectedGlyph);\r\n        slotsLeft--;\r\n      }\r\n      return toLoad;\r\n    },\r\n    deleteGlyphSet(id) {\r\n      if (!player.reality.glyphs.sets[id].glyphs.length) return;\r\n      if (player.options.confirmations.deleteGlyphSetSave) Modal.glyphSetSaveDelete.show({ glyphSetId: id });\r\n      else {\r\n        player.reality.glyphs.sets[id].glyphs = [];\r\n        this.refreshGlyphSets();\r\n        EventHub.dispatch(GAME_EVENT.GLYPH_SET_SAVE_CHANGE);\r\n      }\r\n    },\r\n    nicknameBlur(event) {\r\n      player.reality.glyphs.sets[event.target.id].name = event.target.value.slice(0, 20);\r\n      this.names[event.target.id] = player.reality.glyphs.sets[event.target.id].name;\r\n      this.refreshGlyphSets();\r\n    },\r\n    setLengthValid(set) {\r\n      return set.length && set.length <= Glyphs.activeSlotCount;\r\n    },\r\n    loadingTooltip(set) {\r\n      return this.setLengthValid(set) && this.hasEquipped\r\n        ? \"This set may not load properly because you already have some Glyphs equipped\"\r\n        : null;\r\n    },\r\n    glyphSetKey(set, index) {\r\n      return `${index} ${Glyphs.hash(set)}`;\r\n    }\r\n  }\r\n};\r\n</script>\r\n\r\n<template>\r\n  <div class=\"l-glyph-sacrifice-options c-glyph-sacrifice-options l-glyph-sidebar-panel-size\">\r\n    <span\r\n      v-tooltip=\"questionmarkTooltip\"\r\n      class=\"l-glyph-sacrifice-options__help c-glyph-sacrifice-options__help o-questionmark\"\r\n    >\r\n      ?\r\n    </span>\r\n    <div class=\"l-glyph-set-save__header\">\r\n      When loading a preset, try to match the following attributes. \"Exact\" will only equip Glyphs\r\n      identical to the ones in the preset. The other settings will, loosely speaking, allow \"better\" Glyphs to be\r\n      equipped in their place.\r\n    </div>\r\n    <div class=\"c-glyph-set-save-container\">\r\n      <ToggleButton\r\n        v-model=\"effects\"\r\n        class=\"c-glyph-set-save-setting-button\"\r\n        label=\"Effects:\"\r\n        on=\"Including\"\r\n        off=\"Exact\"\r\n      />\r\n      <ToggleButton\r\n        v-model=\"level\"\r\n        class=\"c-glyph-set-save-setting-button\"\r\n        label=\"Level:\"\r\n        on=\"Increased\"\r\n        off=\"Exact\"\r\n      />\r\n      <ToggleButton\r\n        v-model=\"rarity\"\r\n        class=\"c-glyph-set-save-setting-button\"\r\n        label=\"Rarity:\"\r\n        on=\"Increased\"\r\n        off=\"Exact\"\r\n      />\r\n    </div>\r\n    <div\r\n      v-for=\"(set, id) in glyphSets\"\r\n      :key=\"id\"\r\n      class=\"c-glyph-single-set-save\"\r\n    >\r\n      <div class=\"c-glyph-set-preview-area\">\r\n        <GlyphSetPreview\r\n          :key=\"glyphSetKey(set, id)\"\r\n          :text=\"setName(id)\"\r\n          :text-hidden=\"true\"\r\n          :glyphs=\"set\"\r\n          :flip-tooltip=\"true\"\r\n          :none-text=\"noSet\"\r\n        />\r\n      </div>\r\n      <div class=\"c-glyph-single-set-save-flexbox\">\r\n        <div ach-tooltip=\"Set a custom name (up to 20 characters)\">\r\n          <input\r\n            :id=\"id\"\r\n            type=\"text\"\r\n            size=\"20\"\r\n            maxlength=\"20\"\r\n            placeholder=\"Custom set name\"\r\n            class=\"c-glyph-sets-save-name__input\"\r\n            :value=\"names[id]\"\r\n            @blur=\"nicknameBlur\"\r\n          >\r\n        </div>\r\n        <div class=\"c-glyph-single-set-save-flexbox-buttons\">\r\n          <button\r\n            class=\"c-glyph-set-save-button\"\r\n            :class=\"{'c-glyph-set-save-button--unavailable': !hasEquipped || set.length}\"\r\n            @click=\"saveGlyphSet(id)\"\r\n          >\r\n            Save\r\n          </button>\r\n          <button\r\n            v-tooltip=\"loadingTooltip(set)\"\r\n            class=\"c-glyph-set-save-button\"\r\n            :class=\"{'c-glyph-set-save-button--unavailable': !setLengthValid(set)}\"\r\n            @click=\"loadGlyphSet(set, id)\"\r\n          >\r\n            Load\r\n          </button>\r\n          <button\r\n            class=\"c-glyph-set-save-button\"\r\n            :class=\"{'c-glyph-set-save-button--unavailable': !set.length}\"\r\n            @click=\"deleteGlyphSet(id)\"\r\n          >\r\n            Delete\r\n          </button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<style scoped>\r\n.l-glyph-set-save__header {\r\n  margin: -1.5rem 2rem 0;\r\n}\r\n\r\n.c-glyph-set-save-container {\r\n  display: flex;\r\n  flex-wrap: wrap;\r\n  width: 100%;\r\n  justify-content: center;\r\n  margin: 1rem auto 0;\r\n}\r\n\r\n.c-glyph-single-set-save-flexbox {\r\n  width: 17rem;\r\n}\r\n\r\n.c-glyph-set-preview-area {\r\n  width: 18rem;\r\n}\r\n</style>\r\n"],"sourceRoot":"src/components/tabs/glyphs/sidebar"},"metadata":{},"sourceType":"module"}