{"ast":null,"code":"import _objectSpread from \"C:/Games/ADFasterer/ADfasterer/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nexport default {\n  name: \"AutomatorDocsTemplateList\",\n\n  data() {\n    return {\n      isBlock: false,\n      blockTemplates: [],\n      selectedTemplateID: -1\n    };\n  },\n\n  computed: {\n    templates: () => GameDatabase.reality.automator.templates.scripts,\n\n    pasteText() {\n      return this.isBlock ? `create a special block you can drag into your Automator where you would like it to be placed. It will then\n          automatically fill in all of the individual blocks needed for the template` : `copy the template as text onto your clipboard. You can directly paste the template text into your Automator\n          wherever you would like it`;\n    }\n\n  },\n  methods: {\n    update() {\n      this.isBlock = player.reality.automator.type === AUTOMATOR_TYPE.BLOCK;\n      this.blockTemplates = AutomatorData.blockTemplates;\n    },\n\n    showModal(template) {\n      Modal.automatorScriptTemplate.show(template);\n    },\n\n    unpackTemplateBlocks(event) {\n      const templateBlocks = this.blockTemplates[this.selectedTemplateID].blocks;\n      const beforeBlocks = BlockAutomator.lines.slice(0, event.newIndex); // Note that slice will also pick up the Vue observer, so we need to remove that as well\n\n      const afterBlocks = BlockAutomator.lines.slice(event.newIndex).filter(b => b.cmd); // Remap IDs, in case the template gets added more than once\n\n      const maxExistingID = Math.max(...BlockAutomator._idArray.filter(id => id));\n      const minTemplateID = Math.min(...templateBlocks.map(b => b.id));\n      const blocksToAdd = [];\n\n      for (const block of templateBlocks) {\n        blocksToAdd.push(_objectSpread(_objectSpread({}, block), {}, {\n          id: block.id + maxExistingID - minTemplateID + 1\n        }));\n      }\n\n      BlockAutomator.lines = beforeBlocks;\n      BlockAutomator.lines.push(...blocksToAdd);\n      BlockAutomator.lines.push(...afterBlocks);\n      BlockAutomator.updateIdArray();\n    },\n\n    setIndex(index) {\n      this.selectedTemplateID = index;\n    }\n\n  }\n};","map":{"version":3,"sources":["AutomatorDocsTemplateList.vue"],"names":[],"mappings":";;AACA,eAAA;AACA,EAAA,IAAA,EAAA,2BADA;;AAEA,EAAA,IAAA,GAAA;AACA,WAAA;AACA,MAAA,OAAA,EAAA,KADA;AAEA,MAAA,cAAA,EAAA,EAFA;AAGA,MAAA,kBAAA,EAAA,CAAA;AAHA,KAAA;AAKA,GARA;;AASA,EAAA,QAAA,EAAA;AACA,IAAA,SAAA,EAAA,MAAA,YAAA,CAAA,OAAA,CAAA,SAAA,CAAA,SAAA,CAAA,OADA;;AAEA,IAAA,SAAA,GAAA;AACA,aAAA,KAAA,OAAA,GACA;AACA,qFAFA,GAGA;AACA,qCAJA;AAKA;;AARA,GATA;AAmBA,EAAA,OAAA,EAAA;AACA,IAAA,MAAA,GAAA;AACA,WAAA,OAAA,GAAA,MAAA,CAAA,OAAA,CAAA,SAAA,CAAA,IAAA,KAAA,cAAA,CAAA,KAAA;AACA,WAAA,cAAA,GAAA,aAAA,CAAA,cAAA;AACA,KAJA;;AAKA,IAAA,SAAA,CAAA,QAAA,EAAA;AACA,MAAA,KAAA,CAAA,uBAAA,CAAA,IAAA,CAAA,QAAA;AACA,KAPA;;AAQA,IAAA,oBAAA,CAAA,KAAA,EAAA;AACA,YAAA,cAAA,GAAA,KAAA,cAAA,CAAA,KAAA,kBAAA,EAAA,MAAA;AACA,YAAA,YAAA,GAAA,cAAA,CAAA,KAAA,CAAA,KAAA,CAAA,CAAA,EAAA,KAAA,CAAA,QAAA,CAAA,CAFA,CAGA;;AACA,YAAA,WAAA,GAAA,cAAA,CAAA,KAAA,CAAA,KAAA,CAAA,KAAA,CAAA,QAAA,EAAA,MAAA,CAAA,CAAA,IAAA,CAAA,CAAA,GAAA,CAAA,CAJA,CAMA;;AACA,YAAA,aAAA,GAAA,IAAA,CAAA,GAAA,CAAA,GAAA,cAAA,CAAA,QAAA,CAAA,MAAA,CAAA,EAAA,IAAA,EAAA,CAAA,CAAA;AACA,YAAA,aAAA,GAAA,IAAA,CAAA,GAAA,CAAA,GAAA,cAAA,CAAA,GAAA,CAAA,CAAA,IAAA,CAAA,CAAA,EAAA,CAAA,CAAA;AACA,YAAA,WAAA,GAAA,EAAA;;AACA,WAAA,MAAA,KAAA,IAAA,cAAA,EAAA;AACA,QAAA,WAAA,CAAA,IAAA,iCACA,KADA;AAEA,UAAA,EAAA,EAAA,KAAA,CAAA,EAAA,GAAA,aAAA,GAAA,aAAA,GAAA;AAFA;AAIA;;AACA,MAAA,cAAA,CAAA,KAAA,GAAA,YAAA;AACA,MAAA,cAAA,CAAA,KAAA,CAAA,IAAA,CAAA,GAAA,WAAA;AACA,MAAA,cAAA,CAAA,KAAA,CAAA,IAAA,CAAA,GAAA,WAAA;AACA,MAAA,cAAA,CAAA,aAAA;AACA,KA5BA;;AA6BA,IAAA,QAAA,CAAA,KAAA,EAAA;AACA,WAAA,kBAAA,GAAA,KAAA;AACA;;AA/BA;AAnBA,CAAA","sourcesContent":["<script>\r\nexport default {\r\n  name: \"AutomatorDocsTemplateList\",\r\n  data() {\r\n    return {\r\n      isBlock: false,\r\n      blockTemplates: [],\r\n      selectedTemplateID: -1,\r\n    };\r\n  },\r\n  computed: {\r\n    templates: () => GameDatabase.reality.automator.templates.scripts,\r\n    pasteText() {\r\n      return this.isBlock\r\n        ? `create a special block you can drag into your Automator where you would like it to be placed. It will then\r\n          automatically fill in all of the individual blocks needed for the template`\r\n        : `copy the template as text onto your clipboard. You can directly paste the template text into your Automator\r\n          wherever you would like it`;\r\n    }\r\n  },\r\n  methods: {\r\n    update() {\r\n      this.isBlock = player.reality.automator.type === AUTOMATOR_TYPE.BLOCK;\r\n      this.blockTemplates = AutomatorData.blockTemplates;\r\n    },\r\n    showModal(template) {\r\n      Modal.automatorScriptTemplate.show(template);\r\n    },\r\n    unpackTemplateBlocks(event) {\r\n      const templateBlocks = this.blockTemplates[this.selectedTemplateID].blocks;\r\n      const beforeBlocks = BlockAutomator.lines.slice(0, event.newIndex);\r\n      // Note that slice will also pick up the Vue observer, so we need to remove that as well\r\n      const afterBlocks = BlockAutomator.lines.slice(event.newIndex).filter(b => b.cmd);\r\n\r\n      // Remap IDs, in case the template gets added more than once\r\n      const maxExistingID = Math.max(...BlockAutomator._idArray.filter(id => id));\r\n      const minTemplateID = Math.min(...templateBlocks.map(b => b.id));\r\n      const blocksToAdd = [];\r\n      for (const block of templateBlocks) {\r\n        blocksToAdd.push({\r\n          ...block,\r\n          id: block.id + maxExistingID - minTemplateID + 1\r\n        });\r\n      }\r\n      BlockAutomator.lines = beforeBlocks;\r\n      BlockAutomator.lines.push(...blocksToAdd);\r\n      BlockAutomator.lines.push(...afterBlocks);\r\n      BlockAutomator.updateIdArray();\r\n    },\r\n    setIndex(index) {\r\n      this.selectedTemplateID = index;\r\n    }\r\n  }\r\n};\r\n</script>\r\n\r\n<template>\r\n  <div>\r\n    These templates will let you do some more common things within the Automator. They may be slightly slower than\r\n    manually-written scripts, but don't require you to have any previous programming experience to use. Clicking any\r\n    of these buttons will open up a prompt with some input fields, which will generate a template you can place into\r\n    your Automator.\r\n    <button\r\n      v-for=\"template in templates\"\r\n      :key=\"template.name\"\r\n      class=\"o-primary-btn c-automator-docs-template--button l-automator__button\"\r\n      @click=\"showModal(template)\"\r\n    >\r\n      Template: {{ template.name }}\r\n    </button>\r\n    Since you are currently in the {{ isBlock ? \"Block\" : \"Text\" }} editor, this panel will {{ pasteText }}.\r\n    <br>\r\n    <br>\r\n    <draggable\r\n      v-if=\"isBlock\"\r\n      :key=\"blockTemplates.length\"\r\n      class=\"template-container\"\r\n      :list=\"blockTemplates\"\r\n      :group=\"{ name: 'code-blocks', pull: 'clone', put: false }\"\r\n      :sort=\"false\"\r\n      @end=\"unpackTemplateBlocks\"\r\n    >\r\n      <div\r\n        v-for=\"(template, i) in blockTemplates\"\r\n        :key=\"i\"\r\n        class=\"o-automator-command o-automator-block-list draggable-blocks\"\r\n        @dragstart=\"setIndex(i)\"\r\n      >\r\n        {{ template.name }}\r\n      </div>\r\n    </draggable>\r\n  </div>\r\n</template>\r\n\r\n<style scoped>\r\n.c-automator-docs-template--button {\r\n  margin: 0.4rem;\r\n  border-radius: var(--var-border-radius, 0.4rem);\r\n  border-width: var(--var-border-width, 0.2rem);\r\n  cursor: pointer;\r\n}\r\n\r\n.template-container {\r\n  display: flex;\r\n  flex-direction: column;\r\n}\r\n</style>\r\n"],"sourceRoot":"src/components/tabs/automator"},"metadata":{},"sourceType":"module"}