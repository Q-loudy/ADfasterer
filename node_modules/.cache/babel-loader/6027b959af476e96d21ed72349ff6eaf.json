{"ast":null,"code":"import \"core-js/modules/es.regexp.exec.js\";\nimport { forbiddenConstantPatterns } from \"@/core/automator\";\nexport default {\n  name: \"AutomatorDefineSingleEntry\",\n  props: {\n    constant: {\n      type: String,\n      required: true\n    }\n  },\n\n  data() {\n    return {\n      oldAlias: \"\",\n      aliasString: \"\",\n      valueString: \"\"\n    };\n  },\n\n  computed: {\n    maxNameLength() {\n      return AutomatorData.MAX_ALLOWED_CONSTANT_NAME_LENGTH;\n    },\n\n    maxValueLength() {\n      return AutomatorData.MAX_ALLOWED_CONSTANT_VALUE_LENGTH;\n    }\n\n  },\n\n  created() {\n    this.aliasString = this.constant;\n    this.oldAlias = this.aliasString;\n    this.valueString = player.reality.automator.constants[this.aliasString];\n  },\n\n  methods: {\n    // We combine error checking from both input fields together and only show one of them because showing multiple\n    // errors at once is unnecessary and results in some bad UI overlapping\n    currentError() {\n      if (!this.aliasString) return null;\n      const isValidName = this.aliasString.match(/^[A-Z_a-z][0-9A-Z_a-z]*$/);\n      const alreadyExists = Object.keys(player.reality.automator.constants).includes(this.aliasString) && this.aliasString !== this.oldAlias; // Use toLowerCase() in order to check against key words in a case-insensitive manner; all the stored regex\n      // patterns in forbiddenConstantPatterns which get meaningfully checked against are a mixture of lowercase\n      // letters and regex metacharacters\n\n      const hasCommandConflict = forbiddenConstantPatterns.some(p => {\n        const matchObj = this.aliasString.toLowerCase().match(p);\n        return matchObj ? matchObj[0] === this.aliasString.toLowerCase() : false;\n      });\n      const shadowsPrototype = [\"constructor\", \"hasOwnProperty\", \"isPrototypeOf\", \"propertyIsEnumerable\", \"toLocaleString\", \"toString\", \"toValueOf\"].some(p => this.aliasString.match(p));\n      if (!isValidName) return \"Constant name must be alphanumeric without spaces and cannot start with a number\";\n      if (alreadyExists) return \"You have already defined a constant with this name\";\n      if (hasCommandConflict) return \"Constant name conflicts with a command key word\";\n      if (shadowsPrototype) return \"Constant name cannot shadow a built-in Javascript prototype prop\";\n      if (!this.valueString) return \"Constant value cannot be empty\";\n      const isNumber = this.valueString.match(/^\\x2D?(0|[1-9][0-9]*)(\\.[0-9]+)?([Ee][\\+\\x2D]?[0-9]+)?$/); // Note: Does not do validation for studies existing\n\n      const isStudyString = TimeStudyTree.isValidImportString(this.valueString);\n      if (!isNumber && !isStudyString) return \"Constant value must either be a number or Time Study string\";\n      return null;\n    },\n\n    errorTooltip() {\n      const error = this.currentError();\n      if (!error) return undefined;\n      return {\n        content: `<div class=\"c-block-automator-error\">\n          <div>${error}</div>\n        </div>`,\n        html: true,\n        trigger: \"manual\",\n        show: true,\n        classes: [\"general-tooltip\"]\n      };\n    },\n\n    handleFocus(focus) {\n      if (focus || this.currentError()) return;\n      if (!this.aliasString) AutomatorBackend.deleteConstant(this.oldAlias);else if (!this.oldAlias) AutomatorBackend.addConstant(this.aliasString, this.valueString);else if (this.oldAlias === this.aliasString) AutomatorBackend.modifyConstant(this.aliasString, this.valueString);else AutomatorBackend.renameConstant(this.oldAlias, this.aliasString);\n      this.oldAlias = this.aliasString; // This makes scripts respond immediately to newly-defined constants if the player types them into the\n      // script before defining them here\n\n      AutomatorData.recalculateErrors();\n      if (player.reality.automator.type === AUTOMATOR_TYPE.BLOCK) BlockAutomator.parseTextFromBlocks();\n    },\n\n    deleteConstant() {\n      AutomatorBackend.deleteConstant(this.aliasString);\n      this.oldAlias = \"\";\n      this.aliasString = \"\";\n      this.valueString = \"\";\n    }\n\n  }\n};","map":{"version":3,"sources":["AutomatorDefineSingleEntry.vue"],"names":[],"mappings":"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","sourcesContent":["<script>\r\nimport { forbiddenConstantPatterns } from \"@/core/automator\";\r\n\r\nexport default {\r\n  name: \"AutomatorDefineSingleEntry\",\r\n  props: {\r\n    constant: {\r\n      type: String,\r\n      required: true,\r\n    },\r\n  },\r\n  data() {\r\n    return {\r\n      oldAlias: \"\",\r\n      aliasString: \"\",\r\n      valueString: \"\",\r\n    };\r\n  },\r\n  computed: {\r\n    maxNameLength() {\r\n      return AutomatorData.MAX_ALLOWED_CONSTANT_NAME_LENGTH;\r\n    },\r\n    maxValueLength() {\r\n      return AutomatorData.MAX_ALLOWED_CONSTANT_VALUE_LENGTH;\r\n    },\r\n  },\r\n  created() {\r\n    this.aliasString = this.constant;\r\n    this.oldAlias = this.aliasString;\r\n    this.valueString = player.reality.automator.constants[this.aliasString];\r\n  },\r\n  methods: {\r\n    // We combine error checking from both input fields together and only show one of them because showing multiple\r\n    // errors at once is unnecessary and results in some bad UI overlapping\r\n    currentError() {\r\n      if (!this.aliasString) return null;\r\n\r\n      const isValidName = this.aliasString.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/u);\r\n      const alreadyExists = Object.keys(player.reality.automator.constants).includes(this.aliasString) &&\r\n        this.aliasString !== this.oldAlias;\r\n      // Use toLowerCase() in order to check against key words in a case-insensitive manner; all the stored regex\r\n      // patterns in forbiddenConstantPatterns which get meaningfully checked against are a mixture of lowercase\r\n      // letters and regex metacharacters\r\n      const hasCommandConflict = forbiddenConstantPatterns.some(p => {\r\n        const matchObj = this.aliasString.toLowerCase().match(p);\r\n        return matchObj ? matchObj[0] === this.aliasString.toLowerCase() : false;\r\n      });\r\n      const shadowsPrototype = [\"constructor\", \"hasOwnProperty\", \"isPrototypeOf\", \"propertyIsEnumerable\",\r\n        \"toLocaleString\", \"toString\", \"toValueOf\"].some(p => this.aliasString.match(p));\r\n\r\n      if (!isValidName) return \"Constant name must be alphanumeric without spaces and cannot start with a number\";\r\n      if (alreadyExists) return \"You have already defined a constant with this name\";\r\n      if (hasCommandConflict) return \"Constant name conflicts with a command key word\";\r\n      if (shadowsPrototype) return \"Constant name cannot shadow a built-in Javascript prototype prop\";\r\n\r\n      if (!this.valueString) return \"Constant value cannot be empty\";\r\n\r\n      const isNumber = this.valueString.match(/^-?(0|[1-9]\\d*)(\\.\\d+)?([eE][+-]?\\d+)?$/u);\r\n      // Note: Does not do validation for studies existing\r\n      const isStudyString = TimeStudyTree.isValidImportString(this.valueString);\r\n\r\n      if (!isNumber && !isStudyString) return \"Constant value must either be a number or Time Study string\";\r\n      return null;\r\n    },\r\n    errorTooltip() {\r\n      const error = this.currentError();\r\n      if (!error) return undefined;\r\n      return {\r\n        content:\r\n          `<div class=\"c-block-automator-error\">\r\n          <div>${error}</div>\r\n        </div>`,\r\n        html: true,\r\n        trigger: \"manual\",\r\n        show: true,\r\n        classes: [\"general-tooltip\"]\r\n      };\r\n    },\r\n    handleFocus(focus) {\r\n      if (focus || this.currentError()) return;\r\n      if (!this.aliasString) AutomatorBackend.deleteConstant(this.oldAlias);\r\n      else if (!this.oldAlias) AutomatorBackend.addConstant(this.aliasString, this.valueString);\r\n      else if (this.oldAlias === this.aliasString) AutomatorBackend.modifyConstant(this.aliasString, this.valueString);\r\n      else AutomatorBackend.renameConstant(this.oldAlias, this.aliasString);\r\n      this.oldAlias = this.aliasString;\r\n\r\n      // This makes scripts respond immediately to newly-defined constants if the player types them into the\r\n      // script before defining them here\r\n      AutomatorData.recalculateErrors();\r\n      if (player.reality.automator.type === AUTOMATOR_TYPE.BLOCK) BlockAutomator.parseTextFromBlocks();\r\n    },\r\n    deleteConstant() {\r\n      AutomatorBackend.deleteConstant(this.aliasString);\r\n      this.oldAlias = \"\";\r\n      this.aliasString = \"\";\r\n      this.valueString = \"\";\r\n    }\r\n  }\r\n};\r\n</script>\r\n\r\n<template>\r\n  <div class=\"l-single-definition-container\">\r\n    <input\r\n      v-model=\"aliasString\"\r\n      class=\"c-define-textbox c-alias\"\r\n      :class=\"{ 'l-limit-textbox' : aliasString.length === maxNameLength }\"\r\n      placeholder=\"New constant...\"\r\n      :maxlength=\"maxNameLength\"\r\n      @focusin=\"handleFocus(true)\"\r\n      @focusout=\"handleFocus(false)\"\r\n    >\r\n    <span\r\n      v-if=\"aliasString\"\r\n      v-tooltip=\"errorTooltip()\"\r\n      class=\"o-arrow-padding\"\r\n    >\r\n      ðŸ ˆ\r\n    </span>\r\n    <input\r\n      v-if=\"aliasString\"\r\n      v-model=\"valueString\"\r\n      class=\"c-define-textbox c-value\"\r\n      :class=\"{ 'l-limit-textbox' : valueString && valueString.length === maxValueLength }\"\r\n      placeholder=\"Value for constant...\"\r\n      :maxlength=\"maxValueLength\"\r\n      @focusin=\"handleFocus(true)\"\r\n      @focusout=\"handleFocus(false)\"\r\n    >\r\n    <button\r\n      v-if=\"aliasString\"\r\n      v-tooltip=\"'Delete this constant'\"\r\n      class=\"c-delete-button fas fa-eraser\"\r\n      @click=\"deleteConstant\"\r\n    />\r\n  </div>\r\n</template>\r\n\r\n<style scoped>\r\n.c-delete-button {\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  border: var(--var-border-width, 0.2rem) solid var(--color-automator-controls-border);\r\n  border-radius: var(--var-border-radius, 0.3rem);\r\n  margin: 0.1rem -0.4rem 0.1rem 0.6rem;\r\n  cursor: pointer;\r\n  color: var(--color-automator-docs-font);\r\n  background-color: var(--color-automator-controls-inactive);\r\n}\r\n\r\n.c-delete-button:hover {\r\n  background-color: var(--color-automator-error-background);\r\n}\r\n\r\n.l-single-definition-container {\r\n  display: flex;\r\n  flex-direction: row;\r\n  padding: 0.5rem;\r\n}\r\n\r\n.o-arrow-padding {\r\n  display: flex;\r\n  flex-direction: column;\r\n  justify-content: center;\r\n  padding: 0 1rem;\r\n}\r\n\r\n.c-define-textbox {\r\n  display: inline-block;\r\n  font-family: Typewriter, serif;\r\n  font-size: 1.1rem;\r\n  background: var(--color-blockmator-block-background);\r\n  border: 0.1rem solid var(--color-blockmator-block-border);\r\n  border-radius: var(--var-border-radius, 0.5rem);\r\n  padding: 0.5rem;\r\n  color: #00ac00;\r\n}\r\n\r\n.l-error-textbox {\r\n  background: var(--color-automator-error-background);\r\n}\r\n\r\n.l-limit-textbox {\r\n  border-style: dotted;\r\n  border-color: var(--color-automator-error-outline);\r\n}\r\n\r\n.c-alias {\r\n  min-width: 14.5rem;\r\n}\r\n\r\n.c-value {\r\n  width: 100%;\r\n}\r\n</style>\r\n"],"sourceRoot":"src/components/tabs/automator"},"metadata":{},"sourceType":"module"}