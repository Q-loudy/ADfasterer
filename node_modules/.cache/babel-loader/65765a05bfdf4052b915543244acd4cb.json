{"ast":null,"code":"import PrimaryButton from \"@/components/PrimaryButton\";\nimport { BACKUP_SLOT_TYPE } from \"@/core/storage\";\nexport default {\n  name: \"BackupEntry\",\n  components: {\n    PrimaryButton\n  },\n  props: {\n    slotData: {\n      type: Object,\n      required: true\n    }\n  },\n\n  data() {\n    return {\n      currTime: 0\n    };\n  },\n\n  computed: {\n    save() {\n      return GameStorage.loadFromBackup(this.slotData.id);\n    },\n\n    progressStr() {\n      if (!this.save) return \"(Empty)\"; // These will be checked in order; the first nonzero resource will be returned\n\n      const resources = [this.save.celestials.pelle.realityShards, this.save.reality.iMCap, this.save.reality.realityMachines, this.save.eternityPoints, this.save.infinityPoints, this.save.antimatter];\n      const names = [\"Reality Shards\", \"Imaginary Machine Cap\", \"Reality Machines\", \"Eternity Points\", \"Infinity Points\", \"Antimatter\"];\n\n      for (let index = 0; index < resources.length; index++) {\n        const val = new Decimal(resources[index]);\n        if (val.gt(0)) return `${names[index]}: ${formatPostBreak(val, 2)}`;\n      } // In practice this should never happen, unless a save triggers on the same tick the very first AD1 is bought\n\n\n      return \"No resources\";\n    },\n\n    slotType() {\n      var _this$slotData$interv, _this$slotData;\n\n      const formattedTime = (_this$slotData$interv = (_this$slotData = this.slotData).intervalStr) === null || _this$slotData$interv === void 0 ? void 0 : _this$slotData$interv.call(_this$slotData);\n\n      switch (this.slotData.type) {\n        case BACKUP_SLOT_TYPE.ONLINE:\n          return `Saves every ${formattedTime} online`;\n\n        case BACKUP_SLOT_TYPE.OFFLINE:\n          return `Saves after ${formattedTime} offline`;\n\n        case BACKUP_SLOT_TYPE.RESERVE:\n          return \"Pre-loading save\";\n\n        default:\n          throw new Error(\"Unrecognized backup save type\");\n      }\n    },\n\n    lastSaved() {\n      var _GameStorage$lastBack, _GameStorage$lastBack2;\n\n      const lastSave = (_GameStorage$lastBack = (_GameStorage$lastBack2 = GameStorage.lastBackupTimes[this.slotData.id]) === null || _GameStorage$lastBack2 === void 0 ? void 0 : _GameStorage$lastBack2.date) !== null && _GameStorage$lastBack !== void 0 ? _GameStorage$lastBack : 0;\n      return lastSave ? `Last saved: ${TimeSpan.fromMilliseconds(this.currTime - lastSave)} ago` : \"Slot not currently in use\";\n    }\n\n  },\n  methods: {\n    update() {\n      this.currTime = Date.now();\n    },\n\n    load() {\n      if (!this.save) return; // This seems to be the only way to properly hide the modal after the save is properly loaded,\n      // since the offline progress modal appears nearly immediately after clicking the button\n\n      Modal.hide(); // We still save to the reserve slot even if we're loading from it, so we temporarily store the\n      // save-to-be-loaded into a string in this scope so that it doesn't get overwritten by the current save\n\n      const toLoad = this.save;\n      GameStorage.saveToReserveSlot();\n      GameStorage.ignoreBackupTimer = true;\n      GameStorage.offlineEnabled = player.options.loadBackupWithoutOffline ? false : undefined;\n      GameStorage.oldBackupTimer = player.backupTimer;\n      GameStorage.loadPlayerObject(toLoad);\n      GameUI.notify.info(`Game loaded from backup slot #${this.slotData.id}`);\n      GameStorage.loadBackupTimes();\n      GameStorage.ignoreBackupTimer = false;\n      GameStorage.offlineEnabled = undefined;\n      GameStorage.resetBackupTimer();\n      GameStorage.save(true);\n    }\n\n  }\n};","map":{"version":3,"sources":["BackupEntry.vue"],"names":[],"mappings":"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","sourcesContent":["<script>\r\nimport PrimaryButton from \"@/components/PrimaryButton\";\r\n\r\nimport { BACKUP_SLOT_TYPE } from \"@/core/storage\";\r\n\r\nexport default {\r\n  name: \"BackupEntry\",\r\n  components: {\r\n    PrimaryButton\r\n  },\r\n  props: {\r\n    slotData: {\r\n      type: Object,\r\n      required: true\r\n    }\r\n  },\r\n  data() {\r\n    return {\r\n      currTime: 0,\r\n    };\r\n  },\r\n  computed: {\r\n    save() {\r\n      return GameStorage.loadFromBackup(this.slotData.id);\r\n    },\r\n    progressStr() {\r\n      if (!this.save) return \"(Empty)\";\r\n\r\n      // These will be checked in order; the first nonzero resource will be returned\r\n      const resources = [this.save.celestials.pelle.realityShards,\r\n        this.save.reality.iMCap,\r\n        this.save.reality.realityMachines,\r\n        this.save.eternityPoints,\r\n        this.save.infinityPoints,\r\n        this.save.antimatter\r\n      ];\r\n      const names = [\"Reality Shards\",\r\n        \"Imaginary Machine Cap\",\r\n        \"Reality Machines\",\r\n        \"Eternity Points\",\r\n        \"Infinity Points\",\r\n        \"Antimatter\"];\r\n\r\n      for (let index = 0; index < resources.length; index++) {\r\n        const val = new Decimal(resources[index]);\r\n        if (val.gt(0)) return `${names[index]}: ${formatPostBreak(val, 2)}`;\r\n      }\r\n\r\n      // In practice this should never happen, unless a save triggers on the same tick the very first AD1 is bought\r\n      return \"No resources\";\r\n    },\r\n    slotType() {\r\n      const formattedTime = this.slotData.intervalStr?.();\r\n      switch (this.slotData.type) {\r\n        case BACKUP_SLOT_TYPE.ONLINE:\r\n          return `Saves every ${formattedTime} online`;\r\n        case BACKUP_SLOT_TYPE.OFFLINE:\r\n          return `Saves after ${formattedTime} offline`;\r\n        case BACKUP_SLOT_TYPE.RESERVE:\r\n          return \"Pre-loading save\";\r\n        default:\r\n          throw new Error(\"Unrecognized backup save type\");\r\n      }\r\n    },\r\n    lastSaved() {\r\n      const lastSave = GameStorage.lastBackupTimes[this.slotData.id]?.date ?? 0;\r\n      return lastSave\r\n        ? `Last saved: ${TimeSpan.fromMilliseconds(this.currTime - lastSave)} ago`\r\n        : \"Slot not currently in use\";\r\n    },\r\n  },\r\n  methods: {\r\n    update() {\r\n      this.currTime = Date.now();\r\n    },\r\n    load() {\r\n      if (!this.save) return;\r\n      // This seems to be the only way to properly hide the modal after the save is properly loaded,\r\n      // since the offline progress modal appears nearly immediately after clicking the button\r\n      Modal.hide();\r\n\r\n      // We still save to the reserve slot even if we're loading from it, so we temporarily store the\r\n      // save-to-be-loaded into a string in this scope so that it doesn't get overwritten by the current save\r\n      const toLoad = this.save;\r\n      GameStorage.saveToReserveSlot();\r\n\r\n      GameStorage.ignoreBackupTimer = true;\r\n      GameStorage.offlineEnabled = player.options.loadBackupWithoutOffline ? false : undefined;\r\n      GameStorage.oldBackupTimer = player.backupTimer;\r\n      GameStorage.loadPlayerObject(toLoad);\r\n      GameUI.notify.info(`Game loaded from backup slot #${this.slotData.id}`);\r\n      GameStorage.loadBackupTimes();\r\n      GameStorage.ignoreBackupTimer = false;\r\n      GameStorage.offlineEnabled = undefined;\r\n      GameStorage.resetBackupTimer();\r\n      GameStorage.save(true);\r\n    },\r\n  },\r\n};\r\n</script>\r\n\r\n<template>\r\n  <div class=\"c-bordered-entry\">\r\n    <h3>Slot #{{ slotData.id }}:</h3>\r\n    <span>{{ progressStr }}</span>\r\n    <span>\r\n      {{ slotType }}\r\n    </span>\r\n    <span class=\"c-fixed-height\">{{ lastSaved }}</span>\r\n    <PrimaryButton\r\n      class=\"o-primary-btn--width-medium\"\r\n      :class=\"{ 'o-primary-btn--disabled' : !save }\"\r\n      @click=\"load()\"\r\n    >\r\n      Load\r\n    </PrimaryButton>\r\n  </div>\r\n</template>\r\n\r\n<style scoped>\r\n.c-bordered-entry {\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  font-size: 1.1rem;\r\n  border: var(--var-border-width, 0.2rem) solid;\r\n  border-radius: var(--var-border-radius, 0.4rem);\r\n  padding: 0.5rem 0.3rem;\r\n  margin: 0.3rem;\r\n}\r\n\r\n.c-fixed-height {\r\n  height: 4rem;\r\n}\r\n</style>\r\n"],"sourceRoot":"src/components/modals/options"},"metadata":{},"sourceType":"module"}