{"ast":null,"code":"import _objectSpread from \"C:/Games/ADFasterer/ADfasterer/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport { GameDatabase } from \"./secret-formula/game-database\";\n/**\r\n * Multiple glyph effects are combined into a summary object of this type.\r\n * @typedef {Object} GlyphEffectConfig__combine_result\r\n * @property {number | Decimal} value The final effect value (boost to whatever)\r\n * @property {boolean} capped whether or not a cap or limit was applied (softcaps, etc)\r\n*/\n\nclass GlyphEffectConfig {\n  /**\r\n  * @param {Object} setup The fields here mostly match the properties of GlyphEffectConfig\r\n  * @param {string} setup.id powerpow, etc\r\n  * @param {string[]} setup.glyphTypes\r\n  * @param {string} setup.singleDesc Specify how to show a single glyph's effect. Use a string with {value}\r\n  *  somewhere in it; that will be replaced with a number.\r\n  * @param {string} [setup.totalDesc] (Defaults to singleDesc) specify how to show the combined effect of many\r\n  *  glyphs.\r\n  * @param {string} [setup.genericDesc] (Defaults to singleDesc with {value} replaced with \"x\") Generic\r\n  *  description of the glyph's effect\r\n  * @param {string} [setup.shortDesc] Short and condensed version of the glyph's effect for use in the Modal\r\n  * @param {(function(number, number): number) | function(number, number): Decimal} [setup.effect] Calculate effect\r\n  *  value from level and strength\r\n  * @param {function(number | Decimal): string} [setup.formatEffect] Format the effect's value into a string. Defaults\r\n  *  to format(x, 3, 3)\r\n  * @param {function(number | Decimal): string} [setup.formatSingleEffect] Format the effect's value into a string, used\r\n  *  for effects which need to display different values in single values versus combined values (eg. power effects)\r\n  * @param {function(number | Decimal): number | Decimal} [setup.softcap] An optional softcap to be applied after glyph\r\n  *  effects are combined.\r\n  * @param {((function(number[]): GlyphEffectConfig__combine_result) | function(number[]): number)} setup.combine\r\n  *  Specification of how multiple glyphs combine. Can be GlyphCombiner.add or GlyphCombiner.multiply for most glyphs.\r\n  *  Otherwise, should be a function that takes a potentially empty array of numbers (each glyph's effect value)\r\n  *  and returns a combined effect or an object with the combined effect amd a capped indicator.\r\n  * @param {boolean} [setup.enabledInDoomed] Determines if this effect is enabled while doomed. Defaults to false\r\n  */\n  constructor(setup) {\n    var _setup$totalDesc, _setup$genericDesc, _setup$formatEffect, _setup$enabledInDoome;\n\n    GlyphEffectConfig.checkInputs(setup);\n    /** @type {string} unique key for the effect -- powerpow, etc */\n\n    this.id = setup.id;\n    /** @type {number} bit position for the effect in the effect bitmask */\n\n    this.bitmaskIndex = setup.bitmaskIndex;\n    /** @type {boolean} flag to separate \"basic\"/effarig glyphs from cursed/reality glyphs */\n\n    this.isGenerated = setup.isGenerated;\n    /** @type {string[]} the types of glyphs this effect can occur on */\n\n    this.glyphTypes = setup.glyphTypes;\n    /** @type {string} See info about setup, above */\n\n    this._singleDesc = setup.singleDesc;\n    /** @type {string} See info about setup, above */\n\n    this._totalDesc = (_setup$totalDesc = setup.totalDesc) !== null && _setup$totalDesc !== void 0 ? _setup$totalDesc : setup.singleDesc;\n    /** @type {string} description of the effect without a specific value */\n\n    this._genericDesc = (_setup$genericDesc = setup.genericDesc) !== null && _setup$genericDesc !== void 0 ? _setup$genericDesc : setup.singleDesc.replace(\"{value}\", \"x\");\n    /** @type {string} shortened description for use in glyph choice info modal */\n\n    this._shortDesc = setup.shortDesc;\n    /**\r\n    * @type {(function(number, number): number) | function(number, number): Decimal} Calculate effect\r\n    *  value from level and strength\r\n    */\n\n    this.effect = setup.effect;\n    /**\r\n    * @type {function(number | Decimal): string} formatting function for the effect\r\n    * (just the number conversion). Combined with the description strings to make descriptions\r\n    */\n\n    this.formatEffect = (_setup$formatEffect = setup.formatEffect) !== null && _setup$formatEffect !== void 0 ? _setup$formatEffect : x => format(x, 3, 3);\n    /** @type {function(number | Decimal): string} See info about setup, above */\n\n    this.formatSingleEffect = setup.formatSingleEffect || this.formatEffect;\n    /**\r\n    *  @type {function(number[]): GlyphEffectConfig__combine_result} combine Function that combines\r\n    * multiple glyph effects into one value (adds up, applies softcaps, etc)\r\n    */\n\n    this.combine = GlyphEffectConfig.setupCombine(setup);\n    /** @type {function(number)} conversion function to produce altered glyph effect */\n\n    this.conversion = setup.conversion;\n    /**\r\n    * @type {function(number | Decimal): string} formatSecondaryEffect formatting function for\r\n    * the secondary effect (if there is one)\r\n    */\n\n    this.formatSecondaryEffect = setup.formatSecondaryEffect || (x => format(x, 3, 3));\n    /** @type {function(number | Decimal): string} See info about setup, above */\n\n\n    this.formatSingleSecondaryEffect = setup.formatSingleSecondaryEffect || this.formatSecondaryEffect;\n    /** @type {string} color to show numbers in glyph tooltips if boosted */\n\n    this.alteredColor = setup.alteredColor;\n    /** @type {number} string passed along to tooltip code to ensure proper formatting */\n\n    this.alterationType = setup.alterationType;\n    /** @type {boolean} Indicates whether the effect grows with level or shrinks */\n\n    this._biggerIsBetter = undefined;\n    /** @type {boolean} Determines if effect is disabled while in doomed */\n\n    this._enabledInDoomed = (_setup$enabledInDoome = setup.enabledInDoomed) !== null && _setup$enabledInDoome !== void 0 ? _setup$enabledInDoome : false;\n  }\n  /**\r\n   * @returns {boolean}\r\n   */\n\n\n  get biggerIsBetter() {\n    if (this._biggerIsBetter === undefined) this._biggerIsBetter = this.checkBiggerIsBetter();\n    return this._biggerIsBetter;\n  }\n\n  get singleDesc() {\n    const singleDesc = this._singleDesc;\n    return typeof singleDesc === \"function\" ? singleDesc() : singleDesc;\n  }\n\n  get totalDesc() {\n    const totalDesc = this._totalDesc;\n    return typeof totalDesc === \"function\" ? totalDesc() : totalDesc;\n  }\n\n  get genericDesc() {\n    const genericDesc = this._genericDesc;\n    return typeof genericDesc === \"function\" ? genericDesc() : genericDesc;\n  }\n\n  get shortDesc() {\n    const shortDesc = this._shortDesc;\n    return typeof shortDesc === \"function\" ? shortDesc() : shortDesc;\n  }\n\n  get isDisabledByDoomed() {\n    return Pelle.isDoomed && !this._enabledInDoomed;\n  }\n  /** @returns {number} */\n\n\n  compareValues(effectValueA, effectValueB) {\n    const result = Decimal.compare(effectValueA, effectValueB);\n    return this.biggerIsBetter ? result : -result;\n  }\n  /**\r\n   * @private\r\n   * @returns {boolean}\r\n   */\n\n\n  checkBiggerIsBetter() {\n    const baseEffect = new Decimal(this.effect(1, 1.01));\n    const biggerEffect = new Decimal(this.effect(100, 2));\n    return biggerEffect.gt(baseEffect);\n  }\n  /** @private */\n\n\n  static checkInputs(setup) {\n    const KNOWN_KEYS = [\"id\", \"bitmaskIndex\", \"glyphTypes\", \"singleDesc\", \"totalDesc\", \"genericDesc\", \"effect\", \"formatEffect\", \"formatSingleEffect\", \"combine\", \"softcap\", \"conversion\", \"formatSecondaryEffect\", \"formatSingleSecondaryEffect\", \"alteredColor\", \"alterationType\", \"isGenerated\", \"shortDesc\", \"enabledInDoomed\"];\n    const unknownField = Object.keys(setup).find(k => !KNOWN_KEYS.includes(k));\n\n    if (unknownField !== undefined) {\n      throw new Error(`Glyph effect \"${setup.id}\" includes unrecognized field \"${unknownField}\"`);\n    }\n\n    const unknownGlyphType = setup.glyphTypes.find(e => !GLYPH_TYPES.includes(e));\n\n    if (unknownGlyphType !== undefined) {\n      throw new Error(`Glyph effect \"${setup.id}\" references unknown glyphType \"${unknownGlyphType}\"`);\n    }\n\n    const emptyCombine = setup.combine([]);\n\n    if (typeof emptyCombine !== \"number\" && !(emptyCombine instanceof Decimal)) {\n      if (emptyCombine.value === undefined || emptyCombine.capped === undefined) {\n        throw new Error(`The combine function for Glyph effect \"${setup.id}\" has invalid return type`);\n      }\n\n      if (setup.softcap) {\n        throw new Error(`The combine function for Glyph effect \"${setup.id}\" gives capped information, ` + `but there's also a softcap method`);\n      }\n    }\n  }\n  /** @private */\n\n\n  static setupCombine(setup) {\n    let combine = setup.combine;\n    const softcap = setup.softcap;\n    const emptyCombine = combine([]); // No supplied capped indicator\n\n    if (typeof emptyCombine === \"number\") {\n      if (softcap === undefined) return effects => ({\n        value: combine(effects),\n        capped: false\n      });\n      return effects => {\n        const rawValue = combine(effects);\n        const cappedValue = softcap(rawValue);\n        return {\n          value: cappedValue,\n          capped: rawValue !== cappedValue\n        };\n      };\n    }\n\n    if (emptyCombine instanceof Decimal) {\n      if (softcap === undefined) return effects => ({\n        value: combine(effects),\n        capped: false\n      });\n      const neqTest = emptyCombine.value instanceof Decimal ? (a, b) => a.neq(b) : (a, b) => a !== b;\n      return combine = effects => {\n        const rawValue = combine(effects);\n        const cappedValue = softcap(rawValue.value);\n        return {\n          value: cappedValue,\n          capped: rawValue.capped || neqTest(rawValue.value, cappedValue)\n        };\n      };\n    } // The result's an object, so it already has a capped propery, so we don't need to do anything.\n\n\n    return combine;\n  }\n\n}\n\nexport const realityGlyphEffectLevelThresholds = [0, 9000, 15000, 25000];\nexport const GlyphEffects = mapGameDataToObject(GameDatabase.reality.glyphEffects, config => new GlyphEffectConfig(config));\nexport function findGlyphTypeEffects(glyphType) {\n  return GlyphEffects.all.filter(e => e.glyphTypes.includes(glyphType));\n}\nexport function makeGlyphEffectBitmask(effectList) {\n  return effectList.reduce((mask, eff) => mask + (1 << GlyphEffects[eff].bitmaskIndex), 0);\n}\nexport function getGlyphEffectsFromBitmask(bitmask) {\n  return orderedEffectList.map(effectName => GlyphEffects[effectName]).filter(effect => (bitmask & 1 << effect.bitmaskIndex) !== 0);\n}\nexport function getGlyphIDsFromBitmask(bitmask) {\n  return getGlyphEffectsFromBitmask(bitmask).map(x => x.id);\n}\n\nclass FunctionalGlyphType {\n  /**\r\n   * @param {Object} setup\r\n   * @param {string} setup.id\r\n   * @param {function(): string} [setup.primaryEffect] All glyphs generated will have this effect, if specified\r\n   * @param {function(): boolean} [setup.isUnlocked] If this glyph type is not available initially, this specifies\r\n   * how to check to see if it is available\r\n   * @param {number} setup.alchemyResource Alchemy resource generated by sacrificing this glyph\r\n   * @param {boolean} setup.hasRarity If the glyph can have rarity or not\r\n   */\n  constructor(setup) {\n    /** @type {string} identifier for this type (time, power, etc)*/\n    this.id = setup.id;\n    /** @type {GlyphEffectConfig[]} list of effects that this glyph can have */\n\n    this.effects = findGlyphTypeEffects(setup.id);\n    /** @type {string?} all glyphs generated will have at least this effect */\n\n    this.primaryEffect = setup.primaryEffect;\n    /** @type {undefined | function(): boolean} */\n\n    this._isUnlocked = setup.isUnlocked;\n    /** @type {number} */\n\n    this.alchemyResource = setup.alchemyResource;\n    /** @type {boolean} */\n\n    this.hasRarity = setup.hasRarity;\n\n    if (!GLYPH_TYPES.includes(this.id)) {\n      throw new Error(`Id ${this.id} not found in GLYPH_TYPES`);\n    }\n  }\n  /** @returns {boolean} */\n\n\n  get isUnlocked() {\n    var _this$_isUnlocked, _this$_isUnlocked2;\n\n    return (_this$_isUnlocked = (_this$_isUnlocked2 = this._isUnlocked) === null || _this$_isUnlocked2 === void 0 ? void 0 : _this$_isUnlocked2.call(this)) !== null && _this$_isUnlocked !== void 0 ? _this$_isUnlocked : true;\n  }\n\n}\n\nconst functionalGlyphTypes = mapGameDataToObject(GameDatabase.reality.glyphTypes, config => new FunctionalGlyphType(config));\nexport const GlyphTypes = _objectSpread(_objectSpread({}, functionalGlyphTypes), {}, {\n  /**\r\n    * @param {function(): number} rng Random number source (0..1)\r\n    * @param {string} [blacklisted] Do not return the specified type\r\n    * @returns {string | null}\r\n    */\n  random(rng, blacklisted = []) {\n    const types = generatedTypes.filter(x => (EffarigUnlock.reality.isUnlocked || x !== \"effarig\") && !blacklisted.includes(x));\n    return types[Math.floor(rng.uniform() * types.length)];\n  },\n\n  get list() {\n    return GLYPH_TYPES.map(e => GlyphTypes[e]);\n  },\n\n  get locked() {\n    return this.list.filter(e => !e.isUnlocked);\n  }\n\n});","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/glyph-effects.js"],"names":["GameDatabase","GlyphEffectConfig","constructor","setup","checkInputs","id","bitmaskIndex","isGenerated","glyphTypes","_singleDesc","singleDesc","_totalDesc","totalDesc","_genericDesc","genericDesc","replace","_shortDesc","shortDesc","effect","formatEffect","x","format","formatSingleEffect","combine","setupCombine","conversion","formatSecondaryEffect","formatSingleSecondaryEffect","alteredColor","alterationType","_biggerIsBetter","undefined","_enabledInDoomed","enabledInDoomed","biggerIsBetter","checkBiggerIsBetter","isDisabledByDoomed","Pelle","isDoomed","compareValues","effectValueA","effectValueB","result","Decimal","compare","baseEffect","biggerEffect","gt","KNOWN_KEYS","unknownField","Object","keys","find","k","includes","Error","unknownGlyphType","e","GLYPH_TYPES","emptyCombine","value","capped","softcap","effects","rawValue","cappedValue","neqTest","a","b","neq","realityGlyphEffectLevelThresholds","GlyphEffects","mapGameDataToObject","reality","glyphEffects","config","findGlyphTypeEffects","glyphType","all","filter","makeGlyphEffectBitmask","effectList","reduce","mask","eff","getGlyphEffectsFromBitmask","bitmask","orderedEffectList","map","effectName","getGlyphIDsFromBitmask","FunctionalGlyphType","primaryEffect","_isUnlocked","isUnlocked","alchemyResource","hasRarity","functionalGlyphTypes","GlyphTypes","random","rng","blacklisted","types","generatedTypes","EffarigUnlock","Math","floor","uniform","length","list","locked"],"mappings":"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","sourcesContent":["import { GameDatabase } from \"./secret-formula/game-database\";\r\n\r\n/**\r\n * Multiple glyph effects are combined into a summary object of this type.\r\n * @typedef {Object} GlyphEffectConfig__combine_result\r\n * @property {number | Decimal} value The final effect value (boost to whatever)\r\n * @property {boolean} capped whether or not a cap or limit was applied (softcaps, etc)\r\n*/\r\nclass GlyphEffectConfig {\r\n  /**\r\n  * @param {Object} setup The fields here mostly match the properties of GlyphEffectConfig\r\n  * @param {string} setup.id powerpow, etc\r\n  * @param {string[]} setup.glyphTypes\r\n  * @param {string} setup.singleDesc Specify how to show a single glyph's effect. Use a string with {value}\r\n  *  somewhere in it; that will be replaced with a number.\r\n  * @param {string} [setup.totalDesc] (Defaults to singleDesc) specify how to show the combined effect of many\r\n  *  glyphs.\r\n  * @param {string} [setup.genericDesc] (Defaults to singleDesc with {value} replaced with \"x\") Generic\r\n  *  description of the glyph's effect\r\n  * @param {string} [setup.shortDesc] Short and condensed version of the glyph's effect for use in the Modal\r\n  * @param {(function(number, number): number) | function(number, number): Decimal} [setup.effect] Calculate effect\r\n  *  value from level and strength\r\n  * @param {function(number | Decimal): string} [setup.formatEffect] Format the effect's value into a string. Defaults\r\n  *  to format(x, 3, 3)\r\n  * @param {function(number | Decimal): string} [setup.formatSingleEffect] Format the effect's value into a string, used\r\n  *  for effects which need to display different values in single values versus combined values (eg. power effects)\r\n  * @param {function(number | Decimal): number | Decimal} [setup.softcap] An optional softcap to be applied after glyph\r\n  *  effects are combined.\r\n  * @param {((function(number[]): GlyphEffectConfig__combine_result) | function(number[]): number)} setup.combine\r\n  *  Specification of how multiple glyphs combine. Can be GlyphCombiner.add or GlyphCombiner.multiply for most glyphs.\r\n  *  Otherwise, should be a function that takes a potentially empty array of numbers (each glyph's effect value)\r\n  *  and returns a combined effect or an object with the combined effect amd a capped indicator.\r\n  * @param {boolean} [setup.enabledInDoomed] Determines if this effect is enabled while doomed. Defaults to false\r\n  */\r\n  constructor(setup) {\r\n    GlyphEffectConfig.checkInputs(setup);\r\n    /** @type {string} unique key for the effect -- powerpow, etc */\r\n    this.id = setup.id;\r\n    /** @type {number} bit position for the effect in the effect bitmask */\r\n    this.bitmaskIndex = setup.bitmaskIndex;\r\n    /** @type {boolean} flag to separate \"basic\"/effarig glyphs from cursed/reality glyphs */\r\n    this.isGenerated = setup.isGenerated;\r\n    /** @type {string[]} the types of glyphs this effect can occur on */\r\n    this.glyphTypes = setup.glyphTypes;\r\n    /** @type {string} See info about setup, above */\r\n    this._singleDesc = setup.singleDesc;\r\n    /** @type {string} See info about setup, above */\r\n    this._totalDesc = setup.totalDesc ?? setup.singleDesc;\r\n    /** @type {string} description of the effect without a specific value */\r\n    this._genericDesc = setup.genericDesc ?? setup.singleDesc.replace(\"{value}\", \"x\");\r\n    /** @type {string} shortened description for use in glyph choice info modal */\r\n    this._shortDesc = setup.shortDesc;\r\n    /**\r\n    * @type {(function(number, number): number) | function(number, number): Decimal} Calculate effect\r\n    *  value from level and strength\r\n    */\r\n    this.effect = setup.effect;\r\n    /**\r\n    * @type {function(number | Decimal): string} formatting function for the effect\r\n    * (just the number conversion). Combined with the description strings to make descriptions\r\n    */\r\n    this.formatEffect = setup.formatEffect ?? (x => format(x, 3, 3));\r\n    /** @type {function(number | Decimal): string} See info about setup, above */\r\n    this.formatSingleEffect = setup.formatSingleEffect || this.formatEffect;\r\n    /**\r\n    *  @type {function(number[]): GlyphEffectConfig__combine_result} combine Function that combines\r\n    * multiple glyph effects into one value (adds up, applies softcaps, etc)\r\n    */\r\n    this.combine = GlyphEffectConfig.setupCombine(setup);\r\n    /** @type {function(number)} conversion function to produce altered glyph effect */\r\n    this.conversion = setup.conversion;\r\n    /**\r\n    * @type {function(number | Decimal): string} formatSecondaryEffect formatting function for\r\n    * the secondary effect (if there is one)\r\n    */\r\n    this.formatSecondaryEffect = setup.formatSecondaryEffect || (x => format(x, 3, 3));\r\n    /** @type {function(number | Decimal): string} See info about setup, above */\r\n    this.formatSingleSecondaryEffect = setup.formatSingleSecondaryEffect || this.formatSecondaryEffect;\r\n    /** @type {string} color to show numbers in glyph tooltips if boosted */\r\n    this.alteredColor = setup.alteredColor;\r\n    /** @type {number} string passed along to tooltip code to ensure proper formatting */\r\n    this.alterationType = setup.alterationType;\r\n    /** @type {boolean} Indicates whether the effect grows with level or shrinks */\r\n    this._biggerIsBetter = undefined;\r\n    /** @type {boolean} Determines if effect is disabled while in doomed */\r\n    this._enabledInDoomed = setup.enabledInDoomed ?? false;\r\n  }\r\n\r\n  /**\r\n   * @returns {boolean}\r\n   */\r\n  get biggerIsBetter() {\r\n    if (this._biggerIsBetter === undefined) this._biggerIsBetter = this.checkBiggerIsBetter();\r\n    return this._biggerIsBetter;\r\n  }\r\n\r\n  get singleDesc() {\r\n    const singleDesc = this._singleDesc;\r\n    return typeof singleDesc === \"function\" ? singleDesc() : singleDesc;\r\n  }\r\n\r\n  get totalDesc() {\r\n    const totalDesc = this._totalDesc;\r\n    return typeof totalDesc === \"function\" ? totalDesc() : totalDesc;\r\n  }\r\n\r\n  get genericDesc() {\r\n    const genericDesc = this._genericDesc;\r\n    return typeof genericDesc === \"function\" ? genericDesc() : genericDesc;\r\n  }\r\n\r\n  get shortDesc() {\r\n    const shortDesc = this._shortDesc;\r\n    return typeof shortDesc === \"function\" ? shortDesc() : shortDesc;\r\n  }\r\n\r\n  get isDisabledByDoomed() {\r\n    return Pelle.isDoomed && !this._enabledInDoomed;\r\n  }\r\n\r\n  /** @returns {number} */\r\n  compareValues(effectValueA, effectValueB) {\r\n    const result = Decimal.compare(effectValueA, effectValueB);\r\n    return this.biggerIsBetter ? result : -result;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @returns {boolean}\r\n   */\r\n  checkBiggerIsBetter() {\r\n    const baseEffect = new Decimal(this.effect(1, 1.01));\r\n    const biggerEffect = new Decimal(this.effect(100, 2));\r\n    return biggerEffect.gt(baseEffect);\r\n  }\r\n\r\n  /** @private */\r\n  static checkInputs(setup) {\r\n    const KNOWN_KEYS = [\"id\", \"bitmaskIndex\", \"glyphTypes\", \"singleDesc\", \"totalDesc\", \"genericDesc\", \"effect\",\r\n      \"formatEffect\", \"formatSingleEffect\", \"combine\", \"softcap\", \"conversion\", \"formatSecondaryEffect\",\r\n      \"formatSingleSecondaryEffect\", \"alteredColor\", \"alterationType\", \"isGenerated\", \"shortDesc\", \"enabledInDoomed\"];\r\n    const unknownField = Object.keys(setup).find(k => !KNOWN_KEYS.includes(k));\r\n    if (unknownField !== undefined) {\r\n      throw new Error(`Glyph effect \"${setup.id}\" includes unrecognized field \"${unknownField}\"`);\r\n    }\r\n\r\n    const unknownGlyphType = setup.glyphTypes.find(e => !GLYPH_TYPES.includes(e));\r\n    if (unknownGlyphType !== undefined) {\r\n      throw new Error(`Glyph effect \"${setup.id}\" references unknown glyphType \"${unknownGlyphType}\"`);\r\n    }\r\n\r\n    const emptyCombine = setup.combine([]);\r\n    if (typeof emptyCombine !== \"number\" && !(emptyCombine instanceof Decimal)) {\r\n      if (emptyCombine.value === undefined || emptyCombine.capped === undefined) {\r\n        throw new Error(`The combine function for Glyph effect \"${setup.id}\" has invalid return type`);\r\n      }\r\n      if (setup.softcap) {\r\n        throw new Error(`The combine function for Glyph effect \"${setup.id}\" gives capped information, ` +\r\n          `but there's also a softcap method`);\r\n      }\r\n    }\r\n  }\r\n\r\n  /** @private */\r\n  static setupCombine(setup) {\r\n    let combine = setup.combine;\r\n    const softcap = setup.softcap;\r\n    const emptyCombine = combine([]);\r\n    // No supplied capped indicator\r\n    if (typeof (emptyCombine) === \"number\") {\r\n      if (softcap === undefined) return effects => ({ value: combine(effects), capped: false });\r\n      return effects => {\r\n        const rawValue = combine(effects);\r\n        const cappedValue = softcap(rawValue);\r\n        return { value: cappedValue, capped: rawValue !== cappedValue };\r\n      };\r\n    }\r\n    if (emptyCombine instanceof Decimal) {\r\n      if (softcap === undefined) return effects => ({ value: combine(effects), capped: false });\r\n      const neqTest = emptyCombine.value instanceof Decimal ? (a, b) => a.neq(b) : (a, b) => a !== b;\r\n      return combine = effects => {\r\n        const rawValue = combine(effects);\r\n        const cappedValue = softcap(rawValue.value);\r\n        return { value: cappedValue, capped: rawValue.capped || neqTest(rawValue.value, cappedValue) };\r\n      };\r\n    }\r\n    // The result's an object, so it already has a capped propery, so we don't need to do anything.\r\n    return combine;\r\n  }\r\n}\r\n\r\nexport const realityGlyphEffectLevelThresholds = [0, 9000, 15000, 25000];\r\n\r\nexport const GlyphEffects = mapGameDataToObject(\r\n  GameDatabase.reality.glyphEffects,\r\n  config => new GlyphEffectConfig(config)\r\n);\r\n\r\nexport function findGlyphTypeEffects(glyphType) {\r\n  return GlyphEffects.all.filter(e => e.glyphTypes.includes(glyphType));\r\n}\r\n\r\nexport function makeGlyphEffectBitmask(effectList) {\r\n  return effectList.reduce((mask, eff) => mask + (1 << GlyphEffects[eff].bitmaskIndex), 0);\r\n}\r\n\r\nexport function getGlyphEffectsFromBitmask(bitmask) {\r\n  return orderedEffectList\r\n    .map(effectName => GlyphEffects[effectName])\r\n    .filter(effect => (bitmask & (1 << effect.bitmaskIndex)) !== 0);\r\n}\r\n\r\nexport function getGlyphIDsFromBitmask(bitmask) {\r\n  return getGlyphEffectsFromBitmask(bitmask).map(x => x.id);\r\n}\r\n\r\nclass FunctionalGlyphType {\r\n  /**\r\n   * @param {Object} setup\r\n   * @param {string} setup.id\r\n   * @param {function(): string} [setup.primaryEffect] All glyphs generated will have this effect, if specified\r\n   * @param {function(): boolean} [setup.isUnlocked] If this glyph type is not available initially, this specifies\r\n   * how to check to see if it is available\r\n   * @param {number} setup.alchemyResource Alchemy resource generated by sacrificing this glyph\r\n   * @param {boolean} setup.hasRarity If the glyph can have rarity or not\r\n   */\r\n  constructor(setup) {\r\n    /** @type {string} identifier for this type (time, power, etc)*/\r\n    this.id = setup.id;\r\n    /** @type {GlyphEffectConfig[]} list of effects that this glyph can have */\r\n    this.effects = findGlyphTypeEffects(setup.id);\r\n    /** @type {string?} all glyphs generated will have at least this effect */\r\n    this.primaryEffect = setup.primaryEffect;\r\n    /** @type {undefined | function(): boolean} */\r\n    this._isUnlocked = setup.isUnlocked;\r\n    /** @type {number} */\r\n    this.alchemyResource = setup.alchemyResource;\r\n    /** @type {boolean} */\r\n    this.hasRarity = setup.hasRarity;\r\n    if (!GLYPH_TYPES.includes(this.id)) {\r\n      throw new Error(`Id ${this.id} not found in GLYPH_TYPES`);\r\n    }\r\n  }\r\n\r\n  /** @returns {boolean} */\r\n  get isUnlocked() {\r\n    return this._isUnlocked?.() ?? true;\r\n  }\r\n}\r\n\r\nconst functionalGlyphTypes = mapGameDataToObject(\r\n  GameDatabase.reality.glyphTypes,\r\n  config => new FunctionalGlyphType(config)\r\n);\r\n\r\nexport const GlyphTypes = {\r\n  ...functionalGlyphTypes,\r\n  /**\r\n    * @param {function(): number} rng Random number source (0..1)\r\n    * @param {string} [blacklisted] Do not return the specified type\r\n    * @returns {string | null}\r\n    */\r\n  random(rng, blacklisted = []) {\r\n    const types = generatedTypes.filter(\r\n      x => (EffarigUnlock.reality.isUnlocked || x !== \"effarig\") && !blacklisted.includes(x));\r\n    return types[Math.floor(rng.uniform() * types.length)];\r\n  },\r\n  get list() {\r\n    return GLYPH_TYPES.map(e => GlyphTypes[e]);\r\n  },\r\n  get locked() {\r\n    return this.list.filter(e => !e.isUnlocked);\r\n  }\r\n};\r\n"]},"metadata":{},"sourceType":"module"}