{"ast":null,"code":"export const TUTORIAL_STATE = {\n  DIM1: 0,\n  DIM2: 1,\n  TICKSPEED: 2,\n  DIMBOOST: 3,\n  GALAXY: 4,\n  AUTOMATOR: 5\n}; // Tutorial has two ways of moving on, either by Tutorial.moveOn() or by having it's condition be true. This\n// is checked by moving on when the NEXT state's condition evaluates to true\n\nconst tutorialStates = [{\n  // Highlight the 1st dim button\n  id: TUTORIAL_STATE.DIM1,\n  condition: () => true\n}, {\n  // Highlight the 2nd dim button\n  id: TUTORIAL_STATE.DIM2,\n  condition: () => Currency.antimatter.gte(100)\n}, {\n  id: TUTORIAL_STATE.TICKSPEED,\n  condition: () => AntimatterDimension(2).bought > 0\n}, {\n  id: TUTORIAL_STATE.DIMBOOST,\n  condition: () => AntimatterDimension(4).amount.gte(20)\n}, {\n  id: TUTORIAL_STATE.GALAXY,\n  condition: () => AntimatterDimension(8).amount.gte(80)\n}, {\n  id: TUTORIAL_STATE.AUTOMATOR,\n  condition: () => Player.automatorUnlocked\n}];\nexport const Tutorial = {\n  isActive(atState) {\n    return player.records.fullGameCompletions === 0 && ui.view.tutorialState === atState && ui.view.tutorialActive;\n  },\n\n  // This will remain visible until the first dimboost is purchased. However, since the tutorial state generally\n  // only visually updates whenever the UI elements need changing, we need to explicitly check boost count or else\n  // this will remain visible until a galaxy can be purchased\n  emphasizeH2P() {\n    const hasFirstBoost = player.tutorialState > TUTORIAL_STATE.DIMBOOST || player.dimensionBoosts > 0;\n    return player.records.fullGameCompletions === 0 && !hasFirstBoost;\n  },\n\n  // Turns off the visual effect\n  turnOffEffect(fromState) {\n    if (fromState !== player.tutorialState) return;\n    player.tutorialActive = false;\n    ui.view.tutorialActive = false; // Check if we can immediately enter next tutorial state. This is needed\n    // to correctly handle buying dimension 2 + tickspeed in the same tick,\n    // for example.\n\n    this.tutorialLoop();\n  },\n\n  // Moves on to the next tutorialState, but only if parameter is current state.\n  moveOn(fromState) {\n    if (fromState !== player.tutorialState) return;\n    player.tutorialState++;\n    ui.view.tutorialState++;\n    player.tutorialActive = true;\n    ui.view.tutorialActive = true;\n  },\n\n  tutorialLoop() {\n    const nextState = tutorialStates.find(o => o.id === player.tutorialState + 1);\n    if (nextState && nextState.condition()) this.moveOn(player.tutorialState);\n  }\n\n};","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/tutorial.js"],"names":["TUTORIAL_STATE","DIM1","DIM2","TICKSPEED","DIMBOOST","GALAXY","AUTOMATOR","tutorialStates","id","condition","Currency","antimatter","gte","AntimatterDimension","bought","amount","Player","automatorUnlocked","Tutorial","isActive","atState","player","records","fullGameCompletions","ui","view","tutorialState","tutorialActive","emphasizeH2P","hasFirstBoost","dimensionBoosts","turnOffEffect","fromState","tutorialLoop","moveOn","nextState","find","o"],"mappings":"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","sourcesContent":["export const TUTORIAL_STATE = {\r\n  DIM1: 0,\r\n  DIM2: 1,\r\n  TICKSPEED: 2,\r\n  DIMBOOST: 3,\r\n  GALAXY: 4,\r\n  AUTOMATOR: 5\r\n};\r\n\r\n// Tutorial has two ways of moving on, either by Tutorial.moveOn() or by having it's condition be true. This\r\n// is checked by moving on when the NEXT state's condition evaluates to true\r\nconst tutorialStates = [\r\n  {\r\n    // Highlight the 1st dim button\r\n    id: TUTORIAL_STATE.DIM1,\r\n    condition: () => true\r\n  },\r\n  {\r\n    // Highlight the 2nd dim button\r\n    id: TUTORIAL_STATE.DIM2,\r\n    condition: () => Currency.antimatter.gte(100)\r\n  },\r\n  {\r\n    id: TUTORIAL_STATE.TICKSPEED,\r\n    condition: () => AntimatterDimension(2).bought > 0\r\n  },\r\n  {\r\n    id: TUTORIAL_STATE.DIMBOOST,\r\n    condition: () => AntimatterDimension(4).amount.gte(20)\r\n  },\r\n  {\r\n    id: TUTORIAL_STATE.GALAXY,\r\n    condition: () => AntimatterDimension(8).amount.gte(80)\r\n  },\r\n  {\r\n    id: TUTORIAL_STATE.AUTOMATOR,\r\n    condition: () => Player.automatorUnlocked\r\n  }\r\n];\r\n\r\nexport const Tutorial = {\r\n\r\n  isActive(atState) {\r\n    return player.records.fullGameCompletions === 0 && ui.view.tutorialState === atState && ui.view.tutorialActive;\r\n  },\r\n\r\n  // This will remain visible until the first dimboost is purchased. However, since the tutorial state generally\r\n  // only visually updates whenever the UI elements need changing, we need to explicitly check boost count or else\r\n  // this will remain visible until a galaxy can be purchased\r\n  emphasizeH2P() {\r\n    const hasFirstBoost = player.tutorialState > TUTORIAL_STATE.DIMBOOST || player.dimensionBoosts > 0;\r\n    return player.records.fullGameCompletions === 0 && !hasFirstBoost;\r\n  },\r\n\r\n  // Turns off the visual effect\r\n  turnOffEffect(fromState) {\r\n    if (fromState !== player.tutorialState) return;\r\n    player.tutorialActive = false;\r\n    ui.view.tutorialActive = false;\r\n    // Check if we can immediately enter next tutorial state. This is needed\r\n    // to correctly handle buying dimension 2 + tickspeed in the same tick,\r\n    // for example.\r\n    this.tutorialLoop();\r\n  },\r\n\r\n  // Moves on to the next tutorialState, but only if parameter is current state.\r\n  moveOn(fromState) {\r\n    if (fromState !== player.tutorialState) return;\r\n    player.tutorialState++;\r\n    ui.view.tutorialState++;\r\n    player.tutorialActive = true;\r\n    ui.view.tutorialActive = true;\r\n  },\r\n\r\n  tutorialLoop() {\r\n    const nextState = tutorialStates.find(o => o.id === player.tutorialState + 1);\r\n    if (nextState && nextState.condition()) this.moveOn(player.tutorialState);\r\n  }\r\n};\r\n"]},"metadata":{},"sourceType":"module"}