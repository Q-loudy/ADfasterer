{"ast":null,"code":"import \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport { BitUpgradeState, GameMechanicState } from \"../../game-mechanics\";\nimport { Quotes } from \"../quotes\";\n\nclass RaUnlockState extends BitUpgradeState {\n  get bits() {\n    return player.celestials.ra.unlockBits;\n  }\n\n  set bits(value) {\n    player.celestials.ra.unlockBits = value;\n  }\n\n  get disabledByPelle() {\n    return Pelle.isDoomed && this.config.disabledByPelle;\n  }\n\n  get isEffectActive() {\n    return this.isUnlocked && !this.disabledByPelle;\n  }\n\n  get requirementText() {\n    const pet = this.pet.name;\n    return this.level === 1 ? `Unlock ${pet}` : `Get ${pet} to level ${this.level}`;\n  }\n\n  get reward() {\n    return typeof this.config.reward === \"function\" ? this.config.reward() : this.config.reward;\n  }\n\n  get displayIcon() {\n    return this.disabledByPelle ? `<span class=\"fas fa-ban\"></span>` : this.config.displayIcon;\n  }\n\n  get pet() {\n    return Ra.pets[this.config.pet];\n  }\n\n  get level() {\n    return this.config.level;\n  }\n\n  get canBeUnlocked() {\n    return this.pet.level >= this.level && !this.isUnlocked;\n  }\n\n  onUnlock() {\n    var _this$config$onUnlock, _this$config;\n\n    (_this$config$onUnlock = (_this$config = this.config).onUnlock) === null || _this$config$onUnlock === void 0 ? void 0 : _this$config$onUnlock.call(_this$config);\n  }\n\n}\n\nconst unlocks = mapGameDataToObject(GameDatabase.celestials.ra.unlocks, config => new RaUnlockState(config));\n\nclass RaPetState extends GameMechanicState {\n  get data() {\n    return player.celestials.ra.pets[this.id];\n  }\n\n  get name() {\n    return this.config.name;\n  }\n\n  get chunkGain() {\n    return this.config.chunkGain;\n  }\n\n  get memoryGain() {\n    return this.config.memoryGain;\n  }\n\n  get color() {\n    return this.config.color;\n  }\n\n  get requiredUnlock() {\n    var _this$config$required, _this$config2;\n\n    return (_this$config$required = (_this$config2 = this.config).requiredUnlock) === null || _this$config$required === void 0 ? void 0 : _this$config$required.call(_this$config2);\n  }\n\n  get rawMemoryChunksPerSecond() {\n    return this.config.rawMemoryChunksPerSecond();\n  }\n\n  get memoryProductionMultiplier() {\n    return this.config.memoryProductionMultiplier();\n  }\n\n  get isUnlocked() {\n    return this.requiredUnlock === undefined || this.requiredUnlock.isUnlocked;\n  }\n\n  get isCapped() {\n    return this.level >= Ra.levelCap;\n  }\n\n  get level() {\n    return this.isUnlocked ? this.data.level : 0;\n  }\n\n  set level(value) {\n    this.data.level = value;\n  }\n\n  get memories() {\n    return this.data.memories;\n  }\n\n  set memories(value) {\n    this.data.memories = value;\n  }\n\n  get memoryChunks() {\n    return this.data.memoryChunks;\n  }\n\n  set memoryChunks(value) {\n    this.data.memoryChunks = value;\n  }\n\n  get requiredMemories() {\n    return Ra.requiredMemoriesForLevel(this.level);\n  }\n\n  get memoryChunksPerSecond() {\n    if (!this.canGetMemoryChunks) return 0;\n    let res = this.rawMemoryChunksPerSecond * this.chunkUpgradeCurrentMult * Effects.product(Ra.unlocks.continuousTTBoost.effects.memoryChunks, GlyphSacrifice.reality);\n    if (this.hasRemembrance) res *= Ra.remembrance.multiplier;else if (Ra.petWithRemembrance) res *= Ra.remembrance.nerf;\n    return res;\n  }\n\n  get canGetMemoryChunks() {\n    return this.isUnlocked && Ra.isRunning;\n  }\n\n  get hasRemembrance() {\n    return Ra.petWithRemembrance === this.name;\n  }\n\n  get memoryUpgradeCurrentMult() {\n    return Math.pow(1.3, this.data.memoryUpgrades);\n  }\n\n  get chunkUpgradeCurrentMult() {\n    return Math.pow(1.5, this.data.chunkUpgrades);\n  }\n\n  get memoryUpgradeCost() {\n    return 1000 * Math.pow(5, this.data.memoryUpgrades);\n  }\n\n  get chunkUpgradeCost() {\n    return 5000 * Math.pow(25, this.data.chunkUpgrades);\n  }\n\n  get canBuyMemoryUpgrade() {\n    return this.memoryUpgradeCost <= this.memories;\n  }\n\n  get canBuyChunkUpgrade() {\n    return this.chunkUpgradeCost <= this.memories;\n  }\n\n  get memoryUpgradeCapped() {\n    return this.memoryUpgradeCost >= 0.5 * Ra.requiredMemoriesForLevel(Ra.levelCap - 1);\n  }\n\n  get chunkUpgradeCapped() {\n    return this.chunkUpgradeCost >= 0.5 * Ra.requiredMemoriesForLevel(Ra.levelCap - 1);\n  }\n\n  purchaseMemoryUpgrade() {\n    if (!this.canBuyMemoryUpgrade || this.memoryUpgradeCapped) return;\n    this.memories -= this.memoryUpgradeCost;\n    this.data.memoryUpgrades++;\n  }\n\n  purchaseChunkUpgrade() {\n    if (!this.canBuyChunkUpgrade || this.chunkUpgradeCapped) return;\n    this.memories -= this.chunkUpgradeCost;\n    this.data.chunkUpgrades++;\n  }\n\n  levelUp() {\n    if (this.memories < this.requiredMemories) return;\n    this.memories -= this.requiredMemories;\n    this.level++;\n    Ra.checkForUnlocks();\n  }\n\n  get unlocks() {\n    return Ra.unlocks.all.filter(x => x.pet === this).sort((a, b) => a.level - b.level);\n  }\n\n  tick(realDiff, generateChunks) {\n    const seconds = realDiff / 1000;\n    const newMemoryChunks = generateChunks ? seconds * this.memoryChunksPerSecond : 0; // Adding memories from half of the gained chunks this tick results in the best mathematical behavior\n    // for very long simulated ticks\n\n    const newMemories = seconds * (this.memoryChunks + newMemoryChunks / 2) * Ra.productionPerMemoryChunk * this.memoryUpgradeCurrentMult;\n    this.memoryChunks += newMemoryChunks;\n    this.memories += newMemories;\n  }\n\n  reset() {\n    this.data.level = 1;\n    this.data.memories = 0;\n    this.data.memoryChunks = 0;\n    this.data.memoryUpgrades = 0;\n    this.data.chunkUpgrades = 0;\n  }\n\n}\n\nconst pets = mapGameDataToObject(GameDatabase.celestials.ra.pets, config => new RaPetState(config));\nexport const Ra = {\n  displayName: \"Ra\",\n  possessiveName: \"Ra's\",\n  unlocks,\n  pets,\n  remembrance: {\n    multiplier: 5,\n    nerf: 0.5,\n    requiredLevels: 20,\n\n    get isUnlocked() {\n      return Ra.totalPetLevel >= this.requiredLevels;\n    }\n\n  },\n\n  // Dev/debug function for easier testing\n  reset() {\n    const data = player.celestials.ra;\n    data.unlockBits = 0;\n    data.run = false;\n    data.charged = new Set();\n    data.disCharge = false;\n    data.peakGamespeed = 1;\n\n    for (const pet of Ra.pets.all) pet.reset();\n  },\n\n  memoryTick(realDiff, generateChunks) {\n    if (!this.isUnlocked) return;\n\n    for (const pet of Ra.pets.all) pet.tick(realDiff, generateChunks);\n  },\n\n  get productionPerMemoryChunk() {\n    let res = Effects.product(Ra.unlocks.continuousTTBoost.effects.memories, Achievement(168));\n\n    for (const pet of Ra.pets.all) {\n      if (pet.isUnlocked) res *= pet.memoryProductionMultiplier;\n    }\n\n    return res;\n  },\n\n  get memoryBoostResources() {\n    const boostList = [];\n\n    for (const pet of Ra.pets.all) {\n      if (pet.memoryProductionMultiplier !== 1) boostList.push(pet.memoryGain);\n    }\n\n    if (Achievement(168).isUnlocked) boostList.push(\"Achievement 168\");\n    if (Ra.unlocks.continuousTTBoost.canBeApplied) boostList.push(\"current TT\");\n    if (boostList.length === 1) return `${boostList[0]}`;\n    if (boostList.length === 2) return `${boostList[0]} and ${boostList[1]}`;\n    return `${boostList.slice(0, -1).join(\", \")}, and ${boostList[boostList.length - 1]}`;\n  },\n\n  // This is the exp required ON \"level\" in order to reach \"level + 1\"\n  requiredMemoriesForLevel(level) {\n    if (level >= Ra.levelCap) return Infinity;\n    const adjustedLevel = level + Math.pow(level, 2) / 10;\n    const post15Scaling = Math.pow(1.5, Math.max(0, level - 15));\n    return Math.floor(Math.pow(adjustedLevel, 5.52) * post15Scaling * 1e6);\n  },\n\n  // Returns a string containing a time estimate for gaining a specific amount of exp (UI only)\n  timeToGoalString(pet, expToGain) {\n    // Quadratic formula for growth (uses constant growth for a = 0)\n    const a = Enslaved.isStoringRealTime ? 0 : Ra.productionPerMemoryChunk * pet.memoryUpgradeCurrentMult * pet.memoryChunksPerSecond / 2;\n    const b = Ra.productionPerMemoryChunk * pet.memoryUpgradeCurrentMult * pet.memoryChunks;\n    const c = -expToGain;\n    const estimate = a === 0 ? -c / b : (Math.sqrt(Math.pow(b, 2) - 4 * a * c) - b) / (2 * a);\n\n    if (Number.isFinite(estimate)) {\n      return `in ${TimeSpan.fromSeconds(estimate).toStringShort()}`;\n    }\n\n    return \"\";\n  },\n\n  get totalPetLevel() {\n    return this.pets.all.map(pet => pet.isUnlocked ? pet.level : 0).sum();\n  },\n\n  get levelCap() {\n    return 25;\n  },\n\n  get maxTotalPetLevel() {\n    return this.levelCap * this.pets.all.length;\n  },\n\n  checkForUnlocks() {\n    if (!VUnlocks.raUnlock.canBeApplied) return;\n\n    for (const unl of Ra.unlocks.all) {\n      unl.unlock();\n    }\n\n    Ra.checkForQuotes();\n  },\n\n  checkForQuotes() {\n    for (const quote of Ra.quotes.all) {\n      // Quotes without requirements will be shown in other ways\n      if (quote.requirement) {\n        quote.show();\n      }\n    }\n  },\n\n  initializeRun() {\n    clearCelestialRuns();\n    player.celestials.ra.run = true;\n    this.quotes.realityEnter.show();\n  },\n\n  toggleMode() {\n    player.celestials.ra.activeMode = !player.celestials.ra.activeMode;\n  },\n\n  // This gets widely used in lots of places since the relevant upgrade is \"all forms of continuous non-dimension\n  // production\", which in this case is infinities, eternities, replicanti, dilated time, and time theorem generation.\n  // It also includes the 1% IP time study, Teresa's 1% EP upgrade, and the charged RM generation upgrade. Note that\n  // removing the hardcap of 10 may cause runaways.\n  theoremBoostFactor() {\n    return Math.min(10, Math.max(0, Currency.timeTheorems.value.pLog10() - 350) / 50);\n  },\n\n  get isUnlocked() {\n    return V.spaceTheorems >= 36;\n  },\n\n  get isRunning() {\n    return player.celestials.ra.run;\n  },\n\n  get totalCharges() {\n    return Ra.unlocks.chargedInfinityUpgrades.effectOrDefault(0);\n  },\n\n  get chargesLeft() {\n    return this.totalCharges - player.celestials.ra.charged.size;\n  },\n\n  get canBuyTriad() {\n    return Ra.unlocks.unlockHardV.canBeApplied;\n  },\n\n  get petWithRemembrance() {\n    return player.celestials.ra.petWithRemembrance;\n  },\n\n  set petWithRemembrance(name) {\n    player.celestials.ra.petWithRemembrance = name;\n  },\n\n  updateAlchemyFlow(realityRealTime) {\n    const perSecond = 1000 / realityRealTime;\n\n    for (const resource of AlchemyResources.all) {\n      resource.ema.addValue((resource.amount - resource.before) * perSecond);\n      resource.before = resource.amount;\n    }\n  },\n\n  applyAlchemyReactions(realityRealTime) {\n    if (!Ra.unlocks.effarigUnlock.canBeApplied) return;\n    const sortedReactions = AlchemyReactions.all.compact().sort((r1, r2) => r2.priority - r1.priority);\n\n    for (const reaction of sortedReactions) {\n      reaction.combineReagents();\n    }\n\n    this.updateAlchemyFlow(realityRealTime);\n  },\n\n  get alchemyResourceCap() {\n    return 25000;\n  },\n\n  get momentumValue() {\n    const hoursFromUnlock = TimeSpan.fromMilliseconds(player.celestials.ra.momentumTime).totalHours;\n    return Math.clampMax(1 + 0.005 * hoursFromUnlock, AlchemyResource.momentum.effectValue);\n  },\n\n  quotes: Quotes.ra,\n  symbol: \"<i class='fas fa-sun'></i>\"\n};\nexport const GlyphAlteration = {\n  // Adding a secondary effect to some effects\n  get additionThreshold() {\n    return 1e36;\n  },\n\n  // One-time massive boost of a single effect\n  get empowermentThreshold() {\n    return 1e43;\n  },\n\n  // Scaling boost from sacrifice quantity\n  get boostingThreshold() {\n    return 1e60;\n  },\n\n  getSacrificePower(type) {\n    if (Pelle.isDisabled(\"alteration\")) return 0;\n    const sacPower = player.reality.glyphs.sac[type];\n\n    if (sacPower === undefined) {\n      throw new Error(\"Unknown sacrifice type\");\n    }\n\n    return sacPower;\n  },\n\n  get isUnlocked() {\n    if (Pelle.isDisabled(\"alteration\")) return false;\n    return Ra.unlocks.alteredGlyphs.canBeApplied;\n  },\n\n  isAdded(type) {\n    return this.isUnlocked && this.getSacrificePower(type) >= this.additionThreshold;\n  },\n\n  isEmpowered(type) {\n    return this.isUnlocked && this.getSacrificePower(type) >= this.empowermentThreshold;\n  },\n\n  isBoosted(type) {\n    return this.isUnlocked && this.getSacrificePower(type) >= this.boostingThreshold;\n  },\n\n  sacrificeBoost(type) {\n    const capped = Math.clampMax(this.getSacrificePower(type), GlyphSacrificeHandler.maxSacrificeForEffects);\n    return Math.log10(Math.clampMin(capped / this.boostingThreshold, 1)) / 2;\n  },\n\n  baseAdditionColor(isDark = Theme.current().isDark()) {\n    return isDark ? \"#CCCCCC\" : \"black\";\n  },\n\n  baseEmpowermentColor(isDark = Theme.current().isDark()) {\n    return isDark ? \"#EEEE30\" : \"#C6C610\";\n  },\n\n  baseBoostColor(isDark = Theme.current().isDark()) {\n    return isDark ? \"#60DDDD\" : \"#28BDBD\";\n  },\n\n  getAdditionColor(type) {\n    const isDark = CosmeticGlyphTypes[type].currentColor.bg === \"black\";\n    return this.isAdded(type) ? this.baseAdditionColor(isDark) : undefined;\n  },\n\n  getEmpowermentColor(type) {\n    const isDark = CosmeticGlyphTypes[type].currentColor.bg === \"black\";\n    return this.isEmpowered(type) ? this.baseEmpowermentColor(isDark) : undefined;\n  },\n\n  getBoostColor(type) {\n    const isDark = CosmeticGlyphTypes[type].currentColor.bg === \"black\";\n    return this.isBoosted(type) ? this.baseBoostColor(isDark) : undefined;\n  }\n\n};\nEventHub.logic.on(GAME_EVENT.TAB_CHANGED, () => {\n  if (Tab.celestials.ra.isOpen) Ra.quotes.unlock.show();\n});","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/celestials/ra/ra.js"],"names":["BitUpgradeState","GameMechanicState","Quotes","RaUnlockState","bits","player","celestials","ra","unlockBits","value","disabledByPelle","Pelle","isDoomed","config","isEffectActive","isUnlocked","requirementText","pet","name","level","reward","displayIcon","Ra","pets","canBeUnlocked","onUnlock","unlocks","mapGameDataToObject","GameDatabase","RaPetState","data","id","chunkGain","memoryGain","color","requiredUnlock","rawMemoryChunksPerSecond","memoryProductionMultiplier","undefined","isCapped","levelCap","memories","memoryChunks","requiredMemories","requiredMemoriesForLevel","memoryChunksPerSecond","canGetMemoryChunks","res","chunkUpgradeCurrentMult","Effects","product","continuousTTBoost","effects","GlyphSacrifice","reality","hasRemembrance","remembrance","multiplier","petWithRemembrance","nerf","isRunning","memoryUpgradeCurrentMult","Math","pow","memoryUpgrades","chunkUpgrades","memoryUpgradeCost","chunkUpgradeCost","canBuyMemoryUpgrade","canBuyChunkUpgrade","memoryUpgradeCapped","chunkUpgradeCapped","purchaseMemoryUpgrade","purchaseChunkUpgrade","levelUp","checkForUnlocks","all","filter","x","sort","a","b","tick","realDiff","generateChunks","seconds","newMemoryChunks","newMemories","productionPerMemoryChunk","reset","displayName","possessiveName","requiredLevels","totalPetLevel","run","charged","Set","disCharge","peakGamespeed","memoryTick","Achievement","memoryBoostResources","boostList","push","canBeApplied","length","slice","join","Infinity","adjustedLevel","post15Scaling","max","floor","timeToGoalString","expToGain","Enslaved","isStoringRealTime","c","estimate","sqrt","Number","isFinite","TimeSpan","fromSeconds","toStringShort","map","sum","maxTotalPetLevel","VUnlocks","raUnlock","unl","unlock","checkForQuotes","quote","quotes","requirement","show","initializeRun","clearCelestialRuns","realityEnter","toggleMode","activeMode","theoremBoostFactor","min","Currency","timeTheorems","pLog10","V","spaceTheorems","totalCharges","chargedInfinityUpgrades","effectOrDefault","chargesLeft","size","canBuyTriad","unlockHardV","updateAlchemyFlow","realityRealTime","perSecond","resource","AlchemyResources","ema","addValue","amount","before","applyAlchemyReactions","effarigUnlock","sortedReactions","AlchemyReactions","compact","r1","r2","priority","reaction","combineReagents","alchemyResourceCap","momentumValue","hoursFromUnlock","fromMilliseconds","momentumTime","totalHours","clampMax","AlchemyResource","momentum","effectValue","symbol","GlyphAlteration","additionThreshold","empowermentThreshold","boostingThreshold","getSacrificePower","type","isDisabled","sacPower","glyphs","sac","Error","alteredGlyphs","isAdded","isEmpowered","isBoosted","sacrificeBoost","capped","GlyphSacrificeHandler","maxSacrificeForEffects","log10","clampMin","baseAdditionColor","isDark","Theme","current","baseEmpowermentColor","baseBoostColor","getAdditionColor","CosmeticGlyphTypes","currentColor","bg","getEmpowermentColor","getBoostColor","EventHub","logic","on","GAME_EVENT","TAB_CHANGED","Tab","isOpen"],"mappings":"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","sourcesContent":["import { BitUpgradeState, GameMechanicState } from \"../../game-mechanics\";\r\nimport { Quotes } from \"../quotes\";\r\n\r\nclass RaUnlockState extends BitUpgradeState {\r\n  get bits() { return player.celestials.ra.unlockBits; }\r\n  set bits(value) { player.celestials.ra.unlockBits = value; }\r\n\r\n  get disabledByPelle() {\r\n    return Pelle.isDoomed && this.config.disabledByPelle;\r\n  }\r\n\r\n  get isEffectActive() {\r\n    return this.isUnlocked && !this.disabledByPelle;\r\n  }\r\n\r\n  get requirementText() {\r\n    const pet = this.pet.name;\r\n    return this.level === 1\r\n      ? `Unlock ${pet}`\r\n      : `Get ${pet} to level ${this.level}`;\r\n  }\r\n\r\n  get reward() {\r\n    return typeof this.config.reward === \"function\"\r\n      ? this.config.reward()\r\n      : this.config.reward;\r\n  }\r\n\r\n  get displayIcon() {\r\n    return this.disabledByPelle ? `<span class=\"fas fa-ban\"></span>` : this.config.displayIcon;\r\n  }\r\n\r\n  get pet() {\r\n    return Ra.pets[this.config.pet];\r\n  }\r\n\r\n  get level() {\r\n    return this.config.level;\r\n  }\r\n\r\n  get canBeUnlocked() {\r\n    return this.pet.level >= this.level && !this.isUnlocked;\r\n  }\r\n\r\n  onUnlock() {\r\n    this.config.onUnlock?.();\r\n  }\r\n}\r\n\r\nconst unlocks = mapGameDataToObject(\r\n  GameDatabase.celestials.ra.unlocks,\r\n  config => new RaUnlockState(config)\r\n);\r\n\r\nclass RaPetState extends GameMechanicState {\r\n  get data() {\r\n    return player.celestials.ra.pets[this.id];\r\n  }\r\n\r\n  get name() {\r\n    return this.config.name;\r\n  }\r\n\r\n  get chunkGain() {\r\n    return this.config.chunkGain;\r\n  }\r\n\r\n  get memoryGain() {\r\n    return this.config.memoryGain;\r\n  }\r\n\r\n  get color() {\r\n    return this.config.color;\r\n  }\r\n\r\n  get requiredUnlock() {\r\n    return this.config.requiredUnlock?.();\r\n  }\r\n\r\n  get rawMemoryChunksPerSecond() {\r\n    return this.config.rawMemoryChunksPerSecond();\r\n  }\r\n\r\n  get memoryProductionMultiplier() {\r\n    return this.config.memoryProductionMultiplier();\r\n  }\r\n\r\n  get isUnlocked() {\r\n    return this.requiredUnlock === undefined || this.requiredUnlock.isUnlocked;\r\n  }\r\n\r\n  get isCapped() {\r\n    return this.level >= Ra.levelCap;\r\n  }\r\n\r\n  get level() {\r\n    return this.isUnlocked ? this.data.level : 0;\r\n  }\r\n\r\n  set level(value) {\r\n    this.data.level = value;\r\n  }\r\n\r\n  get memories() {\r\n    return this.data.memories;\r\n  }\r\n\r\n  set memories(value) {\r\n    this.data.memories = value;\r\n  }\r\n\r\n  get memoryChunks() {\r\n    return this.data.memoryChunks;\r\n  }\r\n\r\n  set memoryChunks(value) {\r\n    this.data.memoryChunks = value;\r\n  }\r\n\r\n  get requiredMemories() {\r\n    return Ra.requiredMemoriesForLevel(this.level);\r\n  }\r\n\r\n  get memoryChunksPerSecond() {\r\n    if (!this.canGetMemoryChunks) return 0;\r\n    let res = this.rawMemoryChunksPerSecond * this.chunkUpgradeCurrentMult *\r\n      Effects.product(Ra.unlocks.continuousTTBoost.effects.memoryChunks, GlyphSacrifice.reality);\r\n    if (this.hasRemembrance) res *= Ra.remembrance.multiplier;\r\n    else if (Ra.petWithRemembrance) res *= Ra.remembrance.nerf;\r\n    return res;\r\n  }\r\n\r\n  get canGetMemoryChunks() {\r\n    return this.isUnlocked && Ra.isRunning;\r\n  }\r\n\r\n  get hasRemembrance() {\r\n    return Ra.petWithRemembrance === this.name;\r\n  }\r\n\r\n  get memoryUpgradeCurrentMult() {\r\n    return Math.pow(1.3, this.data.memoryUpgrades);\r\n  }\r\n\r\n  get chunkUpgradeCurrentMult() {\r\n    return Math.pow(1.5, this.data.chunkUpgrades);\r\n  }\r\n\r\n  get memoryUpgradeCost() {\r\n    return 1000 * Math.pow(5, this.data.memoryUpgrades);\r\n  }\r\n\r\n  get chunkUpgradeCost() {\r\n    return 5000 * Math.pow(25, this.data.chunkUpgrades);\r\n  }\r\n\r\n  get canBuyMemoryUpgrade() {\r\n    return this.memoryUpgradeCost <= this.memories;\r\n  }\r\n\r\n  get canBuyChunkUpgrade() {\r\n    return this.chunkUpgradeCost <= this.memories;\r\n  }\r\n\r\n  get memoryUpgradeCapped() {\r\n    return this.memoryUpgradeCost >= 0.5 * Ra.requiredMemoriesForLevel(Ra.levelCap - 1);\r\n  }\r\n\r\n  get chunkUpgradeCapped() {\r\n    return this.chunkUpgradeCost >= 0.5 * Ra.requiredMemoriesForLevel(Ra.levelCap - 1);\r\n  }\r\n\r\n  purchaseMemoryUpgrade() {\r\n    if (!this.canBuyMemoryUpgrade || this.memoryUpgradeCapped) return;\r\n\r\n    this.memories -= this.memoryUpgradeCost;\r\n    this.data.memoryUpgrades++;\r\n  }\r\n\r\n  purchaseChunkUpgrade() {\r\n    if (!this.canBuyChunkUpgrade || this.chunkUpgradeCapped) return;\r\n\r\n    this.memories -= this.chunkUpgradeCost;\r\n    this.data.chunkUpgrades++;\r\n  }\r\n\r\n  levelUp() {\r\n    if (this.memories < this.requiredMemories) return;\r\n\r\n    this.memories -= this.requiredMemories;\r\n    this.level++;\r\n    Ra.checkForUnlocks();\r\n  }\r\n\r\n  get unlocks() {\r\n    return Ra.unlocks.all\r\n      .filter(x => x.pet === this)\r\n      .sort((a, b) => a.level - b.level);\r\n  }\r\n\r\n  tick(realDiff, generateChunks) {\r\n    const seconds = realDiff / 1000;\r\n    const newMemoryChunks = generateChunks\r\n      ? seconds * this.memoryChunksPerSecond\r\n      : 0;\r\n    // Adding memories from half of the gained chunks this tick results in the best mathematical behavior\r\n    // for very long simulated ticks\r\n    const newMemories = seconds * (this.memoryChunks + newMemoryChunks / 2) * Ra.productionPerMemoryChunk *\r\n      this.memoryUpgradeCurrentMult;\r\n    this.memoryChunks += newMemoryChunks;\r\n    this.memories += newMemories;\r\n  }\r\n\r\n  reset() {\r\n    this.data.level = 1;\r\n    this.data.memories = 0;\r\n    this.data.memoryChunks = 0;\r\n    this.data.memoryUpgrades = 0;\r\n    this.data.chunkUpgrades = 0;\r\n  }\r\n}\r\n\r\nconst pets = mapGameDataToObject(\r\n  GameDatabase.celestials.ra.pets,\r\n  config => new RaPetState(config)\r\n);\r\n\r\nexport const Ra = {\r\n  displayName: \"Ra\",\r\n  possessiveName: \"Ra's\",\r\n  unlocks,\r\n  pets,\r\n  remembrance: {\r\n    multiplier: 5,\r\n    nerf: 0.5,\r\n    requiredLevels: 20,\r\n    get isUnlocked() {\r\n      return Ra.totalPetLevel >= this.requiredLevels;\r\n    }\r\n  },\r\n  // Dev/debug function for easier testing\r\n  reset() {\r\n    const data = player.celestials.ra;\r\n    data.unlockBits = 0;\r\n    data.run = false;\r\n    data.charged = new Set();\r\n    data.disCharge = false;\r\n    data.peakGamespeed = 1;\r\n    for (const pet of Ra.pets.all) pet.reset();\r\n  },\r\n  memoryTick(realDiff, generateChunks) {\r\n    if (!this.isUnlocked) return;\r\n    for (const pet of Ra.pets.all) pet.tick(realDiff, generateChunks);\r\n  },\r\n  get productionPerMemoryChunk() {\r\n    let res = Effects.product(Ra.unlocks.continuousTTBoost.effects.memories, Achievement(168));\r\n    for (const pet of Ra.pets.all) {\r\n      if (pet.isUnlocked) res *= pet.memoryProductionMultiplier;\r\n    }\r\n    return res;\r\n  },\r\n  get memoryBoostResources() {\r\n    const boostList = [];\r\n    for (const pet of Ra.pets.all) {\r\n      if (pet.memoryProductionMultiplier !== 1) boostList.push(pet.memoryGain);\r\n    }\r\n    if (Achievement(168).isUnlocked) boostList.push(\"Achievement 168\");\r\n    if (Ra.unlocks.continuousTTBoost.canBeApplied) boostList.push(\"current TT\");\r\n\r\n    if (boostList.length === 1) return `${boostList[0]}`;\r\n    if (boostList.length === 2) return `${boostList[0]} and ${boostList[1]}`;\r\n    return `${boostList.slice(0, -1).join(\", \")}, and ${boostList[boostList.length - 1]}`;\r\n  },\r\n  // This is the exp required ON \"level\" in order to reach \"level + 1\"\r\n  requiredMemoriesForLevel(level) {\r\n    if (level >= Ra.levelCap) return Infinity;\r\n    const adjustedLevel = level + Math.pow(level, 2) / 10;\r\n    const post15Scaling = Math.pow(1.5, Math.max(0, level - 15));\r\n    return Math.floor(Math.pow(adjustedLevel, 5.52) * post15Scaling * 1e6);\r\n  },\r\n  // Returns a string containing a time estimate for gaining a specific amount of exp (UI only)\r\n  timeToGoalString(pet, expToGain) {\r\n    // Quadratic formula for growth (uses constant growth for a = 0)\r\n    const a = Enslaved.isStoringRealTime\r\n      ? 0\r\n      : Ra.productionPerMemoryChunk * pet.memoryUpgradeCurrentMult * pet.memoryChunksPerSecond / 2;\r\n    const b = Ra.productionPerMemoryChunk * pet.memoryUpgradeCurrentMult * pet.memoryChunks;\r\n    const c = -expToGain;\r\n    const estimate = a === 0\r\n      ? -c / b\r\n      : (Math.sqrt(Math.pow(b, 2) - 4 * a * c) - b) / (2 * a);\r\n    if (Number.isFinite(estimate)) {\r\n      return `in ${TimeSpan.fromSeconds(estimate).toStringShort()}`;\r\n    }\r\n    return \"\";\r\n  },\r\n  get totalPetLevel() {\r\n    return this.pets.all.map(pet => (pet.isUnlocked ? pet.level : 0)).sum();\r\n  },\r\n  get levelCap() {\r\n    return 25;\r\n  },\r\n  get maxTotalPetLevel() {\r\n    return this.levelCap * this.pets.all.length;\r\n  },\r\n  checkForUnlocks() {\r\n    if (!VUnlocks.raUnlock.canBeApplied) return;\r\n    for (const unl of Ra.unlocks.all) {\r\n      unl.unlock();\r\n    }\r\n\r\n    Ra.checkForQuotes();\r\n  },\r\n  checkForQuotes() {\r\n    for (const quote of Ra.quotes.all) {\r\n      // Quotes without requirements will be shown in other ways\r\n      if (quote.requirement) {\r\n        quote.show();\r\n      }\r\n    }\r\n  },\r\n  initializeRun() {\r\n    clearCelestialRuns();\r\n    player.celestials.ra.run = true;\r\n    this.quotes.realityEnter.show();\r\n  },\r\n  toggleMode() {\r\n    player.celestials.ra.activeMode = !player.celestials.ra.activeMode;\r\n  },\r\n  // This gets widely used in lots of places since the relevant upgrade is \"all forms of continuous non-dimension\r\n  // production\", which in this case is infinities, eternities, replicanti, dilated time, and time theorem generation.\r\n  // It also includes the 1% IP time study, Teresa's 1% EP upgrade, and the charged RM generation upgrade. Note that\r\n  // removing the hardcap of 10 may cause runaways.\r\n  theoremBoostFactor() {\r\n    return Math.min(10, Math.max(0, Currency.timeTheorems.value.pLog10() - 350) / 50);\r\n  },\r\n  get isUnlocked() {\r\n    return V.spaceTheorems >= 36;\r\n  },\r\n  get isRunning() {\r\n    return player.celestials.ra.run;\r\n  },\r\n  get totalCharges() {\r\n    return Ra.unlocks.chargedInfinityUpgrades.effectOrDefault(0);\r\n  },\r\n  get chargesLeft() {\r\n    return this.totalCharges - player.celestials.ra.charged.size;\r\n  },\r\n  get canBuyTriad() {\r\n    return Ra.unlocks.unlockHardV.canBeApplied;\r\n  },\r\n  get petWithRemembrance() {\r\n    return player.celestials.ra.petWithRemembrance;\r\n  },\r\n  set petWithRemembrance(name) {\r\n    player.celestials.ra.petWithRemembrance = name;\r\n  },\r\n  updateAlchemyFlow(realityRealTime) {\r\n    const perSecond = 1000 / realityRealTime;\r\n    for (const resource of AlchemyResources.all) {\r\n      resource.ema.addValue((resource.amount - resource.before) * perSecond);\r\n      resource.before = resource.amount;\r\n    }\r\n  },\r\n  applyAlchemyReactions(realityRealTime) {\r\n    if (!Ra.unlocks.effarigUnlock.canBeApplied) return;\r\n    const sortedReactions = AlchemyReactions.all\r\n      .compact()\r\n      .sort((r1, r2) => r2.priority - r1.priority);\r\n    for (const reaction of sortedReactions) {\r\n      reaction.combineReagents();\r\n    }\r\n    this.updateAlchemyFlow(realityRealTime);\r\n  },\r\n  get alchemyResourceCap() {\r\n    return 25000;\r\n  },\r\n  get momentumValue() {\r\n    const hoursFromUnlock = TimeSpan.fromMilliseconds(player.celestials.ra.momentumTime).totalHours;\r\n    return Math.clampMax(1 + 0.005 * hoursFromUnlock, AlchemyResource.momentum.effectValue);\r\n  },\r\n  quotes: Quotes.ra,\r\n  symbol: \"<i class='fas fa-sun'></i>\"\r\n};\r\n\r\nexport const GlyphAlteration = {\r\n  // Adding a secondary effect to some effects\r\n  get additionThreshold() {\r\n    return 1e36;\r\n  },\r\n  // One-time massive boost of a single effect\r\n  get empowermentThreshold() {\r\n    return 1e43;\r\n  },\r\n  // Scaling boost from sacrifice quantity\r\n  get boostingThreshold() {\r\n    return 1e60;\r\n  },\r\n  getSacrificePower(type) {\r\n    if (Pelle.isDisabled(\"alteration\")) return 0;\r\n    const sacPower = player.reality.glyphs.sac[type];\r\n    if (sacPower === undefined) {\r\n      throw new Error(\"Unknown sacrifice type\");\r\n    }\r\n    return sacPower;\r\n  },\r\n  get isUnlocked() {\r\n    if (Pelle.isDisabled(\"alteration\")) return false;\r\n    return Ra.unlocks.alteredGlyphs.canBeApplied;\r\n  },\r\n  isAdded(type) {\r\n    return this.isUnlocked && this.getSacrificePower(type) >= this.additionThreshold;\r\n  },\r\n  isEmpowered(type) {\r\n    return this.isUnlocked && this.getSacrificePower(type) >= this.empowermentThreshold;\r\n  },\r\n  isBoosted(type) {\r\n    return this.isUnlocked && this.getSacrificePower(type) >= this.boostingThreshold;\r\n  },\r\n  sacrificeBoost(type) {\r\n    const capped = Math.clampMax(this.getSacrificePower(type), GlyphSacrificeHandler.maxSacrificeForEffects);\r\n    return Math.log10(Math.clampMin(capped / this.boostingThreshold, 1)) / 2;\r\n  },\r\n  baseAdditionColor(isDark = Theme.current().isDark()) {\r\n    return isDark ? \"#CCCCCC\" : \"black\";\r\n  },\r\n  baseEmpowermentColor(isDark = Theme.current().isDark()) {\r\n    return isDark ? \"#EEEE30\" : \"#C6C610\";\r\n  },\r\n  baseBoostColor(isDark = Theme.current().isDark()) {\r\n    return isDark ? \"#60DDDD\" : \"#28BDBD\";\r\n  },\r\n  getAdditionColor(type) {\r\n    const isDark = CosmeticGlyphTypes[type].currentColor.bg === \"black\";\r\n    return this.isAdded(type) ? this.baseAdditionColor(isDark) : undefined;\r\n  },\r\n  getEmpowermentColor(type) {\r\n    const isDark = CosmeticGlyphTypes[type].currentColor.bg === \"black\";\r\n    return this.isEmpowered(type) ? this.baseEmpowermentColor(isDark) : undefined;\r\n  },\r\n  getBoostColor(type) {\r\n    const isDark = CosmeticGlyphTypes[type].currentColor.bg === \"black\";\r\n    return this.isBoosted(type) ? this.baseBoostColor(isDark) : undefined;\r\n  }\r\n};\r\n\r\nEventHub.logic.on(GAME_EVENT.TAB_CHANGED, () => {\r\n  if (Tab.celestials.ra.isOpen) Ra.quotes.unlock.show();\r\n});\r\n"]},"metadata":{},"sourceType":"module"}