{"ast":null,"code":"import \"core-js/modules/es.regexp.exec.js\";\nexport default {\n  name: \"AutomatorTextEditor\",\n  props: {\n    currentScriptId: {\n      type: [Number, String],\n      required: true\n    }\n  },\n\n  data() {\n    return {\n      markedLineNumber: 0,\n      unclearedLines: false,\n      isActiveScript: false\n    };\n  },\n\n  computed: {\n    UI() {\n      AutomatorTextUI.initialize();\n      return AutomatorTextUI;\n    },\n\n    fullScreen() {\n      return this.$viewModel.tabs.reality.automator.fullScreen;\n    }\n\n  },\n  watch: {\n    currentScriptId: {\n      handler(id, oldId) {\n        this.unmarkActiveLine();\n        const storedScripts = player.reality.automator.scripts;\n\n        if (!this.UI.documents[id] || this.UI.documents[id].getValue() !== storedScripts[id].content) {\n          this.UI.documents[id] = CodeMirror.Doc(storedScripts[id].content, \"automato\");\n        }\n\n        if (this.UI.editor.getDoc() !== this.UI.documents[id]) this.UI.editor.swapDoc(this.UI.documents[id]); // When a script gets deleted, get rid of the old document object\n\n        if (this.UI.documents[oldId] !== undefined && storedScripts[oldId] === undefined) {\n          delete this.UI.documents[oldId];\n        }\n      },\n\n      immediate: true\n    },\n\n    fullScreen() {\n      this.$nextTick(() => this.UI.editor.refresh());\n    }\n\n  },\n\n  created() {\n    AutomatorTextUI.initialize();\n    this.on$(GAME_EVENT.GAME_LOAD, () => this.onGameLoad());\n    this.on$(GAME_EVENT.AUTOMATOR_SAVE_CHANGED, () => this.onGameLoad());\n  },\n\n  mounted() {\n    this.$refs.container.appendChild(this.UI.container);\n    this.$nextTick(() => {\n      this.UI.editor.refresh();\n      this.UI.editor.performLint();\n      this.UI.editor.scrollTo(null, AutomatorTextUI.savedVertPos);\n    });\n  },\n\n  beforeDestroy() {\n    // This will stick around, otherwise\n    AutomatorHighlighter.clearAllHighlightedLines();\n    AutomatorTextUI.savedVertPos = AutomatorTextUI.editor.doc.scrollTop;\n    this.$refs.container.removeChild(this.UI.container);\n  },\n\n  methods: {\n    update() {\n      AutomatorBackend.jumpToActiveLine();\n      if (this.unclearedLines && !AutomatorBackend.isOn) this.clearAllActiveLines();\n\n      if (AutomatorBackend.isOn) {\n        this.setActiveState(`${AutomatorBackend.state.topLevelScript}`, AutomatorBackend.stack.top.lineNumber);\n      } else {\n        this.setActiveState(\"\", -1);\n      }\n    },\n\n    onGameLoad() {\n      this.UI.documents = {};\n    },\n\n    unmarkActiveLine() {\n      AutomatorHighlighter.updateHighlightedLine(-1, LineEnum.Active);\n    },\n\n    markActiveLine(lineNumber) {\n      AutomatorHighlighter.updateHighlightedLine(lineNumber, LineEnum.Active);\n      this.unclearedLines = true;\n    },\n\n    // This only runs when a script is interrupted and stops during execution because of the player editing the text\n    clearAllActiveLines() {\n      AutomatorHighlighter.clearAllHighlightedLines();\n      this.unclearedLines = false;\n    },\n\n    setActiveState(scriptID, lineNumber) {\n      if (`${this.currentScriptId}` === scriptID) this.markActiveLine(lineNumber);else this.unmarkActiveLine();\n    }\n\n  }\n};\nexport const AutomatorTextUI = {\n  documents: {},\n  wrapper: null,\n  editor: null,\n  container: null,\n  textArea: null,\n  mode: {\n    mode: \"automato\",\n    lint: \"automato\",\n    lineNumbers: true,\n    theme: \"liquibyte\",\n    tabSize: 2,\n    extraKeys: {\n      Tab: cm => cm.execCommand(\"indentMore\"),\n      \"Shift-Tab\": cm => cm.execCommand(\"indentLess\")\n    },\n    autoCloseBrackets: true,\n    lineWrapping: true\n  },\n\n  initialize() {\n    if (this.container) return;\n    this.setUpContainer();\n    this.setUpEditor();\n    EventHub.ui.on(GAME_EVENT.GAME_LOAD, () => this.documents = {});\n  },\n\n  setUpContainer() {\n    this.container = document.createElement(\"div\");\n    this.container.className = \"l-automator-editor__codemirror-container\";\n    this.textArea = document.createElement(\"textarea\");\n    this.container.appendChild(this.textArea);\n  },\n\n  setUpEditor() {\n    this.editor = CodeMirror.fromTextArea(this.textArea, this.mode); // CodeMirror has a built-in undo/redo functionality bound to ctrl-z/ctrl-y which doesn't have an\n    // easily-configured history buffer; we need to specifically cancel this event since we have our own undo\n\n    this.editor.on(\"beforeChange\", (_, event) => {\n      if (event.origin === \"undo\") event.cancel();\n    });\n    this.editor.on(\"keydown\", (editor, event) => {\n      const key = event.key;\n\n      if (event.ctrlKey && [\"z\", \"y\"].includes(key)) {\n        if (key === \"z\") AutomatorData.undoScriptEdit();\n        if (key === \"y\") AutomatorData.redoScriptEdit();\n        return;\n      } // This check is related to the drop-down command suggestion menu, but must come after the undo/redo check\n      // as it often evaluates to innocuous false positives which eat the keybinds\n\n\n      if (editor.state.completionActive) return;\n      if (event.ctrlKey || event.altKey || event.metaKey || !/^[\\t 0-9A-Za-z]$/.test(key)) return;\n      CodeMirror.commands.autocomplete(editor, null, {\n        completeSingle: false\n      });\n    });\n    this.editor.on(\"change\", (editor, event) => {\n      const scriptID = ui.view.tabs.reality.automator.editorScriptID;\n      const scriptText = editor.getDoc().getValue(); // Undo/redo directly changes the editor contents, which also causes this event to be fired; we have a few\n      // things which we specifically only want to do on manual typing changes\n\n      if (event.origin !== \"setValue\") {\n        AutomatorBackend.saveScript(scriptID, scriptText);\n        AutomatorData.redoBuffer = [];\n      }\n\n      AutomatorData.recalculateErrors();\n      const errors = AutomatorData.currentErrors().length;\n      if (errors > editor.doc.size) SecretAchievement(48).unlock(); // Clear all line highlighting as soon as any text is changed because that might have shifted lines around\n\n      AutomatorHighlighter.clearAllHighlightedLines();\n    });\n  },\n\n  clearEditor() {\n    // In some importing cases (mostly when importing a save without the automator unlocked), the editor doesn't exist\n    // and attempting to modify it will cause console errors; in this case we initialize it to a blank editor (even\n    // though its inaccessible) in order to prevent errors on-load and when first checking that subtab\n    if (!this.editor) {\n      this.setUpContainer();\n      this.setUpEditor();\n    }\n\n    this.editor.setValue(\"\");\n    this.editor.clearHistory();\n    this.editor.clearGutter(\"gutterId\");\n  },\n\n  // Used to return back to the same line the editor was on from before switching tabs\n  savedVertPos: 0\n};","map":{"version":3,"sources":["AutomatorTextEditor.vue"],"names":[],"mappings":"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","sourcesContent":["<script>\r\nexport default {\r\n  name: \"AutomatorTextEditor\",\r\n  props: {\r\n    currentScriptId: {\r\n      type: [Number, String],\r\n      required: true\r\n    },\r\n  },\r\n  data() {\r\n    return {\r\n      markedLineNumber: 0,\r\n      unclearedLines: false,\r\n      isActiveScript: false,\r\n    };\r\n  },\r\n  computed: {\r\n    UI() {\r\n      AutomatorTextUI.initialize();\r\n      return AutomatorTextUI;\r\n    },\r\n    fullScreen() {\r\n      return this.$viewModel.tabs.reality.automator.fullScreen;\r\n    },\r\n  },\r\n  watch: {\r\n    currentScriptId: {\r\n      handler(id, oldId) {\r\n        this.unmarkActiveLine();\r\n        const storedScripts = player.reality.automator.scripts;\r\n        if (!this.UI.documents[id] || this.UI.documents[id].getValue() !== storedScripts[id].content) {\r\n          this.UI.documents[id] = CodeMirror.Doc(storedScripts[id].content, \"automato\");\r\n        }\r\n        if (this.UI.editor.getDoc() !== this.UI.documents[id]) this.UI.editor.swapDoc(this.UI.documents[id]);\r\n        // When a script gets deleted, get rid of the old document object\r\n        if (this.UI.documents[oldId] !== undefined && storedScripts[oldId] === undefined) {\r\n          delete this.UI.documents[oldId];\r\n        }\r\n      },\r\n      immediate: true,\r\n    },\r\n    fullScreen() {\r\n      this.$nextTick(() => this.UI.editor.refresh());\r\n    }\r\n  },\r\n  created() {\r\n    AutomatorTextUI.initialize();\r\n    this.on$(GAME_EVENT.GAME_LOAD, () => this.onGameLoad());\r\n    this.on$(GAME_EVENT.AUTOMATOR_SAVE_CHANGED, () => this.onGameLoad());\r\n  },\r\n  mounted() {\r\n    this.$refs.container.appendChild(this.UI.container);\r\n    this.$nextTick(() => {\r\n      this.UI.editor.refresh();\r\n      this.UI.editor.performLint();\r\n      this.UI.editor.scrollTo(null, AutomatorTextUI.savedVertPos);\r\n    });\r\n  },\r\n  beforeDestroy() {\r\n    // This will stick around, otherwise\r\n    AutomatorHighlighter.clearAllHighlightedLines();\r\n    AutomatorTextUI.savedVertPos = AutomatorTextUI.editor.doc.scrollTop;\r\n    this.$refs.container.removeChild(this.UI.container);\r\n  },\r\n  methods: {\r\n    update() {\r\n      AutomatorBackend.jumpToActiveLine();\r\n      if (this.unclearedLines && !AutomatorBackend.isOn) this.clearAllActiveLines();\r\n      if (AutomatorBackend.isOn) {\r\n        this.setActiveState(`${AutomatorBackend.state.topLevelScript}`, AutomatorBackend.stack.top.lineNumber);\r\n      } else {\r\n        this.setActiveState(\"\", -1);\r\n      }\r\n    },\r\n    onGameLoad() {\r\n      this.UI.documents = {};\r\n    },\r\n    unmarkActiveLine() {\r\n      AutomatorHighlighter.updateHighlightedLine(-1, LineEnum.Active);\r\n    },\r\n    markActiveLine(lineNumber) {\r\n      AutomatorHighlighter.updateHighlightedLine(lineNumber, LineEnum.Active);\r\n      this.unclearedLines = true;\r\n    },\r\n    // This only runs when a script is interrupted and stops during execution because of the player editing the text\r\n    clearAllActiveLines() {\r\n      AutomatorHighlighter.clearAllHighlightedLines();\r\n      this.unclearedLines = false;\r\n    },\r\n    setActiveState(scriptID, lineNumber) {\r\n      if (`${this.currentScriptId}` === scriptID) this.markActiveLine(lineNumber);\r\n      else this.unmarkActiveLine();\r\n    },\r\n  }\r\n};\r\n\r\nexport const AutomatorTextUI = {\r\n  documents: {},\r\n  wrapper: null,\r\n  editor: null,\r\n  container: null,\r\n  textArea: null,\r\n  mode: {\r\n    mode: \"automato\",\r\n    lint: \"automato\",\r\n    lineNumbers: true,\r\n    theme: \"liquibyte\",\r\n    tabSize: 2,\r\n    extraKeys: {\r\n      Tab: cm => cm.execCommand(\"indentMore\"),\r\n      \"Shift-Tab\": cm => cm.execCommand(\"indentLess\"),\r\n    },\r\n    autoCloseBrackets: true,\r\n    lineWrapping: true\r\n  },\r\n  initialize() {\r\n    if (this.container) return;\r\n    this.setUpContainer();\r\n    this.setUpEditor();\r\n    EventHub.ui.on(GAME_EVENT.GAME_LOAD, () => this.documents = {});\r\n  },\r\n  setUpContainer() {\r\n    this.container = document.createElement(\"div\");\r\n    this.container.className = \"l-automator-editor__codemirror-container\";\r\n    this.textArea = document.createElement(\"textarea\");\r\n    this.container.appendChild(this.textArea);\r\n  },\r\n  setUpEditor() {\r\n    this.editor = CodeMirror.fromTextArea(this.textArea, this.mode);\r\n    // CodeMirror has a built-in undo/redo functionality bound to ctrl-z/ctrl-y which doesn't have an\r\n    // easily-configured history buffer; we need to specifically cancel this event since we have our own undo\r\n    this.editor.on(\"beforeChange\", (_, event) => {\r\n      if (event.origin === \"undo\") event.cancel();\r\n    });\r\n    this.editor.on(\"keydown\", (editor, event) => {\r\n      const key = event.key;\r\n      if (event.ctrlKey && [\"z\", \"y\"].includes(key)) {\r\n        if (key === \"z\") AutomatorData.undoScriptEdit();\r\n        if (key === \"y\") AutomatorData.redoScriptEdit();\r\n        return;\r\n      }\r\n      // This check is related to the drop-down command suggestion menu, but must come after the undo/redo check\r\n      // as it often evaluates to innocuous false positives which eat the keybinds\r\n      if (editor.state.completionActive) return;\r\n      if (event.ctrlKey || event.altKey || event.metaKey || !/^[a-zA-Z0-9 \\t]$/u.test(key)) return;\r\n      CodeMirror.commands.autocomplete(editor, null, { completeSingle: false });\r\n    });\r\n    this.editor.on(\"change\", (editor, event) => {\r\n      const scriptID = ui.view.tabs.reality.automator.editorScriptID;\r\n      const scriptText = editor.getDoc().getValue();\r\n      // Undo/redo directly changes the editor contents, which also causes this event to be fired; we have a few\r\n      // things which we specifically only want to do on manual typing changes\r\n      if (event.origin !== \"setValue\") {\r\n        AutomatorBackend.saveScript(scriptID, scriptText);\r\n        AutomatorData.redoBuffer = [];\r\n      }\r\n\r\n      AutomatorData.recalculateErrors();\r\n      const errors = AutomatorData.currentErrors().length;\r\n      if (errors > editor.doc.size) SecretAchievement(48).unlock();\r\n\r\n      // Clear all line highlighting as soon as any text is changed because that might have shifted lines around\r\n      AutomatorHighlighter.clearAllHighlightedLines();\r\n    });\r\n  },\r\n  clearEditor() {\r\n    // In some importing cases (mostly when importing a save without the automator unlocked), the editor doesn't exist\r\n    // and attempting to modify it will cause console errors; in this case we initialize it to a blank editor (even\r\n    // though its inaccessible) in order to prevent errors on-load and when first checking that subtab\r\n    if (!this.editor) {\r\n      this.setUpContainer();\r\n      this.setUpEditor();\r\n    }\r\n    this.editor.setValue(\"\");\r\n    this.editor.clearHistory();\r\n    this.editor.clearGutter(\"gutterId\");\r\n  },\r\n  // Used to return back to the same line the editor was on from before switching tabs\r\n  savedVertPos: 0,\r\n};\r\n</script>\r\n\r\n<template>\r\n  <div\r\n    ref=\"container\"\r\n    class=\"c-automator-editor l-automator-editor l-automator-pane__content\"\r\n  />\r\n</template>\r\n"],"sourceRoot":"src/components/tabs/automator"},"metadata":{},"sourceType":"module"}