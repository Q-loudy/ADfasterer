{"ast":null,"code":"import \"core-js/modules/web.dom-collections.iterator.js\";\nimport { GameMechanicState, SetPurchasableMechanicState } from \"./game-mechanics\";\nimport { DC } from \"./constants\";\n\nclass ChargedInfinityUpgradeState extends GameMechanicState {\n  constructor(config, upgrade) {\n    super(config);\n    this._upgrade = upgrade;\n  }\n\n  get isEffectActive() {\n    return this._upgrade.isBought && this._upgrade.isCharged;\n  }\n\n}\n\nexport class InfinityUpgradeState extends SetPurchasableMechanicState {\n  constructor(config) {\n    super(config);\n\n    if (config.charged) {\n      this._chargedEffect = new ChargedInfinityUpgradeState(config.charged, this);\n    }\n  }\n\n  get currency() {\n    return Currency.infinityPoints;\n  }\n\n  get set() {\n    return player.infinityUpgrades;\n  }\n\n  get isAvailableForPurchase() {\n    var _this$config$checkReq, _this$config$checkReq2, _this$config;\n\n    return (_this$config$checkReq = (_this$config$checkReq2 = (_this$config = this.config).checkRequirement) === null || _this$config$checkReq2 === void 0 ? void 0 : _this$config$checkReq2.call(_this$config)) !== null && _this$config$checkReq !== void 0 ? _this$config$checkReq : true;\n  }\n\n  get isEffectActive() {\n    return this.isBought && !this.isCharged;\n  }\n\n  get chargedEffect() {\n    return this._chargedEffect;\n  }\n\n  purchase() {\n    if (super.purchase()) {\n      // This applies the 4th column of infinity upgrades retroactively\n      if (this.config.id.includes(\"skip\")) skipResetsIfPossible();\n      EventHub.dispatch(GAME_EVENT.INFINITY_UPGRADE_BOUGHT);\n      return true;\n    }\n\n    if (this.canCharge) {\n      this.charge();\n      EventHub.dispatch(GAME_EVENT.INFINITY_UPGRADE_CHARGED);\n      return true;\n    }\n\n    return false;\n  }\n\n  get hasChargeEffect() {\n    return this.config.charged !== undefined;\n  }\n\n  get isCharged() {\n    return player.celestials.ra.charged.has(this.id);\n  }\n\n  get canCharge() {\n    return this.isBought && this.hasChargeEffect && !this.isCharged && Ra.chargesLeft !== 0 && !Pelle.isDisabled(\"chargedInfinityUpgrades\");\n  }\n\n  charge() {\n    player.celestials.ra.charged.add(this.id);\n  }\n\n  disCharge() {\n    player.celestials.ra.charged.delete(this.id);\n  }\n\n}\nexport function totalIPMult() {\n  if (Effarig.isRunning && Effarig.currentStage === EFFARIG_STAGES.INFINITY) {\n    return DC.D1;\n  }\n\n  let ipMult = DC.D1.times(ShopPurchase.IPPurchases.currentMult).timesEffectsOf(TimeStudy(41), TimeStudy(51), TimeStudy(141), TimeStudy(142), TimeStudy(143), Achievement(85), Achievement(93), Achievement(116), Achievement(125), Achievement(141).effects.ipGain, InfinityUpgrade.ipMult, DilationUpgrade.ipMultDT, GlyphEffect.ipMult);\n  ipMult = ipMult.times(Replicanti.amount.powEffectOf(AlchemyResource.exponential));\n  return ipMult;\n}\nexport function disChargeAll() {\n  const upgrades = [InfinityUpgrade.totalTimeMult, InfinityUpgrade.dim18mult, InfinityUpgrade.dim36mult, InfinityUpgrade.resetBoost, InfinityUpgrade.buy10Mult, InfinityUpgrade.dim27mult, InfinityUpgrade.dim45mult, InfinityUpgrade.galaxyBoost, InfinityUpgrade.thisInfinityTimeMult, InfinityUpgrade.unspentIPMult, InfinityUpgrade.dimboostMult, InfinityUpgrade.ipGen];\n\n  for (const upgrade of upgrades) {\n    if (upgrade.isCharged) {\n      upgrade.disCharge();\n    }\n  }\n\n  player.celestials.ra.disCharge = false;\n  EventHub.dispatch(GAME_EVENT.INFINITY_UPGRADES_DISCHARGED);\n} // The repeatable 2xIP upgrade has an odd cost structure - it follows a shallow exponential (step *10) up to e3M, at\n// which point it follows a steeper one (step *1e10) up to e6M before finally hardcapping. At the hardcap, there's\n// an extra bump that increases the multipler itself from e993k to e1M. All these numbers are specified in\n// GameDatabase.infinity.upgrades.ipMult\n\nclass InfinityIPMultUpgrade extends GameMechanicState {\n  get cost() {\n    if (this.purchaseCount >= this.purchasesAtIncrease) {\n      return this.config.costIncreaseThreshold.times(Decimal.pow(this.costIncrease, this.purchaseCount - this.purchasesAtIncrease));\n    }\n\n    return Decimal.pow(this.costIncrease, this.purchaseCount + 1);\n  }\n\n  get purchaseCount() {\n    return player.IPMultPurchases;\n  }\n\n  get purchasesAtIncrease() {\n    return this.config.costIncreaseThreshold.log10() - 1;\n  }\n\n  get hasIncreasedCost() {\n    return this.purchaseCount >= this.purchasesAtIncrease;\n  }\n\n  get costIncrease() {\n    return this.hasIncreasedCost ? 1e10 : 10;\n  }\n\n  get isCapped() {\n    return this.cost.gte(this.config.costCap);\n  }\n\n  get isBought() {\n    return this.isCapped;\n  }\n\n  get isRequirementSatisfied() {\n    return Achievement(41).isUnlocked;\n  }\n\n  get canBeBought() {\n    return !Pelle.isDoomed && !this.isCapped && Currency.infinityPoints.gte(this.cost) && this.isRequirementSatisfied;\n  } // This is only ever called with amount = 1 or within buyMax under conditions that ensure the scaling doesn't\n  // change mid-purchase\n\n\n  purchase(amount = 1) {\n    if (!this.canBeBought) return;\n\n    if (!TimeStudy(181).isBought) {\n      Autobuyer.bigCrunch.bumpAmount(DC.D2.pow(amount));\n    }\n\n    Currency.infinityPoints.subtract(Decimal.sumGeometricSeries(amount, this.cost, this.costIncrease, 0));\n    player.IPMultPurchases += amount;\n    GameUI.update();\n  }\n\n  buyMax() {\n    if (!this.canBeBought) return;\n\n    if (!this.hasIncreasedCost) {\n      // Only allow IP below the softcap to be used\n      const availableIP = Currency.infinityPoints.value.clampMax(this.config.costIncreaseThreshold);\n      const purchases = Decimal.affordGeometricSeries(availableIP, this.cost, this.costIncrease, 0).toNumber();\n      if (purchases <= 0) return;\n      this.purchase(purchases);\n    } // Do not replace it with `if else` - it's specifically designed to process two sides of threshold separately\n    // (for example, we have 1e4000000 IP and no mult - first it will go to (but not including) 1e3000000 and then\n    // it will go in this part)\n\n\n    if (this.hasIncreasedCost) {\n      const availableIP = Currency.infinityPoints.value.clampMax(this.config.costCap);\n      const purchases = Decimal.affordGeometricSeries(availableIP, this.cost, this.costIncrease, 0).toNumber();\n      if (purchases <= 0) return;\n      this.purchase(purchases);\n    }\n  }\n\n}\n\nexport const InfinityUpgrade = mapGameDataToObject(GameDatabase.infinity.upgrades, config => config.id === \"ipMult\" ? new InfinityIPMultUpgrade(config) : new InfinityUpgradeState(config));","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/infinity-upgrades.js"],"names":["GameMechanicState","SetPurchasableMechanicState","DC","ChargedInfinityUpgradeState","constructor","config","upgrade","_upgrade","isEffectActive","isBought","isCharged","InfinityUpgradeState","charged","_chargedEffect","currency","Currency","infinityPoints","set","player","infinityUpgrades","isAvailableForPurchase","checkRequirement","chargedEffect","purchase","id","includes","skipResetsIfPossible","EventHub","dispatch","GAME_EVENT","INFINITY_UPGRADE_BOUGHT","canCharge","charge","INFINITY_UPGRADE_CHARGED","hasChargeEffect","undefined","celestials","ra","has","Ra","chargesLeft","Pelle","isDisabled","add","disCharge","delete","totalIPMult","Effarig","isRunning","currentStage","EFFARIG_STAGES","INFINITY","D1","ipMult","times","ShopPurchase","IPPurchases","currentMult","timesEffectsOf","TimeStudy","Achievement","effects","ipGain","InfinityUpgrade","DilationUpgrade","ipMultDT","GlyphEffect","Replicanti","amount","powEffectOf","AlchemyResource","exponential","disChargeAll","upgrades","totalTimeMult","dim18mult","dim36mult","resetBoost","buy10Mult","dim27mult","dim45mult","galaxyBoost","thisInfinityTimeMult","unspentIPMult","dimboostMult","ipGen","INFINITY_UPGRADES_DISCHARGED","InfinityIPMultUpgrade","cost","purchaseCount","purchasesAtIncrease","costIncreaseThreshold","Decimal","pow","costIncrease","IPMultPurchases","log10","hasIncreasedCost","isCapped","gte","costCap","isRequirementSatisfied","isUnlocked","canBeBought","isDoomed","Autobuyer","bigCrunch","bumpAmount","D2","subtract","sumGeometricSeries","GameUI","update","buyMax","availableIP","value","clampMax","purchases","affordGeometricSeries","toNumber","mapGameDataToObject","GameDatabase","infinity"],"mappings":";AAAA,SAASA,iBAAT,EAA4BC,2BAA5B,QAA+D,kBAA/D;AACA,SAASC,EAAT,QAAmB,aAAnB;;AAEA,MAAMC,2BAAN,SAA0CH,iBAA1C,CAA4D;AAC1DI,EAAAA,WAAW,CAACC,MAAD,EAASC,OAAT,EAAkB;AAC3B,UAAMD,MAAN;AACA,SAAKE,QAAL,GAAgBD,OAAhB;AACD;;AAEiB,MAAdE,cAAc,GAAG;AACnB,WAAO,KAAKD,QAAL,CAAcE,QAAd,IAA0B,KAAKF,QAAL,CAAcG,SAA/C;AACD;;AARyD;;AAW5D,OAAO,MAAMC,oBAAN,SAAmCV,2BAAnC,CAA+D;AACpEG,EAAAA,WAAW,CAACC,MAAD,EAAS;AAClB,UAAMA,MAAN;;AACA,QAAIA,MAAM,CAACO,OAAX,EAAoB;AAClB,WAAKC,cAAL,GAAsB,IAAIV,2BAAJ,CAAgCE,MAAM,CAACO,OAAvC,EAAgD,IAAhD,CAAtB;AACD;AACF;;AAEW,MAARE,QAAQ,GAAG;AACb,WAAOC,QAAQ,CAACC,cAAhB;AACD;;AAEM,MAAHC,GAAG,GAAG;AACR,WAAOC,MAAM,CAACC,gBAAd;AACD;;AAEyB,MAAtBC,sBAAsB,GAAG;AAAA;;AAC3B,8DAAO,qBAAKf,MAAL,EAAYgB,gBAAnB,2DAAO,yCAAP,yEAA2C,IAA3C;AACD;;AAEiB,MAAdb,cAAc,GAAG;AACnB,WAAO,KAAKC,QAAL,IAAiB,CAAC,KAAKC,SAA9B;AACD;;AAEgB,MAAbY,aAAa,GAAG;AAClB,WAAO,KAAKT,cAAZ;AACD;;AAEDU,EAAAA,QAAQ,GAAG;AACT,QAAI,MAAMA,QAAN,EAAJ,EAAsB;AACpB;AACA,UAAI,KAAKlB,MAAL,CAAYmB,EAAZ,CAAeC,QAAf,CAAwB,MAAxB,CAAJ,EAAqCC,oBAAoB;AACzDC,MAAAA,QAAQ,CAACC,QAAT,CAAkBC,UAAU,CAACC,uBAA7B;AACA,aAAO,IAAP;AACD;;AACD,QAAI,KAAKC,SAAT,EAAoB;AAClB,WAAKC,MAAL;AACAL,MAAAA,QAAQ,CAACC,QAAT,CAAkBC,UAAU,CAACI,wBAA7B;AACA,aAAO,IAAP;AACD;;AACD,WAAO,KAAP;AACD;;AAEkB,MAAfC,eAAe,GAAG;AACpB,WAAO,KAAK7B,MAAL,CAAYO,OAAZ,KAAwBuB,SAA/B;AACD;;AAEY,MAATzB,SAAS,GAAG;AACd,WAAOQ,MAAM,CAACkB,UAAP,CAAkBC,EAAlB,CAAqBzB,OAArB,CAA6B0B,GAA7B,CAAiC,KAAKd,EAAtC,CAAP;AACD;;AAEY,MAATO,SAAS,GAAG;AACd,WAAO,KAAKtB,QAAL,IACL,KAAKyB,eADA,IAEL,CAAC,KAAKxB,SAFD,IAGL6B,EAAE,CAACC,WAAH,KAAmB,CAHd,IAIL,CAACC,KAAK,CAACC,UAAN,CAAiB,yBAAjB,CAJH;AAKD;;AAEDV,EAAAA,MAAM,GAAG;AACPd,IAAAA,MAAM,CAACkB,UAAP,CAAkBC,EAAlB,CAAqBzB,OAArB,CAA6B+B,GAA7B,CAAiC,KAAKnB,EAAtC;AACD;;AAEDoB,EAAAA,SAAS,GAAG;AACV1B,IAAAA,MAAM,CAACkB,UAAP,CAAkBC,EAAlB,CAAqBzB,OAArB,CAA6BiC,MAA7B,CAAoC,KAAKrB,EAAzC;AACD;;AAjEmE;AAoEtE,OAAO,SAASsB,WAAT,GAAuB;AAC5B,MAAIC,OAAO,CAACC,SAAR,IAAqBD,OAAO,CAACE,YAAR,KAAyBC,cAAc,CAACC,QAAjE,EAA2E;AACzE,WAAOjD,EAAE,CAACkD,EAAV;AACD;;AACD,MAAIC,MAAM,GAAGnD,EAAE,CAACkD,EAAH,CACVE,KADU,CACJC,YAAY,CAACC,WAAb,CAAyBC,WADrB,EAEVC,cAFU,CAGTC,SAAS,CAAC,EAAD,CAHA,EAITA,SAAS,CAAC,EAAD,CAJA,EAKTA,SAAS,CAAC,GAAD,CALA,EAMTA,SAAS,CAAC,GAAD,CANA,EAOTA,SAAS,CAAC,GAAD,CAPA,EAQTC,WAAW,CAAC,EAAD,CARF,EASTA,WAAW,CAAC,EAAD,CATF,EAUTA,WAAW,CAAC,GAAD,CAVF,EAWTA,WAAW,CAAC,GAAD,CAXF,EAYTA,WAAW,CAAC,GAAD,CAAX,CAAiBC,OAAjB,CAAyBC,MAZhB,EAaTC,eAAe,CAACV,MAbP,EAcTW,eAAe,CAACC,QAdP,EAeTC,WAAW,CAACb,MAfH,CAAb;AAiBAA,EAAAA,MAAM,GAAGA,MAAM,CAACC,KAAP,CAAaa,UAAU,CAACC,MAAX,CAAkBC,WAAlB,CAA8BC,eAAe,CAACC,WAA9C,CAAb,CAAT;AACA,SAAOlB,MAAP;AACD;AAED,OAAO,SAASmB,YAAT,GAAwB;AAC7B,QAAMC,QAAQ,GAAG,CACfV,eAAe,CAACW,aADD,EAEfX,eAAe,CAACY,SAFD,EAGfZ,eAAe,CAACa,SAHD,EAIfb,eAAe,CAACc,UAJD,EAKfd,eAAe,CAACe,SALD,EAMff,eAAe,CAACgB,SAND,EAOfhB,eAAe,CAACiB,SAPD,EAQfjB,eAAe,CAACkB,WARD,EASflB,eAAe,CAACmB,oBATD,EAUfnB,eAAe,CAACoB,aAVD,EAWfpB,eAAe,CAACqB,YAXD,EAYfrB,eAAe,CAACsB,KAZD,CAAjB;;AAcA,OAAK,MAAM/E,OAAX,IAAsBmE,QAAtB,EAAgC;AAC9B,QAAInE,OAAO,CAACI,SAAZ,EAAuB;AACrBJ,MAAAA,OAAO,CAACsC,SAAR;AACD;AACF;;AACD1B,EAAAA,MAAM,CAACkB,UAAP,CAAkBC,EAAlB,CAAqBO,SAArB,GAAiC,KAAjC;AACAjB,EAAAA,QAAQ,CAACC,QAAT,CAAkBC,UAAU,CAACyD,4BAA7B;AACD,C,CAED;AACA;AACA;AACA;;AACA,MAAMC,qBAAN,SAAoCvF,iBAApC,CAAsD;AAC5C,MAAJwF,IAAI,GAAG;AACT,QAAI,KAAKC,aAAL,IAAsB,KAAKC,mBAA/B,EAAoD;AAClD,aAAO,KAAKrF,MAAL,CAAYsF,qBAAZ,CACJrC,KADI,CACEsC,OAAO,CAACC,GAAR,CAAY,KAAKC,YAAjB,EAA+B,KAAKL,aAAL,GAAqB,KAAKC,mBAAzD,CADF,CAAP;AAED;;AACD,WAAOE,OAAO,CAACC,GAAR,CAAY,KAAKC,YAAjB,EAA+B,KAAKL,aAAL,GAAqB,CAApD,CAAP;AACD;;AAEgB,MAAbA,aAAa,GAAG;AAClB,WAAOvE,MAAM,CAAC6E,eAAd;AACD;;AAEsB,MAAnBL,mBAAmB,GAAG;AACxB,WAAO,KAAKrF,MAAL,CAAYsF,qBAAZ,CAAkCK,KAAlC,KAA4C,CAAnD;AACD;;AAEmB,MAAhBC,gBAAgB,GAAG;AACrB,WAAO,KAAKR,aAAL,IAAsB,KAAKC,mBAAlC;AACD;;AAEe,MAAZI,YAAY,GAAG;AACjB,WAAO,KAAKG,gBAAL,GAAwB,IAAxB,GAA+B,EAAtC;AACD;;AAEW,MAARC,QAAQ,GAAG;AACb,WAAO,KAAKV,IAAL,CAAUW,GAAV,CAAc,KAAK9F,MAAL,CAAY+F,OAA1B,CAAP;AACD;;AAEW,MAAR3F,QAAQ,GAAG;AACb,WAAO,KAAKyF,QAAZ;AACD;;AAEyB,MAAtBG,sBAAsB,GAAG;AAC3B,WAAOzC,WAAW,CAAC,EAAD,CAAX,CAAgB0C,UAAvB;AACD;;AAEc,MAAXC,WAAW,GAAG;AAChB,WAAO,CAAC9D,KAAK,CAAC+D,QAAP,IAAmB,CAAC,KAAKN,QAAzB,IAAqCnF,QAAQ,CAACC,cAAT,CAAwBmF,GAAxB,CAA4B,KAAKX,IAAjC,CAArC,IAA+E,KAAKa,sBAA3F;AACD,GAvCmD,CAyCpD;AACA;;;AACA9E,EAAAA,QAAQ,CAAC6C,MAAM,GAAG,CAAV,EAAa;AACnB,QAAI,CAAC,KAAKmC,WAAV,EAAuB;;AACvB,QAAI,CAAC5C,SAAS,CAAC,GAAD,CAAT,CAAelD,QAApB,EAA8B;AAC5BgG,MAAAA,SAAS,CAACC,SAAV,CAAoBC,UAApB,CAA+BzG,EAAE,CAAC0G,EAAH,CAAMf,GAAN,CAAUzB,MAAV,CAA/B;AACD;;AACDrD,IAAAA,QAAQ,CAACC,cAAT,CAAwB6F,QAAxB,CAAiCjB,OAAO,CAACkB,kBAAR,CAA2B1C,MAA3B,EAAmC,KAAKoB,IAAxC,EAA8C,KAAKM,YAAnD,EAAiE,CAAjE,CAAjC;AACA5E,IAAAA,MAAM,CAAC6E,eAAP,IAA0B3B,MAA1B;AACA2C,IAAAA,MAAM,CAACC,MAAP;AACD;;AAEDC,EAAAA,MAAM,GAAG;AACP,QAAI,CAAC,KAAKV,WAAV,EAAuB;;AACvB,QAAI,CAAC,KAAKN,gBAAV,EAA4B;AAC1B;AACA,YAAMiB,WAAW,GAAGnG,QAAQ,CAACC,cAAT,CAAwBmG,KAAxB,CAA8BC,QAA9B,CAAuC,KAAK/G,MAAL,CAAYsF,qBAAnD,CAApB;AACA,YAAM0B,SAAS,GAAGzB,OAAO,CAAC0B,qBAAR,CAA8BJ,WAA9B,EAA2C,KAAK1B,IAAhD,EAAsD,KAAKM,YAA3D,EAAyE,CAAzE,EAA4EyB,QAA5E,EAAlB;AACA,UAAIF,SAAS,IAAI,CAAjB,EAAoB;AACpB,WAAK9F,QAAL,CAAc8F,SAAd;AACD,KARM,CASP;AACA;AACA;;;AACA,QAAI,KAAKpB,gBAAT,EAA2B;AACzB,YAAMiB,WAAW,GAAGnG,QAAQ,CAACC,cAAT,CAAwBmG,KAAxB,CAA8BC,QAA9B,CAAuC,KAAK/G,MAAL,CAAY+F,OAAnD,CAApB;AACA,YAAMiB,SAAS,GAAGzB,OAAO,CAAC0B,qBAAR,CAA8BJ,WAA9B,EAA2C,KAAK1B,IAAhD,EAAsD,KAAKM,YAA3D,EAAyE,CAAzE,EAA4EyB,QAA5E,EAAlB;AACA,UAAIF,SAAS,IAAI,CAAjB,EAAoB;AACpB,WAAK9F,QAAL,CAAc8F,SAAd;AACD;AACF;;AAvEmD;;AA0EtD,OAAO,MAAMtD,eAAe,GAAGyD,mBAAmB,CAChDC,YAAY,CAACC,QAAb,CAAsBjD,QAD0B,EAEhDpE,MAAM,IAAKA,MAAM,CAACmB,EAAP,KAAc,QAAd,GACP,IAAI+D,qBAAJ,CAA0BlF,MAA1B,CADO,GAEP,IAAIM,oBAAJ,CAAyBN,MAAzB,CAJ4C,CAA3C","sourcesContent":["import { GameMechanicState, SetPurchasableMechanicState } from \"./game-mechanics\";\r\nimport { DC } from \"./constants\";\r\n\r\nclass ChargedInfinityUpgradeState extends GameMechanicState {\r\n  constructor(config, upgrade) {\r\n    super(config);\r\n    this._upgrade = upgrade;\r\n  }\r\n\r\n  get isEffectActive() {\r\n    return this._upgrade.isBought && this._upgrade.isCharged;\r\n  }\r\n}\r\n\r\nexport class InfinityUpgradeState extends SetPurchasableMechanicState {\r\n  constructor(config) {\r\n    super(config);\r\n    if (config.charged) {\r\n      this._chargedEffect = new ChargedInfinityUpgradeState(config.charged, this);\r\n    }\r\n  }\r\n\r\n  get currency() {\r\n    return Currency.infinityPoints;\r\n  }\r\n\r\n  get set() {\r\n    return player.infinityUpgrades;\r\n  }\r\n\r\n  get isAvailableForPurchase() {\r\n    return this.config.checkRequirement?.() ?? true;\r\n  }\r\n\r\n  get isEffectActive() {\r\n    return this.isBought && !this.isCharged;\r\n  }\r\n\r\n  get chargedEffect() {\r\n    return this._chargedEffect;\r\n  }\r\n\r\n  purchase() {\r\n    if (super.purchase()) {\r\n      // This applies the 4th column of infinity upgrades retroactively\r\n      if (this.config.id.includes(\"skip\")) skipResetsIfPossible();\r\n      EventHub.dispatch(GAME_EVENT.INFINITY_UPGRADE_BOUGHT);\r\n      return true;\r\n    }\r\n    if (this.canCharge) {\r\n      this.charge();\r\n      EventHub.dispatch(GAME_EVENT.INFINITY_UPGRADE_CHARGED);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  get hasChargeEffect() {\r\n    return this.config.charged !== undefined;\r\n  }\r\n\r\n  get isCharged() {\r\n    return player.celestials.ra.charged.has(this.id);\r\n  }\r\n\r\n  get canCharge() {\r\n    return this.isBought &&\r\n      this.hasChargeEffect &&\r\n      !this.isCharged &&\r\n      Ra.chargesLeft !== 0 &&\r\n      !Pelle.isDisabled(\"chargedInfinityUpgrades\");\r\n  }\r\n\r\n  charge() {\r\n    player.celestials.ra.charged.add(this.id);\r\n  }\r\n\r\n  disCharge() {\r\n    player.celestials.ra.charged.delete(this.id);\r\n  }\r\n}\r\n\r\nexport function totalIPMult() {\r\n  if (Effarig.isRunning && Effarig.currentStage === EFFARIG_STAGES.INFINITY) {\r\n    return DC.D1;\r\n  }\r\n  let ipMult = DC.D1\r\n    .times(ShopPurchase.IPPurchases.currentMult)\r\n    .timesEffectsOf(\r\n      TimeStudy(41),\r\n      TimeStudy(51),\r\n      TimeStudy(141),\r\n      TimeStudy(142),\r\n      TimeStudy(143),\r\n      Achievement(85),\r\n      Achievement(93),\r\n      Achievement(116),\r\n      Achievement(125),\r\n      Achievement(141).effects.ipGain,\r\n      InfinityUpgrade.ipMult,\r\n      DilationUpgrade.ipMultDT,\r\n      GlyphEffect.ipMult\r\n    );\r\n  ipMult = ipMult.times(Replicanti.amount.powEffectOf(AlchemyResource.exponential));\r\n  return ipMult;\r\n}\r\n\r\nexport function disChargeAll() {\r\n  const upgrades = [\r\n    InfinityUpgrade.totalTimeMult,\r\n    InfinityUpgrade.dim18mult,\r\n    InfinityUpgrade.dim36mult,\r\n    InfinityUpgrade.resetBoost,\r\n    InfinityUpgrade.buy10Mult,\r\n    InfinityUpgrade.dim27mult,\r\n    InfinityUpgrade.dim45mult,\r\n    InfinityUpgrade.galaxyBoost,\r\n    InfinityUpgrade.thisInfinityTimeMult,\r\n    InfinityUpgrade.unspentIPMult,\r\n    InfinityUpgrade.dimboostMult,\r\n    InfinityUpgrade.ipGen\r\n  ];\r\n  for (const upgrade of upgrades) {\r\n    if (upgrade.isCharged) {\r\n      upgrade.disCharge();\r\n    }\r\n  }\r\n  player.celestials.ra.disCharge = false;\r\n  EventHub.dispatch(GAME_EVENT.INFINITY_UPGRADES_DISCHARGED);\r\n}\r\n\r\n// The repeatable 2xIP upgrade has an odd cost structure - it follows a shallow exponential (step *10) up to e3M, at\r\n// which point it follows a steeper one (step *1e10) up to e6M before finally hardcapping. At the hardcap, there's\r\n// an extra bump that increases the multipler itself from e993k to e1M. All these numbers are specified in\r\n// GameDatabase.infinity.upgrades.ipMult\r\nclass InfinityIPMultUpgrade extends GameMechanicState {\r\n  get cost() {\r\n    if (this.purchaseCount >= this.purchasesAtIncrease) {\r\n      return this.config.costIncreaseThreshold\r\n        .times(Decimal.pow(this.costIncrease, this.purchaseCount - this.purchasesAtIncrease));\r\n    }\r\n    return Decimal.pow(this.costIncrease, this.purchaseCount + 1);\r\n  }\r\n\r\n  get purchaseCount() {\r\n    return player.IPMultPurchases;\r\n  }\r\n\r\n  get purchasesAtIncrease() {\r\n    return this.config.costIncreaseThreshold.log10() - 1;\r\n  }\r\n\r\n  get hasIncreasedCost() {\r\n    return this.purchaseCount >= this.purchasesAtIncrease;\r\n  }\r\n\r\n  get costIncrease() {\r\n    return this.hasIncreasedCost ? 1e10 : 10;\r\n  }\r\n\r\n  get isCapped() {\r\n    return this.cost.gte(this.config.costCap);\r\n  }\r\n\r\n  get isBought() {\r\n    return this.isCapped;\r\n  }\r\n\r\n  get isRequirementSatisfied() {\r\n    return Achievement(41).isUnlocked;\r\n  }\r\n\r\n  get canBeBought() {\r\n    return !Pelle.isDoomed && !this.isCapped && Currency.infinityPoints.gte(this.cost) && this.isRequirementSatisfied;\r\n  }\r\n\r\n  // This is only ever called with amount = 1 or within buyMax under conditions that ensure the scaling doesn't\r\n  // change mid-purchase\r\n  purchase(amount = 1) {\r\n    if (!this.canBeBought) return;\r\n    if (!TimeStudy(181).isBought) {\r\n      Autobuyer.bigCrunch.bumpAmount(DC.D2.pow(amount));\r\n    }\r\n    Currency.infinityPoints.subtract(Decimal.sumGeometricSeries(amount, this.cost, this.costIncrease, 0));\r\n    player.IPMultPurchases += amount;\r\n    GameUI.update();\r\n  }\r\n\r\n  buyMax() {\r\n    if (!this.canBeBought) return;\r\n    if (!this.hasIncreasedCost) {\r\n      // Only allow IP below the softcap to be used\r\n      const availableIP = Currency.infinityPoints.value.clampMax(this.config.costIncreaseThreshold);\r\n      const purchases = Decimal.affordGeometricSeries(availableIP, this.cost, this.costIncrease, 0).toNumber();\r\n      if (purchases <= 0) return;\r\n      this.purchase(purchases);\r\n    }\r\n    // Do not replace it with `if else` - it's specifically designed to process two sides of threshold separately\r\n    // (for example, we have 1e4000000 IP and no mult - first it will go to (but not including) 1e3000000 and then\r\n    // it will go in this part)\r\n    if (this.hasIncreasedCost) {\r\n      const availableIP = Currency.infinityPoints.value.clampMax(this.config.costCap);\r\n      const purchases = Decimal.affordGeometricSeries(availableIP, this.cost, this.costIncrease, 0).toNumber();\r\n      if (purchases <= 0) return;\r\n      this.purchase(purchases);\r\n    }\r\n  }\r\n}\r\n\r\nexport const InfinityUpgrade = mapGameDataToObject(\r\n  GameDatabase.infinity.upgrades,\r\n  config => (config.id === \"ipMult\"\r\n    ? new InfinityIPMultUpgrade(config)\r\n    : new InfinityUpgradeState(config))\r\n);\r\n"]},"metadata":{},"sourceType":"module"}