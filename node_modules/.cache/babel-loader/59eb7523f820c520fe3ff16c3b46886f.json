{"ast":null,"code":"import \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.json.stringify.js\";\nimport * as ADNotations from \"@antimatter-dimensions/notations\";\nexport const NG = {\n  startNewGame() {\n    GameEnd.creditsClosed = false;\n    GameEnd.creditsEverClosed = false;\n    player.isGameEnd = false; // We set this ASAP so that the AD tab is immediately recreated without END formatting, and any lag which could\n    // happen is instead hidden by the overlay from the credits rollback\n\n    player.celestials.pelle.doomed = false; // This is where we \"confirm\" a speedrun as completed and store all its information into the previous run prop\n    // before resetting everything.\n\n    const speedrun = player.speedrun;\n\n    if (speedrun.isActive) {\n      player.speedrun.previousRuns[player.records.fullGameCompletions + 1] = {\n        isSegmented: speedrun.isSegmented,\n        usedSTD: speedrun.usedSTD,\n        startDate: speedrun.startDate,\n        name: speedrun.name,\n        offlineTimeUsed: speedrun.offlineTimeUsed,\n        records: [...speedrun.records],\n        achievementTimes: JSON.parse(JSON.stringify(speedrun.achievementTimes)),\n        seedSelection: speedrun.seedSelection,\n        initialSeed: speedrun.initialSeed\n      }; // For the sake of keeping a bounded savefile size, we only keep a queue of the last 100 full runs. The earliest\n      // this will feasibly become an issue from nonstop speedruns is around 2030; I guess we can revisit it at that\n      // point if we really need to, but I suspect this limit should be high enough\n\n      const prevRunIndices = Object.keys(speedrun.previousRuns).map(k => Number(k));\n      if (prevRunIndices.length > 100) player.speedrun.previousRuns[prevRunIndices.min()] = undefined;\n    } // Modify beaten-game quantities before doing a carryover reset\n\n\n    player.records.fullGameCompletions++;\n    GlyphAppearanceHandler.unlockSet();\n    this.restartWithCarryover(); // The ending animation ends at 12.5, although the value continues to increase after that. We set it to a bit above\n    // 12.5 when we start the rollback animation to hide some of the unavoidable lag from all the reset functions\n\n    GameEnd.removeAdditionalEnd = true;\n    GameEnd.additionalEnd = 15; // Without the delay, this causes the saving (and its notification) to occur during the credits rollback\n\n    setTimeout(() => GameStorage.save(), 10000);\n  },\n\n  // Reset the game, but carry over some post-completion stats. We also call this when starting a speedrun, so make sure\n  // any stats which are updated due to completion happen in startNewGame() instead of in here\n  restartWithCarryover() {\n    const backUpOptions = JSON.stringify(player.options); // This can't be JSONed as it contains sets\n\n    const secretUnlocks = player.secretUnlocks;\n    const secretAchievements = JSON.stringify(player.secretAchievementBits); // We don't backup the whole player.reality.automator object because it contains \"state\",\n    // which could lead to some edge cases where it starts when it shouldn't (ie before it's unlocked)\n    // It's easier to do something like this to avoid it entirely.\n\n    const automatorConstants = JSON.stringify(player.reality.automator.constants);\n    const automatorConstantSort = JSON.stringify(player.reality.automator.constantSortOrder);\n    const automatorScripts = JSON.stringify(player.reality.automator.scripts);\n    const fullCompletions = player.records.fullGameCompletions;\n    const fullTimePlayed = player.records.previousRunRealTime + player.records.realTimePlayed;\n    const glyphCosmetics = JSON.stringify(player.reality.glyphs.cosmetics);\n    const speedrunRecords = JSON.stringify(player.speedrun.previousRuns);\n    const hasSpeedrun = player.speedrun.isUnlocked;\n    const presets = JSON.stringify(player.timestudy.presets);\n    const companions = JSON.stringify(Glyphs.allGlyphs.filter(g => g.type === \"companion\"));\n    Modal.hideAll();\n    Quote.clearAll();\n    GameStorage.hardReset();\n    player.options = JSON.parse(backUpOptions); // We need to force this one to be true because otherwise the player will be unable to select their glyphs\n    // until they can auto-reality\n\n    player.options.confirmations.glyphSelection = true;\n    player.secretUnlocks = secretUnlocks;\n    player.secretAchievementBits = JSON.parse(secretAchievements);\n    player.reality.automator.constants = JSON.parse(automatorConstants);\n    player.reality.automator.constantSortOrder = JSON.parse(automatorConstantSort);\n    player.reality.automator.scripts = JSON.parse(automatorScripts);\n    player.records.fullGameCompletions = fullCompletions;\n    player.records.previousRunRealTime = fullTimePlayed;\n    ui.view.newUI = player.options.newUI;\n    ui.view.news = player.options.news.enabled;\n    player.reality.glyphs.cosmetics = JSON.parse(glyphCosmetics);\n    player.speedrun.previousRuns = JSON.parse(speedrunRecords);\n    player.speedrun.isUnlocked = hasSpeedrun;\n    player.timestudy.presets = JSON.parse(presets);\n    JSON.parse(companions).forEach(g => {\n      Glyphs.addToInventory(g);\n    });\n    Themes.find(Theme.currentName()).set();\n    Notations.all.find(n => n.name === player.options.notation).setAsCurrent();\n    ADNotations.Settings.exponentCommas.min = 10 ** player.options.notationDigits.comma;\n    ADNotations.Settings.exponentCommas.max = 10 ** player.options.notationDigits.notation;\n    player.lastUpdate = Date.now();\n  }\n\n};","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/new-game.js"],"names":["ADNotations","NG","startNewGame","GameEnd","creditsClosed","creditsEverClosed","player","isGameEnd","celestials","pelle","doomed","speedrun","isActive","previousRuns","records","fullGameCompletions","isSegmented","usedSTD","startDate","name","offlineTimeUsed","achievementTimes","JSON","parse","stringify","seedSelection","initialSeed","prevRunIndices","Object","keys","map","k","Number","length","min","undefined","GlyphAppearanceHandler","unlockSet","restartWithCarryover","removeAdditionalEnd","additionalEnd","setTimeout","GameStorage","save","backUpOptions","options","secretUnlocks","secretAchievements","secretAchievementBits","automatorConstants","reality","automator","constants","automatorConstantSort","constantSortOrder","automatorScripts","scripts","fullCompletions","fullTimePlayed","previousRunRealTime","realTimePlayed","glyphCosmetics","glyphs","cosmetics","speedrunRecords","hasSpeedrun","isUnlocked","presets","timestudy","companions","Glyphs","allGlyphs","filter","g","type","Modal","hideAll","Quote","clearAll","hardReset","confirmations","glyphSelection","ui","view","newUI","news","enabled","forEach","addToInventory","Themes","find","Theme","currentName","set","Notations","all","n","notation","setAsCurrent","Settings","exponentCommas","notationDigits","comma","max","lastUpdate","Date","now"],"mappings":";;AAAA,OAAO,KAAKA,WAAZ,MAA6B,kCAA7B;AAEA,OAAO,MAAMC,EAAE,GAAG;AAChBC,EAAAA,YAAY,GAAG;AACbC,IAAAA,OAAO,CAACC,aAAR,GAAwB,KAAxB;AACAD,IAAAA,OAAO,CAACE,iBAAR,GAA4B,KAA5B;AACAC,IAAAA,MAAM,CAACC,SAAP,GAAmB,KAAnB,CAHa,CAIb;AACA;;AACAD,IAAAA,MAAM,CAACE,UAAP,CAAkBC,KAAlB,CAAwBC,MAAxB,GAAiC,KAAjC,CANa,CAQb;AACA;;AACA,UAAMC,QAAQ,GAAGL,MAAM,CAACK,QAAxB;;AACA,QAAIA,QAAQ,CAACC,QAAb,EAAuB;AACrBN,MAAAA,MAAM,CAACK,QAAP,CAAgBE,YAAhB,CAA6BP,MAAM,CAACQ,OAAP,CAAeC,mBAAf,GAAqC,CAAlE,IAAuE;AACrEC,QAAAA,WAAW,EAAEL,QAAQ,CAACK,WAD+C;AAErEC,QAAAA,OAAO,EAAEN,QAAQ,CAACM,OAFmD;AAGrEC,QAAAA,SAAS,EAAEP,QAAQ,CAACO,SAHiD;AAIrEC,QAAAA,IAAI,EAAER,QAAQ,CAACQ,IAJsD;AAKrEC,QAAAA,eAAe,EAAET,QAAQ,CAACS,eAL2C;AAMrEN,QAAAA,OAAO,EAAE,CAAC,GAAGH,QAAQ,CAACG,OAAb,CAN4D;AAOrEO,QAAAA,gBAAgB,EAAEC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAeb,QAAQ,CAACU,gBAAxB,CAAX,CAPmD;AAQrEI,QAAAA,aAAa,EAAEd,QAAQ,CAACc,aAR6C;AASrEC,QAAAA,WAAW,EAAEf,QAAQ,CAACe;AAT+C,OAAvE,CADqB,CAarB;AACA;AACA;;AACA,YAAMC,cAAc,GAAGC,MAAM,CAACC,IAAP,CAAYlB,QAAQ,CAACE,YAArB,EAAmCiB,GAAnC,CAAuCC,CAAC,IAAIC,MAAM,CAACD,CAAD,CAAlD,CAAvB;AACA,UAAIJ,cAAc,CAACM,MAAf,GAAwB,GAA5B,EAAiC3B,MAAM,CAACK,QAAP,CAAgBE,YAAhB,CAA6Bc,cAAc,CAACO,GAAf,EAA7B,IAAqDC,SAArD;AAClC,KA7BY,CA+Bb;;;AACA7B,IAAAA,MAAM,CAACQ,OAAP,CAAeC,mBAAf;AACAqB,IAAAA,sBAAsB,CAACC,SAAvB;AACA,SAAKC,oBAAL,GAlCa,CAoCb;AACA;;AACAnC,IAAAA,OAAO,CAACoC,mBAAR,GAA8B,IAA9B;AACApC,IAAAA,OAAO,CAACqC,aAAR,GAAwB,EAAxB,CAvCa,CAwCb;;AACAC,IAAAA,UAAU,CAAC,MAAMC,WAAW,CAACC,IAAZ,EAAP,EAA2B,KAA3B,CAAV;AACD,GA3Ce;;AA6ChB;AACA;AACAL,EAAAA,oBAAoB,GAAG;AACrB,UAAMM,aAAa,GAAGtB,IAAI,CAACE,SAAL,CAAelB,MAAM,CAACuC,OAAtB,CAAtB,CADqB,CAErB;;AACA,UAAMC,aAAa,GAAGxC,MAAM,CAACwC,aAA7B;AACA,UAAMC,kBAAkB,GAAGzB,IAAI,CAACE,SAAL,CAAelB,MAAM,CAAC0C,qBAAtB,CAA3B,CAJqB,CAKrB;AACA;AACA;;AACA,UAAMC,kBAAkB,GAAG3B,IAAI,CAACE,SAAL,CAAelB,MAAM,CAAC4C,OAAP,CAAeC,SAAf,CAAyBC,SAAxC,CAA3B;AACA,UAAMC,qBAAqB,GAAG/B,IAAI,CAACE,SAAL,CAAelB,MAAM,CAAC4C,OAAP,CAAeC,SAAf,CAAyBG,iBAAxC,CAA9B;AACA,UAAMC,gBAAgB,GAAGjC,IAAI,CAACE,SAAL,CAAelB,MAAM,CAAC4C,OAAP,CAAeC,SAAf,CAAyBK,OAAxC,CAAzB;AACA,UAAMC,eAAe,GAAGnD,MAAM,CAACQ,OAAP,CAAeC,mBAAvC;AACA,UAAM2C,cAAc,GAAGpD,MAAM,CAACQ,OAAP,CAAe6C,mBAAf,GAAqCrD,MAAM,CAACQ,OAAP,CAAe8C,cAA3E;AACA,UAAMC,cAAc,GAAGvC,IAAI,CAACE,SAAL,CAAelB,MAAM,CAAC4C,OAAP,CAAeY,MAAf,CAAsBC,SAArC,CAAvB;AACA,UAAMC,eAAe,GAAG1C,IAAI,CAACE,SAAL,CAAelB,MAAM,CAACK,QAAP,CAAgBE,YAA/B,CAAxB;AACA,UAAMoD,WAAW,GAAG3D,MAAM,CAACK,QAAP,CAAgBuD,UAApC;AACA,UAAMC,OAAO,GAAG7C,IAAI,CAACE,SAAL,CAAelB,MAAM,CAAC8D,SAAP,CAAiBD,OAAhC,CAAhB;AACA,UAAME,UAAU,GAAG/C,IAAI,CAACE,SAAL,CAAe8C,MAAM,CAACC,SAAP,CAAiBC,MAAjB,CAAwBC,CAAC,IAAIA,CAAC,CAACC,IAAF,KAAW,WAAxC,CAAf,CAAnB;AACAC,IAAAA,KAAK,CAACC,OAAN;AACAC,IAAAA,KAAK,CAACC,QAAN;AACApC,IAAAA,WAAW,CAACqC,SAAZ;AACAzE,IAAAA,MAAM,CAACuC,OAAP,GAAiBvB,IAAI,CAACC,KAAL,CAAWqB,aAAX,CAAjB,CArBqB,CAsBrB;AACA;;AACAtC,IAAAA,MAAM,CAACuC,OAAP,CAAemC,aAAf,CAA6BC,cAA7B,GAA8C,IAA9C;AACA3E,IAAAA,MAAM,CAACwC,aAAP,GAAuBA,aAAvB;AACAxC,IAAAA,MAAM,CAAC0C,qBAAP,GAA+B1B,IAAI,CAACC,KAAL,CAAWwB,kBAAX,CAA/B;AACAzC,IAAAA,MAAM,CAAC4C,OAAP,CAAeC,SAAf,CAAyBC,SAAzB,GAAqC9B,IAAI,CAACC,KAAL,CAAW0B,kBAAX,CAArC;AACA3C,IAAAA,MAAM,CAAC4C,OAAP,CAAeC,SAAf,CAAyBG,iBAAzB,GAA6ChC,IAAI,CAACC,KAAL,CAAW8B,qBAAX,CAA7C;AACA/C,IAAAA,MAAM,CAAC4C,OAAP,CAAeC,SAAf,CAAyBK,OAAzB,GAAmClC,IAAI,CAACC,KAAL,CAAWgC,gBAAX,CAAnC;AACAjD,IAAAA,MAAM,CAACQ,OAAP,CAAeC,mBAAf,GAAqC0C,eAArC;AACAnD,IAAAA,MAAM,CAACQ,OAAP,CAAe6C,mBAAf,GAAqCD,cAArC;AACAwB,IAAAA,EAAE,CAACC,IAAH,CAAQC,KAAR,GAAgB9E,MAAM,CAACuC,OAAP,CAAeuC,KAA/B;AACAF,IAAAA,EAAE,CAACC,IAAH,CAAQE,IAAR,GAAe/E,MAAM,CAACuC,OAAP,CAAewC,IAAf,CAAoBC,OAAnC;AACAhF,IAAAA,MAAM,CAAC4C,OAAP,CAAeY,MAAf,CAAsBC,SAAtB,GAAkCzC,IAAI,CAACC,KAAL,CAAWsC,cAAX,CAAlC;AACAvD,IAAAA,MAAM,CAACK,QAAP,CAAgBE,YAAhB,GAA+BS,IAAI,CAACC,KAAL,CAAWyC,eAAX,CAA/B;AACA1D,IAAAA,MAAM,CAACK,QAAP,CAAgBuD,UAAhB,GAA6BD,WAA7B;AACA3D,IAAAA,MAAM,CAAC8D,SAAP,CAAiBD,OAAjB,GAA2B7C,IAAI,CAACC,KAAL,CAAW4C,OAAX,CAA3B;AACA7C,IAAAA,IAAI,CAACC,KAAL,CAAW8C,UAAX,EAAuBkB,OAAvB,CAA+Bd,CAAC,IAAI;AAClCH,MAAAA,MAAM,CAACkB,cAAP,CAAsBf,CAAtB;AACD,KAFD;AAGAgB,IAAAA,MAAM,CAACC,IAAP,CAAYC,KAAK,CAACC,WAAN,EAAZ,EAAiCC,GAAjC;AACAC,IAAAA,SAAS,CAACC,GAAV,CAAcL,IAAd,CAAmBM,CAAC,IAAIA,CAAC,CAAC7E,IAAF,KAAWb,MAAM,CAACuC,OAAP,CAAeoD,QAAlD,EAA4DC,YAA5D;AACAlG,IAAAA,WAAW,CAACmG,QAAZ,CAAqBC,cAArB,CAAoClE,GAApC,GAA0C,MAAM5B,MAAM,CAACuC,OAAP,CAAewD,cAAf,CAA8BC,KAA9E;AACAtG,IAAAA,WAAW,CAACmG,QAAZ,CAAqBC,cAArB,CAAoCG,GAApC,GAA0C,MAAMjG,MAAM,CAACuC,OAAP,CAAewD,cAAf,CAA8BJ,QAA9E;AACA3F,IAAAA,MAAM,CAACkG,UAAP,GAAoBC,IAAI,CAACC,GAAL,EAApB;AACD;;AA7Fe,CAAX","sourcesContent":["import * as ADNotations from \"@antimatter-dimensions/notations\";\r\n\r\nexport const NG = {\r\n  startNewGame() {\r\n    GameEnd.creditsClosed = false;\r\n    GameEnd.creditsEverClosed = false;\r\n    player.isGameEnd = false;\r\n    // We set this ASAP so that the AD tab is immediately recreated without END formatting, and any lag which could\r\n    // happen is instead hidden by the overlay from the credits rollback\r\n    player.celestials.pelle.doomed = false;\r\n\r\n    // This is where we \"confirm\" a speedrun as completed and store all its information into the previous run prop\r\n    // before resetting everything.\r\n    const speedrun = player.speedrun;\r\n    if (speedrun.isActive) {\r\n      player.speedrun.previousRuns[player.records.fullGameCompletions + 1] = {\r\n        isSegmented: speedrun.isSegmented,\r\n        usedSTD: speedrun.usedSTD,\r\n        startDate: speedrun.startDate,\r\n        name: speedrun.name,\r\n        offlineTimeUsed: speedrun.offlineTimeUsed,\r\n        records: [...speedrun.records],\r\n        achievementTimes: JSON.parse(JSON.stringify(speedrun.achievementTimes)),\r\n        seedSelection: speedrun.seedSelection,\r\n        initialSeed: speedrun.initialSeed,\r\n      };\r\n\r\n      // For the sake of keeping a bounded savefile size, we only keep a queue of the last 100 full runs. The earliest\r\n      // this will feasibly become an issue from nonstop speedruns is around 2030; I guess we can revisit it at that\r\n      // point if we really need to, but I suspect this limit should be high enough\r\n      const prevRunIndices = Object.keys(speedrun.previousRuns).map(k => Number(k));\r\n      if (prevRunIndices.length > 100) player.speedrun.previousRuns[prevRunIndices.min()] = undefined;\r\n    }\r\n\r\n    // Modify beaten-game quantities before doing a carryover reset\r\n    player.records.fullGameCompletions++;\r\n    GlyphAppearanceHandler.unlockSet();\r\n    this.restartWithCarryover();\r\n\r\n    // The ending animation ends at 12.5, although the value continues to increase after that. We set it to a bit above\r\n    // 12.5 when we start the rollback animation to hide some of the unavoidable lag from all the reset functions\r\n    GameEnd.removeAdditionalEnd = true;\r\n    GameEnd.additionalEnd = 15;\r\n    // Without the delay, this causes the saving (and its notification) to occur during the credits rollback\r\n    setTimeout(() => GameStorage.save(), 10000);\r\n  },\r\n\r\n  // Reset the game, but carry over some post-completion stats. We also call this when starting a speedrun, so make sure\r\n  // any stats which are updated due to completion happen in startNewGame() instead of in here\r\n  restartWithCarryover() {\r\n    const backUpOptions = JSON.stringify(player.options);\r\n    // This can't be JSONed as it contains sets\r\n    const secretUnlocks = player.secretUnlocks;\r\n    const secretAchievements = JSON.stringify(player.secretAchievementBits);\r\n    // We don't backup the whole player.reality.automator object because it contains \"state\",\r\n    // which could lead to some edge cases where it starts when it shouldn't (ie before it's unlocked)\r\n    // It's easier to do something like this to avoid it entirely.\r\n    const automatorConstants = JSON.stringify(player.reality.automator.constants);\r\n    const automatorConstantSort = JSON.stringify(player.reality.automator.constantSortOrder);\r\n    const automatorScripts = JSON.stringify(player.reality.automator.scripts);\r\n    const fullCompletions = player.records.fullGameCompletions;\r\n    const fullTimePlayed = player.records.previousRunRealTime + player.records.realTimePlayed;\r\n    const glyphCosmetics = JSON.stringify(player.reality.glyphs.cosmetics);\r\n    const speedrunRecords = JSON.stringify(player.speedrun.previousRuns);\r\n    const hasSpeedrun = player.speedrun.isUnlocked;\r\n    const presets = JSON.stringify(player.timestudy.presets);\r\n    const companions = JSON.stringify(Glyphs.allGlyphs.filter(g => g.type === \"companion\"));\r\n    Modal.hideAll();\r\n    Quote.clearAll();\r\n    GameStorage.hardReset();\r\n    player.options = JSON.parse(backUpOptions);\r\n    // We need to force this one to be true because otherwise the player will be unable to select their glyphs\r\n    // until they can auto-reality\r\n    player.options.confirmations.glyphSelection = true;\r\n    player.secretUnlocks = secretUnlocks;\r\n    player.secretAchievementBits = JSON.parse(secretAchievements);\r\n    player.reality.automator.constants = JSON.parse(automatorConstants);\r\n    player.reality.automator.constantSortOrder = JSON.parse(automatorConstantSort);\r\n    player.reality.automator.scripts = JSON.parse(automatorScripts);\r\n    player.records.fullGameCompletions = fullCompletions;\r\n    player.records.previousRunRealTime = fullTimePlayed;\r\n    ui.view.newUI = player.options.newUI;\r\n    ui.view.news = player.options.news.enabled;\r\n    player.reality.glyphs.cosmetics = JSON.parse(glyphCosmetics);\r\n    player.speedrun.previousRuns = JSON.parse(speedrunRecords);\r\n    player.speedrun.isUnlocked = hasSpeedrun;\r\n    player.timestudy.presets = JSON.parse(presets);\r\n    JSON.parse(companions).forEach(g => {\r\n      Glyphs.addToInventory(g);\r\n    });\r\n    Themes.find(Theme.currentName()).set();\r\n    Notations.all.find(n => n.name === player.options.notation).setAsCurrent();\r\n    ADNotations.Settings.exponentCommas.min = 10 ** player.options.notationDigits.comma;\r\n    ADNotations.Settings.exponentCommas.max = 10 ** player.options.notationDigits.notation;\r\n    player.lastUpdate = Date.now();\r\n  }\r\n};\r\n"]},"metadata":{},"sourceType":"module"}