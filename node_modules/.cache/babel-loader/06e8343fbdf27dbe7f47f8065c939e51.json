{"ast":null,"code":"// There's a vue directive, long-press, defined at the bottom, which may be\n// what you want to use.\n//\n// Because it's related, we also define another directive, repeating-click, which\n// sends repeated events if the mouse is held down. (It sends firstclick and repeatclick)\n// LongPress produces 3 possible events:\n// 1) a long press (longPress property in handlers)\n// 2) a long press cancellation (early release, cancel property)\n// 3) a click (a short click, click property)\n// handlers can also have a \"repeat\" property, which is a number in ms. If defined,\n// the long press event will be fired repeatedly if the press continues, at that frequency\n//\n// Don't add your own click handlers to the object; get your clicks through\n// LongPress\n//\n// The long-press directive (v-long-press=\"{ delay:1000 }\")\n// attaches LongPress for you, and emits the following events you can listen for:\n// longpress\n// longpresscancel\n// longpressclick\nclass LongPress {\n  static initializeVars() {\n    LongPress._wasLongPress = false;\n    LongPress._pressTimer = null;\n    LongPress._currentCancelHandler = null;\n    LongPress._currentTarget = null; // Debug\n\n    LongPress._pressCount = 0;\n  }\n\n  static addTo(obj, timeout, handlers) {\n    if (!Object.prototype.hasOwnProperty.call(handlers, \"longPress\")) {\n      throw \"Need to specify a longPress handler\";\n    }\n\n    const begin = e => LongPress._pressBegin(timeout, handlers.longPress, handlers.cancel, handlers.repeat, e);\n\n    obj.addEventListener(\"mousedown\", begin);\n    obj.addEventListener(\"touchstart\", begin);\n    obj.addEventListener(\"mouseout\", LongPress._cancelCurrentPress);\n    obj.addEventListener(\"touchcancel\", LongPress._cancelCurrentPress);\n    obj.addEventListener(\"touchmove\", e => {\n      // Suggested in stackoverflow example\n      e.preventDefault();\n      const t = e.changedTouches[0];\n\n      if (obj !== document.elementFromPoint(t.pageX, t.pageY)) {\n        LongPress._cancelCurrentPress();\n      }\n    });\n\n    if (handlers.click) {\n      obj.addEventListener(\"click\", e => LongPress._handleClick(e, handlers.click));\n      obj.addEventListener(\"touchend\", e => LongPress._handleTouchEnd(e, handlers.click));\n    } else {\n      obj.addEventListener(\"click\", LongPress._cancelCurrentPress);\n      obj.addEventListener(\"touchend\", LongPress._cancelCurrentPress);\n    }\n  }\n\n  static _cancelCurrentPress(e) {\n    if (LongPress._currentCancelHandler) {\n      LongPress._currentCancelHandler(e);\n\n      LongPress._currentCancelHandler = null;\n    }\n\n    if (LongPress._pressTimer !== null) {\n      clearTimeout(LongPress._pressTimer);\n      LongPress._pressTimer = null;\n    }\n\n    LongPress._wasLongPress = false;\n    LongPress._currentTarget = null;\n  } // eslint-disable-next-line max-params\n\n\n  static _pressBegin(timeout, handler, cancelHandler, repeat, e) {\n    // If there's a timer already running, that means that something wasn't cancelled\n    // properly (a press shouldn't begin if it hasn't ended). Clear out any existing presses:\n    LongPress._cancelCurrentPress(e); // Ignore right click\n\n\n    if (e.type === \"click\" && e.button !== 0) return;\n    ++LongPress._pressCount;\n    LongPress._currentCancelHandler = cancelHandler;\n    LongPress._wasLongPress = false;\n    LongPress._currentTarget = e.target;\n    e.target.focus();\n    LongPress._pressTimer = setTimeout(() => {\n      LongPress._wasLongPress = true;\n      handler(e);\n\n      if (repeat) {\n        LongPress._beginRepeat(repeat, handler, e);\n      } else {\n        LongPress._pressTimer = null;\n        LongPress._currentCancelHandler = null;\n      }\n    }, timeout);\n  }\n\n  static _beginRepeat(timeout, handler, e) {\n    LongPress._pressTimer = setTimeout(() => {\n      handler(e);\n\n      LongPress._beginRepeat(timeout, handler, e);\n    }, timeout);\n  }\n\n  static _handleClick(e, handler) {\n    const wasLP = LongPress._wasLongPress; // If the click was of a right button, just handle it\n\n    if (e.button !== 0) return handler(e); // Cancel any existing presses\n\n    LongPress._cancelCurrentPress(e); // If we just had a long press event, ignore the click\n\n\n    return wasLP ? false : handler(e);\n  }\n\n  static _handleTouchEnd(e, handler) {\n    // On touch devices, I don't think we get a normal click event; so we determine\n    // a click based on a touch ending. To be on the safe side, we make sure the touch\n    // began in the same place.\n    const savedTarget = LongPress._currentTarget;\n    const wasLP = LongPress._wasLongPress; // Cancel any existing presses\n\n    LongPress._cancelCurrentPress(e); // If we just had a long press event, ignore the click; make sure targets match\n\n\n    return !wasLP && savedTarget === e.target ? handler(e) : false;\n  }\n\n}\n\nLongPress.initializeVars();\nexport function useLongPress(vue) {\n  vue.directive(\"long-press\", {\n    bind(el, binding, vnode) {\n      // This seems to be the only way to get events to our component\n      const emit = (name, data) => {\n        const handlers = vnode.data && vnode.data.on;\n\n        if (handlers && handlers[name]) {\n          handlers[name].fns(data);\n        }\n      };\n\n      LongPress.addTo(el, binding.value.delay, {\n        longPress: () => emit(\"longpress\"),\n        cancel: () => emit(\"longpresscancel\"),\n        click: () => emit(\"longpressclick\")\n      });\n    }\n\n  });\n}\nexport function useRepeatingClick(vue) {\n  vue.directive(\"repeating-click\", {\n    bind(el, binding, vnode) {\n      // This seems to be the only way to get events to our component\n      const emit = (name, data) => {\n        const handlers = vnode.data && vnode.data.on;\n\n        if (handlers && handlers[name]) {\n          handlers[name].fns(data);\n        }\n      };\n\n      LongPress.addTo(el, binding.value.delay, {\n        longPress: () => emit(\"repeatclick\"),\n        click: () => emit(\"firstclick\"),\n        repeat: 250\n      });\n    }\n\n  });\n}","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/longpress.js"],"names":["LongPress","initializeVars","_wasLongPress","_pressTimer","_currentCancelHandler","_currentTarget","_pressCount","addTo","obj","timeout","handlers","Object","prototype","hasOwnProperty","call","begin","e","_pressBegin","longPress","cancel","repeat","addEventListener","_cancelCurrentPress","preventDefault","t","changedTouches","document","elementFromPoint","pageX","pageY","click","_handleClick","_handleTouchEnd","clearTimeout","handler","cancelHandler","type","button","target","focus","setTimeout","_beginRepeat","wasLP","savedTarget","useLongPress","vue","directive","bind","el","binding","vnode","emit","name","data","on","fns","value","delay","useRepeatingClick"],"mappings":"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","sourcesContent":["// There's a vue directive, long-press, defined at the bottom, which may be\r\n// what you want to use.\r\n//\r\n// Because it's related, we also define another directive, repeating-click, which\r\n// sends repeated events if the mouse is held down. (It sends firstclick and repeatclick)\r\n\r\n// LongPress produces 3 possible events:\r\n// 1) a long press (longPress property in handlers)\r\n// 2) a long press cancellation (early release, cancel property)\r\n// 3) a click (a short click, click property)\r\n// handlers can also have a \"repeat\" property, which is a number in ms. If defined,\r\n// the long press event will be fired repeatedly if the press continues, at that frequency\r\n//\r\n// Don't add your own click handlers to the object; get your clicks through\r\n// LongPress\r\n//\r\n// The long-press directive (v-long-press=\"{ delay:1000 }\")\r\n// attaches LongPress for you, and emits the following events you can listen for:\r\n// longpress\r\n// longpresscancel\r\n// longpressclick\r\n\r\nclass LongPress {\r\n  static initializeVars() {\r\n    LongPress._wasLongPress = false;\r\n    LongPress._pressTimer = null;\r\n    LongPress._currentCancelHandler = null;\r\n    LongPress._currentTarget = null;\r\n    // Debug\r\n    LongPress._pressCount = 0;\r\n  }\r\n\r\n  static addTo(obj, timeout, handlers) {\r\n    if (!Object.prototype.hasOwnProperty.call(handlers, \"longPress\")) {\r\n      throw \"Need to specify a longPress handler\";\r\n    }\r\n    const begin = e => LongPress._pressBegin(timeout, handlers.longPress, handlers.cancel, handlers.repeat, e);\r\n    obj.addEventListener(\"mousedown\", begin);\r\n    obj.addEventListener(\"touchstart\", begin);\r\n    obj.addEventListener(\"mouseout\", LongPress._cancelCurrentPress);\r\n    obj.addEventListener(\"touchcancel\", LongPress._cancelCurrentPress);\r\n    obj.addEventListener(\"touchmove\", e => {\r\n      // Suggested in stackoverflow example\r\n      e.preventDefault();\r\n      const t = e.changedTouches[0];\r\n      if (obj !== document.elementFromPoint(t.pageX, t.pageY)) {\r\n        LongPress._cancelCurrentPress();\r\n      }\r\n    });\r\n    if (handlers.click) {\r\n      obj.addEventListener(\"click\", e => LongPress._handleClick(e, handlers.click));\r\n      obj.addEventListener(\"touchend\", e => LongPress._handleTouchEnd(e, handlers.click));\r\n    } else {\r\n      obj.addEventListener(\"click\", LongPress._cancelCurrentPress);\r\n      obj.addEventListener(\"touchend\", LongPress._cancelCurrentPress);\r\n    }\r\n  }\r\n\r\n  static _cancelCurrentPress(e) {\r\n    if (LongPress._currentCancelHandler) {\r\n      LongPress._currentCancelHandler(e);\r\n      LongPress._currentCancelHandler = null;\r\n    }\r\n    if (LongPress._pressTimer !== null) {\r\n      clearTimeout(LongPress._pressTimer);\r\n      LongPress._pressTimer = null;\r\n    }\r\n    LongPress._wasLongPress = false;\r\n    LongPress._currentTarget = null;\r\n  }\r\n\r\n  // eslint-disable-next-line max-params\r\n  static _pressBegin(timeout, handler, cancelHandler, repeat, e) {\r\n    // If there's a timer already running, that means that something wasn't cancelled\r\n    // properly (a press shouldn't begin if it hasn't ended). Clear out any existing presses:\r\n    LongPress._cancelCurrentPress(e);\r\n    // Ignore right click\r\n    if (e.type === \"click\" && e.button !== 0) return;\r\n    ++LongPress._pressCount;\r\n    LongPress._currentCancelHandler = cancelHandler;\r\n    LongPress._wasLongPress = false;\r\n    LongPress._currentTarget = e.target;\r\n    e.target.focus();\r\n    LongPress._pressTimer = setTimeout(() => {\r\n      LongPress._wasLongPress = true;\r\n      handler(e);\r\n      if (repeat) {\r\n        LongPress._beginRepeat(repeat, handler, e);\r\n      } else {\r\n        LongPress._pressTimer = null;\r\n        LongPress._currentCancelHandler = null;\r\n      }\r\n    }, timeout);\r\n  }\r\n\r\n  static _beginRepeat(timeout, handler, e) {\r\n    LongPress._pressTimer = setTimeout(() => {\r\n      handler(e);\r\n      LongPress._beginRepeat(timeout, handler, e);\r\n    }, timeout);\r\n  }\r\n\r\n  static _handleClick(e, handler) {\r\n    const wasLP = LongPress._wasLongPress;\r\n    // If the click was of a right button, just handle it\r\n    if (e.button !== 0) return handler(e);\r\n    // Cancel any existing presses\r\n    LongPress._cancelCurrentPress(e);\r\n    // If we just had a long press event, ignore the click\r\n    return wasLP ? false : handler(e);\r\n  }\r\n\r\n  static _handleTouchEnd(e, handler) {\r\n    // On touch devices, I don't think we get a normal click event; so we determine\r\n    // a click based on a touch ending. To be on the safe side, we make sure the touch\r\n    // began in the same place.\r\n    const savedTarget = LongPress._currentTarget;\r\n    const wasLP = LongPress._wasLongPress;\r\n    // Cancel any existing presses\r\n    LongPress._cancelCurrentPress(e);\r\n    // If we just had a long press event, ignore the click; make sure targets match\r\n    return !wasLP && savedTarget === e.target ? handler(e) : false;\r\n  }\r\n}\r\n\r\nLongPress.initializeVars();\r\n\r\nexport function useLongPress(vue) {\r\n  vue.directive(\"long-press\", {\r\n    bind(el, binding, vnode) {\r\n      // This seems to be the only way to get events to our component\r\n      const emit = (name, data) => {\r\n        const handlers = (vnode.data && vnode.data.on);\r\n        if (handlers && handlers[name]) {\r\n          handlers[name].fns(data);\r\n        }\r\n      };\r\n      LongPress.addTo(el, binding.value.delay, {\r\n        longPress: () => emit(\"longpress\"),\r\n        cancel: () => emit(\"longpresscancel\"),\r\n        click: () => emit(\"longpressclick\"),\r\n      });\r\n    }\r\n  });\r\n}\r\n\r\nexport function useRepeatingClick(vue) {\r\n  vue.directive(\"repeating-click\", {\r\n    bind(el, binding, vnode) {\r\n      // This seems to be the only way to get events to our component\r\n      const emit = (name, data) => {\r\n        const handlers = (vnode.data && vnode.data.on);\r\n        if (handlers && handlers[name]) {\r\n          handlers[name].fns(data);\r\n        }\r\n      };\r\n      LongPress.addTo(el, binding.value.delay, {\r\n        longPress: () => emit(\"repeatclick\"),\r\n        click: () => emit(\"firstclick\"),\r\n        repeat: 250\r\n      });\r\n    }\r\n  });\r\n}\r\n"]},"metadata":{},"sourceType":"module"}