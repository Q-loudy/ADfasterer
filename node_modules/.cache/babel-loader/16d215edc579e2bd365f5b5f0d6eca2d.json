{"ast":null,"code":"import { BitPurchasableMechanicState, RebuyableMechanicState } from \"./game-mechanics\";\n\nclass RealityUpgradeState extends BitPurchasableMechanicState {\n  constructor(config) {\n    super(config);\n    this.registerEvents(config.checkEvent, () => this.tryUnlock());\n  }\n\n  get automatorPoints() {\n    return this.config.automatorPoints ? this.config.automatorPoints : 0;\n  }\n\n  get name() {\n    return this.config.name;\n  }\n\n  get shortDescription() {\n    return this.config.shortDescription ? this.config.shortDescription() : \"\";\n  }\n\n  get requirement() {\n    return typeof this.config.requirement === \"function\" ? this.config.requirement() : this.config.requirement;\n  }\n\n  get lockEvent() {\n    return typeof this.config.lockEvent === \"function\" ? this.config.lockEvent() : this.config.lockEvent;\n  }\n\n  get currency() {\n    return Currency.realityMachines;\n  }\n\n  get bitIndex() {\n    return this.id;\n  }\n\n  get bits() {\n    return player.reality.upgradeBits;\n  }\n\n  set bits(value) {\n    player.reality.upgradeBits = value;\n  }\n\n  get hasPlayerLock() {\n    return (player.reality.reqLock.reality & 1 << this.bitIndex) !== 0;\n  }\n\n  set hasPlayerLock(value) {\n    if (value) player.reality.reqLock.reality |= 1 << this.bitIndex;else player.reality.reqLock.reality &= ~(1 << this.bitIndex);\n  }\n\n  get isLockingMechanics() {\n    var _this$config$bypassLo, _this$config$bypassLo2, _this$config;\n\n    const shouldBypass = (_this$config$bypassLo = (_this$config$bypassLo2 = (_this$config = this.config).bypassLock) === null || _this$config$bypassLo2 === void 0 ? void 0 : _this$config$bypassLo2.call(_this$config)) !== null && _this$config$bypassLo !== void 0 ? _this$config$bypassLo : false;\n    return this.hasPlayerLock && this.isPossible && !shouldBypass && !this.isAvailableForPurchase;\n  } // Required to be changed this way to avoid direct prop mutation in Vue components\n\n\n  setMechanicLock(value) {\n    this.hasPlayerLock = value;\n  }\n\n  toggleMechanicLock() {\n    this.hasPlayerLock = !this.hasPlayerLock;\n  } // Note we don't actually show the modal if we already failed or unlocked it\n\n\n  tryShowWarningModal(specialLockText) {\n    if (this.isPossible && !this.isAvailableForPurchase) {\n      Modal.upgradeLock.show({\n        upgrade: this,\n        isImaginary: false,\n        specialLockText\n      });\n    }\n  }\n\n  get isAvailableForPurchase() {\n    return (player.reality.upgReqs & 1 << this.id) !== 0;\n  }\n\n  get isPossible() {\n    return this.config.hasFailed ? !this.config.hasFailed() : true;\n  }\n\n  tryUnlock() {\n    const realityReached = PlayerProgress.realityUnlocked() || TimeStudy.reality.isBought;\n    if (!realityReached || this.isAvailableForPurchase || !this.config.checkRequirement()) return;\n    player.reality.upgReqs |= 1 << this.id;\n    GameUI.notify.reality(`You've unlocked a Reality Upgrade: ${this.config.name}`);\n    this.hasPlayerLock = false;\n  }\n\n  onPurchased() {\n    EventHub.dispatch(GAME_EVENT.REALITY_UPGRADE_BOUGHT);\n    const id = this.id;\n\n    if (id === 9 || id === 24) {\n      Glyphs.refreshActive();\n    }\n\n    if (id === 10) {\n      applyRUPG10();\n      playerInfinityUpgradesOnReset();\n      EventHub.dispatch(GAME_EVENT.REALITY_UPGRADE_TEN_BOUGHT);\n    }\n\n    if (id === 20 && player.blackHole[0].unlocked) {\n      player.blackHole[1].unlocked = true;\n    }\n\n    GameCache.staticGlyphWeights.invalidate();\n  }\n\n}\n\nclass RebuyableRealityUpgradeState extends RebuyableMechanicState {\n  get currency() {\n    return Currency.realityMachines;\n  }\n\n  get boughtAmount() {\n    return player.reality.rebuyables[this.id];\n  }\n\n  set boughtAmount(value) {\n    player.reality.rebuyables[this.id] = value;\n  }\n\n}\n\nRealityUpgradeState.index = mapGameData(GameDatabase.reality.upgrades, config => config.id < 6 ? new RebuyableRealityUpgradeState(config) : new RealityUpgradeState(config));\n/**\r\n * @param {number} id\r\n * @return {RealityUpgradeState|RebuyableRealityUpgradeState}\r\n */\n\nexport const RealityUpgrade = id => RealityUpgradeState.index[id];\nexport const RealityUpgrades = {\n  /**\r\n   * @type {(RealityUpgradeState|RebuyableRealityUpgradeState)[]}\r\n   */\n  all: RealityUpgradeState.index.compact(),\n\n  get allBought() {\n    return (player.reality.upgradeBits >> 6) + 1 === 1 << GameDatabase.reality.upgrades.length - 5;\n  }\n\n};","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/reality-upgrades.js"],"names":["BitPurchasableMechanicState","RebuyableMechanicState","RealityUpgradeState","constructor","config","registerEvents","checkEvent","tryUnlock","automatorPoints","name","shortDescription","requirement","lockEvent","currency","Currency","realityMachines","bitIndex","id","bits","player","reality","upgradeBits","value","hasPlayerLock","reqLock","isLockingMechanics","shouldBypass","bypassLock","isPossible","isAvailableForPurchase","setMechanicLock","toggleMechanicLock","tryShowWarningModal","specialLockText","Modal","upgradeLock","show","upgrade","isImaginary","upgReqs","hasFailed","realityReached","PlayerProgress","realityUnlocked","TimeStudy","isBought","checkRequirement","GameUI","notify","onPurchased","EventHub","dispatch","GAME_EVENT","REALITY_UPGRADE_BOUGHT","Glyphs","refreshActive","applyRUPG10","playerInfinityUpgradesOnReset","REALITY_UPGRADE_TEN_BOUGHT","blackHole","unlocked","GameCache","staticGlyphWeights","invalidate","RebuyableRealityUpgradeState","boughtAmount","rebuyables","index","mapGameData","GameDatabase","upgrades","RealityUpgrade","RealityUpgrades","all","compact","allBought","length"],"mappings":"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","sourcesContent":["import { BitPurchasableMechanicState, RebuyableMechanicState } from \"./game-mechanics\";\r\n\r\nclass RealityUpgradeState extends BitPurchasableMechanicState {\r\n  constructor(config) {\r\n    super(config);\r\n    this.registerEvents(config.checkEvent, () => this.tryUnlock());\r\n  }\r\n\r\n  get automatorPoints() {\r\n    return this.config.automatorPoints ? this.config.automatorPoints : 0;\r\n  }\r\n\r\n  get name() {\r\n    return this.config.name;\r\n  }\r\n\r\n  get shortDescription() {\r\n    return this.config.shortDescription ? this.config.shortDescription() : \"\";\r\n  }\r\n\r\n  get requirement() {\r\n    return typeof this.config.requirement === \"function\" ? this.config.requirement() : this.config.requirement;\r\n  }\r\n\r\n  get lockEvent() {\r\n    return typeof this.config.lockEvent === \"function\" ? this.config.lockEvent() : this.config.lockEvent;\r\n  }\r\n\r\n  get currency() {\r\n    return Currency.realityMachines;\r\n  }\r\n\r\n  get bitIndex() {\r\n    return this.id;\r\n  }\r\n\r\n  get bits() {\r\n    return player.reality.upgradeBits;\r\n  }\r\n\r\n  set bits(value) {\r\n    player.reality.upgradeBits = value;\r\n  }\r\n\r\n  get hasPlayerLock() {\r\n    return (player.reality.reqLock.reality & (1 << this.bitIndex)) !== 0;\r\n  }\r\n\r\n  set hasPlayerLock(value) {\r\n    if (value) player.reality.reqLock.reality |= 1 << this.bitIndex;\r\n    else player.reality.reqLock.reality &= ~(1 << this.bitIndex);\r\n  }\r\n\r\n  get isLockingMechanics() {\r\n    const shouldBypass = this.config.bypassLock?.() ?? false;\r\n    return this.hasPlayerLock && this.isPossible && !shouldBypass && !this.isAvailableForPurchase;\r\n  }\r\n\r\n  // Required to be changed this way to avoid direct prop mutation in Vue components\r\n  setMechanicLock(value) {\r\n    this.hasPlayerLock = value;\r\n  }\r\n\r\n  toggleMechanicLock() {\r\n    this.hasPlayerLock = !this.hasPlayerLock;\r\n  }\r\n\r\n  // Note we don't actually show the modal if we already failed or unlocked it\r\n  tryShowWarningModal(specialLockText) {\r\n    if (this.isPossible && !this.isAvailableForPurchase) {\r\n      Modal.upgradeLock.show({ upgrade: this, isImaginary: false, specialLockText });\r\n    }\r\n  }\r\n\r\n  get isAvailableForPurchase() {\r\n    return (player.reality.upgReqs & (1 << this.id)) !== 0;\r\n  }\r\n\r\n  get isPossible() {\r\n    return this.config.hasFailed ? !this.config.hasFailed() : true;\r\n  }\r\n\r\n  tryUnlock() {\r\n    const realityReached = PlayerProgress.realityUnlocked() || TimeStudy.reality.isBought;\r\n    if (!realityReached || this.isAvailableForPurchase || !this.config.checkRequirement()) return;\r\n    player.reality.upgReqs |= (1 << this.id);\r\n    GameUI.notify.reality(`You've unlocked a Reality Upgrade: ${this.config.name}`);\r\n    this.hasPlayerLock = false;\r\n  }\r\n\r\n  onPurchased() {\r\n    EventHub.dispatch(GAME_EVENT.REALITY_UPGRADE_BOUGHT);\r\n    const id = this.id;\r\n    if (id === 9 || id === 24) {\r\n      Glyphs.refreshActive();\r\n    }\r\n    if (id === 10) {\r\n      applyRUPG10();\r\n      playerInfinityUpgradesOnReset();\r\n      EventHub.dispatch(GAME_EVENT.REALITY_UPGRADE_TEN_BOUGHT);\r\n    }\r\n    if (id === 20 && player.blackHole[0].unlocked) {\r\n      player.blackHole[1].unlocked = true;\r\n    }\r\n    GameCache.staticGlyphWeights.invalidate();\r\n  }\r\n}\r\n\r\nclass RebuyableRealityUpgradeState extends RebuyableMechanicState {\r\n  get currency() {\r\n    return Currency.realityMachines;\r\n  }\r\n\r\n  get boughtAmount() {\r\n    return player.reality.rebuyables[this.id];\r\n  }\r\n\r\n  set boughtAmount(value) {\r\n    player.reality.rebuyables[this.id] = value;\r\n  }\r\n}\r\n\r\nRealityUpgradeState.index = mapGameData(\r\n  GameDatabase.reality.upgrades,\r\n  config => (config.id < 6\r\n    ? new RebuyableRealityUpgradeState(config)\r\n    : new RealityUpgradeState(config))\r\n);\r\n\r\n/**\r\n * @param {number} id\r\n * @return {RealityUpgradeState|RebuyableRealityUpgradeState}\r\n */\r\nexport const RealityUpgrade = id => RealityUpgradeState.index[id];\r\n\r\nexport const RealityUpgrades = {\r\n  /**\r\n   * @type {(RealityUpgradeState|RebuyableRealityUpgradeState)[]}\r\n   */\r\n  all: RealityUpgradeState.index.compact(),\r\n  get allBought() {\r\n    return (player.reality.upgradeBits >> 6) + 1 === 1 << (GameDatabase.reality.upgrades.length - 5);\r\n  }\r\n};\r\n"]},"metadata":{},"sourceType":"module"}