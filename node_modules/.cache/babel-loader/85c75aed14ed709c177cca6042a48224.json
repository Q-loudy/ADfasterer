{"ast":null,"code":"import \"core-js/modules/web.dom-collections.iterator.js\";\nimport { GameMechanicState } from \"./game-mechanics\";\nexport function tryCompleteInfinityChallenges() {\n  if (EternityMilestone.autoIC.isReached) {\n    const toComplete = InfinityChallenges.all.filter(x => x.isUnlocked && !x.isCompleted);\n\n    for (const challenge of toComplete) challenge.complete();\n  }\n}\n\nclass InfinityChallengeRewardState extends GameMechanicState {\n  constructor(config, challenge) {\n    super(config);\n    this._challenge = challenge;\n  }\n\n  get isEffectActive() {\n    return this._challenge.isCompleted;\n  }\n\n}\n\nclass InfinityChallengeState extends GameMechanicState {\n  constructor(config) {\n    super(config);\n    this._reward = new InfinityChallengeRewardState(config.reward, this);\n  }\n\n  get unlockAM() {\n    return this.config.unlockAM;\n  }\n\n  get isUnlocked() {\n    return player.records.thisEternity.maxAM.gte(this.unlockAM) || Achievement(133).isUnlocked && !Pelle.isDoomed || PelleUpgrade.keepInfinityChallenges.canBeApplied && Pelle.cel.records.totalAntimatter.gte(this.unlockAM);\n  }\n\n  get isRunning() {\n    return player.challenge.infinity.current === this.id;\n  }\n\n  requestStart() {\n    if (!this.isUnlocked) return;\n    if (GameEnd.creditsEverClosed) return;\n\n    if (!player.options.confirmations.challenges) {\n      this.start();\n      return;\n    }\n\n    Modal.startInfinityChallenge.show(this.id);\n  }\n\n  start() {\n    if (!this.isUnlocked || this.isRunning) return; // Forces big crunch reset but ensures IP gain, if any.\n\n    bigCrunchReset(true, true);\n    player.challenge.normal.current = 0;\n    player.challenge.infinity.current = this.id;\n    if (!Enslaved.isRunning) Tab.dimensions.antimatter.show();\n    player.break = true;\n    if (EternityChallenge.isRunning) Achievement(115).unlock();\n  }\n\n  get isCompleted() {\n    return (player.challenge.infinity.completedBits & 1 << this.id) !== 0;\n  }\n\n  complete() {\n    player.challenge.infinity.completedBits |= 1 << this.id;\n    EventHub.dispatch(GAME_EVENT.INFINITY_CHALLENGE_COMPLETED);\n  }\n\n  get isEffectActive() {\n    return this.isRunning;\n  }\n  /**\r\n   * @return {InfinityChallengeRewardState}\r\n   */\n\n\n  get reward() {\n    return this._reward;\n  }\n\n  get isQuickResettable() {\n    return this.config.isQuickResettable;\n  }\n\n  get goal() {\n    return this.config.goal;\n  }\n\n  updateChallengeTime() {\n    const bestTimes = player.challenge.infinity.bestTimes;\n\n    if (bestTimes[this.id - 1] <= player.records.thisInfinity.time / getGlobalSpeedFactor()) {\n      return;\n    }\n\n    player.challenge.infinity.bestTimes[this.id - 1] = player.records.thisInfinity.time / getGlobalSpeedFactor();\n    GameCache.infinityChallengeTimeSum.invalidate();\n  }\n\n  exit() {\n    player.challenge.infinity.current = 0;\n    bigCrunchReset(true, false);\n    if (!Enslaved.isRunning) Tab.dimensions.antimatter.show();\n  }\n\n}\n/**\r\n * @param {number} id\r\n * @return {InfinityChallengeState}\r\n */\n\n\nexport const InfinityChallenge = InfinityChallengeState.createAccessor(GameDatabase.challenges.infinity);\n/**\r\n * @returns {InfinityChallengeState}\r\n */\n\nObject.defineProperty(InfinityChallenge, \"current\", {\n  get: () => player.challenge.infinity.current > 0 ? InfinityChallenge(player.challenge.infinity.current) : undefined\n});\nObject.defineProperty(InfinityChallenge, \"isRunning\", {\n  get: () => InfinityChallenge.current !== undefined\n});\nexport const InfinityChallenges = {\n  /**\r\n   * @type {InfinityChallengeState[]}\r\n   */\n  all: InfinityChallenge.index.compact(),\n\n  completeAll() {\n    for (const challenge of InfinityChallenges.all) challenge.complete();\n  },\n\n  clearCompletions() {\n    player.challenge.infinity.completedBits = 0;\n  },\n\n  get nextIC() {\n    return InfinityChallenges.all.find(x => !x.isUnlocked);\n  },\n\n  get nextICUnlockAM() {\n    var _this$nextIC;\n\n    return (_this$nextIC = this.nextIC) === null || _this$nextIC === void 0 ? void 0 : _this$nextIC.unlockAM;\n  },\n\n  /**\r\n   * Displays a notification if the antimatter gained will surpass the next unlockAM requirement.\r\n   * @param value {Decimal} - total antimatter\r\n   */\n  notifyICUnlock(value) {\n    // Disable the popup if the user will automatically complete the IC.\n    if (EternityMilestone.autoIC.isReached) return;\n    if (InfinityChallenges.nextIC === undefined) return;\n\n    for (const ic of InfinityChallenges.all) {\n      if (ic.isUnlocked || ic.isCompleted) continue;\n      if (value.lt(ic.unlockAM)) break; // This has a reasonably high likelihood of happening when the player isn't looking at the game, so\n      // we also give it a tab notification\n\n      TabNotification.ICUnlock.clearTrigger();\n      GameUI.notify.infinity(`You have unlocked Infinity Challenge ${ic.id}`, 7000);\n      TabNotification.ICUnlock.tryTrigger();\n    }\n  },\n\n  /**\r\n   * @returns {InfinityChallengeState[]}\r\n   */\n  get completed() {\n    return InfinityChallenges.all.filter(ic => ic.isCompleted);\n  }\n\n};","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/infinity-challenges.js"],"names":["GameMechanicState","tryCompleteInfinityChallenges","EternityMilestone","autoIC","isReached","toComplete","InfinityChallenges","all","filter","x","isUnlocked","isCompleted","challenge","complete","InfinityChallengeRewardState","constructor","config","_challenge","isEffectActive","InfinityChallengeState","_reward","reward","unlockAM","player","records","thisEternity","maxAM","gte","Achievement","Pelle","isDoomed","PelleUpgrade","keepInfinityChallenges","canBeApplied","cel","totalAntimatter","isRunning","infinity","current","id","requestStart","GameEnd","creditsEverClosed","options","confirmations","challenges","start","Modal","startInfinityChallenge","show","bigCrunchReset","normal","Enslaved","Tab","dimensions","antimatter","break","EternityChallenge","unlock","completedBits","EventHub","dispatch","GAME_EVENT","INFINITY_CHALLENGE_COMPLETED","isQuickResettable","goal","updateChallengeTime","bestTimes","thisInfinity","time","getGlobalSpeedFactor","GameCache","infinityChallengeTimeSum","invalidate","exit","InfinityChallenge","createAccessor","GameDatabase","Object","defineProperty","get","undefined","index","compact","completeAll","clearCompletions","nextIC","find","nextICUnlockAM","notifyICUnlock","value","ic","lt","TabNotification","ICUnlock","clearTrigger","GameUI","notify","tryTrigger","completed"],"mappings":"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","sourcesContent":["import { GameMechanicState } from \"./game-mechanics\";\r\n\r\nexport function tryCompleteInfinityChallenges() {\r\n  if (EternityMilestone.autoIC.isReached) {\r\n    const toComplete = InfinityChallenges.all.filter(x => x.isUnlocked && !x.isCompleted);\r\n    for (const challenge of toComplete) challenge.complete();\r\n  }\r\n}\r\n\r\nclass InfinityChallengeRewardState extends GameMechanicState {\r\n  constructor(config, challenge) {\r\n    super(config);\r\n    this._challenge = challenge;\r\n  }\r\n\r\n  get isEffectActive() {\r\n    return this._challenge.isCompleted;\r\n  }\r\n}\r\n\r\nclass InfinityChallengeState extends GameMechanicState {\r\n  constructor(config) {\r\n    super(config);\r\n    this._reward = new InfinityChallengeRewardState(config.reward, this);\r\n  }\r\n\r\n  get unlockAM() {\r\n    return this.config.unlockAM;\r\n  }\r\n\r\n  get isUnlocked() {\r\n    return player.records.thisEternity.maxAM.gte(this.unlockAM) || (Achievement(133).isUnlocked && !Pelle.isDoomed) ||\r\n      (PelleUpgrade.keepInfinityChallenges.canBeApplied && Pelle.cel.records.totalAntimatter.gte(this.unlockAM));\r\n  }\r\n\r\n  get isRunning() {\r\n    return player.challenge.infinity.current === this.id;\r\n  }\r\n\r\n  requestStart() {\r\n    if (!this.isUnlocked) return;\r\n    if (GameEnd.creditsEverClosed) return;\r\n    if (!player.options.confirmations.challenges) {\r\n      this.start();\r\n      return;\r\n    }\r\n    Modal.startInfinityChallenge.show(this.id);\r\n  }\r\n\r\n  start() {\r\n    if (!this.isUnlocked || this.isRunning) return;\r\n    // Forces big crunch reset but ensures IP gain, if any.\r\n    bigCrunchReset(true, true);\r\n    player.challenge.normal.current = 0;\r\n    player.challenge.infinity.current = this.id;\r\n    if (!Enslaved.isRunning) Tab.dimensions.antimatter.show();\r\n    player.break = true;\r\n    if (EternityChallenge.isRunning) Achievement(115).unlock();\r\n  }\r\n\r\n  get isCompleted() {\r\n    return (player.challenge.infinity.completedBits & (1 << this.id)) !== 0;\r\n  }\r\n\r\n  complete() {\r\n    player.challenge.infinity.completedBits |= 1 << this.id;\r\n    EventHub.dispatch(GAME_EVENT.INFINITY_CHALLENGE_COMPLETED);\r\n  }\r\n\r\n  get isEffectActive() {\r\n    return this.isRunning;\r\n  }\r\n\r\n  /**\r\n   * @return {InfinityChallengeRewardState}\r\n   */\r\n  get reward() {\r\n    return this._reward;\r\n  }\r\n\r\n  get isQuickResettable() {\r\n    return this.config.isQuickResettable;\r\n  }\r\n\r\n  get goal() {\r\n    return this.config.goal;\r\n  }\r\n\r\n  updateChallengeTime() {\r\n    const bestTimes = player.challenge.infinity.bestTimes;\r\n    if (bestTimes[this.id - 1] <= player.records.thisInfinity.time  / getGlobalSpeedFactor()) {\r\n      return;\r\n    }\r\n    player.challenge.infinity.bestTimes[this.id - 1] = player.records.thisInfinity.time  / getGlobalSpeedFactor();\r\n    GameCache.infinityChallengeTimeSum.invalidate();\r\n  }\r\n\r\n  exit() {\r\n    player.challenge.infinity.current = 0;\r\n    bigCrunchReset(true, false);\r\n    if (!Enslaved.isRunning) Tab.dimensions.antimatter.show();\r\n  }\r\n}\r\n\r\n/**\r\n * @param {number} id\r\n * @return {InfinityChallengeState}\r\n */\r\nexport const InfinityChallenge = InfinityChallengeState.createAccessor(GameDatabase.challenges.infinity);\r\n\r\n/**\r\n * @returns {InfinityChallengeState}\r\n */\r\nObject.defineProperty(InfinityChallenge, \"current\", {\r\n  get: () => (player.challenge.infinity.current > 0\r\n    ? InfinityChallenge(player.challenge.infinity.current)\r\n    : undefined),\r\n});\r\n\r\nObject.defineProperty(InfinityChallenge, \"isRunning\", {\r\n  get: () => InfinityChallenge.current !== undefined,\r\n});\r\n\r\nexport const InfinityChallenges = {\r\n  /**\r\n   * @type {InfinityChallengeState[]}\r\n   */\r\n  all: InfinityChallenge.index.compact(),\r\n  completeAll() {\r\n    for (const challenge of InfinityChallenges.all) challenge.complete();\r\n  },\r\n  clearCompletions() {\r\n    player.challenge.infinity.completedBits = 0;\r\n  },\r\n  get nextIC() {\r\n    return InfinityChallenges.all.find(x => !x.isUnlocked);\r\n  },\r\n  get nextICUnlockAM() {\r\n    return this.nextIC?.unlockAM;\r\n  },\r\n  /**\r\n   * Displays a notification if the antimatter gained will surpass the next unlockAM requirement.\r\n   * @param value {Decimal} - total antimatter\r\n   */\r\n  notifyICUnlock(value) {\r\n    // Disable the popup if the user will automatically complete the IC.\r\n    if (EternityMilestone.autoIC.isReached) return;\r\n    if (InfinityChallenges.nextIC === undefined) return;\r\n    for (const ic of InfinityChallenges.all) {\r\n      if (ic.isUnlocked || ic.isCompleted) continue;\r\n      if (value.lt(ic.unlockAM)) break;\r\n      // This has a reasonably high likelihood of happening when the player isn't looking at the game, so\r\n      // we also give it a tab notification\r\n      TabNotification.ICUnlock.clearTrigger();\r\n      GameUI.notify.infinity(`You have unlocked Infinity Challenge ${ic.id}`, 7000);\r\n      TabNotification.ICUnlock.tryTrigger();\r\n    }\r\n  },\r\n  /**\r\n   * @returns {InfinityChallengeState[]}\r\n   */\r\n  get completed() {\r\n    return InfinityChallenges.all.filter(ic => ic.isCompleted);\r\n  }\r\n};\r\n"]},"metadata":{},"sourceType":"module"}