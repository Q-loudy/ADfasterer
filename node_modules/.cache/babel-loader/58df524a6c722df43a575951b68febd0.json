{"ast":null,"code":"export default {\n  name: \"ProgressConnector\",\n  props: {\n    complete: {\n      type: Number,\n      required: true\n    },\n    completeWidth: {\n      type: Number,\n      required: false,\n      default: 8\n    },\n    incompleteWidth: {\n      type: Number,\n      required: false,\n      default: 6\n    },\n    noBG: {\n      type: Boolean,\n      required: false,\n      default: false\n    },\n    opacity: {\n      type: Number,\n      required: false,\n      default: 1\n    },\n    fill: {\n      type: String,\n      required: false,\n      default: \"#5151ec\"\n    },\n    filterName: {\n      type: String,\n      required: false,\n      default: \"completeGlow\"\n    },\n    path: {\n      type: Object,\n      required: true\n    },\n    pathStart: {\n      type: Number,\n      required: true\n    },\n    pathEnd: {\n      type: Number,\n      required: true\n    },\n    pathPadStart: {\n      type: Number,\n      required: false,\n      default: 0\n    },\n    pathPadEnd: {\n      type: Number,\n      required: false,\n      default: 0\n    }\n  },\n  computed: {\n    unpaddedSpan() {\n      return this.pathEnd - this.pathPadEnd - (this.pathStart + this.pathPadStart);\n    },\n\n    incompleteStart() {\n      return this.complete >= 1 ? this.pathEnd : this.pathStart + this.pathPadStart + this.unpaddedSpan * this.complete;\n    },\n\n    incompleteStartShape() {\n      return this.shapeAt(this.incompleteStart);\n    },\n\n    completeStartShape() {\n      return this.shapeAt(this.pathStart);\n    },\n\n    incompleteTransform() {\n      const shape = this.incompleteStartShape;\n      return `${shape.position.asTranslate()} ${shape.direction.asRotate()}`;\n    },\n\n    pathEndShape() {\n      return this.shapeAt(this.pathEnd);\n    },\n\n    // In order to support gradients that fill along a completed path,\n    // we render in a coordinate system that's scaled to be 0..1 from start to end\n    totalPathOffsetPx() {\n      return this.pathEndShape.position.minus(this.completeStartShape.position);\n    },\n\n    completeTransform() {\n      const shape = this.completeStartShape;\n      const scale = this.totalPathOffsetPx.length;\n      return `${shape.position.asTranslate()} ${shape.direction.asRotate()} scale(${scale})`;\n    },\n\n    incompleteFadeEnd() {\n      const shape = this.incompleteStartShape;\n      const fadeLength = 12 / shape.derivative.length;\n      return this.pathEnd > this.pathStart ? Math.min(this.incompleteStart + fadeLength, this.pathEnd) : Math.max(this.incompleteStart - fadeLength, this.pathEnd);\n    },\n\n    incompleteFadePath() {\n      return this.generateIncompletePath(this.incompleteStart, this.incompleteFadeEnd);\n    },\n\n    incompleteSolidPath() {\n      return this.generateIncompletePath(this.incompleteFadeEnd - 1e-3 * (this.pathEnd - this.incompleteFadeEnd), this.pathEnd);\n    },\n\n    completePath() {\n      const startShape = this.completeStartShape;\n      const scale = 1 / this.totalPathOffsetPx.length;\n      const tform = AffineTransform.translation(startShape.position.negative).rotated(-startShape.direction.angle).scaled(scale);\n      const tStart = this.pathStart,\n            tEnd = this.incompleteStart;\n      const w = this.completeWidth;\n      const insetPath = this.getOffsetPath(-w / 2, tStart, tEnd).transformedBy(tform);\n      const outsetPath = this.getOffsetPath(w / 2, tEnd, tStart).transformedBy(tform);\n      const endVector = this.incompleteStartShape.direction.transformedBy(tform.withoutTranslation);\n      const inEnd = insetPath.path[insetPath.path.length - 1];\n      const outStart = outsetPath.path[0];\n      const capCP0 = inEnd.position(1).plus(endVector.times(w / 2));\n      const capCP1 = outStart.position(0).plus(endVector.times(w / 2));\n      const cap = `C ${capCP0.x} ${capCP0.y} ${capCP1.x} ${capCP1.y} ${outStart.p0.x} ${outStart.p0.y}\\n`;\n      return insetPath.toSVG(\"M\") + cap + outsetPath.toSVG(\"L\");\n    },\n\n    hasIncompleteSolidPath() {\n      return this.incompleteFadeEnd !== this.pathEnd;\n    },\n\n    filter() {\n      return `url(#${this.filterName})`;\n    }\n\n  },\n  methods: {\n    generateIncompletePath(tStart, tEnd) {\n      const inset = this.getOffsetPath(-this.incompleteWidth / 2, tStart, tEnd);\n      const outset = this.getOffsetPath(this.incompleteWidth / 2, tEnd, tStart);\n      const s0 = this.incompleteStartShape;\n      const tform = AffineTransform.translation(s0.position.negative).rotated(-s0.direction.angle);\n      return inset.transformedBy(tform).toSVG(\"M\") + outset.transformedBy(tform).toSVG(\"L\");\n    },\n\n    getOffsetPath(offset, tStart, tEnd) {\n      if (this.path instanceof LinearPath) {\n        return new PiecewisePath([this.path.createOffsetLine(offset, tStart, tEnd)]);\n      }\n\n      const offsetPath = new OffsetCurve(this.path, offset);\n      return PiecewisePath.cubicBezierFitToCurveSection(offsetPath, tStart, tEnd);\n    },\n\n    shapeAt(t) {\n      const shape = this.path.shapeAt(t);\n\n      if (this.pathStart > this.pathEnd) {\n        shape.direction = shape.direction.negative;\n        shape.derivative = shape.derivative.negative;\n      }\n\n      return shape;\n    }\n\n  }\n};","map":{"version":3,"sources":["ProgressConnector.vue"],"names":[],"mappings":"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","sourcesContent":["<script>\r\nexport default {\r\n  name: \"ProgressConnector\",\r\n  props: {\r\n    complete: {\r\n      type: Number,\r\n      required: true\r\n    },\r\n    completeWidth: {\r\n      type: Number,\r\n      required: false,\r\n      default: 8\r\n    },\r\n    incompleteWidth: {\r\n      type: Number,\r\n      required: false,\r\n      default: 6,\r\n    },\r\n    noBG: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: false,\r\n    },\r\n    opacity: {\r\n      type: Number,\r\n      required: false,\r\n      default: 1,\r\n    },\r\n    fill: {\r\n      type: String,\r\n      required: false,\r\n      default: \"#5151ec\",\r\n    },\r\n    filterName: {\r\n      type: String,\r\n      required: false,\r\n      default: \"completeGlow\",\r\n    },\r\n    path: {\r\n      type: Object,\r\n      required: true\r\n    },\r\n    pathStart: {\r\n      type: Number,\r\n      required: true\r\n    },\r\n    pathEnd: {\r\n      type: Number,\r\n      required: true\r\n    },\r\n    pathPadStart: {\r\n      type: Number,\r\n      required: false,\r\n      default: 0,\r\n    },\r\n    pathPadEnd: {\r\n      type: Number,\r\n      required: false,\r\n      default: 0,\r\n    },\r\n  },\r\n  computed: {\r\n    unpaddedSpan() {\r\n      return (this.pathEnd - this.pathPadEnd) - (this.pathStart + this.pathPadStart);\r\n    },\r\n    incompleteStart() {\r\n      return this.complete >= 1\r\n        ? this.pathEnd\r\n        : this.pathStart + this.pathPadStart + this.unpaddedSpan * this.complete;\r\n    },\r\n    incompleteStartShape() {\r\n      return this.shapeAt(this.incompleteStart);\r\n    },\r\n    completeStartShape() {\r\n      return this.shapeAt(this.pathStart);\r\n    },\r\n    incompleteTransform() {\r\n      const shape = this.incompleteStartShape;\r\n      return `${shape.position.asTranslate()} ${shape.direction.asRotate()}`;\r\n    },\r\n    pathEndShape() {\r\n      return this.shapeAt(this.pathEnd);\r\n    },\r\n    // In order to support gradients that fill along a completed path,\r\n    // we render in a coordinate system that's scaled to be 0..1 from start to end\r\n    totalPathOffsetPx() {\r\n      return this.pathEndShape.position.minus(this.completeStartShape.position);\r\n    },\r\n    completeTransform() {\r\n      const shape = this.completeStartShape;\r\n      const scale = this.totalPathOffsetPx.length;\r\n      return `${shape.position.asTranslate()} ${shape.direction.asRotate()} scale(${scale})`;\r\n    },\r\n    incompleteFadeEnd() {\r\n      const shape = this.incompleteStartShape;\r\n      const fadeLength = 12 / shape.derivative.length;\r\n      return this.pathEnd > this.pathStart\r\n        ? Math.min(this.incompleteStart + fadeLength, this.pathEnd)\r\n        : Math.max(this.incompleteStart - fadeLength, this.pathEnd);\r\n    },\r\n    incompleteFadePath() {\r\n      return this.generateIncompletePath(this.incompleteStart, this.incompleteFadeEnd);\r\n    },\r\n    incompleteSolidPath() {\r\n      return this.generateIncompletePath(\r\n        this.incompleteFadeEnd - 1e-3 * (this.pathEnd - this.incompleteFadeEnd), this.pathEnd);\r\n    },\r\n    completePath() {\r\n      const startShape = this.completeStartShape;\r\n      const scale = 1 / this.totalPathOffsetPx.length;\r\n      const tform = AffineTransform\r\n        .translation(startShape.position.negative)\r\n        .rotated(-startShape.direction.angle)\r\n        .scaled(scale);\r\n      const tStart = this.pathStart, tEnd = this.incompleteStart;\r\n      const w = this.completeWidth;\r\n      const insetPath = this.getOffsetPath(-w / 2, tStart, tEnd).transformedBy(tform);\r\n      const outsetPath = this.getOffsetPath(w / 2, tEnd, tStart).transformedBy(tform);\r\n      const endVector = this.incompleteStartShape.direction.transformedBy(tform.withoutTranslation);\r\n      const inEnd = insetPath.path[insetPath.path.length - 1];\r\n      const outStart = outsetPath.path[0];\r\n      const capCP0 = inEnd.position(1).plus(endVector.times(w / 2));\r\n      const capCP1 = outStart.position(0).plus(endVector.times(w / 2));\r\n      const cap = `C ${capCP0.x} ${capCP0.y} ${capCP1.x} ${capCP1.y} ${outStart.p0.x} ${outStart.p0.y}\\n`;\r\n      return insetPath.toSVG(\"M\") + cap + outsetPath.toSVG(\"L\");\r\n    },\r\n    hasIncompleteSolidPath() {\r\n      return this.incompleteFadeEnd !== this.pathEnd;\r\n    },\r\n    filter() {\r\n      return `url(#${this.filterName})`;\r\n    },\r\n  },\r\n  methods: {\r\n    generateIncompletePath(tStart, tEnd) {\r\n      const inset = this.getOffsetPath(-this.incompleteWidth / 2, tStart, tEnd);\r\n      const outset = this.getOffsetPath(this.incompleteWidth / 2, tEnd, tStart);\r\n      const s0 = this.incompleteStartShape;\r\n      const tform = AffineTransform.translation(s0.position.negative).rotated(-s0.direction.angle);\r\n      return inset.transformedBy(tform).toSVG(\"M\") + outset.transformedBy(tform).toSVG(\"L\");\r\n    },\r\n    getOffsetPath(offset, tStart, tEnd) {\r\n      if (this.path instanceof LinearPath) {\r\n        return new PiecewisePath([this.path.createOffsetLine(offset, tStart, tEnd)]);\r\n      }\r\n      const offsetPath = new OffsetCurve(this.path, offset);\r\n      return PiecewisePath.cubicBezierFitToCurveSection(offsetPath, tStart, tEnd);\r\n    },\r\n    shapeAt(t) {\r\n      const shape = this.path.shapeAt(t);\r\n      if (this.pathStart > this.pathEnd) {\r\n        shape.direction = shape.direction.negative;\r\n        shape.derivative = shape.derivative.negative;\r\n      }\r\n      return shape;\r\n    }\r\n  }\r\n};\r\n</script>\r\n\r\n<template>\r\n  <g>\r\n    <g\r\n      v-if=\"!noBG\"\r\n      :transform=\"incompleteTransform\"\r\n    >\r\n      <path\r\n        :d=\"incompleteFadePath\"\r\n        fill=\"url(#incompleteFade)\"\r\n      />\r\n      <path\r\n        v-if=\"hasIncompleteSolidPath\"\r\n        :d=\"incompleteSolidPath\"\r\n        fill=\"#888\"\r\n      />\r\n    </g>\r\n    <g :filter=\"filter\">\r\n      <path\r\n        :transform=\"completeTransform\"\r\n        :fill=\"fill\"\r\n        stroke=\"none\"\r\n        :d=\"completePath\"\r\n        :style=\"{ 'opacity': opacity }\"\r\n      />\r\n    </g>\r\n  </g>\r\n</template>\r\n\r\n<style scoped>\r\n\r\n</style>\r\n"],"sourceRoot":"src/components/tabs/celestial-navigation"},"metadata":{},"sourceType":"module"}