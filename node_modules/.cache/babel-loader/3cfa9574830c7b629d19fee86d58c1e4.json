{"ast":null,"code":"import \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport { DC } from \"./constants\";\nimport { SpeedrunMilestones } from \"./speedrun\";\n\nclass BlackHoleUpgradeState {\n  constructor(config) {\n    const {\n      getAmount,\n      setAmount,\n      calculateValue,\n      initialCost,\n      costMult\n    } = config;\n\n    this.incrementAmount = () => setAmount(getAmount() + 1);\n\n    this._lazyValue = new Lazy(() => calculateValue(getAmount()));\n    this._lazyCost = new Lazy(() => getHybridCostScaling(getAmount(), 1e30, initialCost, costMult, 0.2, DC.E310, 1e5, 10));\n    this.id = config.id;\n    this.hasAutobuyer = config.hasAutobuyer;\n    this.onPurchase = config.onPurchase;\n  }\n\n  get value() {\n    return this._lazyValue.value;\n  }\n\n  get cost() {\n    return this._lazyCost.value;\n  }\n\n  get isAffordable() {\n    return Currency.realityMachines.gte(this.cost);\n  }\n\n  purchase() {\n    if (!this.isAffordable || this.value === 0) return; // Keep the cycle phase consistent before and after purchase so that upgrading doesn't cause weird behavior\n    // such as immediately activating it when inactive (or worse, skipping past the active segment entirely).\n\n    const bh = BlackHole(this.id);\n    const beforeProg = bh.isCharged ? 1 - bh.stateProgress : bh.stateProgress;\n    Currency.realityMachines.purchase(this.cost);\n    this.incrementAmount();\n\n    this._lazyValue.invalidate();\n\n    this._lazyCost.invalidate();\n\n    if (this.onPurchase) {\n      this.onPurchase();\n    } // Adjust the phase to what it was before purchase by changing it directly. This will often result in passing\n    // in a negative argument to updatePhase(), but this shouldn't cause any problems because it'll never make\n    // the phase itself negative. In very rare cases this may result in a single auto-pause getting skipped\n\n\n    const stateTime = bh.isCharged ? bh.duration : bh.interval;\n    bh.updatePhase(stateTime * beforeProg - bh.phase); // Prevents a rare edge case where the player makes an inactive black hole permanent, locking themselves into\n    // a permanently inactive black hole\n\n    if (bh.isPermanent) player.blackHole[this.id - 1].active = true;\n    EventHub.dispatch(GAME_EVENT.BLACK_HOLE_UPGRADE_BOUGHT);\n  }\n\n}\n\nclass BlackHoleState {\n  constructor(id) {\n    this.id = id + 1;\n    const blackHoleCostMultipliers = [1, 1000]; // Interval: starts at 3600, x0.8 per upgrade, upgrade cost goes x3.5, starts at 15\n\n    this.intervalUpgrade = new BlackHoleUpgradeState({\n      id: this.id,\n      getAmount: () => this._data.intervalUpgrades,\n      setAmount: amount => this._data.intervalUpgrades = amount,\n      calculateValue: amount => 3600 / Math.pow(10, id) * Math.pow(0.8, amount),\n      initialCost: 15 * blackHoleCostMultipliers[id],\n      costMult: 3.5,\n      hasAutobuyer: false,\n      onPurchase: () => {\n        if (!this.isCharged) {\n          this._data.phase = Math.clampMax(this.interval, this._data.phase);\n        }\n      }\n    }); // Power: starts at 5, x1.35 per upgrade, cost goes x2, starts at 20\n\n    this.powerUpgrade = new BlackHoleUpgradeState({\n      id: this.id,\n      getAmount: () => this._data.powerUpgrades,\n      setAmount: amount => this._data.powerUpgrades = amount,\n      calculateValue: amount => 180 / Math.pow(2, id) * Math.pow(1.35, amount),\n      initialCost: 20 * blackHoleCostMultipliers[id],\n      costMult: 2,\n      hasAutobuyer: true\n    }); // Duration: starts at 10, x1.5 per upgrade, cost goes x4, starts at 10\n\n    this.durationUpgrade = new BlackHoleUpgradeState({\n      id: this.id,\n      getAmount: () => this._data.durationUpgrades,\n      setAmount: amount => this._data.durationUpgrades = amount,\n      calculateValue: amount => (10 - id * 3) * Math.pow(1.3, amount),\n      initialCost: 10 * blackHoleCostMultipliers[id],\n      costMult: 4,\n      hasAutobuyer: false\n    });\n  }\n  /**\r\n   * @private\r\n   */\n\n\n  get _data() {\n    return player.blackHole[this.id - 1];\n  }\n  /**\r\n   * Exists to avoid recursion in calculation of whether the black hole is permanent.\r\n   */\n\n\n  get rawInterval() {\n    return this.intervalUpgrade.value * Achievement(145).effectOrDefault(1);\n  }\n  /**\r\n   * Amount of time the black hole is inactive for between activations.\r\n   */\n\n\n  get interval() {\n    return this.isPermanent ? 0 : this.rawInterval;\n  }\n  /**\r\n   * Multiplier to time the black hole gives when active.\r\n   */\n\n\n  get power() {\n    return this.powerUpgrade.value * Achievement(158).effectOrDefault(1);\n  }\n  /**\r\n   * Amount of time the black hole is active for.\r\n   */\n\n\n  get duration() {\n    return this.durationUpgrade.value * Achievement(155).effectOrDefault(1);\n  }\n\n  get isUnlocked() {\n    return this._data.unlocked && !Enslaved.isRunning && !Pelle.isDisabled(\"blackhole\");\n  }\n\n  get isCharged() {\n    return this._data.active;\n  }\n\n  get timeWithPreviousActiveToNextStateChange() {\n    return this.isCharged ? this.duration - this.phase : this.interval - this.phase;\n  } // When inactive, returns time until active; when active, returns time until inactive (or paused for hole 2)\n\n\n  get timeToNextStateChange() {\n    const remainingTime = this.timeWithPreviousActiveToNextStateChange;\n    if (this.id === 1) return remainingTime; // 2nd hole activation logic (not bothering generalizing since we're not adding that 3rd hole again)\n\n    if (this.isCharged) {\n      if (BlackHole(1).isCharged) return Math.min(remainingTime, BlackHole(1).timeToNextStateChange);\n      return BlackHole(1).timeToNextStateChange;\n    }\n\n    return BlackHole(1).timeUntilTimeActive(remainingTime);\n  } // Given x, return time it takes for this black hole to get x time active\n\n\n  timeUntilTimeActive(inputTimeActive) {\n    // Avoid error about reassigning parameter.\n    let timeActive = inputTimeActive;\n\n    if (this.isCharged) {\n      // We start at the next full activation, so if we have a partial activation\n      // then that reduces the time required.\n      // Make sure to handle the case when the current partial activation is enough.\n      if (timeActive < this.timeToNextStateChange) return timeActive; // If it's not enough, we can subtract it from our time.\n\n      timeActive -= this.timeToNextStateChange;\n    } // Determine the time until the next full activation.\n\n\n    let totalTime = this.isCharged ? this.timeToNextStateChange + this.interval : this.timeToNextStateChange; // This is the number of full cycles needed...\n\n    totalTime += Math.floor(timeActive / this.duration) * this.cycleLength; // And the time from a partial cycle.\n\n    totalTime += timeActive % this.duration;\n    return totalTime;\n  } // This is a value which counts up from 0 to 1 when inactive, and 1 to 0 when active\n\n\n  get stateProgress() {\n    if (this.isCharged) {\n      return 1 - this.phase / this.duration;\n    }\n\n    return this.phase / this.interval;\n  } // The logic to determine what state the black hole is in for displaying is nontrivial and used in multiple places\n\n\n  get displayState() {\n    if (Pelle.isDisabled(\"blackhole\")) return `<i class=\"fas fa-ban\"></i> Disabled`;\n\n    if (Enslaved.isAutoReleasing) {\n      if (Enslaved.autoReleaseTick < 3) return `<i class=\"fas fa-compress-arrows-alt u-fa-padding\"></i> Pulsing`;\n      return `<i class=\"fas fa-expand-arrows-alt u-fa-padding\"></i> Pulsing`;\n    }\n\n    if (Enslaved.isStoringGameTime) return `<i class=\"fas fa-compress-arrows-alt\"></i> Charging`;\n    if (BlackHoles.areNegative) return `<i class=\"fas fa-caret-left\"></i> Inverted`;\n    if (BlackHoles.arePaused) return `<i class=\"fas fa-pause\"></i> Paused`;\n    if (this.isPermanent) return `<i class=\"fas fa-infinity\"></i> Permanent`;\n    const timeString = TimeSpan.fromSeconds(this.timeToNextStateChange).toStringShort(true);\n    if (this.isActive) return `<i class=\"fas fa-play\"></i> Active (${timeString})`;\n    return `<i class=\"fas fa-redo\"></i> Inactive (${timeString})`;\n  }\n\n  get isActive() {\n    return this.isCharged && (this.id === 1 || BlackHole(this.id - 1).isActive) && !Pelle.isDisabled(\"blackhole\");\n  } // Proportion of active time, scaled 0 to 1\n\n\n  get dutyCycle() {\n    return this.duration / (this.rawInterval + this.duration);\n  }\n\n  get isPermanent() {\n    return this.dutyCycle >= 0.9999;\n  }\n  /**\r\n   * Amount of time the black hole has spent since last state transition,\r\n   * so if it's active, it's the amount of time it's been active for, and if it's inactive,\r\n   * it's the amount of time it's been inactive for.\r\n   */\n\n\n  get phase() {\n    return this._data.phase;\n  }\n\n  get cycleLength() {\n    return this.interval + this.duration;\n  }\n\n  updatePhase(activePeriod) {\n    if (this.isPermanent) return; // Prevents a flickering black hole if phase gets set too high\n    // (shouldn't ever happen in practice). Also, more importantly,\n    // should work even if activePeriods[i] is very large. To check:\n    // This used to always use the period of blackHole[0], now it doesn't,\n    // will this cause other bugs?\n\n    this._data.phase += activePeriod;\n\n    if (this.phase >= this.cycleLength) {\n      // One activation for each full cycle.\n      this._data.activations += Math.floor(this.phase / this.cycleLength);\n      this._data.phase %= this.cycleLength;\n    }\n\n    if (this.isCharged) {\n      if (this.phase >= this.duration) {\n        this._data.phase -= this.duration;\n        this._data.active = false;\n\n        if (GameUI.notify.showBlackHoles) {\n          GameUI.notify.blackHole(`${this.description(true)} duration ended.`);\n        }\n      }\n    } else if (this.phase >= this.interval) {\n      this._data.phase -= this.interval;\n      this._data.activations++;\n      this._data.active = true;\n\n      if (GameUI.notify.showBlackHoles) {\n        GameUI.notify.blackHole(`${this.description(true)} has activated!`);\n      }\n    }\n  }\n  /**\r\n   * Given the time for which the previous black hole is active,\r\n   * this function returns the time for which current black hole is active.\r\n   * For example, for BlackHole(2), this function, given\r\n   * the time for which for BlackHole(1) is active, will return the time for which\r\n   * BlackHole(2) is active during that time.\r\n   */\n\n\n  realTimeWhileActive(time) {\n    const nextDeactivation = this.timeUntilNextDeactivation;\n    const cooldown = this.interval;\n    const duration = this.duration;\n    const fullCycle = this.cycleLength;\n    const currentActivationDuration = Math.min(nextDeactivation, duration);\n    const activeCyclesUntilLastDeactivation = Math.floor((time - nextDeactivation) / fullCycle);\n    const activeTimeUntilLastDeactivation = duration * activeCyclesUntilLastDeactivation;\n    const timeLeftAfterLastDeactivation = (time - nextDeactivation + fullCycle) % fullCycle;\n    const lastActivationDuration = Math.max(timeLeftAfterLastDeactivation - cooldown, 0);\n    return currentActivationDuration + activeTimeUntilLastDeactivation + lastActivationDuration;\n  }\n  /**\r\n   * Returns the time that the previous black hole must be active until the next change\r\n   * from the active state to the inactive state. For example, for BlackHole(2),\r\n   * this function will return the time BlackHole(1) must be active for BlackHole(2)\r\n   * to transition to the inactive state. This is useful since BlackHole(2)'s phase\r\n   * only increases (that is, its state only changes) while BlackHole(1) is active.\r\n   * In general, a black hole only changes state while the previous black hole is active.\r\n   * So figuring out how long a black hole would be active after some amount of real time\r\n   * (as we do) is best done iteratively via figuring out how long a black hole would be active\r\n   * after a given amount of time of the previous black hole being active.\r\n   */\n\n\n  get timeUntilNextDeactivation() {\n    if (this.isCharged) {\n      return this.duration - this.phase;\n    }\n\n    return this.cycleLength - this.phase;\n  }\n\n  description(capitalized) {\n    if (RealityUpgrade(20).isBought) {\n      return `Black Hole ${this.id}`;\n    }\n\n    return capitalized ? \"The Black Hole\" : \"the Black Hole\";\n  }\n\n}\n\nBlackHoleState.list = Array.range(0, 2).map(id => new BlackHoleState(id));\n/**\r\n * @param {number} id\r\n * @return {BlackHoleState}\r\n */\n\nexport function BlackHole(id) {\n  return BlackHoleState.list[id - 1];\n}\nexport const BlackHoles = {\n  // In seconds\n  ACCELERATION_TIME: 5,\n\n  /**\r\n   * @return {BlackHoleState[]}\r\n   */\n  get list() {\n    return BlackHoleState.list;\n  },\n\n  get canBeUnlocked() {\n    return Currency.realityMachines.gte(100) && !this.areUnlocked;\n  },\n\n  get areUnlocked() {\n    return BlackHole(1).isUnlocked;\n  },\n\n  unlock() {\n    if (!this.canBeUnlocked) return;\n    player.blackHole[0].unlocked = true;\n    Currency.realityMachines.purchase(100);\n    player.records.timePlayedAtBHUnlock = player.records.totalTimePlayed;\n    EventHub.dispatch(GAME_EVENT.BLACK_HOLE_UNLOCKED);\n  },\n\n  togglePause: (automatic = false) => {\n    if (!BlackHoles.areUnlocked) return;\n    const maxInversion = player.requirementChecks.reality.slowestBH <= 1e-300;\n\n    if (ImaginaryUpgrade(24).isLockingMechanics && Ra.isRunning && maxInversion) {\n      if (!automatic) ImaginaryUpgrade(24).tryShowWarningModal(\"uninvert your Black Hole\");\n      return;\n    }\n\n    if (player.blackHolePause) player.requirementChecks.reality.slowestBH = 1;\n    player.blackHolePause = !player.blackHolePause;\n    player.blackHolePauseTime = player.records.realTimePlayed;\n    const blackHoleString = RealityUpgrade(20).isBought ? \"Black Holes\" : \"Black Hole\"; // If black holes are going unpaused -> paused, use \"inverted\" or \"paused\" depending o\n    // whether the player's using negative BH (i.e. BH inversion); if going paused -> unpaused,\n    // use \"unpaused\".\n    // eslint-disable-next-line no-nested-ternary\n\n    const pauseType = player.blackHolePause ? BlackHoles.areNegative ? \"inverted\" : \"paused\" : \"unpaused\";\n    const automaticString = automatic ? \"automatically \" : \"\";\n    GameUI.notify.blackHole(`${blackHoleString} ${automaticString}${pauseType}`);\n  },\n\n  get unpauseAccelerationFactor() {\n    if (this.arePermanent) return 1;\n    return Math.clamp((player.records.realTimePlayed - player.blackHolePauseTime) * getGlobalSpeedFactor() / (1000 * this.ACCELERATION_TIME), 0, 1);\n  },\n\n  get arePaused() {\n    return player.blackHolePause;\n  },\n\n  get areNegative() {\n    return this.arePaused && !Laitela.isRunning && player.blackHoleNegative < 1;\n  },\n\n  get arePermanent() {\n    return BlackHoles.list.every(bh => bh.isPermanent);\n  },\n\n  updatePhases(blackHoleDiff) {\n    if (!this.areUnlocked || this.arePaused) return; // This code is intended to successfully update the black hole phases\n    // even for very large values of blackHoleDiff.\n    // With auto-pause settings, this code also has to take account of that.\n\n    const rawSeconds = blackHoleDiff / 1000;\n    const [autoPause, seconds] = this.autoPauseData(rawSeconds);\n    const activePeriods = this.realTimePeriodsWithBlackHoleActive(seconds, true);\n\n    for (const blackHole of this.list) {\n      if (!blackHole.isUnlocked) break;\n      blackHole.updatePhase(activePeriods[blackHole.id - 1]);\n    }\n\n    if (autoPause) {\n      BlackHoles.togglePause(true);\n    }\n  },\n\n  /**\r\n   * This function takes the total real time spent offline,\r\n   * a number of ticks to simulate, a tolerance for how far ticks can be\r\n   * from average (explained later), and returns a single realTickTime and\r\n   * blackHoleSpeed representing the real time taken up by the first simulated tick\r\n   * and the game speed due to black holess during it.\r\n   *\r\n   * This code makes sure that the following conditions are satisfied:\r\n   * 1: realTickTime * blackHoleSpeed is exactly (up to some small\r\n   * multiple of floating-point precision) the game time which would be spent\r\n   * after realTickTime real time, accounting for black holess\r\n   * (but not for anything else).\r\n   * 2: No tick contains too much (more than a constant multiple of\r\n   * the mean game time per tick) of the game time.\r\n   * 3: No tick has negative or zero real time or (equivalently)\r\n   * negative or zero game time.\r\n   * Note that Patashu has convinced me that we do not want the property\r\n   * \"No tick contains too much (more than a constant multiple of the\r\n   * mean real time per tick) of the real time.\" There's no reason to have it\r\n   * aside from the edge cases of EC12 (and if you're going offline during EC12\r\n   * then you should expect technically correct but somewhat annoying behavior)\r\n   * and auto EC completion (but auto EC completion shouldn't be that much\r\n   * of an issue).\r\n   */\n  calculateOfflineTick(totalRealTime, numberOfTicks, tolerance) {\n    // Cache speedups, so calculateGameTimeFromRealTime doesn't recalculate them every time.\n    const speedups = this.calculateSpeedups();\n    const totalGameTime = this.calculateGameTimeFromRealTime(totalRealTime, speedups); // We have this special case just in case some floating-point mess prevents\n    // binarySearch from working in the numberOfTicks = 1 case.\n    // I doubt that's possible but it seems worth handling just in case.\n\n    if (numberOfTicks === 1) {\n      return [totalRealTime, totalGameTime / totalRealTime];\n    } // We want calculateGameTimeFromRealTime(realTickTime, speedups) * numberOfTicks / totalGameTime to be roughly 1\n    // (that is, the tick taking realTickTime real time has roughly average length in terms of game time).\n    // We use binary search because it has somewhat better worst-case behavior than linear interpolation search here.\n    // Suppose you have 3000 seconds without a black hole and then 100 seconds of a black hole with 3000x power,\n    // and you want to find when 4000 seconds of game time have elapsed. With binary search it will take only\n    // 20 steps or so to get reasonable accuracy, but with linear interpolation it will take about 100 steps.\n    // These extra steps might always average out with cases where linear interpolation is quicker though.\n\n\n    const realTickTime = this.binarySearch(0, totalRealTime, x => this.calculateGameTimeFromRealTime(x, speedups) * numberOfTicks / totalGameTime, 1, tolerance);\n    const blackHoleSpeedup = this.calculateGameTimeFromRealTime(realTickTime, speedups) / realTickTime;\n    return [realTickTime, blackHoleSpeedup];\n  },\n\n  /**\r\n   * Standard implementation of binary search for a monotone increasing function.\r\n   * The only unusual thing is tolerance, which is a bound on\r\n   * Math.abs(evaluationFunction(result) - target).\r\n   */\n  // eslint-disable-next-line max-params\n  binarySearch(start, end, evaluationFunction, target, tolerance) {\n    let middle;\n\n    for (let iter = 0; iter < 100; ++iter) {\n      middle = (start + end) / 2;\n      const error = evaluationFunction(middle) - target;\n      if (Math.abs(error) < tolerance) break;\n\n      if (error < 0) {\n        // eslint-disable-next-line no-param-reassign\n        start = middle;\n      } else {\n        // eslint-disable-next-line no-param-reassign\n        end = middle;\n      }\n    }\n\n    return middle;\n  },\n\n  /**\r\n   * Returns a list of length (number of unlocked black holes + 1),\r\n   * where each element is the *total* speedup while that black hole\r\n   * is the highest-numbered black hole active, the black holes being numbered\r\n   * starting from black hole 1 and black hole 0 being normal game.\r\n   */\n  calculateSpeedups() {\n    const effectsToConsider = [GAME_SPEED_EFFECT.FIXED_SPEED, GAME_SPEED_EFFECT.TIME_GLYPH, GAME_SPEED_EFFECT.SINGULARITY_MILESTONE, GAME_SPEED_EFFECT.NERFS];\n    const speedupWithoutBlackHole = getGameSpeedupFactor(effectsToConsider);\n    const speedups = [speedupWithoutBlackHole];\n    effectsToConsider.push(GAME_SPEED_EFFECT.BLACK_HOLE); // Crucial thing: this works even if the black holes are paused, it's just that the speedups will be 1.\n\n    for (const blackHole of this.list) {\n      if (!blackHole.isUnlocked) break;\n      speedups.push(getGameSpeedupFactor(effectsToConsider, blackHole.id) / speedupWithoutBlackHole);\n    }\n\n    return speedups;\n  },\n\n  calculateGameTimeFromRealTime(realTime, speedups) {\n    // We could do this.autoPauseData(realTime)[1] here but that seems less clear.\n    // Using _ as an unused variable should be reasonable.\n    // eslint-disable-next-line no-unused-vars\n    const [_, realerTime] = this.autoPauseData(realTime);\n    const effectivePeriods = this.realTimePeriodsWithBlackHoleEffective(realerTime, speedups); // This adds in time with black holes paused at the end of the list.\n\n    effectivePeriods[0] += realTime - realerTime;\n    return effectivePeriods.map((period, i) => period * speedups[i]).sum();\n  },\n\n  /**\r\n   * Returns the amount of real time spent with each unlocked black hole\r\n   * being the current \"effective\" black hole, that is, the active black hole\r\n   * with the highest index.\r\n   * For example:\r\n   * active periods = [100, 20, 5] (100ms of real time, 20ms of black hole 1, 5ms of black hole 2)\r\n   * effective periods = [80, 15, 5]\r\n   * 80ms of effective real time, because black hole 1 will be running in total 20ms => 100 - 20\r\n   * 15ms of effective black hole 1 time, because black hole 2 will be running in total 5ms => 20 - 5\r\n   * 5ms of effective black hole 2 time, because no higher black hole overlaps it,\r\n   * so it is effective for the whole active period\r\n   * Note: even though more than one black hole can be active\r\n   * (and thus effective) at once, the calling function first calculates the total speedups\r\n   * while each black hole is the highest-index black hole that's active and then acts\r\n   * as if only the highest-index black hole that's active is effective.\r\n   */\n  realTimePeriodsWithBlackHoleEffective(realTime) {\n    const activePeriods = this.realTimePeriodsWithBlackHoleActive(realTime);\n    const effectivePeriods = [];\n\n    for (let i = 0; i < activePeriods.length - 1; i++) {\n      effectivePeriods.push(activePeriods[i] - activePeriods[i + 1]);\n    }\n\n    effectivePeriods.push(activePeriods.last());\n    return effectivePeriods;\n  },\n\n  /**\r\n   * Returns an array of real time periods spent in each black hole\r\n   * with first element being the \"no black hole\" state that is normal game.\r\n   */\n  realTimePeriodsWithBlackHoleActive(realTime) {\n    const activePeriods = [realTime];\n\n    for (const blackHole of this.list) {\n      if (!blackHole.isUnlocked) break;\n      const activeTime = blackHole.realTimeWhileActive(activePeriods.last());\n      activePeriods.push(activeTime);\n    }\n\n    return activePeriods;\n  },\n\n  /**\r\n   * Takes BH number (1 or 2) and number of steps to do in an internal BH simulation.\r\n   * Returns real time until we can pause before given BH (i.e., we have a gap of at least 5 seconds before it),\r\n   * or null if we can't pause before it.\r\n   */\n  timeToNextPause(bhNum, steps = 100) {\n    if (bhNum === 1) {\n      // This is a simple case that we can do mathematically.\n      const bh = BlackHole(1); // If no blackhole gaps are as long as the warmup time, we never pause.\n\n      if (bh.interval <= BlackHoles.ACCELERATION_TIME) {\n        return null;\n      } // Find the time until next activation.\n\n\n      const t = (bh.isCharged ? bh.duration : 0) + bh.interval - bh.phase; // If the time until next activation is less than the acceleration time,\n      // we have to wait until the activation after that;\n      // otherwise, we can just use the next activation.\n\n      return t < BlackHoles.ACCELERATION_TIME ? t + bh.duration + bh.interval - BlackHoles.ACCELERATION_TIME : t - BlackHoles.ACCELERATION_TIME;\n    } // Look at the next 100 black hole transitions.\n    // This is called every tick if BH pause setting is set to BH2, so we try to optimize it.\n    // I think the bound of 100 means it can fail only in the case one black hole interval is under 5s\n    // and the other isn't. In practice, by this point the other interval is usually about 15 seconds\n    // and both durations are fairly long (a few minutes), making the longest that a gap between activations\n    // can be 20 seconds (so it's fairly OK not to pause).\n    // Precalculate some stuff that won't change (or in the case of charged and phases, stuff we'll change ourself\n    // but just in this simulation) while we call this function.\n\n\n    const charged = [BlackHole(1).isCharged, BlackHole(2).isCharged];\n    const phases = [BlackHole(1).phase, BlackHole(2).phase];\n    const durations = [BlackHole(1).duration, BlackHole(2).duration];\n    const intervals = [BlackHole(1).interval, BlackHole(2).interval]; // This is technically somewhat incorrect, because assuming durations aren't tiny, the maximum\n    // possible gap between BH2 activations is the *sum* of the intervals. However, that's still 10 seconds\n    // if this conditional is true, and pausing the BH because of a 10-second activation gap\n    // doesn't seem to make much sense. If this is an issue, we could use the sum of the intervals.\n    // This should also stop this function from being relatively computationally expensive\n    // if both intervals are 3 seconds (so the next pause would be when they happen to align,\n    // which is rare and will probably lead to a full 100 steps).\n\n    if (intervals[0] <= BlackHoles.ACCELERATION_TIME && intervals[1] <= BlackHoles.ACCELERATION_TIME) {\n      return null;\n    } // Make a list of things to bound phase by.\n\n\n    const phaseBoundList = [[intervals[0]], [durations[0], intervals[1]], [durations[0], durations[1]]]; // Time tracking.\n\n    let inactiveTime = 0;\n    let totalTime = 0;\n\n    for (let i = 0; i < steps; i++) {\n      // Currently active BH (if BH1 and BH2 are both charged, 2,\n      // if only BH1 is, 1, if BH1 isn't, 0 regardless of BH2).\n      // eslint-disable-next-line no-nested-ternary\n      const current = charged[0] ? charged[1] ? 2 : 1 : 0; // Get the list of phase bounds.\n\n      const phaseBounds = phaseBoundList[current]; // Compute time until some phase reaches its bound.\n\n      const minTime = current > 0 ? Math.min(phaseBounds[0] - phases[0], phaseBounds[1] - phases[1]) : phaseBounds[0] - phases[0];\n\n      if (current === 2) {\n        // Check if there was enough time before this activation to pause.\n        if (inactiveTime >= BlackHoles.ACCELERATION_TIME) {\n          return totalTime - BlackHoles.ACCELERATION_TIME;\n        } // Not enough time, reset inactive time to 0.\n\n\n        inactiveTime = 0;\n      } else {\n        // BH2 is inactive, add to inactive time.\n        inactiveTime += minTime;\n      } // Add to total time in any case.\n\n\n      totalTime += minTime; // If BH1 is active we should update BH2.\n\n      if (current > 0) {\n        phases[1] += minTime;\n\n        if (phases[1] >= phaseBounds[1]) {\n          charged[1] = !charged[1];\n          phases[1] -= phaseBounds[1];\n        }\n      } // Update BH1 no matter what.\n\n\n      phases[0] += minTime;\n\n      if (phases[0] >= phaseBounds[0]) {\n        charged[0] = !charged[0];\n        phases[0] -= phaseBounds[0];\n      }\n    } // We didn't activate so we return null.\n\n\n    return null;\n  },\n\n  /**\r\n   * Takes amount of real time.\r\n   * Returns 2-item array:\r\n   * [will BH be paused in the given amount of real time, real time until pause if so].\r\n   */\n  autoPauseData(realTime) {\n    // This can be called when determining offline time if the black holes are already paused.\n    // In that case we don't need to pause them (need to pause = false), but they're already paused (0 time).\n    // This saves us some computation.\n    if (this.arePaused) return [false, 0];\n\n    if (player.blackHoleAutoPauseMode === BLACK_HOLE_PAUSE_MODE.NO_PAUSE) {\n      return [false, realTime];\n    }\n\n    const timeLeft = this.timeToNextPause(player.blackHoleAutoPauseMode); // Cases in which we don't pause in the given amount of real time:\n    // null = no pause, (timeLeft < 1e-9) = we auto-paused and there was maybe rounding error,\n    // now the player's unpaused at this exact point (so we shouldn't pause again),\n    // (timeLeft > realTime) = we will pause but it'll take longer than the given time.\n\n    if (timeLeft === null || timeLeft < 1e-9 || timeLeft > realTime) {\n      return [false, realTime];\n    }\n\n    return [true, timeLeft];\n  }\n\n};","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/black-hole.js"],"names":["DC","SpeedrunMilestones","BlackHoleUpgradeState","constructor","config","getAmount","setAmount","calculateValue","initialCost","costMult","incrementAmount","_lazyValue","Lazy","_lazyCost","getHybridCostScaling","E310","id","hasAutobuyer","onPurchase","value","cost","isAffordable","Currency","realityMachines","gte","purchase","bh","BlackHole","beforeProg","isCharged","stateProgress","invalidate","stateTime","duration","interval","updatePhase","phase","isPermanent","player","blackHole","active","EventHub","dispatch","GAME_EVENT","BLACK_HOLE_UPGRADE_BOUGHT","BlackHoleState","blackHoleCostMultipliers","intervalUpgrade","_data","intervalUpgrades","amount","Math","pow","clampMax","powerUpgrade","powerUpgrades","durationUpgrade","durationUpgrades","rawInterval","Achievement","effectOrDefault","power","isUnlocked","unlocked","Enslaved","isRunning","Pelle","isDisabled","timeWithPreviousActiveToNextStateChange","timeToNextStateChange","remainingTime","min","timeUntilTimeActive","inputTimeActive","timeActive","totalTime","floor","cycleLength","displayState","isAutoReleasing","autoReleaseTick","isStoringGameTime","BlackHoles","areNegative","arePaused","timeString","TimeSpan","fromSeconds","toStringShort","isActive","dutyCycle","activePeriod","activations","GameUI","notify","showBlackHoles","description","realTimeWhileActive","time","nextDeactivation","timeUntilNextDeactivation","cooldown","fullCycle","currentActivationDuration","activeCyclesUntilLastDeactivation","activeTimeUntilLastDeactivation","timeLeftAfterLastDeactivation","lastActivationDuration","max","capitalized","RealityUpgrade","isBought","list","Array","range","map","ACCELERATION_TIME","canBeUnlocked","areUnlocked","unlock","records","timePlayedAtBHUnlock","totalTimePlayed","BLACK_HOLE_UNLOCKED","togglePause","automatic","maxInversion","requirementChecks","reality","slowestBH","ImaginaryUpgrade","isLockingMechanics","Ra","tryShowWarningModal","blackHolePause","blackHolePauseTime","realTimePlayed","blackHoleString","pauseType","automaticString","unpauseAccelerationFactor","arePermanent","clamp","getGlobalSpeedFactor","Laitela","blackHoleNegative","every","updatePhases","blackHoleDiff","rawSeconds","autoPause","seconds","autoPauseData","activePeriods","realTimePeriodsWithBlackHoleActive","calculateOfflineTick","totalRealTime","numberOfTicks","tolerance","speedups","calculateSpeedups","totalGameTime","calculateGameTimeFromRealTime","realTickTime","binarySearch","x","blackHoleSpeedup","start","end","evaluationFunction","target","middle","iter","error","abs","effectsToConsider","GAME_SPEED_EFFECT","FIXED_SPEED","TIME_GLYPH","SINGULARITY_MILESTONE","NERFS","speedupWithoutBlackHole","getGameSpeedupFactor","push","BLACK_HOLE","realTime","_","realerTime","effectivePeriods","realTimePeriodsWithBlackHoleEffective","period","i","sum","length","last","activeTime","timeToNextPause","bhNum","steps","t","charged","phases","durations","intervals","phaseBoundList","inactiveTime","current","phaseBounds","minTime","blackHoleAutoPauseMode","BLACK_HOLE_PAUSE_MODE","NO_PAUSE","timeLeft"],"mappings":"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","sourcesContent":["import { DC } from \"./constants\";\r\nimport { SpeedrunMilestones } from \"./speedrun\";\r\n\r\nclass BlackHoleUpgradeState {\r\n  constructor(config) {\r\n    const { getAmount, setAmount, calculateValue, initialCost, costMult } = config;\r\n    this.incrementAmount = () => setAmount(getAmount() + 1);\r\n    this._lazyValue = new Lazy(() => calculateValue(getAmount()));\r\n    this._lazyCost = new Lazy(() => getHybridCostScaling(getAmount(),\r\n      1e30,\r\n      initialCost,\r\n      costMult,\r\n      0.2,\r\n      DC.E310,\r\n      1e5,\r\n      10));\r\n    this.id = config.id;\r\n    this.hasAutobuyer = config.hasAutobuyer;\r\n    this.onPurchase = config.onPurchase;\r\n  }\r\n\r\n  get value() {\r\n    return this._lazyValue.value;\r\n  }\r\n\r\n  get cost() {\r\n    return this._lazyCost.value;\r\n  }\r\n\r\n  get isAffordable() {\r\n    return Currency.realityMachines.gte(this.cost);\r\n  }\r\n\r\n  purchase() {\r\n    if (!this.isAffordable || this.value === 0) return;\r\n\r\n    // Keep the cycle phase consistent before and after purchase so that upgrading doesn't cause weird behavior\r\n    // such as immediately activating it when inactive (or worse, skipping past the active segment entirely).\r\n    const bh = BlackHole(this.id);\r\n    const beforeProg = bh.isCharged ? 1 - bh.stateProgress : bh.stateProgress;\r\n\r\n    Currency.realityMachines.purchase(this.cost);\r\n    this.incrementAmount();\r\n    this._lazyValue.invalidate();\r\n    this._lazyCost.invalidate();\r\n    if (this.onPurchase) {\r\n      this.onPurchase();\r\n    }\r\n\r\n    // Adjust the phase to what it was before purchase by changing it directly. This will often result in passing\r\n    // in a negative argument to updatePhase(), but this shouldn't cause any problems because it'll never make\r\n    // the phase itself negative. In very rare cases this may result in a single auto-pause getting skipped\r\n    const stateTime = bh.isCharged ? bh.duration : bh.interval;\r\n    bh.updatePhase(stateTime * beforeProg - bh.phase);\r\n\r\n    // Prevents a rare edge case where the player makes an inactive black hole permanent, locking themselves into\r\n    // a permanently inactive black hole\r\n    if (bh.isPermanent) player.blackHole[this.id - 1].active = true;\r\n\r\n    EventHub.dispatch(GAME_EVENT.BLACK_HOLE_UPGRADE_BOUGHT);\r\n  }\r\n}\r\n\r\nclass BlackHoleState {\r\n  constructor(id) {\r\n    this.id = id + 1;\r\n    const blackHoleCostMultipliers = [1, 1000];\r\n    // Interval: starts at 3600, x0.8 per upgrade, upgrade cost goes x3.5, starts at 15\r\n    this.intervalUpgrade = new BlackHoleUpgradeState({\r\n      id: this.id,\r\n      getAmount: () => this._data.intervalUpgrades,\r\n      setAmount: amount => this._data.intervalUpgrades = amount,\r\n      calculateValue: amount => (3600 / (Math.pow(10, id))) * Math.pow(0.8, amount),\r\n      initialCost: 15 * blackHoleCostMultipliers[id],\r\n      costMult: 3.5,\r\n      hasAutobuyer: false,\r\n      onPurchase: () => {\r\n        if (!this.isCharged) {\r\n          this._data.phase = Math.clampMax(this.interval, this._data.phase);\r\n        }\r\n      }\r\n    });\r\n    // Power: starts at 5, x1.35 per upgrade, cost goes x2, starts at 20\r\n    this.powerUpgrade = new BlackHoleUpgradeState({\r\n      id: this.id,\r\n      getAmount: () => this._data.powerUpgrades,\r\n      setAmount: amount => this._data.powerUpgrades = amount,\r\n      calculateValue: amount => (180 / Math.pow(2, id)) * Math.pow(1.35, amount),\r\n      initialCost: 20 * blackHoleCostMultipliers[id],\r\n      costMult: 2,\r\n      hasAutobuyer: true\r\n    });\r\n    // Duration: starts at 10, x1.5 per upgrade, cost goes x4, starts at 10\r\n    this.durationUpgrade = new BlackHoleUpgradeState({\r\n      id: this.id,\r\n      getAmount: () => this._data.durationUpgrades,\r\n      setAmount: amount => this._data.durationUpgrades = amount,\r\n      calculateValue: amount => (10 - (id) * 3) * Math.pow(1.3, amount),\r\n      initialCost: 10 * blackHoleCostMultipliers[id],\r\n      costMult: 4,\r\n      hasAutobuyer: false\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  get _data() {\r\n    return player.blackHole[this.id - 1];\r\n  }\r\n\r\n  /**\r\n   * Exists to avoid recursion in calculation of whether the black hole is permanent.\r\n   */\r\n  get rawInterval() {\r\n    return this.intervalUpgrade.value * Achievement(145).effectOrDefault(1);\r\n  }\r\n\r\n  /**\r\n   * Amount of time the black hole is inactive for between activations.\r\n   */\r\n  get interval() {\r\n    return this.isPermanent ? 0 : this.rawInterval;\r\n  }\r\n\r\n  /**\r\n   * Multiplier to time the black hole gives when active.\r\n   */\r\n  get power() {\r\n    return this.powerUpgrade.value * Achievement(158).effectOrDefault(1);\r\n  }\r\n\r\n  /**\r\n   * Amount of time the black hole is active for.\r\n   */\r\n  get duration() {\r\n    return this.durationUpgrade.value * Achievement(155).effectOrDefault(1);\r\n  }\r\n\r\n  get isUnlocked() {\r\n    return this._data.unlocked && !Enslaved.isRunning && !Pelle.isDisabled(\"blackhole\");\r\n  }\r\n\r\n  get isCharged() {\r\n    return this._data.active;\r\n  }\r\n\r\n  get timeWithPreviousActiveToNextStateChange() {\r\n    return this.isCharged ? this.duration - this.phase : this.interval - this.phase;\r\n  }\r\n\r\n  // When inactive, returns time until active; when active, returns time until inactive (or paused for hole 2)\r\n  get timeToNextStateChange() {\r\n    const remainingTime = this.timeWithPreviousActiveToNextStateChange;\r\n\r\n    if (this.id === 1) return remainingTime;\r\n\r\n    // 2nd hole activation logic (not bothering generalizing since we're not adding that 3rd hole again)\r\n    if (this.isCharged) {\r\n      if (BlackHole(1).isCharged) return Math.min(remainingTime, BlackHole(1).timeToNextStateChange);\r\n      return BlackHole(1).timeToNextStateChange;\r\n    }\r\n    return BlackHole(1).timeUntilTimeActive(remainingTime);\r\n  }\r\n\r\n  // Given x, return time it takes for this black hole to get x time active\r\n  timeUntilTimeActive(inputTimeActive) {\r\n    // Avoid error about reassigning parameter.\r\n    let timeActive = inputTimeActive;\r\n    if (this.isCharged) {\r\n      // We start at the next full activation, so if we have a partial activation\r\n      // then that reduces the time required.\r\n      // Make sure to handle the case when the current partial activation is enough.\r\n      if (timeActive < this.timeToNextStateChange) return timeActive;\r\n      // If it's not enough, we can subtract it from our time.\r\n      timeActive -= this.timeToNextStateChange;\r\n    }\r\n    // Determine the time until the next full activation.\r\n    let totalTime = this.isCharged\r\n      ? this.timeToNextStateChange + this.interval\r\n      : this.timeToNextStateChange;\r\n    // This is the number of full cycles needed...\r\n    totalTime += Math.floor(timeActive / this.duration) * this.cycleLength;\r\n    // And the time from a partial cycle.\r\n    totalTime += timeActive % this.duration;\r\n    return totalTime;\r\n  }\r\n\r\n  // This is a value which counts up from 0 to 1 when inactive, and 1 to 0 when active\r\n  get stateProgress() {\r\n    if (this.isCharged) {\r\n      return 1 - this.phase / this.duration;\r\n    }\r\n    return this.phase / this.interval;\r\n  }\r\n\r\n  // The logic to determine what state the black hole is in for displaying is nontrivial and used in multiple places\r\n  get displayState() {\r\n    if (Pelle.isDisabled(\"blackhole\")) return `<i class=\"fas fa-ban\"></i> Disabled`;\r\n    if (Enslaved.isAutoReleasing) {\r\n      if (Enslaved.autoReleaseTick < 3) return `<i class=\"fas fa-compress-arrows-alt u-fa-padding\"></i> Pulsing`;\r\n      return `<i class=\"fas fa-expand-arrows-alt u-fa-padding\"></i> Pulsing`;\r\n    }\r\n    if (Enslaved.isStoringGameTime) return `<i class=\"fas fa-compress-arrows-alt\"></i> Charging`;\r\n    if (BlackHoles.areNegative) return `<i class=\"fas fa-caret-left\"></i> Inverted`;\r\n    if (BlackHoles.arePaused) return `<i class=\"fas fa-pause\"></i> Paused`;\r\n    if (this.isPermanent) return `<i class=\"fas fa-infinity\"></i> Permanent`;\r\n\r\n    const timeString = TimeSpan.fromSeconds(this.timeToNextStateChange).toStringShort(true);\r\n    if (this.isActive) return `<i class=\"fas fa-play\"></i> Active (${timeString})`;\r\n    return `<i class=\"fas fa-redo\"></i> Inactive (${timeString})`;\r\n  }\r\n\r\n  get isActive() {\r\n    return this.isCharged && (this.id === 1 || BlackHole(this.id - 1).isActive) && !Pelle.isDisabled(\"blackhole\");\r\n  }\r\n\r\n  // Proportion of active time, scaled 0 to 1\r\n  get dutyCycle() {\r\n    return this.duration / (this.rawInterval + this.duration);\r\n  }\r\n\r\n  get isPermanent() {\r\n    return this.dutyCycle >= 0.9999;\r\n  }\r\n\r\n  /**\r\n   * Amount of time the black hole has spent since last state transition,\r\n   * so if it's active, it's the amount of time it's been active for, and if it's inactive,\r\n   * it's the amount of time it's been inactive for.\r\n   */\r\n  get phase() {\r\n    return this._data.phase;\r\n  }\r\n\r\n  get cycleLength() {\r\n    return this.interval + this.duration;\r\n  }\r\n\r\n  updatePhase(activePeriod) {\r\n    if (this.isPermanent) return;\r\n    // Prevents a flickering black hole if phase gets set too high\r\n    // (shouldn't ever happen in practice). Also, more importantly,\r\n    // should work even if activePeriods[i] is very large. To check:\r\n    // This used to always use the period of blackHole[0], now it doesn't,\r\n    // will this cause other bugs?\r\n    this._data.phase += activePeriod;\r\n\r\n    if (this.phase >= this.cycleLength) {\r\n      // One activation for each full cycle.\r\n      this._data.activations += Math.floor(this.phase / this.cycleLength);\r\n      this._data.phase %= this.cycleLength;\r\n    }\r\n    if (this.isCharged) {\r\n      if (this.phase >= this.duration) {\r\n        this._data.phase -= this.duration;\r\n        this._data.active = false;\r\n        if (GameUI.notify.showBlackHoles) {\r\n          GameUI.notify.blackHole(`${this.description(true)} duration ended.`);\r\n        }\r\n      }\r\n    } else if (this.phase >= this.interval) {\r\n      this._data.phase -= this.interval;\r\n      this._data.activations++;\r\n      this._data.active = true;\r\n      if (GameUI.notify.showBlackHoles) {\r\n        GameUI.notify.blackHole(`${this.description(true)} has activated!`);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Given the time for which the previous black hole is active,\r\n   * this function returns the time for which current black hole is active.\r\n   * For example, for BlackHole(2), this function, given\r\n   * the time for which for BlackHole(1) is active, will return the time for which\r\n   * BlackHole(2) is active during that time.\r\n   */\r\n  realTimeWhileActive(time) {\r\n    const nextDeactivation = this.timeUntilNextDeactivation;\r\n    const cooldown = this.interval;\r\n    const duration = this.duration;\r\n    const fullCycle = this.cycleLength;\r\n    const currentActivationDuration = Math.min(nextDeactivation, duration);\r\n    const activeCyclesUntilLastDeactivation = Math.floor((time - nextDeactivation) / fullCycle);\r\n    const activeTimeUntilLastDeactivation = duration * activeCyclesUntilLastDeactivation;\r\n    const timeLeftAfterLastDeactivation = (time - nextDeactivation + fullCycle) % fullCycle;\r\n    const lastActivationDuration = Math.max(timeLeftAfterLastDeactivation - cooldown, 0);\r\n    return currentActivationDuration + activeTimeUntilLastDeactivation + lastActivationDuration;\r\n  }\r\n\r\n  /**\r\n   * Returns the time that the previous black hole must be active until the next change\r\n   * from the active state to the inactive state. For example, for BlackHole(2),\r\n   * this function will return the time BlackHole(1) must be active for BlackHole(2)\r\n   * to transition to the inactive state. This is useful since BlackHole(2)'s phase\r\n   * only increases (that is, its state only changes) while BlackHole(1) is active.\r\n   * In general, a black hole only changes state while the previous black hole is active.\r\n   * So figuring out how long a black hole would be active after some amount of real time\r\n   * (as we do) is best done iteratively via figuring out how long a black hole would be active\r\n   * after a given amount of time of the previous black hole being active.\r\n   */\r\n  get timeUntilNextDeactivation() {\r\n    if (this.isCharged) {\r\n      return this.duration - this.phase;\r\n    }\r\n    return this.cycleLength - this.phase;\r\n  }\r\n\r\n  description(capitalized) {\r\n    if (RealityUpgrade(20).isBought) {\r\n      return `Black Hole ${this.id}`;\r\n    }\r\n    return capitalized ? \"The Black Hole\" : \"the Black Hole\";\r\n  }\r\n}\r\n\r\nBlackHoleState.list = Array.range(0, 2).map(id => new BlackHoleState(id));\r\n\r\n/**\r\n * @param {number} id\r\n * @return {BlackHoleState}\r\n */\r\nexport function BlackHole(id) {\r\n  return BlackHoleState.list[id - 1];\r\n}\r\n\r\nexport const BlackHoles = {\r\n  // In seconds\r\n  ACCELERATION_TIME: 5,\r\n  /**\r\n   * @return {BlackHoleState[]}\r\n   */\r\n  get list() {\r\n    return BlackHoleState.list;\r\n  },\r\n\r\n  get canBeUnlocked() {\r\n    return Currency.realityMachines.gte(100) && !this.areUnlocked;\r\n  },\r\n\r\n  get areUnlocked() {\r\n    return BlackHole(1).isUnlocked;\r\n  },\r\n\r\n  unlock() {\r\n    if (!this.canBeUnlocked) return;\r\n    player.blackHole[0].unlocked = true;\r\n    Currency.realityMachines.purchase(100);\r\n    player.records.timePlayedAtBHUnlock = player.records.totalTimePlayed;\r\n    EventHub.dispatch(GAME_EVENT.BLACK_HOLE_UNLOCKED);\r\n  },\r\n\r\n  togglePause: (automatic = false) => {\r\n    if (!BlackHoles.areUnlocked) return;\r\n    const maxInversion = player.requirementChecks.reality.slowestBH <= 1e-300;\r\n    if (ImaginaryUpgrade(24).isLockingMechanics && Ra.isRunning && maxInversion) {\r\n      if (!automatic) ImaginaryUpgrade(24).tryShowWarningModal(\"uninvert your Black Hole\");\r\n      return;\r\n    }\r\n    if (player.blackHolePause) player.requirementChecks.reality.slowestBH = 1;\r\n    player.blackHolePause = !player.blackHolePause;\r\n    player.blackHolePauseTime = player.records.realTimePlayed;\r\n    const blackHoleString = RealityUpgrade(20).isBought ? \"Black Holes\" : \"Black Hole\";\r\n    // If black holes are going unpaused -> paused, use \"inverted\" or \"paused\" depending o\r\n    // whether the player's using negative BH (i.e. BH inversion); if going paused -> unpaused,\r\n    // use \"unpaused\".\r\n    // eslint-disable-next-line no-nested-ternary\r\n    const pauseType = player.blackHolePause ? (BlackHoles.areNegative ? \"inverted\" : \"paused\") : \"unpaused\";\r\n    const automaticString = automatic ? \"automatically \" : \"\";\r\n    GameUI.notify.blackHole(`${blackHoleString} ${automaticString}${pauseType}`);\r\n  },\r\n\r\n  get unpauseAccelerationFactor() {\r\n    if (this.arePermanent) return 1;\r\n    return Math.clamp((player.records.realTimePlayed - player.blackHolePauseTime) * getGlobalSpeedFactor() /\r\n      (1000 * this.ACCELERATION_TIME), 0, 1);\r\n  },\r\n\r\n  get arePaused() {\r\n    return player.blackHolePause;\r\n  },\r\n\r\n  get areNegative() {\r\n    return this.arePaused && !Laitela.isRunning && player.blackHoleNegative < 1;\r\n  },\r\n\r\n  get arePermanent() {\r\n    return BlackHoles.list.every(bh => bh.isPermanent);\r\n  },\r\n\r\n  updatePhases(blackHoleDiff) {\r\n    if (!this.areUnlocked || this.arePaused) return;\r\n    // This code is intended to successfully update the black hole phases\r\n    // even for very large values of blackHoleDiff.\r\n    // With auto-pause settings, this code also has to take account of that.\r\n    const rawSeconds = blackHoleDiff / 1000;\r\n    const [autoPause, seconds] = this.autoPauseData(rawSeconds);\r\n    const activePeriods = this.realTimePeriodsWithBlackHoleActive(seconds, true);\r\n    for (const blackHole of this.list) {\r\n      if (!blackHole.isUnlocked) break;\r\n      blackHole.updatePhase(activePeriods[blackHole.id - 1]);\r\n    }\r\n    if (autoPause) {\r\n      BlackHoles.togglePause(true);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * This function takes the total real time spent offline,\r\n   * a number of ticks to simulate, a tolerance for how far ticks can be\r\n   * from average (explained later), and returns a single realTickTime and\r\n   * blackHoleSpeed representing the real time taken up by the first simulated tick\r\n   * and the game speed due to black holess during it.\r\n   *\r\n   * This code makes sure that the following conditions are satisfied:\r\n   * 1: realTickTime * blackHoleSpeed is exactly (up to some small\r\n   * multiple of floating-point precision) the game time which would be spent\r\n   * after realTickTime real time, accounting for black holess\r\n   * (but not for anything else).\r\n   * 2: No tick contains too much (more than a constant multiple of\r\n   * the mean game time per tick) of the game time.\r\n   * 3: No tick has negative or zero real time or (equivalently)\r\n   * negative or zero game time.\r\n   * Note that Patashu has convinced me that we do not want the property\r\n   * \"No tick contains too much (more than a constant multiple of the\r\n   * mean real time per tick) of the real time.\" There's no reason to have it\r\n   * aside from the edge cases of EC12 (and if you're going offline during EC12\r\n   * then you should expect technically correct but somewhat annoying behavior)\r\n   * and auto EC completion (but auto EC completion shouldn't be that much\r\n   * of an issue).\r\n   */\r\n  calculateOfflineTick(totalRealTime, numberOfTicks, tolerance) {\r\n    // Cache speedups, so calculateGameTimeFromRealTime doesn't recalculate them every time.\r\n    const speedups = this.calculateSpeedups();\r\n    const totalGameTime = this.calculateGameTimeFromRealTime(totalRealTime, speedups);\r\n    // We have this special case just in case some floating-point mess prevents\r\n    // binarySearch from working in the numberOfTicks = 1 case.\r\n    // I doubt that's possible but it seems worth handling just in case.\r\n    if (numberOfTicks === 1) {\r\n      return [totalRealTime, totalGameTime / totalRealTime];\r\n    }\r\n    // We want calculateGameTimeFromRealTime(realTickTime, speedups) * numberOfTicks / totalGameTime to be roughly 1\r\n    // (that is, the tick taking realTickTime real time has roughly average length in terms of game time).\r\n    // We use binary search because it has somewhat better worst-case behavior than linear interpolation search here.\r\n    // Suppose you have 3000 seconds without a black hole and then 100 seconds of a black hole with 3000x power,\r\n    // and you want to find when 4000 seconds of game time have elapsed. With binary search it will take only\r\n    // 20 steps or so to get reasonable accuracy, but with linear interpolation it will take about 100 steps.\r\n    // These extra steps might always average out with cases where linear interpolation is quicker though.\r\n    const realTickTime = this.binarySearch(\r\n      0,\r\n      totalRealTime,\r\n      x => this.calculateGameTimeFromRealTime(x, speedups) * numberOfTicks / totalGameTime,\r\n      1,\r\n      tolerance\r\n    );\r\n    const blackHoleSpeedup = this.calculateGameTimeFromRealTime(realTickTime, speedups) / realTickTime;\r\n    return [realTickTime, blackHoleSpeedup];\r\n  },\r\n\r\n  /**\r\n   * Standard implementation of binary search for a monotone increasing function.\r\n   * The only unusual thing is tolerance, which is a bound on\r\n   * Math.abs(evaluationFunction(result) - target).\r\n   */\r\n  // eslint-disable-next-line max-params\r\n  binarySearch(start, end, evaluationFunction, target, tolerance) {\r\n    let middle;\r\n    for (let iter = 0; iter < 100; ++iter) {\r\n      middle = (start + end) / 2;\r\n      const error = evaluationFunction(middle) - target;\r\n      if (Math.abs(error) < tolerance) break;\r\n      if (error < 0) {\r\n        // eslint-disable-next-line no-param-reassign\r\n        start = middle;\r\n      } else {\r\n        // eslint-disable-next-line no-param-reassign\r\n        end = middle;\r\n      }\r\n    }\r\n    return middle;\r\n  },\r\n\r\n  /**\r\n   * Returns a list of length (number of unlocked black holes + 1),\r\n   * where each element is the *total* speedup while that black hole\r\n   * is the highest-numbered black hole active, the black holes being numbered\r\n   * starting from black hole 1 and black hole 0 being normal game.\r\n   */\r\n  calculateSpeedups() {\r\n    const effectsToConsider = [GAME_SPEED_EFFECT.FIXED_SPEED, GAME_SPEED_EFFECT.TIME_GLYPH,\r\n      GAME_SPEED_EFFECT.SINGULARITY_MILESTONE, GAME_SPEED_EFFECT.NERFS];\r\n    const speedupWithoutBlackHole = getGameSpeedupFactor(effectsToConsider);\r\n    const speedups = [speedupWithoutBlackHole];\r\n    effectsToConsider.push(GAME_SPEED_EFFECT.BLACK_HOLE);\r\n    // Crucial thing: this works even if the black holes are paused, it's just that the speedups will be 1.\r\n    for (const blackHole of this.list) {\r\n      if (!blackHole.isUnlocked) break;\r\n      speedups.push(getGameSpeedupFactor(effectsToConsider, blackHole.id) / speedupWithoutBlackHole);\r\n    }\r\n    return speedups;\r\n  },\r\n\r\n  calculateGameTimeFromRealTime(realTime, speedups) {\r\n    // We could do this.autoPauseData(realTime)[1] here but that seems less clear.\r\n    // Using _ as an unused variable should be reasonable.\r\n    // eslint-disable-next-line no-unused-vars\r\n    const [_, realerTime] = this.autoPauseData(realTime);\r\n    const effectivePeriods = this.realTimePeriodsWithBlackHoleEffective(realerTime, speedups);\r\n    // This adds in time with black holes paused at the end of the list.\r\n    effectivePeriods[0] += realTime - realerTime;\r\n    return effectivePeriods\r\n      .map((period, i) => period * speedups[i])\r\n      .sum();\r\n  },\r\n\r\n  /**\r\n   * Returns the amount of real time spent with each unlocked black hole\r\n   * being the current \"effective\" black hole, that is, the active black hole\r\n   * with the highest index.\r\n   * For example:\r\n   * active periods = [100, 20, 5] (100ms of real time, 20ms of black hole 1, 5ms of black hole 2)\r\n   * effective periods = [80, 15, 5]\r\n   * 80ms of effective real time, because black hole 1 will be running in total 20ms => 100 - 20\r\n   * 15ms of effective black hole 1 time, because black hole 2 will be running in total 5ms => 20 - 5\r\n   * 5ms of effective black hole 2 time, because no higher black hole overlaps it,\r\n   * so it is effective for the whole active period\r\n   * Note: even though more than one black hole can be active\r\n   * (and thus effective) at once, the calling function first calculates the total speedups\r\n   * while each black hole is the highest-index black hole that's active and then acts\r\n   * as if only the highest-index black hole that's active is effective.\r\n   */\r\n  realTimePeriodsWithBlackHoleEffective(realTime) {\r\n    const activePeriods = this.realTimePeriodsWithBlackHoleActive(realTime);\r\n    const effectivePeriods = [];\r\n    for (let i = 0; i < activePeriods.length - 1; i++) {\r\n      effectivePeriods.push(activePeriods[i] - activePeriods[i + 1]);\r\n    }\r\n    effectivePeriods.push(activePeriods.last());\r\n    return effectivePeriods;\r\n  },\r\n\r\n  /**\r\n   * Returns an array of real time periods spent in each black hole\r\n   * with first element being the \"no black hole\" state that is normal game.\r\n   */\r\n  realTimePeriodsWithBlackHoleActive(realTime) {\r\n    const activePeriods = [realTime];\r\n    for (const blackHole of this.list) {\r\n      if (!blackHole.isUnlocked) break;\r\n      const activeTime = blackHole.realTimeWhileActive(activePeriods.last());\r\n      activePeriods.push(activeTime);\r\n    }\r\n    return activePeriods;\r\n  },\r\n\r\n  /**\r\n   * Takes BH number (1 or 2) and number of steps to do in an internal BH simulation.\r\n   * Returns real time until we can pause before given BH (i.e., we have a gap of at least 5 seconds before it),\r\n   * or null if we can't pause before it.\r\n   */\r\n  timeToNextPause(bhNum, steps = 100) {\r\n    if (bhNum === 1) {\r\n      // This is a simple case that we can do mathematically.\r\n      const bh = BlackHole(1);\r\n      // If no blackhole gaps are as long as the warmup time, we never pause.\r\n      if (bh.interval <= BlackHoles.ACCELERATION_TIME) {\r\n        return null;\r\n      }\r\n      // Find the time until next activation.\r\n      const t = (bh.isCharged ? bh.duration : 0) + bh.interval - bh.phase;\r\n      // If the time until next activation is less than the acceleration time,\r\n      // we have to wait until the activation after that;\r\n      // otherwise, we can just use the next activation.\r\n      return (t < BlackHoles.ACCELERATION_TIME)\r\n        ? t + bh.duration + bh.interval - BlackHoles.ACCELERATION_TIME : t - BlackHoles.ACCELERATION_TIME;\r\n    }\r\n    // Look at the next 100 black hole transitions.\r\n    // This is called every tick if BH pause setting is set to BH2, so we try to optimize it.\r\n    // I think the bound of 100 means it can fail only in the case one black hole interval is under 5s\r\n    // and the other isn't. In practice, by this point the other interval is usually about 15 seconds\r\n    // and both durations are fairly long (a few minutes), making the longest that a gap between activations\r\n    // can be 20 seconds (so it's fairly OK not to pause).\r\n    // Precalculate some stuff that won't change (or in the case of charged and phases, stuff we'll change ourself\r\n    // but just in this simulation) while we call this function.\r\n    const charged = [BlackHole(1).isCharged, BlackHole(2).isCharged];\r\n    const phases = [BlackHole(1).phase, BlackHole(2).phase];\r\n    const durations = [BlackHole(1).duration, BlackHole(2).duration];\r\n    const intervals = [BlackHole(1).interval, BlackHole(2).interval];\r\n    // This is technically somewhat incorrect, because assuming durations aren't tiny, the maximum\r\n    // possible gap between BH2 activations is the *sum* of the intervals. However, that's still 10 seconds\r\n    // if this conditional is true, and pausing the BH because of a 10-second activation gap\r\n    // doesn't seem to make much sense. If this is an issue, we could use the sum of the intervals.\r\n    // This should also stop this function from being relatively computationally expensive\r\n    // if both intervals are 3 seconds (so the next pause would be when they happen to align,\r\n    // which is rare and will probably lead to a full 100 steps).\r\n    if (intervals[0] <= BlackHoles.ACCELERATION_TIME && intervals[1] <= BlackHoles.ACCELERATION_TIME) {\r\n      return null;\r\n    }\r\n    // Make a list of things to bound phase by.\r\n    const phaseBoundList = [[intervals[0]], [durations[0], intervals[1]], [durations[0], durations[1]]];\r\n    // Time tracking.\r\n    let inactiveTime = 0;\r\n    let totalTime = 0;\r\n    for (let i = 0; i < steps; i++) {\r\n      // Currently active BH (if BH1 and BH2 are both charged, 2,\r\n      // if only BH1 is, 1, if BH1 isn't, 0 regardless of BH2).\r\n      // eslint-disable-next-line no-nested-ternary\r\n      const current = charged[0] ? (charged[1] ? 2 : 1) : 0;\r\n      // Get the list of phase bounds.\r\n      const phaseBounds = phaseBoundList[current];\r\n      // Compute time until some phase reaches its bound.\r\n      const minTime = current > 0 ? Math.min(phaseBounds[0] - phases[0], phaseBounds[1] - phases[1])\r\n        : phaseBounds[0] - phases[0];\r\n      if (current === 2) {\r\n        // Check if there was enough time before this activation to pause.\r\n        if (inactiveTime >= BlackHoles.ACCELERATION_TIME) {\r\n          return totalTime - BlackHoles.ACCELERATION_TIME;\r\n        }\r\n        // Not enough time, reset inactive time to 0.\r\n        inactiveTime = 0;\r\n      } else {\r\n        // BH2 is inactive, add to inactive time.\r\n        inactiveTime += minTime;\r\n      }\r\n      // Add to total time in any case.\r\n      totalTime += minTime;\r\n      // If BH1 is active we should update BH2.\r\n      if (current > 0) {\r\n        phases[1] += minTime;\r\n        if (phases[1] >= phaseBounds[1]) {\r\n          charged[1] = !charged[1];\r\n          phases[1] -= phaseBounds[1];\r\n        }\r\n      }\r\n      // Update BH1 no matter what.\r\n      phases[0] += minTime;\r\n      if (phases[0] >= phaseBounds[0]) {\r\n        charged[0] = !charged[0];\r\n        phases[0] -= phaseBounds[0];\r\n      }\r\n    }\r\n    // We didn't activate so we return null.\r\n    return null;\r\n  },\r\n\r\n  /**\r\n   * Takes amount of real time.\r\n   * Returns 2-item array:\r\n   * [will BH be paused in the given amount of real time, real time until pause if so].\r\n   */\r\n  autoPauseData(realTime) {\r\n    // This can be called when determining offline time if the black holes are already paused.\r\n    // In that case we don't need to pause them (need to pause = false), but they're already paused (0 time).\r\n    // This saves us some computation.\r\n    if (this.arePaused) return [false, 0];\r\n    if (player.blackHoleAutoPauseMode === BLACK_HOLE_PAUSE_MODE.NO_PAUSE) {\r\n      return [false, realTime];\r\n    }\r\n    const timeLeft = this.timeToNextPause(player.blackHoleAutoPauseMode);\r\n    // Cases in which we don't pause in the given amount of real time:\r\n    // null = no pause, (timeLeft < 1e-9) = we auto-paused and there was maybe rounding error,\r\n    // now the player's unpaused at this exact point (so we shouldn't pause again),\r\n    // (timeLeft > realTime) = we will pause but it'll take longer than the given time.\r\n    if (timeLeft === null || timeLeft < 1e-9 || timeLeft > realTime) {\r\n      return [false, realTime];\r\n    }\r\n    return [true, timeLeft];\r\n  }\r\n};\r\n"]},"metadata":{},"sourceType":"module"}