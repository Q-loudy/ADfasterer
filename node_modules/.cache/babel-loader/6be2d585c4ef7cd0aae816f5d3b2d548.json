{"ast":null,"code":"import \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport FailableEcText from \"./FailableEcText\";\nimport PrimaryButton from \"@/components/PrimaryButton\";\nexport default {\n  name: \"HeaderChallengeDisplay\",\n  components: {\n    FailableEcText,\n    PrimaryButton\n  },\n\n  data() {\n    return {\n      activityTokens: [],\n      infinityUnlocked: false,\n      showExit: false,\n      exitText: \"\",\n      resetCelestial: false,\n      inPelle: false\n    };\n  },\n\n  computed: {\n    parts() {\n      // We need activityToken for NC/IC/EC because plain check of WhateverChallenge.isRunning\n      // won't trigger display update if we, say, switch from one challenge to another\n      function celestialReality(celestial, name, tab) {\n        return {\n          name: () => `${name} Reality`,\n          isActive: token => token,\n          activityToken: () => celestial.isRunning,\n          tabName: () => tab\n        };\n      }\n\n      return [celestialReality(Teresa, \"Teresa's\", \"teresa\"), celestialReality(Effarig, \"Effarig's\", \"effarig\"), celestialReality(Enslaved, \"The Nameless Ones'\", \"enslaved\"), celestialReality(V, \"V's\", \"v\"), celestialReality(Ra, \"Ra's\", \"ra\"), celestialReality(Laitela, \"Lai'tela's\", \"laitela\"), {\n        name: () => \"Time Dilation\",\n        isActive: token => token,\n        activityToken: () => player.dilation.active\n      }, {\n        name: token => `Eternity Challenge ${token}`,\n        isActive: token => token > 0,\n        activityToken: () => player.challenge.eternity.current\n      }, {\n        name: token => `Infinity Challenge ${token}`,\n        isActive: token => token > 0,\n        activityToken: () => player.challenge.infinity.current\n      }, {\n        name: token => `${NormalChallenge(token).config.name} Challenge`,\n        isActive: token => token > 0,\n        activityToken: () => player.challenge.normal.current\n      }];\n    },\n\n    activeChallengeNames() {\n      const names = [];\n\n      for (let i = 0; i < this.activityTokens.length; i++) {\n        const token = this.activityTokens[i];\n        const part = this.parts[i];\n        if (!part.isActive(token)) continue;\n\n        if (part.name(token).includes(\"Eternity Challenge\")) {\n          const currEC = player.challenge.eternity.current;\n          const nextCompletion = EternityChallenge(currEC).completions + 1;\n          let completionText = \"\";\n\n          if (Enslaved.isRunning && currEC === 1) {\n            completionText = `(${formatInt(nextCompletion)}/???)`;\n          } else if (nextCompletion === 6) {\n            completionText = `(already completed)`;\n          } else {\n            completionText = `(${formatInt(nextCompletion)}/${formatInt(5)})`;\n          }\n\n          names.push(`${part.name(token)} ${completionText}`);\n        } else {\n          names.push(part.name(token));\n        }\n      }\n\n      return names;\n    },\n\n    isVisible() {\n      return this.infinityUnlocked || this.activeChallengeNames.length > 0;\n    },\n\n    isInFailableEC() {\n      return this.activeChallengeNames.some(str => str.match(/Eternity Challenge (4|12)/g));\n    },\n\n    challengeDisplay() {\n      if (this.inPelle && this.activeChallengeNames.length > 0) {\n        return `${this.activeChallengeNames.join(\" + \")} in a Doomed Reality. Good luck.`;\n      }\n\n      if (this.inPelle) return \"a Doomed Reality. Good luck.\";\n\n      if (this.activeChallengeNames.length === 0) {\n        return \"the Antimatter Universe (no active challenges)\";\n      }\n\n      return this.activeChallengeNames.join(\" + \");\n    }\n\n  },\n  methods: {\n    update() {\n      this.infinityUnlocked = PlayerProgress.infinityUnlocked();\n      this.activityTokens = this.parts.map(part => part.activityToken()); // Dilation in Pelle can't be left once entered, but we still want to allow leaving more nested challenges\n\n      this.showExit = this.inPelle && player.dilation.active ? this.activeChallengeNames.length > 1 : this.activeChallengeNames.length !== 0;\n      this.exitText = this.exitDisplay();\n      this.resetCelestial = player.options.retryCelestial;\n      this.inPelle = Pelle.isDoomed;\n    },\n\n    // Process exit requests from the inside out; Challenges first, then dilation, then Celestial Reality. If the\n    // relevant option is toggled, we pass a bunch of information over to a modal - otherwise we immediately exit\n    exitButtonClicked() {\n      let names, clickFn;\n      const isEC = Player.anyChallenge instanceof EternityChallengeState; // Dilation and ECs can't be exited independently and we have a special dilation-exit modal, so we have\n      // to treat that particular case differently. The dilation modal itself will account for EC state\n\n      if (player.dilation.active && (!Player.isInAnyChallenge || isEC)) {\n        if (player.options.confirmations.dilation) Modal.exitDilation.show();else startDilatedEternityRequest();\n        return;\n      }\n\n      if (Player.isInAnyChallenge) {\n        // Regex replacement is used to remove the \"(X/Y)\" which appears after ECs. The ternary statement is there\n        // because this path gets called for NCs, ICs, and ECs\n        const toExit = this.activeChallengeNames[this.activeChallengeNames.length - 1].replace(/(?:[\\0-\\/:-@\\[-\\^`\\{-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+\\((?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*\\)/, \"\");\n        names = {\n          chall: toExit,\n          normal: isEC ? \"Eternity\" : \"Infinity\"\n        };\n\n        clickFn = () => {\n          const oldChall = Player.anyChallenge;\n          Player.anyChallenge.exit(false);\n          if (player.options.retryChallenge) oldChall.requestStart();\n        };\n      } else {\n        names = {\n          chall: this.activeChallengeNames[0],\n          normal: \"Reality\"\n        };\n\n        clickFn = () => beginProcessReality(getRealityProps(true));\n      }\n\n      if (player.options.confirmations.exitChallenge) {\n        Modal.exitChallenge.show({\n          challengeName: names.chall,\n          normalName: names.normal,\n          hasHigherLayers: this.inPelle || this.activeChallengeNames.length > 1,\n          exitFn: clickFn\n        });\n      } else {\n        clickFn();\n      }\n    },\n\n    // Bring the player to the tab related to the innermost challenge\n    textClicked() {\n      if (this.activeChallengeNames.length === 0) return; // Iterating back-to-front and breaking ensures we get the innermost restriction\n\n      let fullName = \"\",\n          celestial = \"\";\n\n      for (let i = this.activityTokens.length - 1; i >= 0; i--) {\n        var _part$tabName;\n\n        const token = this.activityTokens[i];\n        const part = this.parts[i];\n        if (!part.isActive(token)) continue;\n        fullName = part.name(token);\n        celestial = (_part$tabName = part.tabName) === null || _part$tabName === void 0 ? void 0 : _part$tabName.call(part);\n        break;\n      } // Normal challenges are matched with an end-of-string metacharacter\n\n\n      if (fullName.match(\" Challenge$\")) Tab.challenges.normal.show(true);else if (fullName.match(\"Infinity Challenge\")) Tab.challenges.infinity.show(true);else if (fullName.match(\"Eternity Challenge\")) Tab.challenges.eternity.show(true);else if (player.dilation.active) Tab.eternity.dilation.show(true);else Tab.celestials[celestial].show(true);\n    },\n\n    exitDisplay() {\n      if (Player.isInAnyChallenge) return player.options.retryChallenge ? \"Retry Challenge\" : \"Exit Challenge\";\n      if (player.dilation.active) return \"Exit Dilation\";\n      if (this.resetCelestial) return \"Restart Reality\";\n      return \"Exit Reality\";\n    },\n\n    textClassObject() {\n      return {\n        \"l-challenge-display\": true,\n        \"l-challenge-display--clickable\": this.activeChallengeNames.length !== 0\n      };\n    }\n\n  }\n};","map":{"version":3,"sources":["HeaderChallengeDisplay.vue"],"names":[],"mappings":"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","sourcesContent":["<script>\r\nimport FailableEcText from \"./FailableEcText\";\r\nimport PrimaryButton from \"@/components/PrimaryButton\";\r\n\r\nexport default {\r\n  name: \"HeaderChallengeDisplay\",\r\n  components: {\r\n    FailableEcText,\r\n    PrimaryButton\r\n  },\r\n  data() {\r\n    return {\r\n      activityTokens: [],\r\n      infinityUnlocked: false,\r\n      showExit: false,\r\n      exitText: \"\",\r\n      resetCelestial: false,\r\n      inPelle: false,\r\n    };\r\n  },\r\n  computed: {\r\n    parts() {\r\n      // We need activityToken for NC/IC/EC because plain check of WhateverChallenge.isRunning\r\n      // won't trigger display update if we, say, switch from one challenge to another\r\n      function celestialReality(celestial, name, tab) {\r\n        return {\r\n          name: () => `${name} Reality`,\r\n          isActive: token => token,\r\n          activityToken: () => celestial.isRunning,\r\n          tabName: () => tab,\r\n        };\r\n      }\r\n      return [\r\n        celestialReality(Teresa, \"Teresa's\", \"teresa\"),\r\n        celestialReality(Effarig, \"Effarig's\", \"effarig\"),\r\n        celestialReality(Enslaved, \"The Nameless Ones'\", \"enslaved\"),\r\n        celestialReality(V, \"V's\", \"v\"),\r\n        celestialReality(Ra, \"Ra's\", \"ra\"),\r\n        celestialReality(Laitela, \"Lai'tela's\", \"laitela\"),\r\n        {\r\n          name: () => \"Time Dilation\",\r\n          isActive: token => token,\r\n          activityToken: () => player.dilation.active\r\n        },\r\n        {\r\n          name: token => `Eternity Challenge ${token}`,\r\n          isActive: token => token > 0,\r\n          activityToken: () => player.challenge.eternity.current\r\n        },\r\n        {\r\n          name: token => `Infinity Challenge ${token}`,\r\n          isActive: token => token > 0,\r\n          activityToken: () => player.challenge.infinity.current\r\n        },\r\n        {\r\n          name: token => `${NormalChallenge(token).config.name} Challenge`,\r\n          isActive: token => token > 0,\r\n          activityToken: () => player.challenge.normal.current\r\n        },\r\n      ];\r\n    },\r\n    activeChallengeNames() {\r\n      const names = [];\r\n      for (let i = 0; i < this.activityTokens.length; i++) {\r\n        const token = this.activityTokens[i];\r\n        const part = this.parts[i];\r\n        if (!part.isActive(token)) continue;\r\n        if (part.name(token).includes(\"Eternity Challenge\")) {\r\n          const currEC = player.challenge.eternity.current;\r\n          const nextCompletion = EternityChallenge(currEC).completions + 1;\r\n          let completionText = \"\";\r\n          if (Enslaved.isRunning && currEC === 1) {\r\n            completionText = `(${formatInt(nextCompletion)}/???)`;\r\n          } else if (nextCompletion === 6) {\r\n            completionText = `(already completed)`;\r\n          } else {\r\n            completionText = `(${formatInt(nextCompletion)}/${formatInt(5)})`;\r\n          }\r\n          names.push(`${part.name(token)} ${completionText}`);\r\n        } else {\r\n          names.push(part.name(token));\r\n        }\r\n      }\r\n      return names;\r\n    },\r\n    isVisible() {\r\n      return this.infinityUnlocked || this.activeChallengeNames.length > 0;\r\n    },\r\n    isInFailableEC() {\r\n      return this.activeChallengeNames.some(str => str.match(/Eternity Challenge (4|12)/gu));\r\n    },\r\n    challengeDisplay() {\r\n      if (this.inPelle && this.activeChallengeNames.length > 0) {\r\n        return `${this.activeChallengeNames.join(\" + \")} in a Doomed Reality. Good luck.`;\r\n      }\r\n      if (this.inPelle) return \"a Doomed Reality. Good luck.\";\r\n      if (this.activeChallengeNames.length === 0) {\r\n        return \"the Antimatter Universe (no active challenges)\";\r\n      }\r\n      return this.activeChallengeNames.join(\" + \");\r\n    },\r\n  },\r\n  methods: {\r\n    update() {\r\n      this.infinityUnlocked = PlayerProgress.infinityUnlocked();\r\n      this.activityTokens = this.parts.map(part => part.activityToken());\r\n      // Dilation in Pelle can't be left once entered, but we still want to allow leaving more nested challenges\r\n      this.showExit = this.inPelle && player.dilation.active\r\n        ? this.activeChallengeNames.length > 1\r\n        : this.activeChallengeNames.length !== 0;\r\n      this.exitText = this.exitDisplay();\r\n      this.resetCelestial = player.options.retryCelestial;\r\n      this.inPelle = Pelle.isDoomed;\r\n    },\r\n    // Process exit requests from the inside out; Challenges first, then dilation, then Celestial Reality. If the\r\n    // relevant option is toggled, we pass a bunch of information over to a modal - otherwise we immediately exit\r\n    exitButtonClicked() {\r\n      let names, clickFn;\r\n      const isEC = Player.anyChallenge instanceof EternityChallengeState;\r\n\r\n      // Dilation and ECs can't be exited independently and we have a special dilation-exit modal, so we have\r\n      // to treat that particular case differently. The dilation modal itself will account for EC state\r\n      if (player.dilation.active && (!Player.isInAnyChallenge || isEC)) {\r\n        if (player.options.confirmations.dilation) Modal.exitDilation.show();\r\n        else startDilatedEternityRequest();\r\n        return;\r\n      }\r\n\r\n      if (Player.isInAnyChallenge) {\r\n        // Regex replacement is used to remove the \"(X/Y)\" which appears after ECs. The ternary statement is there\r\n        // because this path gets called for NCs, ICs, and ECs\r\n        const toExit = this.activeChallengeNames[this.activeChallengeNames.length - 1].replace(/\\W+\\(.*\\)/u, \"\");\r\n        names = { chall: toExit, normal: isEC ? \"Eternity\" : \"Infinity\" };\r\n        clickFn = () => {\r\n          const oldChall = Player.anyChallenge;\r\n          Player.anyChallenge.exit(false);\r\n          if (player.options.retryChallenge) oldChall.requestStart();\r\n        };\r\n      } else {\r\n        names = { chall: this.activeChallengeNames[0], normal: \"Reality\" };\r\n        clickFn = () => beginProcessReality(getRealityProps(true));\r\n      }\r\n\r\n      if (player.options.confirmations.exitChallenge) {\r\n        Modal.exitChallenge.show(\r\n          {\r\n            challengeName: names.chall,\r\n            normalName: names.normal,\r\n            hasHigherLayers: this.inPelle || this.activeChallengeNames.length > 1,\r\n            exitFn: clickFn\r\n          }\r\n        );\r\n      } else {\r\n        clickFn();\r\n      }\r\n    },\r\n    // Bring the player to the tab related to the innermost challenge\r\n    textClicked() {\r\n      if (this.activeChallengeNames.length === 0) return;\r\n\r\n      // Iterating back-to-front and breaking ensures we get the innermost restriction\r\n      let fullName = \"\", celestial = \"\";\r\n      for (let i = this.activityTokens.length - 1; i >= 0; i--) {\r\n        const token = this.activityTokens[i];\r\n        const part = this.parts[i];\r\n        if (!part.isActive(token)) continue;\r\n        fullName = part.name(token);\r\n        celestial = part.tabName?.();\r\n        break;\r\n      }\r\n\r\n      // Normal challenges are matched with an end-of-string metacharacter\r\n      if (fullName.match(\" Challenge$\")) Tab.challenges.normal.show(true);\r\n      else if (fullName.match(\"Infinity Challenge\")) Tab.challenges.infinity.show(true);\r\n      else if (fullName.match(\"Eternity Challenge\")) Tab.challenges.eternity.show(true);\r\n      else if (player.dilation.active) Tab.eternity.dilation.show(true);\r\n      else Tab.celestials[celestial].show(true);\r\n    },\r\n    exitDisplay() {\r\n      if (Player.isInAnyChallenge) return player.options.retryChallenge ? \"Retry Challenge\" : \"Exit Challenge\";\r\n      if (player.dilation.active) return \"Exit Dilation\";\r\n      if (this.resetCelestial) return \"Restart Reality\";\r\n      return \"Exit Reality\";\r\n    },\r\n    textClassObject() {\r\n      return {\r\n        \"l-challenge-display\": true,\r\n        \"l-challenge-display--clickable\": this.activeChallengeNames.length !== 0,\r\n      };\r\n    }\r\n  },\r\n};\r\n</script>\r\n\r\n<template>\r\n  <div\r\n    v-if=\"isVisible\"\r\n    class=\"l-game-header__challenge-text\"\r\n  >\r\n    <span\r\n      :class=\"textClassObject()\"\r\n      @click=\"textClicked\"\r\n    >\r\n      You are currently in {{ challengeDisplay }}\r\n    </span>\r\n    <FailableEcText v-if=\"isInFailableEC\" />\r\n    <span class=\"l-padding-line\" />\r\n    <PrimaryButton\r\n      v-if=\"showExit\"\r\n      @click=\"exitButtonClicked\"\r\n    >\r\n      {{ exitText }}\r\n    </PrimaryButton>\r\n  </div>\r\n</template>\r\n\r\n<style scoped>\r\n.l-game-header__challenge-text {\r\n  display: flex;\r\n  height: 2rem;\r\n  top: 50%;\r\n  justify-content: center;\r\n  align-items: center;\r\n  font-size: 1.2rem;\r\n  font-weight: bold;\r\n  color: var(--color-text);\r\n  margin: 0.5rem;\r\n}\r\n\r\n.l-challenge-display {\r\n  padding: 0.5rem;\r\n  cursor: default;\r\n}\r\n\r\n.l-challenge-display--clickable {\r\n  cursor: pointer;\r\n  user-select: none;\r\n}\r\n\r\n.l-challenge-display--clickable:hover {\r\n  text-decoration: underline;\r\n}\r\n\r\n.l-padding-line {\r\n  padding: 0.3rem;\r\n}\r\n</style>\r\n"],"sourceRoot":"src/components/ui-modes"},"metadata":{},"sourceType":"module"}