{"ast":null,"code":"import { DC } from \"../constants\";\nimport { UpgradeableAutobuyerState } from \"./autobuyer\";\nexport class AntimatterDimensionAutobuyerState extends UpgradeableAutobuyerState {\n  get tier() {\n    return this.id;\n  }\n\n  get name() {\n    return AntimatterDimension(this.tier).shortDisplayName;\n  }\n\n  get fullName() {\n    return `${this.name} Antimatter Dimension`;\n  }\n\n  get data() {\n    return player.auto.antimatterDims.all[this.tier - 1];\n  }\n\n  get baseInterval() {\n    return Player.defaultStart.auto.antimatterDims.all[this.tier - 1].interval;\n  }\n\n  get isUnlocked() {\n    if (Pelle.isDisabled(`antimatterDimAutobuyer${this.tier}`)) return false;\n    return this.data.isBought || this.canBeUpgraded;\n  }\n\n  get isBought() {\n    return this.data.isBought;\n  }\n\n  get antimatterCost() {\n    return DC.E10.pow(this.tier - 1).times(DC.E40);\n  }\n\n  get canBeBought() {\n    return !Pelle.isDisabled(`antimatterDimAutobuyer${this.tier}`);\n  }\n\n  get canBeUpgraded() {\n    return NormalChallenge(this.tier).isCompleted;\n  }\n\n  get disabledByContinuum() {\n    return Laitela.continuumActive;\n  }\n\n  get bulk() {\n    // Use 1e100 to avoid issues with Infinity.\n    return this.hasUnlimitedBulk ? 1e100 : Math.clampMax(this.data.bulk, this.bulkCap);\n  }\n\n  get hasUnlimitedBulk() {\n    return Achievement(61).isUnlocked;\n  }\n\n  get bulkCap() {\n    return 512;\n  }\n\n  get hasMaxedBulk() {\n    return this.bulk >= this.bulkCap;\n  }\n\n  get mode() {\n    return this.data.mode;\n  }\n\n  set mode(value) {\n    this.data.mode = value;\n  }\n\n  get canUnlockSlowVersion() {\n    return player.records.thisEternity.maxAM.gte(this.antimatterCost);\n  }\n\n  toggleMode() {\n    this.mode = [AUTOBUYER_MODE.BUY_SINGLE, AUTOBUYER_MODE.BUY_10].nextSibling(this.mode);\n  } // We don't want to directly call super.canTick here because the game logic works really weirdly in terms of\n  // interactions between individual and group AD autobuyers. The UI can change and certain settings can become\n  // unmodifiable in some conditions. This is basically the lowest-effort solution to support legacy behavior\n  // because the proper alternatve of an AD autobuyer refactor to untangle this mess is likely not worth the effort\n\n\n  get canTick() {\n    // AD autobuyer-specific logic; if the UI is collapsed then we are unable to toggle groupSetting.\n    // In terms of UX for this case it makes the most sense to ignore it and pretend it's true\n    const settingConfig = player.auto.antimatterDims;\n    const individualSetting = settingConfig.all[this.tier - 1];\n    const groupSetting = settingConfig.isActive;\n    const thisSetting = individualSetting && (Autobuyer.antimatterDimension.collapseDisplay ? groupSetting : true); // General availability\n\n    const dim = AntimatterDimension(this.tier);\n    const hasAutobuyer = dim.isAvailableForPurchase && dim.isAffordable; // From IntervaledAutobuyerState.canTick\n\n    const intervalTick = this.timeSinceLastTick >= this.interval; // From AutobuyerState.canTick (ignores this.constructor.isActive because that's accounted for in thisSetting)\n\n    const autoTick = player.auto.autobuyersOn && this.isActive && (this.isUnlocked || this.isBought);\n    return thisSetting && hasAutobuyer && intervalTick && autoTick;\n  }\n\n  tick() {\n    super.tick();\n    const tier = this.tier;\n\n    switch (this.mode) {\n      case AUTOBUYER_MODE.BUY_SINGLE:\n        buyOneDimension(tier);\n        break;\n\n      case AUTOBUYER_MODE.BUY_10:\n        buyMaxDimension(tier, this.bulk);\n        break;\n    }\n  }\n\n  upgradeBulk() {\n    if (this.hasMaxedBulk) return;\n    if (!Currency.infinityPoints.purchase(this.cost)) return;\n    this.data.bulk = Math.clampMax(this.bulk * 2, this.bulkCap);\n    this.data.cost = Math.ceil(2.4 * this.cost);\n    Achievement(61).tryUnlock();\n    GameUI.update();\n  }\n\n  purchase() {\n    if (!this.canUnlockSlowVersion) return;\n    this.data.isBought = true;\n  }\n\n  get resetTickOn() {\n    return Perk.antimatterNoReset.canBeApplied ? PRESTIGE_EVENT.ANTIMATTER_GALAXY : PRESTIGE_EVENT.DIMENSION_BOOST;\n  }\n\n  reset() {\n    super.reset();\n    if (EternityMilestone.keepAutobuyers.isReached || PelleUpgrade.keepAutobuyers.canBeApplied) return;\n    this.data.isUnlocked = false;\n    this.data.isBought = false;\n    this.data.bulk = 1;\n    TabNotification.newAutobuyer.clearTrigger();\n  }\n\n  static get entryCount() {\n    return 8;\n  }\n\n  static get autobuyerGroupName() {\n    return \"Antimatter Dimension\";\n  } // These are toggled on and off from the group autobuyer checkbox\n\n\n  static get isActive() {\n    return player.auto.antimatterDims.isActive;\n  }\n\n  static set isActive(value) {\n    player.auto.antimatterDims.isActive = value;\n  }\n\n  static createAccessor() {\n    const accessor = super.createAccessor();\n    Object.defineProperties(accessor, {\n      allBought: {\n        get: () => accessor.zeroIndexed.every(x => x.isBought)\n      },\n      // We can get away with this since allUnlimitedBulk is the same for all AD autos\n      allUnlimitedBulk: {\n        get: () => accessor.zeroIndexed[0].hasUnlimitedBulk\n      },\n      bulkCap: {\n        get: () => accessor.zeroIndexed[0].bulkCap\n      },\n      collapseDisplay: {\n        get: () => accessor.allMaxedInterval && accessor.allUnlocked && accessor.allUnlimitedBulk\n      }\n    });\n    return accessor;\n  }\n\n}","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/autobuyers/antimatter-dimension-autobuyer.js"],"names":["DC","UpgradeableAutobuyerState","AntimatterDimensionAutobuyerState","tier","id","name","AntimatterDimension","shortDisplayName","fullName","data","player","auto","antimatterDims","all","baseInterval","Player","defaultStart","interval","isUnlocked","Pelle","isDisabled","isBought","canBeUpgraded","antimatterCost","E10","pow","times","E40","canBeBought","NormalChallenge","isCompleted","disabledByContinuum","Laitela","continuumActive","bulk","hasUnlimitedBulk","Math","clampMax","bulkCap","Achievement","hasMaxedBulk","mode","value","canUnlockSlowVersion","records","thisEternity","maxAM","gte","toggleMode","AUTOBUYER_MODE","BUY_SINGLE","BUY_10","nextSibling","canTick","settingConfig","individualSetting","groupSetting","isActive","thisSetting","Autobuyer","antimatterDimension","collapseDisplay","dim","hasAutobuyer","isAvailableForPurchase","isAffordable","intervalTick","timeSinceLastTick","autoTick","autobuyersOn","tick","buyOneDimension","buyMaxDimension","upgradeBulk","Currency","infinityPoints","purchase","cost","ceil","tryUnlock","GameUI","update","resetTickOn","Perk","antimatterNoReset","canBeApplied","PRESTIGE_EVENT","ANTIMATTER_GALAXY","DIMENSION_BOOST","reset","EternityMilestone","keepAutobuyers","isReached","PelleUpgrade","TabNotification","newAutobuyer","clearTrigger","entryCount","autobuyerGroupName","createAccessor","accessor","Object","defineProperties","allBought","get","zeroIndexed","every","x","allUnlimitedBulk","allMaxedInterval","allUnlocked"],"mappings":"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","sourcesContent":["import { DC } from \"../constants\";\r\n\r\nimport { UpgradeableAutobuyerState } from \"./autobuyer\";\r\n\r\nexport class AntimatterDimensionAutobuyerState extends UpgradeableAutobuyerState {\r\n  get tier() {\r\n    return this.id;\r\n  }\r\n\r\n  get name() {\r\n    return AntimatterDimension(this.tier).shortDisplayName;\r\n  }\r\n\r\n  get fullName() {\r\n    return `${this.name} Antimatter Dimension`;\r\n  }\r\n\r\n  get data() {\r\n    return player.auto.antimatterDims.all[this.tier - 1];\r\n  }\r\n\r\n  get baseInterval() {\r\n    return Player.defaultStart.auto.antimatterDims.all[this.tier - 1].interval;\r\n  }\r\n\r\n  get isUnlocked() {\r\n    if (Pelle.isDisabled(`antimatterDimAutobuyer${this.tier}`)) return false;\r\n    return this.data.isBought || this.canBeUpgraded;\r\n  }\r\n\r\n  get isBought() {\r\n    return this.data.isBought;\r\n  }\r\n\r\n  get antimatterCost() {\r\n    return DC.E10.pow(this.tier - 1).times(DC.E40);\r\n  }\r\n\r\n  get canBeBought() {\r\n    return !Pelle.isDisabled(`antimatterDimAutobuyer${this.tier}`);\r\n  }\r\n\r\n  get canBeUpgraded() {\r\n    return NormalChallenge(this.tier).isCompleted;\r\n  }\r\n\r\n  get disabledByContinuum() {\r\n    return Laitela.continuumActive;\r\n  }\r\n\r\n  get bulk() {\r\n    // Use 1e100 to avoid issues with Infinity.\r\n    return this.hasUnlimitedBulk ? 1e100 : Math.clampMax(this.data.bulk, this.bulkCap);\r\n  }\r\n\r\n  get hasUnlimitedBulk() {\r\n    return Achievement(61).isUnlocked;\r\n  }\r\n\r\n  get bulkCap() {\r\n    return 512;\r\n  }\r\n\r\n  get hasMaxedBulk() {\r\n    return this.bulk >= this.bulkCap;\r\n  }\r\n\r\n  get mode() {\r\n    return this.data.mode;\r\n  }\r\n\r\n  set mode(value) {\r\n    this.data.mode = value;\r\n  }\r\n\r\n  get canUnlockSlowVersion() {\r\n    return player.records.thisEternity.maxAM.gte(this.antimatterCost);\r\n  }\r\n\r\n  toggleMode() {\r\n    this.mode = [\r\n      AUTOBUYER_MODE.BUY_SINGLE,\r\n      AUTOBUYER_MODE.BUY_10\r\n    ]\r\n      .nextSibling(this.mode);\r\n  }\r\n\r\n  // We don't want to directly call super.canTick here because the game logic works really weirdly in terms of\r\n  // interactions between individual and group AD autobuyers. The UI can change and certain settings can become\r\n  // unmodifiable in some conditions. This is basically the lowest-effort solution to support legacy behavior\r\n  // because the proper alternatve of an AD autobuyer refactor to untangle this mess is likely not worth the effort\r\n  get canTick() {\r\n    // AD autobuyer-specific logic; if the UI is collapsed then we are unable to toggle groupSetting.\r\n    // In terms of UX for this case it makes the most sense to ignore it and pretend it's true\r\n    const settingConfig = player.auto.antimatterDims;\r\n    const individualSetting = settingConfig.all[this.tier - 1];\r\n    const groupSetting = settingConfig.isActive;\r\n    const thisSetting = individualSetting && (Autobuyer.antimatterDimension.collapseDisplay ? groupSetting : true);\r\n\r\n    // General availability\r\n    const dim = AntimatterDimension(this.tier);\r\n    const hasAutobuyer = dim.isAvailableForPurchase && dim.isAffordable;\r\n\r\n    // From IntervaledAutobuyerState.canTick\r\n    const intervalTick = this.timeSinceLastTick >= this.interval;\r\n\r\n    // From AutobuyerState.canTick (ignores this.constructor.isActive because that's accounted for in thisSetting)\r\n    const autoTick = player.auto.autobuyersOn && this.isActive && (this.isUnlocked || this.isBought);\r\n\r\n    return thisSetting && hasAutobuyer && intervalTick && autoTick;\r\n  }\r\n\r\n  tick() {\r\n    super.tick();\r\n    const tier = this.tier;\r\n    switch (this.mode) {\r\n      case AUTOBUYER_MODE.BUY_SINGLE:\r\n        buyOneDimension(tier);\r\n        break;\r\n      case AUTOBUYER_MODE.BUY_10:\r\n        buyMaxDimension(tier, this.bulk);\r\n        break;\r\n    }\r\n  }\r\n\r\n  upgradeBulk() {\r\n    if (this.hasMaxedBulk) return;\r\n    if (!Currency.infinityPoints.purchase(this.cost)) return;\r\n    this.data.bulk = Math.clampMax(this.bulk * 2, this.bulkCap);\r\n    this.data.cost = Math.ceil(2.4 * this.cost);\r\n    Achievement(61).tryUnlock();\r\n    GameUI.update();\r\n  }\r\n\r\n  purchase() {\r\n    if (!this.canUnlockSlowVersion) return;\r\n    this.data.isBought = true;\r\n  }\r\n\r\n  get resetTickOn() {\r\n    return Perk.antimatterNoReset.canBeApplied ? PRESTIGE_EVENT.ANTIMATTER_GALAXY : PRESTIGE_EVENT.DIMENSION_BOOST;\r\n  }\r\n\r\n  reset() {\r\n    super.reset();\r\n    if (EternityMilestone.keepAutobuyers.isReached || PelleUpgrade.keepAutobuyers.canBeApplied) return;\r\n    this.data.isUnlocked = false;\r\n    this.data.isBought = false;\r\n    this.data.bulk = 1;\r\n    TabNotification.newAutobuyer.clearTrigger();\r\n  }\r\n\r\n  static get entryCount() { return 8; }\r\n  static get autobuyerGroupName() { return \"Antimatter Dimension\"; }\r\n\r\n  // These are toggled on and off from the group autobuyer checkbox\r\n  static get isActive() { return player.auto.antimatterDims.isActive; }\r\n  static set isActive(value) { player.auto.antimatterDims.isActive = value; }\r\n\r\n  static createAccessor() {\r\n    const accessor = super.createAccessor();\r\n    Object.defineProperties(accessor, {\r\n      allBought: { get: () => accessor.zeroIndexed.every(x => x.isBought) },\r\n      // We can get away with this since allUnlimitedBulk is the same for all AD autos\r\n      allUnlimitedBulk: { get: () => accessor.zeroIndexed[0].hasUnlimitedBulk },\r\n      bulkCap: { get: () => accessor.zeroIndexed[0].bulkCap },\r\n      collapseDisplay: { get: () => accessor.allMaxedInterval && accessor.allUnlocked && accessor.allUnlimitedBulk }\r\n    });\r\n    return accessor;\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}