{"ast":null,"code":"import \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport { GameMechanicState } from \"../../game-mechanics\";\n/**\r\n * @abstract\r\n */\n\nclass AlchemyResourceState extends GameMechanicState {\n  constructor(config) {\n    super(config);\n    this.ema = new ExponentialMovingAverage(0.01, 10, 100, 0.01);\n    this._before = 0;\n  }\n\n  get name() {\n    return this.config.name;\n  }\n\n  get symbol() {\n    return this.config.symbol;\n  }\n\n  get description() {\n    return this.config.description;\n  }\n\n  get isBaseResource() {\n    return this.config.isBaseResource === true;\n  }\n\n  get data() {\n    return player.celestials.ra.alchemy[this.id];\n  }\n\n  get amount() {\n    return this.data.amount;\n  }\n\n  set amount(value) {\n    this.data.amount = value;\n  }\n\n  get before() {\n    return this._before;\n  }\n\n  set before(value) {\n    this._before = value;\n  }\n\n  get flow() {\n    return this.ema.average;\n  }\n\n  get fillFraction() {\n    return Math.clamp(this.amount / this.cap, 0, 1);\n  }\n\n  get unlockedWith() {\n    return Ra.pets.effarig;\n  }\n\n  get unlockedAt() {\n    return this.config.unlockedAt;\n  }\n\n  get isUnlocked() {\n    return this.unlockedWith.level >= this.unlockedAt;\n  }\n\n  get lockText() {\n    return `${this.unlockedWith.name} Level ${formatInt(this.unlockedAt)}`;\n  }\n\n  get isCustomEffect() {\n    return true;\n  }\n\n  get effectValue() {\n    // Disable Exponential alchemy effect in V reality.\n    if (V.isRunning && this.config.id === 14) return 0;\n    return this.config.effect(Pelle.isDisabled(\"alchemy\") ? 0 : this.amount);\n  }\n\n  get reaction() {\n    return AlchemyReactions.all[this.id];\n  }\n  /**\r\n   * @abstract\r\n   */\n\n\n  get cap() {\n    throw new NotImplementedError();\n  }\n\n  get capped() {\n    return this.amount >= this.cap;\n  }\n\n}\n\nclass BasicAlchemyResourceState extends AlchemyResourceState {\n  constructor(config) {\n    super(config); // The names are capitalized, so we need to convert them to lower case\n    // in order to access highestRefinementValue values which are not capitalized.\n\n    this._name = config.name.toLowerCase();\n  }\n\n  get highestRefinementValue() {\n    return player.celestials.ra.highestRefinementValue[this._name];\n  }\n\n  set highestRefinementValue(value) {\n    player.celestials.ra.highestRefinementValue[this._name] = Math.max(this.highestRefinementValue, value);\n  }\n\n  get cap() {\n    return Math.clampMax(Ra.alchemyResourceCap, this.highestRefinementValue);\n  }\n\n}\n\nclass AdvancedAlchemyResourceState extends AlchemyResourceState {\n  get cap() {\n    const reagentCaps = this.reaction.reagents.map(x => x.resource.cap);\n    return Math.min(...reagentCaps);\n  }\n\n}\n\nclass AlchemyReaction {\n  constructor(product, reagents) {\n    this._product = product;\n    this._reagents = reagents;\n  }\n\n  get product() {\n    return this._product;\n  }\n\n  get reagents() {\n    return this._reagents;\n  } // Returns a percentage of a reaction that can be done, accounting for limiting reagents.  This normally caps at\n  // 100%, but the reaction will be forced to occur at higher than 100% if there is significantly more reagent than\n  // product. This allows resources to be created quickly when its reaction is initially turned on with saved reagents.\n\n\n  get reactionYield() {\n    if (!this._product.isUnlocked || this._reagents.some(r => !r.resource.isUnlocked)) return 0;\n    const forcingFactor = (this._reagents.map(r => r.resource.amount).min() - this._product.amount) / 100;\n\n    const totalYield = this._reagents.map(r => r.resource.amount / r.cost).min();\n\n    return Math.min(totalYield, Math.max(forcingFactor, 1));\n  } // Check each reagent for if a full reaction would drop it below the product amount.  If so, reduce reaction yield\n\n\n  get actualYield() {\n    // Assume a full reaction to see what the maximum possible product is\n    const maxFromReaction = this.baseProduction * this.reactionYield * this.reactionEfficiency;\n    const prodBefore = this._product.amount;\n    const prodAfter = prodBefore + maxFromReaction;\n    let cappedYield = this.reactionYield;\n\n    for (const reagent of this._reagents) {\n      const reagentBefore = reagent.resource.amount;\n      const reagentAfter = reagent.resource.amount - this.reactionYield * reagent.cost;\n      const diffBefore = reagentBefore - prodBefore;\n      const diffAfter = reagentAfter - prodAfter;\n      cappedYield = Math.min(cappedYield, this.reactionYield * diffBefore / (diffBefore - diffAfter));\n    }\n\n    return Math.clampMin(cappedYield, 0);\n  } // Assign reactions priority in descending order based on the largest reagent total after the reaction.  The logic\n  // is that if we assume that all the reactions are cap-limited, then by assigning priority in this way, reactions\n  // get applied so that earlier reactions are less likely to reduce the yield of later reactions.\n\n\n  get priority() {\n    let maxReagent = Glyphs.levelCap;\n\n    for (const reagent of this._reagents) {\n      const afterReaction = reagent.resource.amount - reagent.cost * this.actualYield;\n      maxReagent = Math.min(maxReagent, afterReaction);\n    }\n\n    return maxReagent;\n  }\n\n  get isActive() {\n    return this._product.data.reaction;\n  }\n\n  set isActive(value) {\n    this._product.data.reaction = value;\n  }\n\n  get isReality() {\n    return this._product.id === ALCHEMY_RESOURCE.REALITY;\n  } // Reactions are per-10 products because that avoids decimals in the UI for reagents, but efficiency losses can make\n  // products have decimal coefficients.\n\n\n  get baseProduction() {\n    return this.isReality ? 1 : 5;\n  }\n\n  get reactionEfficiency() {\n    return this.isReality ? 1 : AlchemyResource.synergism.effectValue;\n  }\n\n  get reactionProduction() {\n    return this.baseProduction * this.reactionEfficiency;\n  } // Cap products at the minimum amount of all reagents before the reaction occurs, eg. 200Ξ and 350Ψ will not bring\n  // ω above 200.  In fact, since some Ξ will be used during the reaction, the actual cap will be a bit lower.\n\n\n  combineReagents() {\n    if (!this.isActive || this.reactionYield === 0) return;\n    const unpredictabilityEffect = AlchemyResource.unpredictability.effectValue;\n    const times = 1 + poissonDistribution(unpredictabilityEffect / (1 - unpredictabilityEffect));\n    const cap = this._product.cap;\n\n    for (let i = 0; i < times; i++) {\n      const reactionYield = this.actualYield;\n\n      for (const reagent of this._reagents) {\n        reagent.resource.amount -= reactionYield * reagent.cost;\n      } // The minimum reaction yield is 0.05 so the cap is actually reached\n\n\n      const effectiveYield = Math.clampMin(reactionYield * this.reactionProduction, 0.05);\n      this._product.amount = Math.clampMax(this._product.amount + effectiveYield, cap);\n    }\n  }\n\n}\n\nexport const AlchemyResource = mapGameDataToObject(GameDatabase.celestials.alchemy.resources, config => config.isBaseResource ? new BasicAlchemyResourceState(config) : new AdvancedAlchemyResourceState(config));\nexport const AlchemyResources = {\n  all: AlchemyResource.all,\n  base: AlchemyResource.all.filter(r => r.isBaseResource)\n};\nexport const AlchemyReactions = function () {\n  // For convenience and readability, stuff is named differently in GameDatabase\n  function mapReagents(resource) {\n    return resource.config.reagents.map(r => ({\n      resource: AlchemyResources.all.find(x => x.id === r.resource),\n      cost: r.amount\n    }));\n  }\n\n  return {\n    all: AlchemyResources.all.map(r => r.isBaseResource ? null : new AlchemyReaction(r, mapReagents(r)))\n  };\n}();","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/celestials/ra/alchemy.js"],"names":["GameMechanicState","AlchemyResourceState","constructor","config","ema","ExponentialMovingAverage","_before","name","symbol","description","isBaseResource","data","player","celestials","ra","alchemy","id","amount","value","before","flow","average","fillFraction","Math","clamp","cap","unlockedWith","Ra","pets","effarig","unlockedAt","isUnlocked","level","lockText","formatInt","isCustomEffect","effectValue","V","isRunning","effect","Pelle","isDisabled","reaction","AlchemyReactions","all","NotImplementedError","capped","BasicAlchemyResourceState","_name","toLowerCase","highestRefinementValue","max","clampMax","alchemyResourceCap","AdvancedAlchemyResourceState","reagentCaps","reagents","map","x","resource","min","AlchemyReaction","product","_product","_reagents","reactionYield","some","r","forcingFactor","totalYield","cost","actualYield","maxFromReaction","baseProduction","reactionEfficiency","prodBefore","prodAfter","cappedYield","reagent","reagentBefore","reagentAfter","diffBefore","diffAfter","clampMin","priority","maxReagent","Glyphs","levelCap","afterReaction","isActive","isReality","ALCHEMY_RESOURCE","REALITY","AlchemyResource","synergism","reactionProduction","combineReagents","unpredictabilityEffect","unpredictability","times","poissonDistribution","i","effectiveYield","mapGameDataToObject","GameDatabase","resources","AlchemyResources","base","filter","mapReagents","find"],"mappings":"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","sourcesContent":["import { GameMechanicState } from \"../../game-mechanics\";\r\n\r\n/**\r\n * @abstract\r\n */\r\nclass AlchemyResourceState extends GameMechanicState {\r\n  constructor(config) {\r\n    super(config);\r\n    this.ema = new ExponentialMovingAverage(0.01, 10, 100, 0.01);\r\n    this._before = 0;\r\n  }\r\n\r\n  get name() {\r\n    return this.config.name;\r\n  }\r\n\r\n  get symbol() {\r\n    return this.config.symbol;\r\n  }\r\n\r\n  get description() {\r\n    return this.config.description;\r\n  }\r\n\r\n  get isBaseResource() {\r\n    return this.config.isBaseResource === true;\r\n  }\r\n\r\n  get data() {\r\n    return player.celestials.ra.alchemy[this.id];\r\n  }\r\n\r\n  get amount() {\r\n    return this.data.amount;\r\n  }\r\n\r\n  set amount(value) {\r\n    this.data.amount = value;\r\n  }\r\n\r\n  get before() {\r\n    return this._before;\r\n  }\r\n\r\n  set before(value) {\r\n    this._before = value;\r\n  }\r\n\r\n  get flow() {\r\n    return this.ema.average;\r\n  }\r\n\r\n  get fillFraction() {\r\n    return Math.clamp(this.amount / this.cap, 0, 1);\r\n  }\r\n\r\n  get unlockedWith() {\r\n    return Ra.pets.effarig;\r\n  }\r\n\r\n  get unlockedAt() {\r\n    return this.config.unlockedAt;\r\n  }\r\n\r\n  get isUnlocked() {\r\n    return this.unlockedWith.level >= this.unlockedAt;\r\n  }\r\n\r\n  get lockText() {\r\n    return `${this.unlockedWith.name} Level ${formatInt(this.unlockedAt)}`;\r\n  }\r\n\r\n  get isCustomEffect() {\r\n    return true;\r\n  }\r\n\r\n  get effectValue() {\r\n    // Disable Exponential alchemy effect in V reality.\r\n    if (V.isRunning && this.config.id === 14) return 0;\r\n    return this.config.effect(Pelle.isDisabled(\"alchemy\") ? 0 : this.amount);\r\n  }\r\n\r\n  get reaction() {\r\n    return AlchemyReactions.all[this.id];\r\n  }\r\n\r\n  /**\r\n   * @abstract\r\n   */\r\n  get cap() { throw new NotImplementedError(); }\r\n\r\n  get capped() {\r\n    return this.amount >= this.cap;\r\n  }\r\n}\r\n\r\nclass BasicAlchemyResourceState extends AlchemyResourceState {\r\n  constructor(config) {\r\n    super(config);\r\n    // The names are capitalized, so we need to convert them to lower case\r\n    // in order to access highestRefinementValue values which are not capitalized.\r\n    this._name = config.name.toLowerCase();\r\n  }\r\n\r\n  get highestRefinementValue() {\r\n    return player.celestials.ra.highestRefinementValue[this._name];\r\n  }\r\n\r\n  set highestRefinementValue(value) {\r\n    player.celestials.ra.highestRefinementValue[this._name] = Math.max(this.highestRefinementValue, value);\r\n  }\r\n\r\n  get cap() {\r\n    return Math.clampMax(Ra.alchemyResourceCap, this.highestRefinementValue);\r\n  }\r\n}\r\n\r\nclass AdvancedAlchemyResourceState extends AlchemyResourceState {\r\n  get cap() {\r\n    const reagentCaps = this.reaction.reagents.map(x => x.resource.cap);\r\n    return Math.min(...reagentCaps);\r\n  }\r\n}\r\n\r\nclass AlchemyReaction {\r\n  constructor(product, reagents) {\r\n    this._product = product;\r\n    this._reagents = reagents;\r\n  }\r\n\r\n  get product() {\r\n    return this._product;\r\n  }\r\n\r\n  get reagents() {\r\n    return this._reagents;\r\n  }\r\n\r\n  // Returns a percentage of a reaction that can be done, accounting for limiting reagents.  This normally caps at\r\n  // 100%, but the reaction will be forced to occur at higher than 100% if there is significantly more reagent than\r\n  // product. This allows resources to be created quickly when its reaction is initially turned on with saved reagents.\r\n  get reactionYield() {\r\n    if (!this._product.isUnlocked || this._reagents.some(r => !r.resource.isUnlocked)) return 0;\r\n    const forcingFactor = (this._reagents\r\n      .map(r => r.resource.amount)\r\n      .min() - this._product.amount) / 100;\r\n    const totalYield = this._reagents\r\n      .map(r => r.resource.amount / r.cost)\r\n      .min();\r\n    return Math.min(totalYield, Math.max(forcingFactor, 1));\r\n  }\r\n\r\n  // Check each reagent for if a full reaction would drop it below the product amount.  If so, reduce reaction yield\r\n  get actualYield() {\r\n    // Assume a full reaction to see what the maximum possible product is\r\n    const maxFromReaction = this.baseProduction * this.reactionYield * this.reactionEfficiency;\r\n    const prodBefore = this._product.amount;\r\n    const prodAfter = prodBefore + maxFromReaction;\r\n    let cappedYield = this.reactionYield;\r\n    for (const reagent of this._reagents) {\r\n      const reagentBefore = reagent.resource.amount;\r\n      const reagentAfter = reagent.resource.amount - this.reactionYield * reagent.cost;\r\n      const diffBefore = reagentBefore - prodBefore;\r\n      const diffAfter = reagentAfter - prodAfter;\r\n      cappedYield = Math.min(cappedYield, this.reactionYield * diffBefore / (diffBefore - diffAfter));\r\n    }\r\n    return Math.clampMin(cappedYield, 0);\r\n  }\r\n\r\n  // Assign reactions priority in descending order based on the largest reagent total after the reaction.  The logic\r\n  // is that if we assume that all the reactions are cap-limited, then by assigning priority in this way, reactions\r\n  // get applied so that earlier reactions are less likely to reduce the yield of later reactions.\r\n  get priority() {\r\n    let maxReagent = Glyphs.levelCap;\r\n    for (const reagent of this._reagents) {\r\n      const afterReaction = reagent.resource.amount - reagent.cost * this.actualYield;\r\n      maxReagent = Math.min(maxReagent, afterReaction);\r\n    }\r\n    return maxReagent;\r\n  }\r\n\r\n  get isActive() {\r\n    return this._product.data.reaction;\r\n  }\r\n\r\n  set isActive(value) {\r\n    this._product.data.reaction = value;\r\n  }\r\n\r\n  get isReality() {\r\n    return this._product.id === ALCHEMY_RESOURCE.REALITY;\r\n  }\r\n\r\n  // Reactions are per-10 products because that avoids decimals in the UI for reagents, but efficiency losses can make\r\n  // products have decimal coefficients.\r\n  get baseProduction() {\r\n    return this.isReality ? 1 : 5;\r\n  }\r\n\r\n  get reactionEfficiency() {\r\n    return this.isReality ? 1 : AlchemyResource.synergism.effectValue;\r\n  }\r\n\r\n  get reactionProduction() {\r\n    return this.baseProduction * this.reactionEfficiency;\r\n  }\r\n\r\n  // Cap products at the minimum amount of all reagents before the reaction occurs, eg. 200Ξ and 350Ψ will not bring\r\n  // ω above 200.  In fact, since some Ξ will be used during the reaction, the actual cap will be a bit lower.\r\n  combineReagents() {\r\n    if (!this.isActive || this.reactionYield === 0) return;\r\n    const unpredictabilityEffect = AlchemyResource.unpredictability.effectValue;\r\n    const times = 1 + poissonDistribution(unpredictabilityEffect / (1 - unpredictabilityEffect));\r\n    const cap = this._product.cap;\r\n    for (let i = 0; i < times; i++) {\r\n      const reactionYield = this.actualYield;\r\n      for (const reagent of this._reagents) {\r\n        reagent.resource.amount -= reactionYield * reagent.cost;\r\n      }\r\n      // The minimum reaction yield is 0.05 so the cap is actually reached\r\n      const effectiveYield = Math.clampMin(reactionYield * this.reactionProduction, 0.05);\r\n      this._product.amount = Math.clampMax(this._product.amount + effectiveYield, cap);\r\n    }\r\n  }\r\n}\r\n\r\nexport const AlchemyResource = mapGameDataToObject(\r\n  GameDatabase.celestials.alchemy.resources,\r\n  config => (config.isBaseResource\r\n    ? new BasicAlchemyResourceState(config)\r\n    : new AdvancedAlchemyResourceState(config))\r\n);\r\n\r\nexport const AlchemyResources = {\r\n  all: AlchemyResource.all,\r\n  base: AlchemyResource.all.filter(r => r.isBaseResource)\r\n};\r\n\r\nexport const AlchemyReactions = (function() {\r\n  // For convenience and readability, stuff is named differently in GameDatabase\r\n  function mapReagents(resource) {\r\n    return resource.config.reagents\r\n      .map(r => ({\r\n        resource: AlchemyResources.all.find(x => x.id === r.resource),\r\n        cost: r.amount\r\n      }));\r\n  }\r\n  return {\r\n    all: AlchemyResources.all\r\n      .map(r => (r.isBaseResource ? null : new AlchemyReaction(r, mapReagents(r))))\r\n  };\r\n}());\r\n"]},"metadata":{},"sourceType":"module"}