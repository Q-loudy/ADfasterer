{"ast":null,"code":"import _objectSpread from \"C:/Games/ADFasterer/ADfasterer/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport { standardizeAutomatorValues, tokenMap as T } from \"./lexer\";\n/**\r\n * Note: the $ shorthand for the parser object is required by Chevrotain. Don't mess with it.\r\n */\n\nconst presetSplitter = /name[\\t ]+((?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+$)/i;\nconst idSplitter = /id[\\t ]+([0-9])/i;\n\nfunction prestigeNotify(flag) {\n  if (!AutomatorBackend.isOn) return;\n  const state = AutomatorBackend.stack.top.commandState;\n\n  if (state && state.prestigeLevel !== undefined) {\n    state.prestigeLevel = Math.max(state.prestigeLevel, flag);\n  }\n}\n\nEventHub.logic.on(GAME_EVENT.BIG_CRUNCH_AFTER, () => prestigeNotify(T.Infinity.$prestigeLevel));\nEventHub.logic.on(GAME_EVENT.ETERNITY_RESET_AFTER, () => prestigeNotify(T.Eternity.$prestigeLevel));\nEventHub.logic.on(GAME_EVENT.REALITY_RESET_AFTER, () => prestigeNotify(T.Reality.$prestigeLevel)); // Used by while and until - in order to get the text corrext, we need to invert the boolean if it's an until\n// eslint-disable-next-line max-params\n\nfunction compileConditionLoop(evalComparison, commands, ctx, isUntil) {\n  return {\n    run: () => {\n      const loopStr = isUntil ? \"UNTIL\" : \"WHILE\";\n\n      if (!evalComparison()) {\n        AutomatorData.logCommandEvent(`Checked ${parseConditionalIntoText(ctx)} (${isUntil}),\n          exiting loop at line ${AutomatorBackend.translateLineNumber(ctx.RCurly[0].startLine + 1) - 1}\n          (end of ${loopStr} loop)`, ctx.startLine);\n        return AUTOMATOR_COMMAND_STATUS.NEXT_TICK_NEXT_INSTRUCTION;\n      }\n\n      AutomatorBackend.push(commands);\n      AutomatorData.logCommandEvent(`Checked ${parseConditionalIntoText(ctx)} (${!isUntil}),\n        moving to line ${AutomatorBackend.translateLineNumber(ctx.LCurly[0].startLine + 1) - 1}\n        (start of ${loopStr} loop)`, ctx.startLine);\n      return AUTOMATOR_COMMAND_STATUS.SAME_INSTRUCTION;\n    },\n    blockCommands: commands\n  };\n} // Extracts the conditional out of a command and returns it as text\n\n\nfunction parseConditionalIntoText(ctx) {\n  const comp = ctx.comparison[0].children;\n  const getters = comp.compareValue.map(cv => {\n    if (cv.children.AutomatorCurrency) return () => cv.children.AutomatorCurrency[0].image;\n    const val = cv.children.$value;\n    if (typeof val === \"string\") return () => val;\n    return () => format(val, 2, 2);\n  });\n  const compareFn = comp.ComparisonOperator[0].image;\n  return `${getters[0]()} ${compareFn} ${getters[1]()}`;\n} // Determines how much (prestige currency) the previous (layer) reset gave, for event logging\n\n\nfunction findLastPrestigeRecord(layer) {\n  let addedECs, gainedEP;\n\n  switch (layer) {\n    case \"INFINITY\":\n      return `${format(player.records.recentInfinities[0][1], 2)} IP`;\n\n    case \"ETERNITY\":\n      addedECs = AutomatorData.lastECCompletionCount;\n      gainedEP = `${format(player.records.recentEternities[0][1], 2)} EP`;\n      return addedECs === 0 ? `${gainedEP}` : `${gainedEP}, ${addedECs} completions`;\n\n    case \"REALITY\":\n      return `${format(player.records.recentRealities[0][1], 2)} RM`;\n\n    default:\n      throw Error(`Unrecognized prestige ${layer} in Automator event log`);\n  }\n}\n\nexport const AutomatorCommands = [{\n  id: \"auto\",\n  rule: $ => () => {\n    $.CONSUME(T.Auto);\n    $.CONSUME(T.PrestigeEvent);\n    $.OR([{\n      ALT: () => $.CONSUME(T.On)\n    }, {\n      ALT: () => $.CONSUME(T.Off)\n    }, {\n      ALT: () => $.OR1([{\n        ALT: () => $.SUBRULE($.duration)\n      }, {\n        ALT: () => $.SUBRULE($.xHighest)\n      }, {\n        ALT: () => $.SUBRULE($.currencyAmount)\n      }])\n    }]);\n  },\n  // eslint-disable-next-line complexity\n  validate: (ctx, V) => {\n    ctx.startLine = ctx.Auto[0].startLine;\n\n    if (ctx.PrestigeEvent && ctx.currencyAmount) {\n      const desired$ = ctx.PrestigeEvent[0].tokenType.$prestigeCurrency;\n      const specified$ = ctx.currencyAmount[0].children.AutomatorCurrency[0].tokenType.name;\n\n      if (desired$ !== specified$) {\n        V.addError(ctx.currencyAmount, `AutomatorCurrency doesn't match prestige (${desired$} vs ${specified$})`, `Use ${desired$} for the specified prestige resource`);\n        return false;\n      }\n    }\n\n    if (!ctx.PrestigeEvent) return true;\n    const advSetting = ctx.duration || ctx.xHighest; // Do not change to switch statement; T.XXX are Objects, not primitive values\n\n    if (ctx.PrestigeEvent[0].tokenType === T.Infinity) {\n      if (!Autobuyer.bigCrunch.isUnlocked) {\n        V.addError(ctx.PrestigeEvent, \"Infinity autobuyer is not unlocked\", \"Complete the Big Crunch Autobuyer challenge to use this command\");\n        return false;\n      }\n\n      if (advSetting && !EternityMilestone.bigCrunchModes.isReached) {\n        V.addError((ctx.duration || ctx.xHighest)[0], \"Advanced Infinity autobuyer settings are not unlocked\", `Reach ${quantifyInt(\"Eternity\", EternityMilestone.bigCrunchModes.config.eternities)}\n            to use this command`);\n        return false;\n      }\n    }\n\n    if (ctx.PrestigeEvent[0].tokenType === T.Eternity) {\n      if (!EternityMilestone.autobuyerEternity.isReached) {\n        V.addError(ctx.PrestigeEvent, \"Eternity autobuyer is not unlocked\", `Reach ${quantifyInt(\"Eternity\", EternityMilestone.autobuyerEternity.config.eternities)}\n            to use this command`);\n        return false;\n      }\n\n      if (advSetting && !RealityUpgrade(13).isBought) {\n        V.addError((ctx.duration || ctx.xHighest)[0], \"Advanced Eternity autobuyer settings are not unlocked\", \"Purchase the Reality Upgrade which unlocks advanced Eternity autobuyer settings\");\n        return false;\n      }\n    }\n\n    if (ctx.PrestigeEvent[0].tokenType === T.Reality) {\n      if (!RealityUpgrade(25).isBought) {\n        V.addError(ctx.PrestigeEvent, \"Reality autobuyer is not unlocked\", \"Purchase the Reality Upgrade which unlocks the Reality autobuyer\");\n        return false;\n      }\n\n      if (advSetting) {\n        V.addError((ctx.duration || ctx.xHighest)[0], \"Auto Reality cannot be set to a duration or x highest\", \"Use RM for Auto Reality\");\n        return false;\n      }\n    }\n\n    return true;\n  },\n  compile: ctx => {\n    const isReality = ctx.PrestigeEvent[0].tokenType === T.Reality;\n    const on = Boolean(ctx.On || ctx.duration || ctx.xHighest || ctx.currencyAmount);\n    const duration = ctx.duration ? ctx.duration[0].children.$value : undefined;\n    const xHighest = ctx.xHighest ? ctx.xHighest[0].children.$value : undefined;\n    const fixedAmount = ctx.currencyAmount ? ctx.currencyAmount[0].children.$value : undefined;\n    const durationMode = ctx.PrestigeEvent[0].tokenType.$autobuyerDurationMode;\n    const xHighestMode = ctx.PrestigeEvent[0].tokenType.$autobuyerXHighestMode;\n    const fixedMode = ctx.PrestigeEvent[0].tokenType.$autobuyerCurrencyMode;\n    const autobuyer = ctx.PrestigeEvent[0].tokenType.$autobuyer();\n    return () => {\n      autobuyer.isActive = on;\n      let currSetting = \"\";\n\n      if (duration !== undefined) {\n        autobuyer.mode = durationMode;\n        autobuyer.time = duration / 1000; // Can't do the units provided in the script because it's been parsed away like 4 layers up the call stack\n\n        currSetting = `${autobuyer.time > 1000 ? formatInt(autobuyer.time) : quantify(\"second\", autobuyer.time)}`;\n      } else if (xHighest !== undefined) {\n        autobuyer.mode = xHighestMode;\n        autobuyer.xHighest = new Decimal(xHighest);\n        currSetting = `${format(xHighest, 2, 2)} times highest`;\n      } else if (fixedAmount !== undefined) {\n        autobuyer.mode = fixedMode;\n\n        if (isReality) {\n          autobuyer.rm = new Decimal(fixedAmount);\n          currSetting = `${format(autobuyer.rm, 2)} RM`;\n        } else {\n          autobuyer.amount = new Decimal(fixedAmount);\n          currSetting = `${fixedAmount} ${ctx.PrestigeEvent[0].image === \"infinity\" ? \"IP\" : \"EP\"}`;\n        }\n      } // Settings are drawn from the actual automator text; it's not feasible to parse out all the settings\n      // for every combination of autobuyers when they get turned off\n\n\n      const settingString = autobuyer.isActive && currSetting !== \"\" ? `(Setting: ${currSetting})` : \"\";\n      AutomatorData.logCommandEvent(`Automatic ${ctx.PrestigeEvent[0].image}\n          turned ${autobuyer.isActive ? \"ON\" : \"OFF\"} ${settingString}`, ctx.startLine);\n      return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\n    };\n  },\n  blockify: ctx => {\n    const duration = ctx.duration ? `${ctx.duration[0].children.NumberLiteral[0].image} ${ctx.duration[0].children.TimeUnit[0].image}` : undefined;\n    const xHighest = ctx.xHighest ? ctx.xHighest[0].children.$value : undefined;\n    const fixedAmount = ctx.currencyAmount ? `${ctx.currencyAmount[0].children.NumberLiteral[0].image}` + ` ${ctx.currencyAmount[0].children.AutomatorCurrency[0].image.toUpperCase()}` : undefined;\n    const on = Boolean(ctx.On);\n    let input = \"\";\n    if (duration) input = duration;else if (xHighest) input = `${xHighest} x highest`;else if (fixedAmount) input = `${fixedAmount}`;else input = on ? \"ON\" : \"OFF\";\n    return _objectSpread({\n      singleSelectionInput: ctx.PrestigeEvent[0].tokenType.name.toUpperCase(),\n      singleTextInput: input\n    }, automatorBlocksMap.AUTO);\n  }\n}, {\n  id: \"blackHole\",\n  rule: $ => () => {\n    $.CONSUME(T.BlackHole);\n    $.OR([{\n      ALT: () => $.CONSUME(T.On)\n    }, {\n      ALT: () => $.CONSUME(T.Off)\n    }]);\n  },\n  validate: ctx => {\n    ctx.startLine = ctx.BlackHole[0].startLine;\n    return true;\n  },\n  compile: ctx => {\n    const on = Boolean(ctx.On);\n    return () => {\n      if (on === BlackHoles.arePaused) BlackHoles.togglePause();\n      let blackHoleEvent;\n\n      if (BlackHole(1).isUnlocked) {\n        blackHoleEvent = `Black Holes toggled ${ctx.On ? \"ON\" : \"OFF\"}`;\n      } else if (Enslaved.isRunning || Pelle.isDisabled(\"blackhole\")) {\n        blackHoleEvent = \"Black Hole command ignored because BH is disabled in your current Reality\";\n      } else {\n        blackHoleEvent = \"Black Hole command ignored because BH is not unlocked\";\n      }\n\n      AutomatorData.logCommandEvent(blackHoleEvent, ctx.startLine);\n      return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\n    };\n  },\n  blockify: ctx => _objectSpread({\n    singleSelectionInput: ctx.On ? \"ON\" : \"OFF\"\n  }, automatorBlocksMap[\"BLACK HOLE\"])\n}, {\n  id: \"blob\",\n  rule: $ => () => {\n    $.CONSUME(T.Blob);\n  },\n  validate: ctx => {\n    ctx.startLine = ctx.Blob[0].startLine;\n    return true;\n  },\n  // This is an easter egg, it shouldn't do anything\n  compile: () => () => AUTOMATOR_COMMAND_STATUS.SKIP_INSTRUCTION,\n  blockify: () => _objectSpread({}, automatorBlocksMap.BLOB)\n}, {\n  id: \"comment\",\n  rule: $ => () => {\n    $.CONSUME(T.Comment);\n  },\n  validate: ctx => {\n    ctx.startLine = ctx.Comment[0].startLine;\n    return true;\n  },\n  // Comments should be no-ops\n  compile: () => () => AUTOMATOR_COMMAND_STATUS.SKIP_INSTRUCTION,\n  blockify: ctx => _objectSpread(_objectSpread({}, automatorBlocksMap.COMMENT), {}, {\n    singleTextInput: ctx.Comment[0].image.replace(/(#|\\/\\/)[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]?/, \"\")\n  })\n}, {\n  id: \"ifBlock\",\n  rule: $ => () => {\n    $.CONSUME(T.If);\n    $.SUBRULE($.comparison);\n    $.CONSUME(T.LCurly);\n    $.CONSUME(T.EOL);\n    $.SUBRULE($.block);\n    $.CONSUME(T.RCurly);\n  },\n  validate: (ctx, V) => {\n    ctx.startLine = ctx.If[0].startLine;\n    return V.checkBlock(ctx, ctx.If);\n  },\n  compile: (ctx, C) => {\n    const evalComparison = C.visit(ctx.comparison);\n    const commands = C.visit(ctx.block);\n    return {\n      run: S => {\n        // If the commandState is empty, it means we haven't evaluated the if yet\n        if (S.commandState !== null) return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION; // We use this flag to make \"single step\" advance to the next command after the if when the block ends\n\n        S.commandState = {\n          advanceOnPop: true,\n          ifEndLine: ctx.RCurly[0].startLine\n        };\n\n        if (!evalComparison()) {\n          AutomatorData.logCommandEvent(`Checked ${parseConditionalIntoText(ctx)} (false),\n              skipping to line ${AutomatorBackend.translateLineNumber(ctx.RCurly[0].startLine + 1)}`, ctx.startLine);\n          return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\n        }\n\n        AutomatorBackend.push(commands);\n        AutomatorData.logCommandEvent(`Checked ${parseConditionalIntoText(ctx)} (true),\n            entering IF block`, ctx.startLine);\n        return AUTOMATOR_COMMAND_STATUS.SAME_INSTRUCTION;\n      },\n      blockCommands: commands\n    };\n  },\n  blockify: (ctx, B) => {\n    const commands = [];\n    B.visit(ctx.block, commands);\n    const comparison = B.visit(ctx.comparison);\n    return _objectSpread(_objectSpread(_objectSpread({\n      nest: commands\n    }, automatorBlocksMap.IF), comparison), {}, {\n      genericInput1: standardizeAutomatorValues(comparison.genericInput1),\n      genericInput2: standardizeAutomatorValues(comparison.genericInput2)\n    });\n  }\n}, {\n  id: \"notify\",\n  rule: $ => () => {\n    $.CONSUME(T.Notify);\n    $.OR([{\n      ALT: () => $.CONSUME(T.StringLiteral)\n    }, {\n      ALT: () => $.CONSUME(T.StringLiteralSingleQuote)\n    }]);\n  },\n  validate: ctx => {\n    ctx.startLine = ctx.Notify[0].startLine;\n    return true;\n  },\n  compile: ctx => {\n    const notifyText = ctx.StringLiteral || ctx.StringLiteralSingleQuote;\n    return () => {\n      GameUI.notify.automator(`Automator: ${notifyText[0].image}`);\n      AutomatorData.logCommandEvent(`NOTIFY call: ${notifyText[0].image}`, ctx.startLine);\n      return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\n    };\n  },\n  blockify: ctx => _objectSpread(_objectSpread({}, automatorBlocksMap.NOTIFY), {}, {\n    singleTextInput: (ctx.StringLiteral || ctx.StringLiteralSingleQuote)[0].image\n  })\n}, {\n  // Note: this has to appear before pause\n  id: \"pauseTime\",\n  rule: $ => () => {\n    $.CONSUME(T.Pause);\n    $.OR([{\n      ALT: () => $.SUBRULE($.duration)\n    }, {\n      ALT: () => $.CONSUME(T.Identifier)\n    }]);\n  },\n  validate: (ctx, V) => {\n    ctx.startLine = ctx.Pause[0].startLine;\n    let duration;\n\n    if (ctx.Identifier) {\n      if (!V.isValidVarFormat(ctx.Identifier[0], AUTOMATOR_VAR_TYPES.DURATION)) {\n        V.addError(ctx, `Constant ${ctx.Identifier[0].image} is not a valid time duration constant`, `Ensure that ${ctx.Identifier[0].image} is a number of seconds less than\n            ${format(Number.MAX_VALUE / 1000)}`);\n        return false;\n      }\n\n      const lookup = V.lookupVar(ctx.Identifier[0], AUTOMATOR_VAR_TYPES.DURATION);\n      duration = lookup ? lookup.value : lookup;\n    } else {\n      duration = V.visit(ctx.duration);\n    }\n\n    ctx.$duration = duration;\n    return ctx.$duration !== undefined;\n  },\n  compile: ctx => {\n    const duration = ctx.$duration;\n    return S => {\n      let timeString;\n\n      if (ctx.duration) {\n        const c = ctx.duration[0].children;\n        timeString = `${c.NumberLiteral[0].image} ${c.TimeUnit[0].image}`;\n      } else {\n        // This is the case for a defined constant; its value was parsed out during validation\n        timeString = TimeSpan.fromMilliseconds(duration);\n      }\n\n      if (S.commandState === null) {\n        S.commandState = {\n          timeMs: 0\n        };\n        AutomatorData.logCommandEvent(`Pause started (waiting ${timeString})`, ctx.startLine);\n      } else {\n        S.commandState.timeMs += Math.max(Time.unscaledDeltaTime.totalMilliseconds / getGlobalSpeedFactor(), AutomatorBackend.currentInterval);\n      }\n\n      const finishPause = S.commandState.timeMs >= duration;\n\n      if (finishPause) {\n        AutomatorData.logCommandEvent(`Pause finished (waited ${timeString})`, ctx.startLine);\n        return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\n      }\n\n      return AUTOMATOR_COMMAND_STATUS.NEXT_TICK_SAME_INSTRUCTION;\n    };\n  },\n  blockify: ctx => {\n    let blockArg;\n\n    if (ctx.duration) {\n      const c = ctx.duration[0].children;\n      blockArg = `${c.NumberLiteral[0].image} ${c.TimeUnit[0].image}`;\n    } else {\n      blockArg = `${ctx.Identifier[0].image}`;\n    }\n\n    return _objectSpread(_objectSpread({}, automatorBlocksMap.PAUSE), {}, {\n      singleTextInput: blockArg\n    });\n  }\n}, {\n  id: \"prestige\",\n  rule: $ => () => {\n    $.CONSUME(T.PrestigeEvent);\n    $.OPTION(() => $.CONSUME(T.Nowait));\n    $.OPTION1(() => $.CONSUME(T.Respec));\n  },\n  validate: (ctx, V) => {\n    ctx.startLine = ctx.PrestigeEvent[0].startLine;\n\n    if (ctx.PrestigeEvent && ctx.PrestigeEvent[0].tokenType === T.Eternity && !EternityMilestone.autobuyerEternity.isReached) {\n      V.addError(ctx.PrestigeEvent, \"Eternity autobuyer is not unlocked\", `Reach ${quantifyInt(\"Eternity\", EternityMilestone.autobuyerEternity.config.eternities)}\n          to use this command`);\n      return false;\n    }\n\n    if (ctx.PrestigeEvent && ctx.PrestigeEvent[0].tokenType === T.Reality && !RealityUpgrade(25).isBought) {\n      V.addError(ctx.PrestigeEvent, \"Reality autobuyer is not unlocked\", \"Purchase the Reality Upgrade which unlocks the Reality autobuyer\");\n      return false;\n    }\n\n    if (ctx.PrestigeEvent && ctx.PrestigeEvent[0].tokenType === T.Infinity && ctx.Respec) {\n      V.addError(ctx.Respec, \"There's no 'respec' for infinity\", \"Remove 'respec' from the command\");\n    }\n\n    return true;\n  },\n  compile: ctx => {\n    const nowait = ctx.Nowait !== undefined;\n    const respec = ctx.Respec !== undefined;\n    const prestigeToken = ctx.PrestigeEvent[0].tokenType;\n    return () => {\n      const available = prestigeToken.$prestigeAvailable();\n\n      if (!available) {\n        if (!nowait) return AUTOMATOR_COMMAND_STATUS.NEXT_TICK_SAME_INSTRUCTION;\n        AutomatorData.logCommandEvent(`${ctx.PrestigeEvent.image} attempted, but skipped due to NOWAIT`, ctx.startLine);\n        return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\n      }\n\n      if (respec) prestigeToken.$respec();\n      prestigeToken.$prestige();\n      const prestigeName = ctx.PrestigeEvent[0].image.toUpperCase();\n      AutomatorData.logCommandEvent(`${prestigeName} triggered (${findLastPrestigeRecord(prestigeName)})`, ctx.startLine); // In the prestigeToken.$prestige() line above, performing a reality reset has code internal to the call\n      // which makes the automator restart. However, in that case we also need to update the execution state here,\n      // or else the restarted automator will immediately advance lines and always skip the first command\n\n      return prestigeName === \"REALITY\" && AutomatorBackend.state.forceRestart ? AUTOMATOR_COMMAND_STATUS.RESTART : AUTOMATOR_COMMAND_STATUS.NEXT_TICK_NEXT_INSTRUCTION;\n    };\n  },\n  blockify: ctx => _objectSpread(_objectSpread({}, automatorBlocksMap[ctx.PrestigeEvent[0].tokenType.name.toUpperCase()]), {}, {\n    nowait: ctx.Nowait !== undefined,\n    respec: ctx.Respec !== undefined\n  })\n}, {\n  id: \"startDilation\",\n  rule: $ => () => {\n    $.CONSUME(T.Start);\n    $.CONSUME(T.Dilation);\n  },\n  validate: ctx => {\n    ctx.startLine = ctx.Start[0].startLine;\n    return true;\n  },\n  compile: ctx => () => {\n    if (player.dilation.active) {\n      AutomatorData.logCommandEvent(`Start Dilation encountered but ignored due to already being dilated`, ctx.startLine);\n      return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\n    }\n\n    if (startDilatedEternity(true)) {\n      AutomatorData.logCommandEvent(`Dilation entered`, ctx.startLine);\n      return AUTOMATOR_COMMAND_STATUS.NEXT_TICK_NEXT_INSTRUCTION;\n    }\n\n    return AUTOMATOR_COMMAND_STATUS.NEXT_TICK_SAME_INSTRUCTION;\n  },\n  blockify: () => _objectSpread({\n    singleSelectionInput: \"DILATION\"\n  }, automatorBlocksMap.START)\n}, {\n  id: \"startEC\",\n  rule: $ => () => {\n    $.CONSUME(T.Start);\n    $.SUBRULE($.eternityChallenge);\n  },\n  validate: ctx => {\n    ctx.startLine = ctx.Start[0].startLine;\n    return true;\n  },\n  compile: ctx => {\n    const ecNumber = ctx.eternityChallenge[0].children.$ecNumber;\n    return () => {\n      const ec = EternityChallenge(ecNumber);\n\n      if (ec.isRunning) {\n        AutomatorData.logCommandEvent(`Start EC encountered but ignored due to already being in the specified EC`, ctx.startLine);\n        return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\n      }\n\n      if (!EternityChallenge(ecNumber).isUnlocked) {\n        if (!TimeStudy.eternityChallenge(ecNumber).purchase(true)) {\n          return AUTOMATOR_COMMAND_STATUS.NEXT_TICK_SAME_INSTRUCTION;\n        }\n      }\n\n      if (ec.start(true)) {\n        AutomatorData.logCommandEvent(`Eternity Challenge ${ecNumber} started`, ctx.startLine);\n        return AUTOMATOR_COMMAND_STATUS.NEXT_TICK_NEXT_INSTRUCTION;\n      }\n\n      return AUTOMATOR_COMMAND_STATUS.NEXT_TICK_SAME_INSTRUCTION;\n    };\n  },\n  blockify: ctx => _objectSpread({\n    singleSelectionInput: \"EC\",\n    singleTextInput: ctx.eternityChallenge[0].children.$ecNumber\n  }, automatorBlocksMap.START)\n}, {\n  id: \"storeGameTime\",\n  rule: $ => () => {\n    $.CONSUME(T.StoreGameTime);\n    $.OR([{\n      ALT: () => $.CONSUME(T.On)\n    }, {\n      ALT: () => $.CONSUME(T.Off)\n    }, {\n      ALT: () => $.CONSUME(T.Use)\n    }]);\n  },\n  validate: (ctx, V) => {\n    ctx.startLine = ctx.StoreGameTime[0].startLine;\n\n    if (!Enslaved.isUnlocked) {\n      V.addError(ctx.StoreGameTime[0], \"You do not yet know how to store game time\", \"Unlock the ability to store game time\");\n      return false;\n    }\n\n    return true;\n  },\n  compile: ctx => {\n    if (ctx.Use) return () => {\n      if (Enslaved.isUnlocked) {\n        Enslaved.useStoredTime(false);\n        AutomatorData.logCommandEvent(`Stored game time used`, ctx.startLine);\n      } else {\n        AutomatorData.logCommandEvent(`Attempted to use stored game time, but failed (not unlocked yet)`, ctx.startLine);\n      }\n\n      return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\n    };\n    const on = Boolean(ctx.On);\n    return () => {\n      if (on !== player.celestials.enslaved.isStoring) Enslaved.toggleStoreBlackHole();\n      AutomatorData.logCommandEvent(`Storing game time toggled ${ctx.On ? \"ON\" : \"OFF\"}`, ctx.startLine);\n      return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\n    };\n  },\n  blockify: ctx => _objectSpread({\n    // eslint-disable-next-line no-nested-ternary\n    singleSelectionInput: ctx.Use ? \"USE\" : ctx.On ? \"ON\" : \"OFF\"\n  }, automatorBlocksMap[\"STORE GAME TIME\"])\n}, {\n  id: \"studiesBuy\",\n  rule: $ => () => {\n    $.CONSUME(T.Studies);\n    $.OPTION(() => $.CONSUME(T.Nowait));\n    $.CONSUME(T.Purchase);\n    $.OR([{\n      ALT: () => $.SUBRULE($.studyList)\n    }, {\n      ALT: () => $.CONSUME1(T.Identifier)\n    }]);\n  },\n  validate: (ctx, V) => {\n    ctx.startLine = ctx.Studies[0].startLine;\n\n    if (ctx.Identifier) {\n      if (!V.isValidVarFormat(ctx.Identifier[0], AUTOMATOR_VAR_TYPES.STUDIES)) {\n        V.addError(ctx, `Constant ${ctx.Identifier[0].image} is not a valid Time Study constant`, `Ensure that ${ctx.Identifier[0].image} is a properly-formatted Time Study string`);\n        return false;\n      }\n\n      const varInfo = V.lookupVar(ctx.Identifier[0], AUTOMATOR_VAR_TYPES.STUDIES);\n      ctx.$studies = varInfo.value;\n      ctx.$studies.image = ctx.Identifier[0].image;\n    } else if (ctx.studyList) {\n      ctx.$studies = V.visit(ctx.studyList);\n    }\n\n    return true;\n  },\n  compile: ctx => {\n    const studies = ctx.$studies;\n    if (ctx.Nowait === undefined) return () => {\n      let prePurchasedStudies = 0;\n      let purchasedStudies = 0;\n      let finalPurchasedTS;\n\n      for (const tsNumber of studies.normal) {\n        var _finalPurchasedTS;\n\n        if (TimeStudy(tsNumber).isBought) prePurchasedStudies++;else if (TimeStudy(tsNumber).purchase(true)) purchasedStudies++;else finalPurchasedTS = (_finalPurchasedTS = finalPurchasedTS) !== null && _finalPurchasedTS !== void 0 ? _finalPurchasedTS : tsNumber;\n      }\n\n      if (prePurchasedStudies + purchasedStudies < studies.normal.length) {\n        if (prePurchasedStudies + purchasedStudies === 0) {\n          AutomatorData.logCommandEvent(`Could not purchase any of the specified Time Studies`, ctx.startLine);\n        }\n\n        if (purchasedStudies > 0 && finalPurchasedTS) {\n          AutomatorData.logCommandEvent(`Purchased ${quantifyInt(\"Time Study\", purchasedStudies)} and stopped at\n            Time Study ${finalPurchasedTS}, waiting to attempt to purchase more Time Studies`, ctx.startLine);\n        }\n\n        return AUTOMATOR_COMMAND_STATUS.NEXT_TICK_SAME_INSTRUCTION;\n      }\n\n      const hasEC = studies.ec ? TimeStudy.eternityChallenge(studies.ec).isBought : false;\n\n      if (!studies.ec || hasEC && !studies.startEC) {\n        AutomatorData.logCommandEvent(`Purchased all specified Time Studies`, ctx.startLine);\n        return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\n      }\n\n      const unlockedEC = TimeStudy.eternityChallenge(studies.ec).purchase(true);\n\n      if (hasEC || unlockedEC) {\n        if (studies.startEC) {\n          EternityChallenge(studies.ec).start(true);\n\n          if (EternityChallenge(studies.ec).isRunning) {\n            AutomatorData.logCommandEvent(`Purchased all specified Time Studies, then unlocked and started running\n                Eternity Challenge ${studies.ec}`, ctx.startLine);\n          } else {\n            AutomatorData.logCommandEvent(`Purchased all specified Time Studies and unlocked Eternity Challenge\n                ${studies.ec}, but failed to start it`, ctx.startLine);\n          }\n        } else {\n          AutomatorData.logCommandEvent(`Purchased all specified Time Studies and unlocked Eternity Challenge\n              ${studies.ec}`, ctx.startLine);\n        }\n\n        return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\n      }\n\n      return AUTOMATOR_COMMAND_STATUS.NEXT_TICK_SAME_INSTRUCTION;\n    };\n    return () => {\n      for (const tsNumber of studies.normal) TimeStudy(tsNumber).purchase(true);\n\n      if (!studies.ec || TimeStudy.eternityChallenge(studies.ec).isBought) {\n        return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\n      }\n\n      TimeStudy.eternityChallenge(studies.ec).purchase(true);\n      return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\n    };\n  },\n  blockify: ctx => _objectSpread({\n    singleTextInput: ctx.$studies.image,\n    nowait: ctx.Nowait !== undefined\n  }, automatorBlocksMap[\"STUDIES PURCHASE\"])\n}, {\n  id: \"studiesLoad\",\n  rule: $ => () => {\n    $.CONSUME(T.Studies);\n    $.OPTION(() => $.CONSUME(T.Nowait));\n    $.CONSUME(T.Load);\n    $.OR([{\n      ALT: () => $.CONSUME1(T.Id)\n    }, {\n      ALT: () => $.CONSUME1(T.Name)\n    }]);\n  },\n  validate: (ctx, V) => {\n    ctx.startLine = ctx.Studies[0].startLine;\n\n    if (ctx.Id) {\n      const split = idSplitter.exec(ctx.Id[0].image);\n\n      if (!split || ctx.Id[0].isInsertedInRecovery) {\n        V.addError(ctx, \"Missing preset id\", \"Provide the id of a saved study preset slot from the Time Studies page\");\n        return false;\n      }\n\n      const id = parseInt(split[1], 10);\n\n      if (id < 1 || id > 6) {\n        V.addError(ctx.Id[0], `Could not find a preset with an id of ${id}`, \"Type in a valid id (1 - 6) for your study preset\");\n        return false;\n      }\n\n      ctx.$presetIndex = id;\n      return true;\n    }\n\n    if (ctx.Name) {\n      const split = presetSplitter.exec(ctx.Name[0].image);\n\n      if (!split || ctx.Name[0].isInsertedInRecovery) {\n        V.addError(ctx, \"Missing preset name\", \"Provide the name of a saved study preset from the Time Studies page\");\n        return false;\n      } // If it's a name, we check to make sure it exists:\n\n\n      const presetIndex = player.timestudy.presets.findIndex(e => e.name === split[1]) + 1;\n\n      if (presetIndex === 0) {\n        V.addError(ctx.Name[0], `Could not find preset named ${split[1]} (Note: Names are case-sensitive)`, \"Check to make sure you typed in the correct name for your study preset\");\n        return false;\n      }\n\n      ctx.$presetIndex = presetIndex;\n      return true;\n    }\n\n    return false;\n  },\n  compile: ctx => {\n    const presetIndex = ctx.$presetIndex;\n    return () => {\n      const imported = new TimeStudyTree(player.timestudy.presets[presetIndex - 1].studies);\n      const beforeCount = GameCache.currentStudyTree.value.purchasedStudies.length;\n      TimeStudyTree.commitToGameState(imported.purchasedStudies, true, imported.startEC);\n      const afterCount = GameCache.currentStudyTree.value.purchasedStudies.length; // Check if there are still any unbought studies from the preset after attempting to commit it all;\n      // if there are then we keep trying on this line until there aren't, unless we are given nowait\n\n      const missingStudyCount = imported.purchasedStudies.filter(s => !GameCache.currentStudyTree.value.purchasedStudies.includes(s)).length;\n      const presetRepresentation = ctx.Name ? ctx.Name[0].image : ctx.Id[0].image;\n\n      if (missingStudyCount === 0) {\n        AutomatorData.logCommandEvent(`Fully loaded study preset ${presetRepresentation}`, ctx.startLine);\n      } else if (afterCount > beforeCount) {\n        AutomatorData.logCommandEvent(`Partially loaded study preset ${presetRepresentation}\n            (missing ${quantifyInt(\"study\", missingStudyCount)})`, ctx.startLine);\n      }\n\n      return ctx.Nowait !== undefined || missingStudyCount === 0 ? AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION : AUTOMATOR_COMMAND_STATUS.NEXT_TICK_SAME_INSTRUCTION;\n    };\n  },\n  blockify: ctx => _objectSpread({\n    singleSelectionInput: ctx.Name ? \"NAME\" : \"ID\",\n    singleTextInput: ctx.Name ? player.timestudy.presets[ctx.$presetIndex - 1].name : ctx.$presetIndex,\n    nowait: ctx.Nowait !== undefined\n  }, automatorBlocksMap[\"STUDIES LOAD\"])\n}, {\n  id: \"studiesRespec\",\n  rule: $ => () => {\n    $.CONSUME(T.Studies);\n    $.CONSUME(T.Respec);\n  },\n  validate: ctx => {\n    ctx.startLine = ctx.Studies[0].startLine;\n    return true;\n  },\n  compile: ctx => () => {\n    player.respec = true;\n    AutomatorData.logCommandEvent(`Turned study respec ON`, ctx.startLine);\n    return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\n  },\n  blockify: () => automatorBlocksMap[\"STUDIES RESPEC\"]\n}, {\n  id: \"unlockDilation\",\n  rule: $ => () => {\n    $.CONSUME(T.Unlock);\n    $.OPTION(() => $.CONSUME(T.Nowait));\n    $.CONSUME(T.Dilation);\n  },\n  validate: ctx => {\n    ctx.startLine = ctx.Unlock[0].startLine;\n    return true;\n  },\n  compile: ctx => {\n    const nowait = ctx.Nowait !== undefined;\n    return () => {\n      if (PlayerProgress.dilationUnlocked()) {\n        AutomatorData.logCommandEvent(`Skipped dilation unlock due to being already unlocked`, ctx.startLine);\n        return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\n      }\n\n      const unlockedThisTick = TimeStudy.dilation.purchase(true);\n\n      if (unlockedThisTick) {\n        AutomatorData.logCommandEvent(`Unlocked Dilation`, ctx.startLine);\n        return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\n      }\n\n      if (nowait) {\n        AutomatorData.logCommandEvent(`Skipped dilation unlock due to lack of requirements (NOWAIT)`, ctx.startLine);\n        return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\n      }\n\n      return AUTOMATOR_COMMAND_STATUS.NEXT_TICK_SAME_INSTRUCTION;\n    };\n  },\n  blockify: ctx => _objectSpread({\n    singleSelectionInput: \"DILATION\",\n    nowait: ctx.Nowait !== undefined\n  }, automatorBlocksMap.UNLOCK)\n}, {\n  id: \"unlockEC\",\n  rule: $ => () => {\n    $.CONSUME(T.Unlock);\n    $.OPTION(() => $.CONSUME(T.Nowait));\n    $.SUBRULE($.eternityChallenge);\n  },\n  validate: ctx => {\n    ctx.startLine = ctx.Unlock[0].startLine;\n    return true;\n  },\n  compile: ctx => {\n    const nowait = ctx.Nowait !== undefined;\n    const ecNumber = ctx.eternityChallenge[0].children.$ecNumber;\n    return () => {\n      if (EternityChallenge(ecNumber).isUnlocked) {\n        AutomatorData.logCommandEvent(`Skipped EC ${ecNumber} unlock due to being already unlocked`, ctx.startLine);\n        return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\n      }\n\n      if (nowait) {\n        AutomatorData.logCommandEvent(`EC ${ecNumber} unlock failed and skipped (NOWAIT)`, ctx.startLine);\n        return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\n      }\n\n      const purchased = TimeStudy.eternityChallenge(ecNumber).purchase(true);\n\n      if (purchased) {\n        AutomatorData.logCommandEvent(`EC ${ecNumber} unlocked`, ctx.startLine);\n        return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\n      }\n\n      return AUTOMATOR_COMMAND_STATUS.NEXT_TICK_SAME_INSTRUCTION;\n    };\n  },\n  blockify: ctx => _objectSpread({\n    singleSelectionInput: \"EC\",\n    singleTextInput: ctx.eternityChallenge[0].children.$ecNumber,\n    nowait: ctx.Nowait !== undefined\n  }, automatorBlocksMap.UNLOCK)\n}, {\n  id: \"untilLoop\",\n  rule: $ => () => {\n    $.CONSUME(T.Until);\n    $.OR([{\n      ALT: () => $.SUBRULE($.comparison)\n    }, {\n      ALT: () => $.CONSUME(T.PrestigeEvent)\n    }]);\n    $.CONSUME(T.LCurly);\n    $.CONSUME(T.EOL);\n    $.SUBRULE($.block);\n    $.CONSUME(T.RCurly);\n  },\n  validate: (ctx, V) => {\n    ctx.startLine = ctx.Until[0].startLine;\n    return V.checkBlock(ctx, ctx.Until);\n  },\n  compile: (ctx, C) => {\n    const commands = C.visit(ctx.block);\n\n    if (ctx.comparison) {\n      const evalComparison = C.visit(ctx.comparison);\n      return compileConditionLoop(() => !evalComparison(), commands, ctx, true);\n    }\n\n    const prestigeLevel = ctx.PrestigeEvent[0].tokenType.$prestigeLevel;\n    let prestigeName;\n\n    switch (ctx.PrestigeEvent[0].tokenType) {\n      case T.Infinity:\n        prestigeName = \"Infinity\";\n        break;\n\n      case T.Eternity:\n        prestigeName = \"Eternity\";\n        break;\n\n      case T.Reality:\n        prestigeName = \"Reality\";\n        break;\n\n      default:\n        throw Error(\"Unrecognized prestige layer in until loop\");\n    }\n\n    return {\n      run: S => {\n        if (S.commandState === null) {\n          S.commandState = {\n            prestigeLevel: 0\n          };\n        }\n\n        if (S.commandState.prestigeLevel >= prestigeLevel) {\n          AutomatorData.logCommandEvent(`${prestigeName} prestige has occurred, exiting until loop`, ctx.startLine);\n          return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\n        }\n\n        AutomatorBackend.push(commands);\n        AutomatorData.logCommandEvent(`${prestigeName} prestige has not occurred yet, moving to line\n            ${AutomatorBackend.translateLineNumber(ctx.LCurly[0].startLine + 1)} (start of until loop)`, ctx.startLine);\n        return AUTOMATOR_COMMAND_STATUS.SAME_INSTRUCTION;\n      },\n      blockCommands: commands\n    };\n  },\n  blockify: (ctx, B) => {\n    const commands = [];\n    B.visit(ctx.block, commands);\n    const comparison = B.visit(ctx.comparison);\n\n    if (ctx.comparison) {\n      return _objectSpread(_objectSpread(_objectSpread({\n        nest: commands\n      }, automatorBlocksMap.UNTIL), comparison), {}, {\n        genericInput1: standardizeAutomatorValues(comparison.genericInput1),\n        genericInput2: standardizeAutomatorValues(comparison.genericInput2)\n      });\n    }\n\n    return _objectSpread({\n      genericInput1: ctx.PrestigeEvent[0].tokenType.name.toUpperCase(),\n      nest: commands\n    }, automatorBlocksMap.UNTIL);\n  }\n}, {\n  id: \"waitCondition\",\n  rule: $ => () => {\n    $.CONSUME(T.Wait);\n    $.SUBRULE($.comparison);\n  },\n  validate: ctx => {\n    ctx.startLine = ctx.Wait[0].startLine;\n    return true;\n  },\n  compile: (ctx, C) => () => {\n    const evalComparison = C.visit(ctx.comparison);\n    const doneWaiting = evalComparison();\n\n    if (doneWaiting) {\n      const timeWaited = TimeSpan.fromMilliseconds(Date.now() - AutomatorData.waitStart).toStringShort();\n\n      if (AutomatorData.isWaiting) {\n        AutomatorData.logCommandEvent(`Continuing after WAIT\n            (${parseConditionalIntoText(ctx)} is true, after ${timeWaited})`, ctx.startLine);\n      } else {\n        AutomatorData.logCommandEvent(`WAIT skipped (${parseConditionalIntoText(ctx)} is already true)`, ctx.startLine);\n      }\n\n      AutomatorData.isWaiting = false;\n      return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\n    }\n\n    if (!AutomatorData.isWaiting) {\n      AutomatorData.logCommandEvent(`Started WAIT for ${parseConditionalIntoText(ctx)}`, ctx.startLine);\n      AutomatorData.waitStart = Date.now();\n    }\n\n    AutomatorData.isWaiting = true;\n    return AUTOMATOR_COMMAND_STATUS.NEXT_TICK_SAME_INSTRUCTION;\n  },\n  blockify: (ctx, B) => {\n    const commands = [];\n    B.visit(ctx.block, commands);\n    const comparison = B.visit(ctx.comparison);\n    return _objectSpread(_objectSpread(_objectSpread({\n      nest: commands\n    }, automatorBlocksMap.WAIT), comparison), {}, {\n      genericInput1: standardizeAutomatorValues(comparison.genericInput1),\n      genericInput2: standardizeAutomatorValues(comparison.genericInput2)\n    });\n  }\n}, {\n  id: \"waitEvent\",\n  rule: $ => () => {\n    $.CONSUME(T.Wait);\n    $.CONSUME(T.PrestigeEvent);\n  },\n  validate: ctx => {\n    ctx.startLine = ctx.Wait[0].startLine;\n    return true;\n  },\n  compile: ctx => {\n    const prestigeLevel = ctx.PrestigeEvent[0].tokenType.$prestigeLevel;\n    return S => {\n      if (S.commandState === null) {\n        S.commandState = {\n          prestigeLevel: 0\n        };\n      }\n\n      const prestigeOccurred = S.commandState.prestigeLevel >= prestigeLevel;\n      const prestigeName = ctx.PrestigeEvent[0].image.toUpperCase();\n\n      if (prestigeOccurred) {\n        const timeWaited = TimeSpan.fromMilliseconds(Date.now() - AutomatorData.waitStart).toStringShort();\n        AutomatorData.logCommandEvent(`Continuing after WAIT (${prestigeName} occurred for\n            ${findLastPrestigeRecord(prestigeName)}, after ${timeWaited})`, ctx.startLine);\n        AutomatorData.isWaiting = false;\n        return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\n      }\n\n      if (!AutomatorData.isWaiting) {\n        AutomatorData.logCommandEvent(`Started WAIT for ${prestigeName}`, ctx.startLine);\n        AutomatorData.waitStart = Date.now();\n      }\n\n      AutomatorData.isWaiting = true;\n      return AUTOMATOR_COMMAND_STATUS.NEXT_TICK_SAME_INSTRUCTION;\n    };\n  },\n  blockify: ctx => _objectSpread({\n    genericInput1: ctx.PrestigeEvent[0].tokenType.name.toUpperCase()\n  }, automatorBlocksMap.WAIT)\n}, {\n  id: \"waitBlackHole\",\n  rule: $ => () => {\n    $.CONSUME(T.Wait);\n    $.CONSUME(T.BlackHole);\n    $.OR([{\n      ALT: () => $.CONSUME(T.Off)\n    }, {\n      ALT: () => $.CONSUME(T.BlackHoleStr)\n    }]);\n  },\n  validate: ctx => {\n    ctx.startLine = ctx.Wait[0].startLine;\n    return true;\n  },\n  compile: ctx => () => {\n    const off = Boolean(ctx.Off); // This input has the format \"bh#\"\n\n    const holeID = ctx.BlackHoleStr ? Number(ctx.BlackHoleStr[0].image.charAt(2)) : 0;\n    const bhCond = off ? !BlackHole(1).isActive : BlackHole(holeID).isActive;\n    const bhStr = off ? \"inactive Black Holes\" : `active Black Hole ${holeID}`;\n\n    if (bhCond) {\n      const timeWaited = TimeSpan.fromMilliseconds(Date.now() - AutomatorData.waitStart).toStringShort();\n      AutomatorData.logCommandEvent(`Continuing after WAIT (waited ${timeWaited} for ${bhStr})`, ctx.startLine);\n      AutomatorData.isWaiting = false;\n      return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\n    }\n\n    if (!AutomatorData.isWaiting) {\n      AutomatorData.logCommandEvent(`Started WAIT for ${bhStr}`, ctx.startLine);\n      AutomatorData.waitStart = Date.now();\n    }\n\n    AutomatorData.isWaiting = true;\n    return AUTOMATOR_COMMAND_STATUS.NEXT_TICK_SAME_INSTRUCTION;\n  },\n  blockify: ctx => _objectSpread({\n    genericInput1: \"BLACK HOLE\",\n    // Note: In this particular case we aren't actually storing a comparison operator. This is still okay\n    // because internally this is just the variable for the second slot and has no special treatment beyond that\n    compOperator: ctx.BlackHoleStr ? ctx.BlackHoleStr[0].image.toUpperCase() : \"OFF\"\n  }, automatorBlocksMap.WAIT)\n}, {\n  id: \"whileLoop\",\n  rule: $ => () => {\n    $.CONSUME(T.While);\n    $.SUBRULE($.comparison);\n    $.CONSUME(T.LCurly);\n    $.CONSUME(T.EOL);\n    $.SUBRULE($.block);\n    $.CONSUME(T.RCurly);\n  },\n  validate: (ctx, V) => {\n    ctx.startLine = ctx.While[0].startLine;\n    return V.checkBlock(ctx, ctx.While);\n  },\n  compile: (ctx, C) => compileConditionLoop(C.visit(ctx.comparison), C.visit(ctx.block), ctx, false),\n  blockify: (ctx, B) => {\n    const commands = [];\n    B.visit(ctx.block, commands);\n    const comparison = B.visit(ctx.comparison);\n    return _objectSpread(_objectSpread(_objectSpread({\n      nest: commands\n    }, automatorBlocksMap.WHILE), comparison), {}, {\n      genericInput1: standardizeAutomatorValues(comparison.genericInput1),\n      genericInput2: standardizeAutomatorValues(comparison.genericInput2)\n    });\n  }\n}, {\n  id: \"stop\",\n  rule: $ => () => {\n    $.CONSUME(T.Stop);\n  },\n  validate: ctx => {\n    ctx.startLine = ctx.Stop[0].startLine;\n    return true;\n  },\n  compile: ctx => () => {\n    AutomatorData.logCommandEvent(`Automator execution stopped with STOP command`, ctx.startLine);\n    return AUTOMATOR_COMMAND_STATUS.HALT;\n  },\n  blockify: () => _objectSpread({}, automatorBlocksMap.STOP)\n}];","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/automator/automator-commands.js"],"names":["standardizeAutomatorValues","tokenMap","T","presetSplitter","idSplitter","prestigeNotify","flag","AutomatorBackend","isOn","state","stack","top","commandState","prestigeLevel","undefined","Math","max","EventHub","logic","on","GAME_EVENT","BIG_CRUNCH_AFTER","Infinity","$prestigeLevel","ETERNITY_RESET_AFTER","Eternity","REALITY_RESET_AFTER","Reality","compileConditionLoop","evalComparison","commands","ctx","isUntil","run","loopStr","AutomatorData","logCommandEvent","parseConditionalIntoText","translateLineNumber","RCurly","startLine","AUTOMATOR_COMMAND_STATUS","NEXT_TICK_NEXT_INSTRUCTION","push","LCurly","SAME_INSTRUCTION","blockCommands","comp","comparison","children","getters","compareValue","map","cv","AutomatorCurrency","image","val","$value","format","compareFn","ComparisonOperator","findLastPrestigeRecord","layer","addedECs","gainedEP","player","records","recentInfinities","lastECCompletionCount","recentEternities","recentRealities","Error","AutomatorCommands","id","rule","$","CONSUME","Auto","PrestigeEvent","OR","ALT","On","Off","OR1","SUBRULE","duration","xHighest","currencyAmount","validate","V","desired$","tokenType","$prestigeCurrency","specified$","name","addError","advSetting","Autobuyer","bigCrunch","isUnlocked","EternityMilestone","bigCrunchModes","isReached","quantifyInt","config","eternities","autobuyerEternity","RealityUpgrade","isBought","compile","isReality","Boolean","fixedAmount","durationMode","$autobuyerDurationMode","xHighestMode","$autobuyerXHighestMode","fixedMode","$autobuyerCurrencyMode","autobuyer","$autobuyer","isActive","currSetting","mode","time","formatInt","quantify","Decimal","rm","amount","settingString","NEXT_INSTRUCTION","blockify","NumberLiteral","TimeUnit","toUpperCase","input","singleSelectionInput","singleTextInput","automatorBlocksMap","AUTO","BlackHole","BlackHoles","arePaused","togglePause","blackHoleEvent","Enslaved","isRunning","Pelle","isDisabled","Blob","SKIP_INSTRUCTION","BLOB","Comment","COMMENT","replace","If","EOL","block","checkBlock","C","visit","S","advanceOnPop","ifEndLine","B","nest","IF","genericInput1","genericInput2","Notify","StringLiteral","StringLiteralSingleQuote","notifyText","GameUI","notify","automator","NOTIFY","Pause","Identifier","isValidVarFormat","AUTOMATOR_VAR_TYPES","DURATION","Number","MAX_VALUE","lookup","lookupVar","value","$duration","timeString","c","TimeSpan","fromMilliseconds","timeMs","Time","unscaledDeltaTime","totalMilliseconds","getGlobalSpeedFactor","currentInterval","finishPause","NEXT_TICK_SAME_INSTRUCTION","blockArg","PAUSE","OPTION","Nowait","OPTION1","Respec","nowait","respec","prestigeToken","available","$prestigeAvailable","$respec","$prestige","prestigeName","forceRestart","RESTART","Start","Dilation","dilation","active","startDilatedEternity","START","eternityChallenge","ecNumber","$ecNumber","ec","EternityChallenge","TimeStudy","purchase","start","StoreGameTime","Use","useStoredTime","celestials","enslaved","isStoring","toggleStoreBlackHole","Studies","Purchase","studyList","CONSUME1","STUDIES","varInfo","$studies","studies","prePurchasedStudies","purchasedStudies","finalPurchasedTS","tsNumber","normal","length","hasEC","startEC","unlockedEC","Load","Id","Name","split","exec","isInsertedInRecovery","parseInt","$presetIndex","presetIndex","timestudy","presets","findIndex","e","imported","TimeStudyTree","beforeCount","GameCache","currentStudyTree","commitToGameState","afterCount","missingStudyCount","filter","s","includes","presetRepresentation","Unlock","PlayerProgress","dilationUnlocked","unlockedThisTick","UNLOCK","purchased","Until","UNTIL","Wait","doneWaiting","timeWaited","Date","now","waitStart","toStringShort","isWaiting","WAIT","prestigeOccurred","BlackHoleStr","off","holeID","charAt","bhCond","bhStr","compOperator","While","WHILE","Stop","HALT","STOP"],"mappings":"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","sourcesContent":["import { standardizeAutomatorValues, tokenMap as T } from \"./lexer\";\r\n\r\n/**\r\n * Note: the $ shorthand for the parser object is required by Chevrotain. Don't mess with it.\r\n */\r\n\r\nconst presetSplitter = /name[ \\t]+(.+$)/ui;\r\nconst idSplitter = /id[ \\t]+(\\d)/ui;\r\n\r\nfunction prestigeNotify(flag) {\r\n  if (!AutomatorBackend.isOn) return;\r\n  const state = AutomatorBackend.stack.top.commandState;\r\n  if (state && state.prestigeLevel !== undefined) {\r\n    state.prestigeLevel = Math.max(state.prestigeLevel, flag);\r\n  }\r\n}\r\n\r\nEventHub.logic.on(GAME_EVENT.BIG_CRUNCH_AFTER, () => prestigeNotify(T.Infinity.$prestigeLevel));\r\nEventHub.logic.on(GAME_EVENT.ETERNITY_RESET_AFTER, () => prestigeNotify(T.Eternity.$prestigeLevel));\r\nEventHub.logic.on(GAME_EVENT.REALITY_RESET_AFTER, () => prestigeNotify(T.Reality.$prestigeLevel));\r\n\r\n// Used by while and until - in order to get the text corrext, we need to invert the boolean if it's an until\r\n// eslint-disable-next-line max-params\r\nfunction compileConditionLoop(evalComparison, commands, ctx, isUntil) {\r\n  return {\r\n    run: () => {\r\n      const loopStr = isUntil ? \"UNTIL\" : \"WHILE\";\r\n      if (!evalComparison()) {\r\n        AutomatorData.logCommandEvent(`Checked ${parseConditionalIntoText(ctx)} (${isUntil}),\r\n          exiting loop at line ${AutomatorBackend.translateLineNumber(ctx.RCurly[0].startLine + 1) - 1}\r\n          (end of ${loopStr} loop)`, ctx.startLine);\r\n        return AUTOMATOR_COMMAND_STATUS.NEXT_TICK_NEXT_INSTRUCTION;\r\n      }\r\n      AutomatorBackend.push(commands);\r\n      AutomatorData.logCommandEvent(`Checked ${parseConditionalIntoText(ctx)} (${!isUntil}),\r\n        moving to line ${AutomatorBackend.translateLineNumber(ctx.LCurly[0].startLine + 1) - 1}\r\n        (start of ${loopStr} loop)`, ctx.startLine);\r\n      return AUTOMATOR_COMMAND_STATUS.SAME_INSTRUCTION;\r\n    },\r\n    blockCommands: commands,\r\n  };\r\n}\r\n\r\n// Extracts the conditional out of a command and returns it as text\r\nfunction parseConditionalIntoText(ctx) {\r\n  const comp = ctx.comparison[0].children;\r\n  const getters = comp.compareValue.map(cv => {\r\n    if (cv.children.AutomatorCurrency) return () => cv.children.AutomatorCurrency[0].image;\r\n    const val = cv.children.$value;\r\n    if (typeof val === \"string\") return () => val;\r\n    return () => format(val, 2, 2);\r\n  });\r\n  const compareFn = comp.ComparisonOperator[0].image;\r\n  return `${getters[0]()} ${compareFn} ${getters[1]()}`;\r\n}\r\n\r\n// Determines how much (prestige currency) the previous (layer) reset gave, for event logging\r\nfunction findLastPrestigeRecord(layer) {\r\n  let addedECs, gainedEP;\r\n  switch (layer) {\r\n    case \"INFINITY\":\r\n      return `${format(player.records.recentInfinities[0][1], 2)} IP`;\r\n    case \"ETERNITY\":\r\n      addedECs = AutomatorData.lastECCompletionCount;\r\n      gainedEP = `${format(player.records.recentEternities[0][1], 2)} EP`;\r\n      return addedECs === 0\r\n        ? `${gainedEP}`\r\n        : `${gainedEP}, ${addedECs} completions`;\r\n    case \"REALITY\":\r\n      return `${format(player.records.recentRealities[0][1], 2)} RM`;\r\n    default:\r\n      throw Error(`Unrecognized prestige ${layer} in Automator event log`);\r\n  }\r\n}\r\n\r\nexport const AutomatorCommands = [\r\n  {\r\n    id: \"auto\",\r\n    rule: $ => () => {\r\n      $.CONSUME(T.Auto);\r\n      $.CONSUME(T.PrestigeEvent);\r\n      $.OR([\r\n        { ALT: () => $.CONSUME(T.On) },\r\n        { ALT: () => $.CONSUME(T.Off) },\r\n        { ALT: () => $.OR1([\r\n          { ALT: () => $.SUBRULE($.duration) },\r\n          { ALT: () => $.SUBRULE($.xHighest) },\r\n          { ALT: () => $.SUBRULE($.currencyAmount) },\r\n        ]) },\r\n      ]);\r\n    },\r\n    // eslint-disable-next-line complexity\r\n    validate: (ctx, V) => {\r\n      ctx.startLine = ctx.Auto[0].startLine;\r\n      if (ctx.PrestigeEvent && ctx.currencyAmount) {\r\n        const desired$ = ctx.PrestigeEvent[0].tokenType.$prestigeCurrency;\r\n        const specified$ = ctx.currencyAmount[0].children.AutomatorCurrency[0].tokenType.name;\r\n        if (desired$ !== specified$) {\r\n          V.addError(ctx.currencyAmount, `AutomatorCurrency doesn't match prestige (${desired$} vs ${specified$})`,\r\n            `Use ${desired$} for the specified prestige resource`);\r\n          return false;\r\n        }\r\n      }\r\n\r\n      if (!ctx.PrestigeEvent) return true;\r\n      const advSetting = ctx.duration || ctx.xHighest;\r\n      // Do not change to switch statement; T.XXX are Objects, not primitive values\r\n      if (ctx.PrestigeEvent[0].tokenType === T.Infinity) {\r\n        if (!Autobuyer.bigCrunch.isUnlocked) {\r\n          V.addError(ctx.PrestigeEvent, \"Infinity autobuyer is not unlocked\",\r\n            \"Complete the Big Crunch Autobuyer challenge to use this command\");\r\n          return false;\r\n        }\r\n        if (advSetting && !EternityMilestone.bigCrunchModes.isReached) {\r\n          V.addError((ctx.duration || ctx.xHighest)[0],\r\n            \"Advanced Infinity autobuyer settings are not unlocked\",\r\n            `Reach ${quantifyInt(\"Eternity\", EternityMilestone.bigCrunchModes.config.eternities)}\r\n            to use this command`);\r\n          return false;\r\n        }\r\n      }\r\n      if (ctx.PrestigeEvent[0].tokenType === T.Eternity) {\r\n        if (!EternityMilestone.autobuyerEternity.isReached) {\r\n          V.addError(ctx.PrestigeEvent, \"Eternity autobuyer is not unlocked\",\r\n            `Reach ${quantifyInt(\"Eternity\", EternityMilestone.autobuyerEternity.config.eternities)}\r\n            to use this command`);\r\n          return false;\r\n        }\r\n        if (advSetting && !RealityUpgrade(13).isBought) {\r\n          V.addError((ctx.duration || ctx.xHighest)[0],\r\n            \"Advanced Eternity autobuyer settings are not unlocked\",\r\n            \"Purchase the Reality Upgrade which unlocks advanced Eternity autobuyer settings\");\r\n          return false;\r\n        }\r\n      }\r\n      if (ctx.PrestigeEvent[0].tokenType === T.Reality) {\r\n        if (!RealityUpgrade(25).isBought) {\r\n          V.addError(ctx.PrestigeEvent, \"Reality autobuyer is not unlocked\",\r\n            \"Purchase the Reality Upgrade which unlocks the Reality autobuyer\");\r\n          return false;\r\n        }\r\n        if (advSetting) {\r\n          V.addError((ctx.duration || ctx.xHighest)[0],\r\n            \"Auto Reality cannot be set to a duration or x highest\",\r\n            \"Use RM for Auto Reality\");\r\n          return false;\r\n        }\r\n      }\r\n\r\n      return true;\r\n    },\r\n    compile: ctx => {\r\n      const isReality = ctx.PrestigeEvent[0].tokenType === T.Reality;\r\n      const on = Boolean(ctx.On || ctx.duration || ctx.xHighest || ctx.currencyAmount);\r\n      const duration = ctx.duration ? ctx.duration[0].children.$value : undefined;\r\n      const xHighest = ctx.xHighest ? ctx.xHighest[0].children.$value : undefined;\r\n      const fixedAmount = ctx.currencyAmount ? ctx.currencyAmount[0].children.$value : undefined;\r\n      const durationMode = ctx.PrestigeEvent[0].tokenType.$autobuyerDurationMode;\r\n      const xHighestMode = ctx.PrestigeEvent[0].tokenType.$autobuyerXHighestMode;\r\n      const fixedMode = ctx.PrestigeEvent[0].tokenType.$autobuyerCurrencyMode;\r\n      const autobuyer = ctx.PrestigeEvent[0].tokenType.$autobuyer();\r\n      return () => {\r\n        autobuyer.isActive = on;\r\n        let currSetting = \"\";\r\n        if (duration !== undefined) {\r\n          autobuyer.mode = durationMode;\r\n          autobuyer.time = duration / 1000;\r\n          // Can't do the units provided in the script because it's been parsed away like 4 layers up the call stack\r\n          currSetting = `${autobuyer.time > 1000 ? formatInt(autobuyer.time) : quantify(\"second\", autobuyer.time)}`;\r\n        } else if (xHighest !== undefined) {\r\n          autobuyer.mode = xHighestMode;\r\n          autobuyer.xHighest = new Decimal(xHighest);\r\n          currSetting = `${format(xHighest, 2, 2)} times highest`;\r\n        } else if (fixedAmount !== undefined) {\r\n          autobuyer.mode = fixedMode;\r\n          if (isReality) {\r\n            autobuyer.rm = new Decimal(fixedAmount);\r\n            currSetting = `${format(autobuyer.rm, 2)} RM`;\r\n          } else {\r\n            autobuyer.amount = new Decimal(fixedAmount);\r\n            currSetting = `${fixedAmount} ${ctx.PrestigeEvent[0].image === \"infinity\" ? \"IP\" : \"EP\"}`;\r\n          }\r\n        }\r\n        // Settings are drawn from the actual automator text; it's not feasible to parse out all the settings\r\n        // for every combination of autobuyers when they get turned off\r\n        const settingString = (autobuyer.isActive && currSetting !== \"\") ? `(Setting: ${currSetting})` : \"\";\r\n        AutomatorData.logCommandEvent(`Automatic ${ctx.PrestigeEvent[0].image}\r\n          turned ${autobuyer.isActive ? \"ON\" : \"OFF\"} ${settingString}`, ctx.startLine);\r\n        return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\r\n      };\r\n    },\r\n    blockify: ctx => {\r\n      const duration = ctx.duration\r\n        ? `${ctx.duration[0].children.NumberLiteral[0].image} ${ctx.duration[0].children.TimeUnit[0].image}`\r\n        : undefined;\r\n      const xHighest = ctx.xHighest ? ctx.xHighest[0].children.$value : undefined;\r\n      const fixedAmount = ctx.currencyAmount\r\n        ? `${ctx.currencyAmount[0].children.NumberLiteral[0].image}` +\r\n          ` ${ctx.currencyAmount[0].children.AutomatorCurrency[0].image.toUpperCase()}`\r\n        : undefined;\r\n      const on = Boolean(ctx.On);\r\n      let input = \"\";\r\n\r\n      if (duration) input = duration;\r\n      else if (xHighest) input = `${xHighest} x highest`;\r\n      else if (fixedAmount) input = `${fixedAmount}`;\r\n      else input = (on ? \"ON\" : \"OFF\");\r\n\r\n      return {\r\n        singleSelectionInput: ctx.PrestigeEvent[0].tokenType.name.toUpperCase(),\r\n        singleTextInput: input,\r\n        ...automatorBlocksMap.AUTO\r\n      };\r\n    }\r\n  },\r\n  {\r\n    id: \"blackHole\",\r\n    rule: $ => () => {\r\n      $.CONSUME(T.BlackHole);\r\n      $.OR([\r\n        { ALT: () => $.CONSUME(T.On) },\r\n        { ALT: () => $.CONSUME(T.Off) },\r\n      ]);\r\n    },\r\n    validate: ctx => {\r\n      ctx.startLine = ctx.BlackHole[0].startLine;\r\n      return true;\r\n    },\r\n    compile: ctx => {\r\n      const on = Boolean(ctx.On);\r\n      return () => {\r\n        if (on === BlackHoles.arePaused) BlackHoles.togglePause();\r\n        let blackHoleEvent;\r\n        if (BlackHole(1).isUnlocked) {\r\n          blackHoleEvent = `Black Holes toggled ${ctx.On ? \"ON\" : \"OFF\"}`;\r\n        } else if (Enslaved.isRunning || Pelle.isDisabled(\"blackhole\")) {\r\n          blackHoleEvent = \"Black Hole command ignored because BH is disabled in your current Reality\";\r\n        } else {\r\n          blackHoleEvent = \"Black Hole command ignored because BH is not unlocked\";\r\n        }\r\n        AutomatorData.logCommandEvent(blackHoleEvent, ctx.startLine);\r\n        return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\r\n      };\r\n    },\r\n    blockify: ctx => ({\r\n      singleSelectionInput: ctx.On ? \"ON\" : \"OFF\",\r\n      ...automatorBlocksMap[\"BLACK HOLE\"]\r\n    })\r\n  },\r\n  {\r\n    id: \"blob\",\r\n    rule: $ => () => {\r\n      $.CONSUME(T.Blob);\r\n    },\r\n    validate: ctx => {\r\n      ctx.startLine = ctx.Blob[0].startLine;\r\n      return true;\r\n    },\r\n    // This is an easter egg, it shouldn't do anything\r\n    compile: () => () => AUTOMATOR_COMMAND_STATUS.SKIP_INSTRUCTION,\r\n    blockify: () => ({\r\n      ...automatorBlocksMap.BLOB,\r\n    })\r\n  },\r\n  {\r\n    id: \"comment\",\r\n    rule: $ => () => {\r\n      $.CONSUME(T.Comment);\r\n    },\r\n    validate: ctx => {\r\n      ctx.startLine = ctx.Comment[0].startLine;\r\n      return true;\r\n    },\r\n    // Comments should be no-ops\r\n    compile: () => () => AUTOMATOR_COMMAND_STATUS.SKIP_INSTRUCTION,\r\n    blockify: ctx => ({\r\n      ...automatorBlocksMap.COMMENT,\r\n      singleTextInput: ctx.Comment[0].image.replace(/(#|\\/\\/)\\s?/u, \"\"),\r\n    })\r\n  },\r\n  {\r\n    id: \"ifBlock\",\r\n    rule: $ => () => {\r\n      $.CONSUME(T.If);\r\n      $.SUBRULE($.comparison);\r\n      $.CONSUME(T.LCurly);\r\n      $.CONSUME(T.EOL);\r\n      $.SUBRULE($.block);\r\n      $.CONSUME(T.RCurly);\r\n    },\r\n    validate: (ctx, V) => {\r\n      ctx.startLine = ctx.If[0].startLine;\r\n      return V.checkBlock(ctx, ctx.If);\r\n    },\r\n    compile: (ctx, C) => {\r\n      const evalComparison = C.visit(ctx.comparison);\r\n      const commands = C.visit(ctx.block);\r\n      return {\r\n        run: S => {\r\n          // If the commandState is empty, it means we haven't evaluated the if yet\r\n          if (S.commandState !== null) return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\r\n          // We use this flag to make \"single step\" advance to the next command after the if when the block ends\r\n          S.commandState = {\r\n            advanceOnPop: true,\r\n            ifEndLine: ctx.RCurly[0].startLine\r\n          };\r\n          if (!evalComparison()) {\r\n            AutomatorData.logCommandEvent(`Checked ${parseConditionalIntoText(ctx)} (false),\r\n              skipping to line ${AutomatorBackend.translateLineNumber(ctx.RCurly[0].startLine + 1)}`, ctx.startLine);\r\n            return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\r\n          }\r\n          AutomatorBackend.push(commands);\r\n          AutomatorData.logCommandEvent(`Checked ${parseConditionalIntoText(ctx)} (true),\r\n            entering IF block`, ctx.startLine);\r\n          return AUTOMATOR_COMMAND_STATUS.SAME_INSTRUCTION;\r\n        },\r\n        blockCommands: commands,\r\n      };\r\n    },\r\n    blockify: (ctx, B) => {\r\n      const commands = [];\r\n      B.visit(ctx.block, commands);\r\n      const comparison = B.visit(ctx.comparison);\r\n      return {\r\n        nest: commands,\r\n        ...automatorBlocksMap.IF,\r\n        ...comparison,\r\n        genericInput1: standardizeAutomatorValues(comparison.genericInput1),\r\n        genericInput2: standardizeAutomatorValues(comparison.genericInput2)\r\n      };\r\n    }\r\n  },\r\n  {\r\n    id: \"notify\",\r\n    rule: $ => () => {\r\n      $.CONSUME(T.Notify);\r\n      $.OR([\r\n        { ALT: () => $.CONSUME(T.StringLiteral) },\r\n        { ALT: () => $.CONSUME(T.StringLiteralSingleQuote) },\r\n      ]);\r\n    },\r\n    validate: ctx => {\r\n      ctx.startLine = ctx.Notify[0].startLine;\r\n      return true;\r\n    },\r\n    compile: ctx => {\r\n      const notifyText = ctx.StringLiteral || ctx.StringLiteralSingleQuote;\r\n      return () => {\r\n        GameUI.notify.automator(`Automator: ${notifyText[0].image}`);\r\n        AutomatorData.logCommandEvent(`NOTIFY call: ${notifyText[0].image}`, ctx.startLine);\r\n        return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\r\n      };\r\n    },\r\n    blockify: ctx => ({\r\n      ...automatorBlocksMap.NOTIFY,\r\n      singleTextInput: (ctx.StringLiteral || ctx.StringLiteralSingleQuote)[0].image,\r\n    })\r\n  },\r\n  {\r\n    // Note: this has to appear before pause\r\n    id: \"pauseTime\",\r\n    rule: $ => () => {\r\n      $.CONSUME(T.Pause);\r\n      $.OR([\r\n        { ALT: () => $.SUBRULE($.duration) },\r\n        { ALT: () => $.CONSUME(T.Identifier) },\r\n      ]);\r\n    },\r\n    validate: (ctx, V) => {\r\n      ctx.startLine = ctx.Pause[0].startLine;\r\n      let duration;\r\n      if (ctx.Identifier) {\r\n        if (!V.isValidVarFormat(ctx.Identifier[0], AUTOMATOR_VAR_TYPES.DURATION)) {\r\n          V.addError(ctx, `Constant ${ctx.Identifier[0].image} is not a valid time duration constant`,\r\n            `Ensure that ${ctx.Identifier[0].image} is a number of seconds less than\r\n            ${format(Number.MAX_VALUE / 1000)}`);\r\n          return false;\r\n        }\r\n        const lookup = V.lookupVar(ctx.Identifier[0], AUTOMATOR_VAR_TYPES.DURATION);\r\n        duration = lookup ? lookup.value : lookup;\r\n      } else {\r\n        duration = V.visit(ctx.duration);\r\n      }\r\n      ctx.$duration = duration;\r\n      return ctx.$duration !== undefined;\r\n    },\r\n    compile: ctx => {\r\n      const duration = ctx.$duration;\r\n      return S => {\r\n        let timeString;\r\n        if (ctx.duration) {\r\n          const c = ctx.duration[0].children;\r\n          timeString = `${c.NumberLiteral[0].image} ${c.TimeUnit[0].image}`;\r\n        } else {\r\n          // This is the case for a defined constant; its value was parsed out during validation\r\n          timeString = TimeSpan.fromMilliseconds(duration);\r\n        }\r\n        if (S.commandState === null) {\r\n          S.commandState = { timeMs: 0 };\r\n          AutomatorData.logCommandEvent(`Pause started (waiting ${timeString})`, ctx.startLine);\r\n        } else {\r\n          S.commandState.timeMs += Math.max(Time.unscaledDeltaTime.totalMilliseconds / getGlobalSpeedFactor(), AutomatorBackend.currentInterval);\r\n        }\r\n        const finishPause = S.commandState.timeMs >= duration;\r\n        if (finishPause) {\r\n          AutomatorData.logCommandEvent(`Pause finished (waited ${timeString})`, ctx.startLine);\r\n          return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\r\n        }\r\n        return AUTOMATOR_COMMAND_STATUS.NEXT_TICK_SAME_INSTRUCTION;\r\n      };\r\n    },\r\n    blockify: ctx => {\r\n      let blockArg;\r\n      if (ctx.duration) {\r\n        const c = ctx.duration[0].children;\r\n        blockArg = `${c.NumberLiteral[0].image} ${c.TimeUnit[0].image}`;\r\n      } else {\r\n        blockArg = `${ctx.Identifier[0].image}`;\r\n      }\r\n      return {\r\n        ...automatorBlocksMap.PAUSE,\r\n        singleTextInput: blockArg\r\n      };\r\n    }\r\n  },\r\n  {\r\n    id: \"prestige\",\r\n    rule: $ => () => {\r\n      $.CONSUME(T.PrestigeEvent);\r\n      $.OPTION(() => $.CONSUME(T.Nowait));\r\n      $.OPTION1(() => $.CONSUME(T.Respec));\r\n    },\r\n    validate: (ctx, V) => {\r\n      ctx.startLine = ctx.PrestigeEvent[0].startLine;\r\n\r\n      if (ctx.PrestigeEvent && ctx.PrestigeEvent[0].tokenType === T.Eternity &&\r\n        !EternityMilestone.autobuyerEternity.isReached) {\r\n        V.addError(ctx.PrestigeEvent, \"Eternity autobuyer is not unlocked\",\r\n          `Reach ${quantifyInt(\"Eternity\", EternityMilestone.autobuyerEternity.config.eternities)}\r\n          to use this command`);\r\n        return false;\r\n      }\r\n\r\n      if (ctx.PrestigeEvent && ctx.PrestigeEvent[0].tokenType === T.Reality && !RealityUpgrade(25).isBought) {\r\n        V.addError(ctx.PrestigeEvent, \"Reality autobuyer is not unlocked\",\r\n          \"Purchase the Reality Upgrade which unlocks the Reality autobuyer\");\r\n        return false;\r\n      }\r\n\r\n      if (ctx.PrestigeEvent && ctx.PrestigeEvent[0].tokenType === T.Infinity && ctx.Respec) {\r\n        V.addError(ctx.Respec, \"There's no 'respec' for infinity\",\r\n          \"Remove 'respec' from the command\");\r\n      }\r\n      return true;\r\n    },\r\n    compile: ctx => {\r\n      const nowait = ctx.Nowait !== undefined;\r\n      const respec = ctx.Respec !== undefined;\r\n      const prestigeToken = ctx.PrestigeEvent[0].tokenType;\r\n      return () => {\r\n        const available = prestigeToken.$prestigeAvailable();\r\n        if (!available) {\r\n          if (!nowait) return AUTOMATOR_COMMAND_STATUS.NEXT_TICK_SAME_INSTRUCTION;\r\n          AutomatorData.logCommandEvent(`${ctx.PrestigeEvent.image} attempted, but skipped due to NOWAIT`,\r\n            ctx.startLine);\r\n          return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\r\n        }\r\n        if (respec) prestigeToken.$respec();\r\n        prestigeToken.$prestige();\r\n        const prestigeName = ctx.PrestigeEvent[0].image.toUpperCase();\r\n        AutomatorData.logCommandEvent(`${prestigeName} triggered (${findLastPrestigeRecord(prestigeName)})`,\r\n          ctx.startLine);\r\n        // In the prestigeToken.$prestige() line above, performing a reality reset has code internal to the call\r\n        // which makes the automator restart. However, in that case we also need to update the execution state here,\r\n        // or else the restarted automator will immediately advance lines and always skip the first command\r\n        return (prestigeName === \"REALITY\" && AutomatorBackend.state.forceRestart)\r\n          ? AUTOMATOR_COMMAND_STATUS.RESTART\r\n          : AUTOMATOR_COMMAND_STATUS.NEXT_TICK_NEXT_INSTRUCTION;\r\n      };\r\n    },\r\n    blockify: ctx => ({\r\n      ...automatorBlocksMap[\r\n        ctx.PrestigeEvent[0].tokenType.name.toUpperCase()\r\n      ],\r\n      nowait: ctx.Nowait !== undefined,\r\n      respec: ctx.Respec !== undefined\r\n    })\r\n  },\r\n  {\r\n    id: \"startDilation\",\r\n    rule: $ => () => {\r\n      $.CONSUME(T.Start);\r\n      $.CONSUME(T.Dilation);\r\n    },\r\n    validate: ctx => {\r\n      ctx.startLine = ctx.Start[0].startLine;\r\n      return true;\r\n    },\r\n    compile: ctx => () => {\r\n      if (player.dilation.active) {\r\n        AutomatorData.logCommandEvent(`Start Dilation encountered but ignored due to already being dilated`,\r\n          ctx.startLine);\r\n        return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\r\n      }\r\n      if (startDilatedEternity(true)) {\r\n        AutomatorData.logCommandEvent(`Dilation entered`, ctx.startLine);\r\n        return AUTOMATOR_COMMAND_STATUS.NEXT_TICK_NEXT_INSTRUCTION;\r\n      }\r\n      return AUTOMATOR_COMMAND_STATUS.NEXT_TICK_SAME_INSTRUCTION;\r\n    },\r\n    blockify: () => ({ singleSelectionInput: \"DILATION\", ...automatorBlocksMap.START })\r\n  },\r\n  {\r\n    id: \"startEC\",\r\n    rule: $ => () => {\r\n      $.CONSUME(T.Start);\r\n      $.SUBRULE($.eternityChallenge);\r\n    },\r\n    validate: ctx => {\r\n      ctx.startLine = ctx.Start[0].startLine;\r\n      return true;\r\n    },\r\n    compile: ctx => {\r\n      const ecNumber = ctx.eternityChallenge[0].children.$ecNumber;\r\n      return () => {\r\n        const ec = EternityChallenge(ecNumber);\r\n        if (ec.isRunning) {\r\n          AutomatorData.logCommandEvent(`Start EC encountered but ignored due to already being in the specified EC`,\r\n            ctx.startLine);\r\n          return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\r\n        }\r\n        if (!EternityChallenge(ecNumber).isUnlocked) {\r\n          if (!TimeStudy.eternityChallenge(ecNumber).purchase(true)) {\r\n            return AUTOMATOR_COMMAND_STATUS.NEXT_TICK_SAME_INSTRUCTION;\r\n          }\r\n        }\r\n        if (ec.start(true)) {\r\n          AutomatorData.logCommandEvent(`Eternity Challenge ${ecNumber} started`, ctx.startLine);\r\n          return AUTOMATOR_COMMAND_STATUS.NEXT_TICK_NEXT_INSTRUCTION;\r\n        }\r\n        return AUTOMATOR_COMMAND_STATUS.NEXT_TICK_SAME_INSTRUCTION;\r\n      };\r\n    },\r\n    blockify: ctx => ({\r\n      singleSelectionInput: \"EC\",\r\n      singleTextInput: ctx.eternityChallenge[0].children.$ecNumber,\r\n      ...automatorBlocksMap.START\r\n    })\r\n  },\r\n  {\r\n    id: \"storeGameTime\",\r\n    rule: $ => () => {\r\n      $.CONSUME(T.StoreGameTime);\r\n      $.OR([\r\n        { ALT: () => $.CONSUME(T.On) },\r\n        { ALT: () => $.CONSUME(T.Off) },\r\n        { ALT: () => $.CONSUME(T.Use) },\r\n      ]);\r\n    },\r\n    validate: (ctx, V) => {\r\n      ctx.startLine = ctx.StoreGameTime[0].startLine;\r\n      if (!Enslaved.isUnlocked) {\r\n        V.addError(ctx.StoreGameTime[0], \"You do not yet know how to store game time\",\r\n          \"Unlock the ability to store game time\");\r\n        return false;\r\n      }\r\n      return true;\r\n    },\r\n    compile: ctx => {\r\n      if (ctx.Use) return () => {\r\n        if (Enslaved.isUnlocked) {\r\n          Enslaved.useStoredTime(false);\r\n          AutomatorData.logCommandEvent(`Stored game time used`, ctx.startLine);\r\n        } else {\r\n          AutomatorData.logCommandEvent(`Attempted to use stored game time, but failed (not unlocked yet)`,\r\n            ctx.startLine);\r\n        }\r\n        return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\r\n      };\r\n      const on = Boolean(ctx.On);\r\n      return () => {\r\n        if (on !== player.celestials.enslaved.isStoring) Enslaved.toggleStoreBlackHole();\r\n        AutomatorData.logCommandEvent(`Storing game time toggled ${ctx.On ? \"ON\" : \"OFF\"}`, ctx.startLine);\r\n        return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\r\n      };\r\n    },\r\n    blockify: ctx => ({\r\n      // eslint-disable-next-line no-nested-ternary\r\n      singleSelectionInput: ctx.Use ? \"USE\" : (ctx.On ? \"ON\" : \"OFF\"),\r\n      ...automatorBlocksMap[\"STORE GAME TIME\"]\r\n    })\r\n  },\r\n  {\r\n    id: \"studiesBuy\",\r\n    rule: $ => () => {\r\n      $.CONSUME(T.Studies);\r\n      $.OPTION(() => $.CONSUME(T.Nowait));\r\n      $.CONSUME(T.Purchase);\r\n      $.OR([\r\n        { ALT: () => $.SUBRULE($.studyList) },\r\n        { ALT: () => $.CONSUME1(T.Identifier) },\r\n      ]);\r\n    },\r\n    validate: (ctx, V) => {\r\n      ctx.startLine = ctx.Studies[0].startLine;\r\n      if (ctx.Identifier) {\r\n        if (!V.isValidVarFormat(ctx.Identifier[0], AUTOMATOR_VAR_TYPES.STUDIES)) {\r\n          V.addError(ctx, `Constant ${ctx.Identifier[0].image} is not a valid Time Study constant`,\r\n            `Ensure that ${ctx.Identifier[0].image} is a properly-formatted Time Study string`);\r\n          return false;\r\n        }\r\n        const varInfo = V.lookupVar(ctx.Identifier[0], AUTOMATOR_VAR_TYPES.STUDIES);\r\n        ctx.$studies = varInfo.value;\r\n        ctx.$studies.image = ctx.Identifier[0].image;\r\n      } else if (ctx.studyList) {\r\n        ctx.$studies = V.visit(ctx.studyList);\r\n      }\r\n      return true;\r\n    },\r\n    compile: ctx => {\r\n      const studies = ctx.$studies;\r\n      if (ctx.Nowait === undefined) return () => {\r\n        let prePurchasedStudies = 0;\r\n        let purchasedStudies = 0;\r\n        let finalPurchasedTS;\r\n        for (const tsNumber of studies.normal) {\r\n          if (TimeStudy(tsNumber).isBought) prePurchasedStudies++;\r\n          else if (TimeStudy(tsNumber).purchase(true)) purchasedStudies++;\r\n          else finalPurchasedTS = finalPurchasedTS ?? tsNumber;\r\n        }\r\n        if (prePurchasedStudies + purchasedStudies < studies.normal.length) {\r\n          if (prePurchasedStudies + purchasedStudies === 0) {\r\n            AutomatorData.logCommandEvent(`Could not purchase any of the specified Time Studies`, ctx.startLine);\r\n          }\r\n          if (purchasedStudies > 0 && finalPurchasedTS) {\r\n            AutomatorData.logCommandEvent(`Purchased ${quantifyInt(\"Time Study\", purchasedStudies)} and stopped at\r\n            Time Study ${finalPurchasedTS}, waiting to attempt to purchase more Time Studies`, ctx.startLine);\r\n          }\r\n          return AUTOMATOR_COMMAND_STATUS.NEXT_TICK_SAME_INSTRUCTION;\r\n        }\r\n        const hasEC = studies.ec ? TimeStudy.eternityChallenge(studies.ec).isBought : false;\r\n        if (!studies.ec || (hasEC && !studies.startEC)) {\r\n          AutomatorData.logCommandEvent(`Purchased all specified Time Studies`, ctx.startLine);\r\n          return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\r\n        }\r\n        const unlockedEC = TimeStudy.eternityChallenge(studies.ec).purchase(true);\r\n        if (hasEC || unlockedEC) {\r\n          if (studies.startEC) {\r\n            EternityChallenge(studies.ec).start(true);\r\n            if (EternityChallenge(studies.ec).isRunning) {\r\n              AutomatorData.logCommandEvent(`Purchased all specified Time Studies, then unlocked and started running\r\n                Eternity Challenge ${studies.ec}`, ctx.startLine);\r\n            } else {\r\n              AutomatorData.logCommandEvent(`Purchased all specified Time Studies and unlocked Eternity Challenge\r\n                ${studies.ec}, but failed to start it`, ctx.startLine);\r\n            }\r\n          } else {\r\n            AutomatorData.logCommandEvent(`Purchased all specified Time Studies and unlocked Eternity Challenge\r\n              ${studies.ec}`, ctx.startLine);\r\n          }\r\n          return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\r\n        }\r\n        return AUTOMATOR_COMMAND_STATUS.NEXT_TICK_SAME_INSTRUCTION;\r\n      };\r\n      return () => {\r\n        for (const tsNumber of studies.normal) TimeStudy(tsNumber).purchase(true);\r\n        if (!studies.ec || TimeStudy.eternityChallenge(studies.ec).isBought) {\r\n          return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\r\n        }\r\n        TimeStudy.eternityChallenge(studies.ec).purchase(true);\r\n        return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\r\n      };\r\n    },\r\n    blockify: ctx => ({\r\n      singleTextInput: ctx.$studies.image,\r\n      nowait: ctx.Nowait !== undefined,\r\n      ...automatorBlocksMap[\"STUDIES PURCHASE\"]\r\n    })\r\n  },\r\n  {\r\n    id: \"studiesLoad\",\r\n    rule: $ => () => {\r\n      $.CONSUME(T.Studies);\r\n      $.OPTION(() => $.CONSUME(T.Nowait));\r\n      $.CONSUME(T.Load);\r\n      $.OR([\r\n        { ALT: () => $.CONSUME1(T.Id) },\r\n        { ALT: () => $.CONSUME1(T.Name) },\r\n      ]);\r\n    },\r\n    validate: (ctx, V) => {\r\n      ctx.startLine = ctx.Studies[0].startLine;\r\n\r\n      if (ctx.Id) {\r\n        const split = idSplitter.exec(ctx.Id[0].image);\r\n\r\n        if (!split || ctx.Id[0].isInsertedInRecovery) {\r\n          V.addError(ctx, \"Missing preset id\",\r\n            \"Provide the id of a saved study preset slot from the Time Studies page\");\r\n          return false;\r\n        }\r\n\r\n        const id = parseInt(split[1], 10);\r\n        if (id < 1 || id > 6) {\r\n          V.addError(ctx.Id[0], `Could not find a preset with an id of ${id}`,\r\n            \"Type in a valid id (1 - 6) for your study preset\");\r\n          return false;\r\n        }\r\n        ctx.$presetIndex = id;\r\n        return true;\r\n      }\r\n\r\n      if (ctx.Name) {\r\n        const split = presetSplitter.exec(ctx.Name[0].image);\r\n\r\n        if (!split || ctx.Name[0].isInsertedInRecovery) {\r\n          V.addError(ctx, \"Missing preset name\",\r\n            \"Provide the name of a saved study preset from the Time Studies page\");\r\n          return false;\r\n        }\r\n\r\n        // If it's a name, we check to make sure it exists:\r\n        const presetIndex = player.timestudy.presets.findIndex(e => e.name === split[1]) + 1;\r\n        if (presetIndex === 0) {\r\n          V.addError(ctx.Name[0], `Could not find preset named ${split[1]} (Note: Names are case-sensitive)`,\r\n            \"Check to make sure you typed in the correct name for your study preset\");\r\n          return false;\r\n        }\r\n        ctx.$presetIndex = presetIndex;\r\n        return true;\r\n      }\r\n      return false;\r\n    },\r\n    compile: ctx => {\r\n      const presetIndex = ctx.$presetIndex;\r\n      return () => {\r\n        const imported = new TimeStudyTree(player.timestudy.presets[presetIndex - 1].studies);\r\n        const beforeCount = GameCache.currentStudyTree.value.purchasedStudies.length;\r\n        TimeStudyTree.commitToGameState(imported.purchasedStudies, true, imported.startEC);\r\n        const afterCount = GameCache.currentStudyTree.value.purchasedStudies.length;\r\n        // Check if there are still any unbought studies from the preset after attempting to commit it all;\r\n        // if there are then we keep trying on this line until there aren't, unless we are given nowait\r\n        const missingStudyCount = imported.purchasedStudies\r\n          .filter(s => !GameCache.currentStudyTree.value.purchasedStudies.includes(s)).length;\r\n\r\n        const presetRepresentation = ctx.Name ? ctx.Name[0].image : ctx.Id[0].image;\r\n\r\n        if (missingStudyCount === 0) {\r\n          AutomatorData.logCommandEvent(`Fully loaded study preset ${presetRepresentation}`, ctx.startLine);\r\n        } else if (afterCount > beforeCount) {\r\n          AutomatorData.logCommandEvent(`Partially loaded study preset ${presetRepresentation}\r\n            (missing ${quantifyInt(\"study\", missingStudyCount)})`, ctx.startLine);\r\n        }\r\n        return ctx.Nowait !== undefined || missingStudyCount === 0\r\n          ? AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION\r\n          : AUTOMATOR_COMMAND_STATUS.NEXT_TICK_SAME_INSTRUCTION;\r\n      };\r\n    },\r\n    blockify: ctx => ({\r\n      singleSelectionInput: ctx.Name ? \"NAME\" : \"ID\",\r\n      singleTextInput: ctx.Name ? player.timestudy.presets[ctx.$presetIndex - 1].name : ctx.$presetIndex,\r\n      nowait: ctx.Nowait !== undefined,\r\n      ...automatorBlocksMap[\"STUDIES LOAD\"]\r\n    })\r\n  },\r\n  {\r\n    id: \"studiesRespec\",\r\n    rule: $ => () => {\r\n      $.CONSUME(T.Studies);\r\n      $.CONSUME(T.Respec);\r\n    },\r\n    validate: ctx => {\r\n      ctx.startLine = ctx.Studies[0].startLine;\r\n      return true;\r\n    },\r\n    compile: ctx => () => {\r\n      player.respec = true;\r\n      AutomatorData.logCommandEvent(`Turned study respec ON`, ctx.startLine);\r\n      return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\r\n    },\r\n    blockify: () => automatorBlocksMap[\"STUDIES RESPEC\"]\r\n  },\r\n  {\r\n    id: \"unlockDilation\",\r\n    rule: $ => () => {\r\n      $.CONSUME(T.Unlock);\r\n      $.OPTION(() => $.CONSUME(T.Nowait));\r\n      $.CONSUME(T.Dilation);\r\n    },\r\n    validate: ctx => {\r\n      ctx.startLine = ctx.Unlock[0].startLine;\r\n      return true;\r\n    },\r\n    compile: ctx => {\r\n      const nowait = ctx.Nowait !== undefined;\r\n      return () => {\r\n        if (PlayerProgress.dilationUnlocked()) {\r\n          AutomatorData.logCommandEvent(`Skipped dilation unlock due to being already unlocked`, ctx.startLine);\r\n          return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\r\n        }\r\n        const unlockedThisTick = TimeStudy.dilation.purchase(true);\r\n        if (unlockedThisTick) {\r\n          AutomatorData.logCommandEvent(`Unlocked Dilation`, ctx.startLine);\r\n          return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\r\n        }\r\n        if (nowait) {\r\n          AutomatorData.logCommandEvent(`Skipped dilation unlock due to lack of requirements (NOWAIT)`,\r\n            ctx.startLine);\r\n          return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\r\n        }\r\n        return AUTOMATOR_COMMAND_STATUS.NEXT_TICK_SAME_INSTRUCTION;\r\n      };\r\n    },\r\n    blockify: ctx => ({\r\n      singleSelectionInput: \"DILATION\",\r\n      nowait: ctx.Nowait !== undefined,\r\n      ...automatorBlocksMap.UNLOCK\r\n    })\r\n  },\r\n  {\r\n    id: \"unlockEC\",\r\n    rule: $ => () => {\r\n      $.CONSUME(T.Unlock);\r\n      $.OPTION(() => $.CONSUME(T.Nowait));\r\n      $.SUBRULE($.eternityChallenge);\r\n    },\r\n    validate: ctx => {\r\n      ctx.startLine = ctx.Unlock[0].startLine;\r\n      return true;\r\n    },\r\n    compile: ctx => {\r\n      const nowait = ctx.Nowait !== undefined;\r\n      const ecNumber = ctx.eternityChallenge[0].children.$ecNumber;\r\n      return () => {\r\n        if (EternityChallenge(ecNumber).isUnlocked) {\r\n          AutomatorData.logCommandEvent(`Skipped EC ${ecNumber} unlock due to being already unlocked`, ctx.startLine);\r\n          return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\r\n        }\r\n        if (nowait) {\r\n          AutomatorData.logCommandEvent(`EC ${ecNumber} unlock failed and skipped (NOWAIT)`, ctx.startLine);\r\n          return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\r\n        }\r\n        const purchased = TimeStudy.eternityChallenge(ecNumber).purchase(true);\r\n        if (purchased) {\r\n          AutomatorData.logCommandEvent(`EC ${ecNumber} unlocked`, ctx.startLine);\r\n          return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\r\n        }\r\n        return AUTOMATOR_COMMAND_STATUS.NEXT_TICK_SAME_INSTRUCTION;\r\n      };\r\n    },\r\n    blockify: ctx => ({\r\n      singleSelectionInput: \"EC\",\r\n      singleTextInput: ctx.eternityChallenge[0].children.$ecNumber,\r\n      nowait: ctx.Nowait !== undefined,\r\n      ...automatorBlocksMap.UNLOCK\r\n    })\r\n  },\r\n  {\r\n    id: \"untilLoop\",\r\n    rule: $ => () => {\r\n      $.CONSUME(T.Until);\r\n      $.OR([\r\n        { ALT: () => $.SUBRULE($.comparison) },\r\n        { ALT: () => $.CONSUME(T.PrestigeEvent) },\r\n      ]);\r\n      $.CONSUME(T.LCurly);\r\n      $.CONSUME(T.EOL);\r\n      $.SUBRULE($.block);\r\n      $.CONSUME(T.RCurly);\r\n    },\r\n    validate: (ctx, V) => {\r\n      ctx.startLine = ctx.Until[0].startLine;\r\n      return V.checkBlock(ctx, ctx.Until);\r\n    },\r\n    compile: (ctx, C) => {\r\n      const commands = C.visit(ctx.block);\r\n      if (ctx.comparison) {\r\n        const evalComparison = C.visit(ctx.comparison);\r\n        return compileConditionLoop(() => !evalComparison(), commands, ctx, true);\r\n      }\r\n      const prestigeLevel = ctx.PrestigeEvent[0].tokenType.$prestigeLevel;\r\n      let prestigeName;\r\n      switch (ctx.PrestigeEvent[0].tokenType) {\r\n        case T.Infinity:\r\n          prestigeName = \"Infinity\";\r\n          break;\r\n        case T.Eternity:\r\n          prestigeName = \"Eternity\";\r\n          break;\r\n        case T.Reality:\r\n          prestigeName = \"Reality\";\r\n          break;\r\n        default:\r\n          throw Error(\"Unrecognized prestige layer in until loop\");\r\n      }\r\n      return {\r\n        run: S => {\r\n          if (S.commandState === null) {\r\n            S.commandState = { prestigeLevel: 0 };\r\n          }\r\n          if (S.commandState.prestigeLevel >= prestigeLevel) {\r\n            AutomatorData.logCommandEvent(`${prestigeName} prestige has occurred, exiting until loop`,\r\n              ctx.startLine);\r\n            return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\r\n          }\r\n          AutomatorBackend.push(commands);\r\n          AutomatorData.logCommandEvent(`${prestigeName} prestige has not occurred yet, moving to line\r\n            ${AutomatorBackend.translateLineNumber(ctx.LCurly[0].startLine + 1)} (start of until loop)`,\r\n          ctx.startLine);\r\n          return AUTOMATOR_COMMAND_STATUS.SAME_INSTRUCTION;\r\n        },\r\n        blockCommands: commands\r\n      };\r\n    },\r\n    blockify: (ctx, B) => {\r\n      const commands = [];\r\n      B.visit(ctx.block, commands);\r\n      const comparison = B.visit(ctx.comparison);\r\n      if (ctx.comparison) {\r\n        return {\r\n          nest: commands,\r\n          ...automatorBlocksMap.UNTIL,\r\n          ...comparison,\r\n          genericInput1: standardizeAutomatorValues(comparison.genericInput1),\r\n          genericInput2: standardizeAutomatorValues(comparison.genericInput2)\r\n        };\r\n      }\r\n      return {\r\n        genericInput1: ctx.PrestigeEvent[0].tokenType.name.toUpperCase(),\r\n        nest: commands,\r\n        ...automatorBlocksMap.UNTIL\r\n      };\r\n    }\r\n  },\r\n  {\r\n    id: \"waitCondition\",\r\n    rule: $ => () => {\r\n      $.CONSUME(T.Wait);\r\n      $.SUBRULE($.comparison);\r\n    },\r\n    validate: ctx => {\r\n      ctx.startLine = ctx.Wait[0].startLine;\r\n      return true;\r\n    },\r\n    compile: (ctx, C) => () => {\r\n      const evalComparison = C.visit(ctx.comparison);\r\n      const doneWaiting = evalComparison();\r\n      if (doneWaiting) {\r\n        const timeWaited = TimeSpan.fromMilliseconds(Date.now() - AutomatorData.waitStart).toStringShort();\r\n        if (AutomatorData.isWaiting) {\r\n          AutomatorData.logCommandEvent(`Continuing after WAIT\r\n            (${parseConditionalIntoText(ctx)} is true, after ${timeWaited})`, ctx.startLine);\r\n        } else {\r\n          AutomatorData.logCommandEvent(`WAIT skipped (${parseConditionalIntoText(ctx)} is already true)`,\r\n            ctx.startLine);\r\n        }\r\n        AutomatorData.isWaiting = false;\r\n        return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\r\n      }\r\n      if (!AutomatorData.isWaiting) {\r\n        AutomatorData.logCommandEvent(`Started WAIT for ${parseConditionalIntoText(ctx)}`, ctx.startLine);\r\n        AutomatorData.waitStart = Date.now();\r\n      }\r\n      AutomatorData.isWaiting = true;\r\n      return AUTOMATOR_COMMAND_STATUS.NEXT_TICK_SAME_INSTRUCTION;\r\n    },\r\n    blockify: (ctx, B) => {\r\n      const commands = [];\r\n      B.visit(ctx.block, commands);\r\n      const comparison = B.visit(ctx.comparison);\r\n      return {\r\n        nest: commands,\r\n        ...automatorBlocksMap.WAIT,\r\n        ...comparison,\r\n        genericInput1: standardizeAutomatorValues(comparison.genericInput1),\r\n        genericInput2: standardizeAutomatorValues(comparison.genericInput2)\r\n      };\r\n    }\r\n  },\r\n  {\r\n    id: \"waitEvent\",\r\n    rule: $ => () => {\r\n      $.CONSUME(T.Wait);\r\n      $.CONSUME(T.PrestigeEvent);\r\n    },\r\n    validate: ctx => {\r\n      ctx.startLine = ctx.Wait[0].startLine;\r\n      return true;\r\n    },\r\n    compile: ctx => {\r\n      const prestigeLevel = ctx.PrestigeEvent[0].tokenType.$prestigeLevel;\r\n      return S => {\r\n        if (S.commandState === null) {\r\n          S.commandState = { prestigeLevel: 0 };\r\n        }\r\n        const prestigeOccurred = S.commandState.prestigeLevel >= prestigeLevel;\r\n        const prestigeName = ctx.PrestigeEvent[0].image.toUpperCase();\r\n        if (prestigeOccurred) {\r\n          const timeWaited = TimeSpan.fromMilliseconds(Date.now() - AutomatorData.waitStart).toStringShort();\r\n          AutomatorData.logCommandEvent(`Continuing after WAIT (${prestigeName} occurred for\r\n            ${findLastPrestigeRecord(prestigeName)}, after ${timeWaited})`, ctx.startLine);\r\n          AutomatorData.isWaiting = false;\r\n          return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\r\n        }\r\n        if (!AutomatorData.isWaiting) {\r\n          AutomatorData.logCommandEvent(`Started WAIT for ${prestigeName}`, ctx.startLine);\r\n          AutomatorData.waitStart = Date.now();\r\n        }\r\n        AutomatorData.isWaiting = true;\r\n        return AUTOMATOR_COMMAND_STATUS.NEXT_TICK_SAME_INSTRUCTION;\r\n      };\r\n    },\r\n    blockify: ctx => ({\r\n      genericInput1: ctx.PrestigeEvent[0].tokenType.name.toUpperCase(),\r\n      ...automatorBlocksMap.WAIT\r\n    })\r\n  },\r\n  {\r\n    id: \"waitBlackHole\",\r\n    rule: $ => () => {\r\n      $.CONSUME(T.Wait);\r\n      $.CONSUME(T.BlackHole);\r\n      $.OR([\r\n        { ALT: () => $.CONSUME(T.Off) },\r\n        { ALT: () => $.CONSUME(T.BlackHoleStr) },\r\n      ]);\r\n    },\r\n    validate: ctx => {\r\n      ctx.startLine = ctx.Wait[0].startLine;\r\n      return true;\r\n    },\r\n    compile: ctx => () => {\r\n      const off = Boolean(ctx.Off);\r\n      // This input has the format \"bh#\"\r\n      const holeID = ctx.BlackHoleStr ? Number(ctx.BlackHoleStr[0].image.charAt(2)) : 0;\r\n      const bhCond = off ? !BlackHole(1).isActive : BlackHole(holeID).isActive;\r\n      const bhStr = off ? \"inactive Black Holes\" : `active Black Hole ${holeID}`;\r\n      if (bhCond) {\r\n        const timeWaited = TimeSpan.fromMilliseconds(Date.now() - AutomatorData.waitStart).toStringShort();\r\n        AutomatorData.logCommandEvent(`Continuing after WAIT (waited ${timeWaited} for ${bhStr})`,\r\n          ctx.startLine);\r\n        AutomatorData.isWaiting = false;\r\n        return AUTOMATOR_COMMAND_STATUS.NEXT_INSTRUCTION;\r\n      }\r\n      if (!AutomatorData.isWaiting) {\r\n        AutomatorData.logCommandEvent(`Started WAIT for ${bhStr}`, ctx.startLine);\r\n        AutomatorData.waitStart = Date.now();\r\n      }\r\n      AutomatorData.isWaiting = true;\r\n      return AUTOMATOR_COMMAND_STATUS.NEXT_TICK_SAME_INSTRUCTION;\r\n    },\r\n    blockify: ctx => ({\r\n      genericInput1: \"BLACK HOLE\",\r\n      // Note: In this particular case we aren't actually storing a comparison operator. This is still okay\r\n      // because internally this is just the variable for the second slot and has no special treatment beyond that\r\n      compOperator: ctx.BlackHoleStr ? ctx.BlackHoleStr[0].image.toUpperCase() : \"OFF\",\r\n      ...automatorBlocksMap.WAIT\r\n    })\r\n  },\r\n  {\r\n    id: \"whileLoop\",\r\n    rule: $ => () => {\r\n      $.CONSUME(T.While);\r\n      $.SUBRULE($.comparison);\r\n      $.CONSUME(T.LCurly);\r\n      $.CONSUME(T.EOL);\r\n      $.SUBRULE($.block);\r\n      $.CONSUME(T.RCurly);\r\n    },\r\n    validate: (ctx, V) => {\r\n      ctx.startLine = ctx.While[0].startLine;\r\n      return V.checkBlock(ctx, ctx.While);\r\n    },\r\n    compile: (ctx, C) => compileConditionLoop(C.visit(ctx.comparison), C.visit(ctx.block), ctx, false),\r\n    blockify: (ctx, B) => {\r\n      const commands = [];\r\n      B.visit(ctx.block, commands);\r\n      const comparison = B.visit(ctx.comparison);\r\n      return {\r\n        nest: commands,\r\n        ...automatorBlocksMap.WHILE,\r\n        ...comparison,\r\n        genericInput1: standardizeAutomatorValues(comparison.genericInput1),\r\n        genericInput2: standardizeAutomatorValues(comparison.genericInput2)\r\n      };\r\n    }\r\n  },\r\n  {\r\n    id: \"stop\",\r\n    rule: $ => () => {\r\n      $.CONSUME(T.Stop);\r\n    },\r\n    validate: ctx => {\r\n      ctx.startLine = ctx.Stop[0].startLine;\r\n      return true;\r\n    },\r\n    compile: ctx => () => {\r\n      AutomatorData.logCommandEvent(`Automator execution stopped with STOP command`, ctx.startLine);\r\n      return AUTOMATOR_COMMAND_STATUS.HALT;\r\n    },\r\n    blockify: () => ({\r\n      ...automatorBlocksMap.STOP,\r\n    })\r\n  }\r\n];\r\n"]},"metadata":{},"sourceType":"module"}