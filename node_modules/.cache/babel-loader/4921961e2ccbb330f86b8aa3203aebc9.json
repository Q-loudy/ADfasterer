{"ast":null,"code":"import \"core-js/modules/web.dom-collections.iterator.js\";\nimport { EOF, Parser } from \"chevrotain\";\nimport { automatorTokens, tokenMap as T } from \"./lexer\";\nimport { AutomatorCommands } from \"./automator-commands\"; // ----------------- parser -----------------\n\nclass AutomatorParser extends Parser {\n  constructor() {\n    super(automatorTokens, {\n      recoveryEnabled: true,\n      outputCst: true,\n      nodeLocationTracking: \"full\"\n    }); // eslint-disable-next-line consistent-this\n\n    const $ = this;\n    $.RULE(\"script\", () => $.SUBRULE($.block));\n    $.RULE(\"block\", () => $.MANY_SEP({\n      SEP: T.EOL,\n      DEF: () => $.OPTION(() => $.SUBRULE($.command))\n    })); // This is a bit ugly looking. Chevrotain uses Function.toString() to do crazy\n    // optimizations. That clashes with our desire to build our list of commands dynamically.\n    // We are creating a function body like this one:\n    //      $.RULE(\"command\", () => {\n    //          $.OR(\n    //            $.c1 || ($.c1 = [\n    //              { ALT: () => $.SUBRULE($.badCommand) },\n    //              { ALT: () => $.SUBRULE($.auto) },\n    //              { ALT: () => $.SUBRULE($.define) },\n    //              { ALT: () => $.SUBRULE($.ifBlock) },\n\n    const commandAlts = [\"$.SUBRULE($.badCommand)\", \"$.CONSUME(EOF)\"];\n\n    for (const cmd of AutomatorCommands) {\n      $.RULE(cmd.id, cmd.rule($));\n      commandAlts.push(`$.SUBRULE($.${cmd.id})`);\n    }\n\n    const commandOr = window.Function(\"$\", \"EOF\", `\n      return () => $.OR($.c1 || ($.c1 = [\n        ${commandAlts.map(e => `{ ALT: () => ${e} },`).join(\"\\n\")}]));\n    `);\n    $.RULE(\"command\", commandOr($, EOF));\n    $.RULE(\"badCommand\", () => $.AT_LEAST_ONE(() => $.SUBRULE($.badCommandToken)), {\n      resyncEnabled: false\n    });\n    $.RULE(\"badCommandToken\", () => $.OR([{\n      ALT: () => $.CONSUME(T.Identifier)\n    }, {\n      ALT: () => $.CONSUME(T.NumberLiteral)\n    }, {\n      ALT: () => $.CONSUME(T.ComparisonOperator)\n    }]), {\n      resyncEnabled: false\n    });\n    $.RULE(\"comparison\", () => {\n      $.SUBRULE($.compareValue);\n      $.CONSUME(T.ComparisonOperator);\n      $.SUBRULE2($.compareValue);\n    });\n    $.RULE(\"compareValue\", () => $.OR([{\n      ALT: () => $.CONSUME(T.NumberLiteral)\n    }, {\n      ALT: () => $.CONSUME(T.Identifier)\n    }, {\n      ALT: () => $.CONSUME(T.AutomatorCurrency)\n    }]));\n    $.RULE(\"duration\", () => {\n      $.CONSUME(T.NumberLiteral);\n      $.CONSUME(T.TimeUnit);\n    });\n    $.RULE(\"eternityChallenge\", () => $.OR([{\n      ALT: () => {\n        $.CONSUME(T.EC);\n        $.CONSUME(T.NumberLiteral);\n      }\n    }, {\n      ALT: () => $.CONSUME(T.ECLiteral)\n    }]));\n    $.RULE(\"studyList\", () => {\n      $.AT_LEAST_ONE(() => $.SUBRULE($.studyListEntry)); // Support the |3 export format for EC number and optionally the ending exclamation point\n\n      $.OPTION(() => {\n        $.CONSUME(T.Pipe);\n        $.CONSUME1(T.NumberLiteral, {\n          LABEL: \"ECNumber\"\n        });\n        $.OPTION1(() => $.CONSUME(T.Exclamation));\n      });\n    }, {\n      resyncEnabled: false\n    });\n    $.RULE(\"studyListEntry\", () => {\n      $.OR([{\n        ALT: () => $.SUBRULE($.studyRange)\n      }, {\n        ALT: () => $.CONSUME(T.NumberLiteral)\n      }, {\n        ALT: () => $.CONSUME(T.StudyPath)\n      }]);\n      $.OPTION(() => $.CONSUME(T.Comma));\n    });\n    $.RULE(\"studyRange\", () => {\n      $.CONSUME(T.NumberLiteral, {\n        LABEL: \"firstStudy\"\n      });\n      $.CONSUME(T.Dash);\n      $.CONSUME1(T.NumberLiteral, {\n        LABEL: \"lastStudy\"\n      });\n    });\n    $.RULE(\"xHighest\", () => {\n      $.CONSUME(T.NumberLiteral);\n      $.CONSUME(T.XHighest);\n    });\n    $.RULE(\"currencyAmount\", () => {\n      $.CONSUME(T.NumberLiteral);\n      $.CONSUME(T.AutomatorCurrency);\n    }); // Very important to call this after all the rules have been setup.\n    // otherwise the parser may not work correctly as it will lack information\n    // derived from the self analysis.\n\n    $.performSelfAnalysis();\n  }\n\n}\n\nexport const parser = new AutomatorParser();","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/automator/parser.js"],"names":["EOF","Parser","automatorTokens","tokenMap","T","AutomatorCommands","AutomatorParser","constructor","recoveryEnabled","outputCst","nodeLocationTracking","$","RULE","SUBRULE","block","MANY_SEP","SEP","EOL","DEF","OPTION","command","commandAlts","cmd","id","rule","push","commandOr","window","Function","map","e","join","AT_LEAST_ONE","badCommandToken","resyncEnabled","OR","ALT","CONSUME","Identifier","NumberLiteral","ComparisonOperator","compareValue","SUBRULE2","AutomatorCurrency","TimeUnit","EC","ECLiteral","studyListEntry","Pipe","CONSUME1","LABEL","OPTION1","Exclamation","studyRange","StudyPath","Comma","Dash","XHighest","performSelfAnalysis","parser"],"mappings":"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","sourcesContent":["import { EOF, Parser } from \"chevrotain\";\r\n\r\nimport { automatorTokens, tokenMap as T } from \"./lexer\";\r\nimport { AutomatorCommands } from \"./automator-commands\";\r\n\r\n// ----------------- parser -----------------\r\nclass AutomatorParser extends Parser {\r\n  constructor() {\r\n    super(automatorTokens, {\r\n      recoveryEnabled: true,\r\n      outputCst: true,\r\n      nodeLocationTracking: \"full\",\r\n    });\r\n\r\n    // eslint-disable-next-line consistent-this\r\n    const $ = this;\r\n\r\n    $.RULE(\"script\", () => $.SUBRULE($.block));\r\n\r\n    $.RULE(\"block\", () => $.MANY_SEP({\r\n      SEP: T.EOL,\r\n      DEF: () => $.OPTION(() => $.SUBRULE($.command)),\r\n    }));\r\n\r\n    // This is a bit ugly looking. Chevrotain uses Function.toString() to do crazy\r\n    // optimizations. That clashes with our desire to build our list of commands dynamically.\r\n    // We are creating a function body like this one:\r\n    //      $.RULE(\"command\", () => {\r\n    //          $.OR(\r\n    //            $.c1 || ($.c1 = [\r\n    //              { ALT: () => $.SUBRULE($.badCommand) },\r\n    //              { ALT: () => $.SUBRULE($.auto) },\r\n    //              { ALT: () => $.SUBRULE($.define) },\r\n    //              { ALT: () => $.SUBRULE($.ifBlock) },\r\n\r\n    const commandAlts = [\r\n      \"$.SUBRULE($.badCommand)\",\r\n      \"$.CONSUME(EOF)\",\r\n    ];\r\n\r\n    for (const cmd of AutomatorCommands) {\r\n      $.RULE(cmd.id, cmd.rule($));\r\n      commandAlts.push(`$.SUBRULE($.${cmd.id})`);\r\n    }\r\n\r\n    const commandOr = window.Function(\"$\", \"EOF\", `\r\n      return () => $.OR($.c1 || ($.c1 = [\r\n        ${commandAlts.map(e => `{ ALT: () => ${e} },`).join(\"\\n\")}]));\r\n    `);\r\n\r\n    $.RULE(\"command\", commandOr($, EOF));\r\n\r\n    $.RULE(\"badCommand\", () => $.AT_LEAST_ONE(() => $.SUBRULE($.badCommandToken)),\r\n      { resyncEnabled: false, }\r\n    );\r\n\r\n    $.RULE(\"badCommandToken\", () => $.OR([\r\n      { ALT: () => $.CONSUME(T.Identifier) },\r\n      { ALT: () => $.CONSUME(T.NumberLiteral) },\r\n      { ALT: () => $.CONSUME(T.ComparisonOperator) },\r\n    ]), { resyncEnabled: false, });\r\n\r\n    $.RULE(\"comparison\", () => {\r\n      $.SUBRULE($.compareValue);\r\n      $.CONSUME(T.ComparisonOperator);\r\n      $.SUBRULE2($.compareValue);\r\n    });\r\n\r\n    $.RULE(\"compareValue\", () => $.OR([\r\n      { ALT: () => $.CONSUME(T.NumberLiteral) },\r\n      { ALT: () => $.CONSUME(T.Identifier) },\r\n      { ALT: () => $.CONSUME(T.AutomatorCurrency) },\r\n    ]));\r\n\r\n    $.RULE(\"duration\", () => {\r\n      $.CONSUME(T.NumberLiteral);\r\n      $.CONSUME(T.TimeUnit);\r\n    });\r\n\r\n    $.RULE(\"eternityChallenge\", () => $.OR([\r\n      {\r\n        ALT: () => {\r\n          $.CONSUME(T.EC);\r\n          $.CONSUME(T.NumberLiteral);\r\n        }\r\n      },\r\n      { ALT: () => $.CONSUME(T.ECLiteral) }\r\n    ]));\r\n\r\n    $.RULE(\"studyList\", () => {\r\n      $.AT_LEAST_ONE(() => $.SUBRULE($.studyListEntry));\r\n      // Support the |3 export format for EC number and optionally the ending exclamation point\r\n      $.OPTION(() => {\r\n        $.CONSUME(T.Pipe);\r\n        $.CONSUME1(T.NumberLiteral, { LABEL: \"ECNumber\" });\r\n        $.OPTION1(() => $.CONSUME(T.Exclamation));\r\n      });\r\n    }, { resyncEnabled: false });\r\n\r\n    $.RULE(\"studyListEntry\", () => {\r\n      $.OR([\r\n        { ALT: () => $.SUBRULE($.studyRange) },\r\n        { ALT: () => $.CONSUME(T.NumberLiteral) },\r\n        { ALT: () => $.CONSUME(T.StudyPath) },\r\n      ]);\r\n      $.OPTION(() => $.CONSUME(T.Comma));\r\n    });\r\n\r\n    $.RULE(\"studyRange\", () => {\r\n      $.CONSUME(T.NumberLiteral, { LABEL: \"firstStudy\" });\r\n      $.CONSUME(T.Dash);\r\n      $.CONSUME1(T.NumberLiteral, { LABEL: \"lastStudy\" });\r\n    });\r\n\r\n    $.RULE(\"xHighest\", () => {\r\n      $.CONSUME(T.NumberLiteral);\r\n      $.CONSUME(T.XHighest);\r\n    });\r\n\r\n    $.RULE(\"currencyAmount\", () => {\r\n      $.CONSUME(T.NumberLiteral);\r\n      $.CONSUME(T.AutomatorCurrency);\r\n    });\r\n\r\n    // Very important to call this after all the rules have been setup.\r\n    // otherwise the parser may not work correctly as it will lack information\r\n    // derived from the self analysis.\r\n    $.performSelfAnalysis();\r\n  }\r\n}\r\n\r\nexport const parser = new AutomatorParser();\r\n"]},"metadata":{},"sourceType":"module"}