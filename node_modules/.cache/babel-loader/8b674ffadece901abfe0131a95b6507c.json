{"ast":null,"code":"import _wrapRegExp from \"C:/Games/ADFasterer/ADfasterer/node_modules/@babel/runtime/helpers/esm/wrapRegExp\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.string.replace-all.js\";\nexport default {\n  name: \"AutobuyerInput\",\n  props: {\n    autobuyer: {\n      type: Object,\n      required: true\n    },\n    property: {\n      type: String,\n      required: true\n    },\n    type: {\n      type: String,\n      required: true\n    }\n  },\n\n  data() {\n    return {\n      isValid: true,\n      isFocused: false,\n      displayValue: \"0\"\n    };\n  },\n\n  computed: {\n    inputType() {\n      return this.type === \"int\" ? \"number\" : \"text\";\n    },\n\n    typeFunctions() {\n      const functions = AutobuyerInputFunctions[this.type];\n\n      if (functions === undefined) {\n        throw new Error(\"Unknown autobuyer input type\");\n      }\n\n      return functions;\n    },\n\n    validityClass() {\n      return this.isValid ? undefined : \"o-autobuyer-input--invalid\";\n    }\n\n  },\n  methods: {\n    update() {\n      if (this.isFocused) return;\n      this.updateActualValue();\n    },\n\n    updateActualValue() {\n      const actualValue = this.autobuyer[this.property];\n      if (this.areEqual(this.actualValue, actualValue)) return;\n      this.actualValue = this.typeFunctions.copyValue(actualValue);\n      this.updateDisplayValue();\n    },\n\n    areEqual(value, other) {\n      if (other === undefined || value === undefined) return false;\n      return this.typeFunctions.areEqual(value, other);\n    },\n\n    updateDisplayValue() {\n      this.displayValue = this.typeFunctions.formatValue(this.actualValue);\n    },\n\n    handleInput(event) {\n      const input = event.target.value;\n      this.displayValue = input;\n\n      if (input.length === 0) {\n        this.isValid = false;\n        return;\n      }\n\n      const parsedValue = this.typeFunctions.tryParse(input);\n      this.isValid = parsedValue !== undefined;\n      this.actualValue = this.typeFunctions.copyValue(parsedValue);\n    },\n\n    handleFocus() {\n      this.isFocused = true;\n    },\n\n    handleChange(event) {\n      if (this.displayValue === \"69\") {\n        SecretAchievement(28).unlock();\n      }\n\n      if (this.isValid) {\n        this.autobuyer[this.property] = this.typeFunctions.copyValue(this.actualValue);\n      } else {\n        this.updateActualValue();\n      }\n\n      this.updateDisplayValue();\n      this.isValid = true;\n      this.isFocused = false;\n      event.target.blur();\n    }\n\n  }\n};\nexport const AutobuyerInputFunctions = {\n  decimal: {\n    areEqual: (value, other) => Decimal.eq(value, other),\n    formatValue: value => Notation.scientific.format(value, 2, 2),\n    copyValue: value => new Decimal(value),\n    tryParse: input => {\n      if (!input) return undefined;\n\n      try {\n        let decimal;\n\n        if (/^e[0-9]*\\.?[0-9]+$/.test(input.replaceAll(\",\", \"\"))) {\n          // Logarithm Notation\n          decimal = Decimal.pow10(parseFloat(input.replaceAll(\",\", \"\").slice(1)));\n        } else if (/^[0-9]*\\.?[0-9]+(e[0-9]+)?$/.test(input.replaceAll(\",\", \"\"))) {\n          // Scientific notation; internals of break-infinity will gladly strip extraneous letters before parsing, but\n          // since this is largely uncommunicated to the user, we instead explicitly check for formatting and reject\n          // anything that doesn't fit as invalid\n          decimal = Decimal.fromString(input.replaceAll(\",\", \"\"));\n        } else if (/^[0-9]*\\.?[0-9]+(e[0-9]*\\.?[0-9]+)?$/.test(input.replaceAll(\",\", \"\"))) {\n          // \"Mixed scientific notation\" - inputs such as \"2.33e41.2\" cause buggy behavior when fed directly into\n          // Decimal.fromString, so we parse out the mantissa and exponent separately before combining them\n          const regex = /*#__PURE__*/_wrapRegExp(/([0-9]*\\.?[0-9]+)e([0-9]*\\.?[0-9]+)/, {\n            mantissa: 1,\n            exponent: 2\n          });\n\n          const match = input.replaceAll(\",\", \"\").match(regex);\n          decimal = Decimal.pow10(Math.log10(Number(match.groups.mantissa)) + Number(match.groups.exponent));\n        } else {\n          return undefined;\n        }\n\n        return isNaN(decimal.mantissa) || isNaN(decimal.exponent) ? undefined : decimal;\n      } catch (e) {\n        return undefined;\n      }\n    }\n  },\n  float: {\n    areEqual: (value, other) => value === other,\n    formatValue: value => value.toString(),\n    copyValue: value => value,\n    tryParse: input => {\n      const float = parseFloat(input);\n      return isNaN(float) ? undefined : float;\n    }\n  },\n  int: {\n    areEqual: (value, other) => value === other,\n    formatValue: value => value.toString(),\n    copyValue: value => value,\n    tryParse: input => {\n      if (!input) return undefined; // We explicitly check formatting here instead of letting parseInt handle the whole thing because otherwise the\n      // fact that parseInt removes extraneous letters means junk like \"361ebqv3\" registers as valid and parses as 361\n\n      if (!/^[0-9]+$/.test(input.replaceAll(\",\", \"\"))) return undefined;\n      const int = parseInt(input, 10);\n      return isNaN(int) || !Number.isInteger(int) ? undefined : int;\n    }\n  }\n};","map":{"version":3,"sources":["AutobuyerInput.vue"],"names":[],"mappings":"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","sourcesContent":["<script>\r\nexport default {\r\n  name: \"AutobuyerInput\",\r\n  props: {\r\n    autobuyer: {\r\n      type: Object,\r\n      required: true\r\n    },\r\n    property: {\r\n      type: String,\r\n      required: true\r\n    },\r\n    type: {\r\n      type: String,\r\n      required: true\r\n    }\r\n  },\r\n  data() {\r\n    return {\r\n      isValid: true,\r\n      isFocused: false,\r\n      displayValue: \"0\"\r\n    };\r\n  },\r\n  computed: {\r\n    inputType() {\r\n      return this.type === \"int\" ? \"number\" : \"text\";\r\n    },\r\n    typeFunctions() {\r\n      const functions = AutobuyerInputFunctions[this.type];\r\n      if (functions === undefined) {\r\n        throw new Error(\"Unknown autobuyer input type\");\r\n      }\r\n      return functions;\r\n    },\r\n    validityClass() {\r\n      return this.isValid ? undefined : \"o-autobuyer-input--invalid\";\r\n    }\r\n  },\r\n  methods: {\r\n    update() {\r\n      if (this.isFocused) return;\r\n      this.updateActualValue();\r\n    },\r\n    updateActualValue() {\r\n      const actualValue = this.autobuyer[this.property];\r\n      if (this.areEqual(this.actualValue, actualValue)) return;\r\n      this.actualValue = this.typeFunctions.copyValue(actualValue);\r\n      this.updateDisplayValue();\r\n    },\r\n    areEqual(value, other) {\r\n      if (other === undefined || value === undefined) return false;\r\n      return this.typeFunctions.areEqual(value, other);\r\n    },\r\n    updateDisplayValue() {\r\n      this.displayValue = this.typeFunctions.formatValue(this.actualValue);\r\n    },\r\n    handleInput(event) {\r\n      const input = event.target.value;\r\n      this.displayValue = input;\r\n      if (input.length === 0) {\r\n        this.isValid = false;\r\n        return;\r\n      }\r\n      const parsedValue = this.typeFunctions.tryParse(input);\r\n      this.isValid = parsedValue !== undefined;\r\n      this.actualValue = this.typeFunctions.copyValue(parsedValue);\r\n    },\r\n    handleFocus() {\r\n      this.isFocused = true;\r\n    },\r\n    handleChange(event) {\r\n      if (this.displayValue === \"69\") {\r\n        SecretAchievement(28).unlock();\r\n      }\r\n      if (this.isValid) {\r\n        this.autobuyer[this.property] = this.typeFunctions.copyValue(this.actualValue);\r\n      } else {\r\n        this.updateActualValue();\r\n      }\r\n      this.updateDisplayValue();\r\n      this.isValid = true;\r\n\r\n      this.isFocused = false;\r\n      event.target.blur();\r\n    },\r\n  }\r\n};\r\n\r\nexport const AutobuyerInputFunctions = {\r\n  decimal: {\r\n    areEqual: (value, other) => Decimal.eq(value, other),\r\n    formatValue: value => Notation.scientific.format(value, 2, 2),\r\n    copyValue: value => new Decimal(value),\r\n    tryParse: input => {\r\n      if (!input) return undefined;\r\n      try {\r\n        let decimal;\r\n        if (/^e\\d*[.]?\\d+$/u.test(input.replaceAll(\",\", \"\"))) {\r\n          // Logarithm Notation\r\n          decimal = Decimal.pow10(parseFloat(input.replaceAll(\",\", \"\").slice(1)));\r\n        } else if (/^\\d*[.]?\\d+(e\\d+)?$/u.test(input.replaceAll(\",\", \"\"))) {\r\n          // Scientific notation; internals of break-infinity will gladly strip extraneous letters before parsing, but\r\n          // since this is largely uncommunicated to the user, we instead explicitly check for formatting and reject\r\n          // anything that doesn't fit as invalid\r\n          decimal = Decimal.fromString(input.replaceAll(\",\", \"\"));\r\n        } else if (/^\\d*[.]?\\d+(e\\d*[.]?\\d+)?$/u.test(input.replaceAll(\",\", \"\"))) {\r\n          // \"Mixed scientific notation\" - inputs such as \"2.33e41.2\" cause buggy behavior when fed directly into\r\n          // Decimal.fromString, so we parse out the mantissa and exponent separately before combining them\r\n          const regex = /(?<mantissa>\\d*[.]?\\d+)e(?<exponent>\\d*[.]?\\d+)/u;\r\n          const match = input.replaceAll(\",\", \"\").match(regex);\r\n          decimal = Decimal.pow10(Math.log10(Number(match.groups.mantissa)) + Number(match.groups.exponent));\r\n        } else {\r\n          return undefined;\r\n        }\r\n        return isNaN(decimal.mantissa) || isNaN(decimal.exponent) ? undefined : decimal;\r\n      } catch (e) {\r\n        return undefined;\r\n      }\r\n    }\r\n  },\r\n  float: {\r\n    areEqual: (value, other) => value === other,\r\n    formatValue: value => value.toString(),\r\n    copyValue: value => value,\r\n    tryParse: input => {\r\n      const float = parseFloat(input);\r\n      return isNaN(float) ? undefined : float;\r\n    }\r\n  },\r\n  int: {\r\n    areEqual: (value, other) => value === other,\r\n    formatValue: value => value.toString(),\r\n    copyValue: value => value,\r\n    tryParse: input => {\r\n      if (!input) return undefined;\r\n      // We explicitly check formatting here instead of letting parseInt handle the whole thing because otherwise the\r\n      // fact that parseInt removes extraneous letters means junk like \"361ebqv3\" registers as valid and parses as 361\r\n      if (!/^\\d+$/u.test(input.replaceAll(\",\", \"\"))) return undefined;\r\n      const int = parseInt(input, 10);\r\n      return isNaN(int) || !Number.isInteger(int) ? undefined : int;\r\n    }\r\n  }\r\n};\r\n</script>\r\n\r\n<template>\r\n  <input\r\n    :value=\"displayValue\"\r\n    :class=\"validityClass\"\r\n    :type=\"inputType\"\r\n    class=\"o-autobuyer-input\"\r\n    @change=\"handleChange\"\r\n    @focus=\"handleFocus\"\r\n    @input=\"handleInput\"\r\n  >\r\n</template>\r\n\r\n<style scoped>\r\n.o-autobuyer-input--invalid {\r\n  background-color: var(--color-bad);\r\n}\r\n\r\n.s-base--dark .o-autobuyer-input--invalid,\r\n.t-s1 .o-autobuyer-input--invalid {\r\n  background-color: var(--color-bad);\r\n}\r\n</style>\r\n"],"sourceRoot":"src/components/tabs/autobuyers"},"metadata":{},"sourceType":"module"}