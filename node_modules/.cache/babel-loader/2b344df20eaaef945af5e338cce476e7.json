{"ast":null,"code":"import \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.sort.js\";\nexport const AutoGlyphProcessor = {\n  get scoreMode() {\n    return player.reality.glyphs.filter.select;\n  },\n\n  set scoreMode(value) {\n    player.reality.glyphs.filter.select = value;\n  },\n\n  get sacMode() {\n    return player.reality.glyphs.filter.trash;\n  },\n\n  set sacMode(value) {\n    player.reality.glyphs.filter.trash = value;\n  },\n\n  get types() {\n    return player.reality.glyphs.filter.types;\n  },\n\n  // This exists to avoid unnecessary repeated object initialization in the filtering code\n  bitmaskIndexOffset(type) {\n    switch (type) {\n      case \"time\":\n        return 0;\n\n      case \"dilation\":\n        return 4;\n\n      case \"replication\":\n        return 8;\n\n      case \"infinity\":\n        return 12;\n\n      case \"power\":\n        return 16;\n\n      case \"effarig\":\n        return 20;\n\n      default:\n        throw new Error(\"Unknown glyph type mode in bitmaskIndexOffset\");\n    }\n  },\n\n  // This function is meant to be something which assigns a value to every glyph, with the assumption that\n  // higher numbers correspond to better glyphs. This value is also displayed on tooltips when it depends\n  // on only the glyph itself and not external factors.\n  filterValue(glyph) {\n    const typeCfg = this.types[glyph.type];\n    if ([\"companion\", \"reality\"].includes(glyph.type)) return Infinity;\n    if (glyph.type === \"cursed\") return -Infinity;\n\n    switch (this.scoreMode) {\n      case AUTO_GLYPH_SCORE.LOWEST_SACRIFICE:\n        // Picked glyphs are never kept in this mode. Sacrifice cap needs to be checked since effarig caps\n        // at a lower value than the others and we don't want to uselessly pick that to sacrifice all the time\n        return player.reality.glyphs.sac[glyph.type] >= GlyphSacrifice[glyph.type].cap ? -Infinity : -player.reality.glyphs.sac[glyph.type];\n\n      case AUTO_GLYPH_SCORE.EFFECT_COUNT:\n        // Effect count, plus a very small rarity term to break ties in favor of rarer glyphs\n        return strengthToRarity(glyph.strength) / 1000 + getGlyphEffectsFromBitmask(glyph.effects, 0, 0).filter(effect => effect.isGenerated).length;\n\n      case AUTO_GLYPH_SCORE.RARITY_THRESHOLD:\n        return strengthToRarity(glyph.strength);\n\n      case AUTO_GLYPH_SCORE.SPECIFIED_EFFECT:\n        {\n          // Value is equal to rarity but minus 200 for each missing effect. This makes all glyphs which don't\n          // satisfy the requirements have a negative score and generally the worse a glyph misses the requirements,\n          // the more negative of a score it will have\n          const glyphEffectCount = countValuesFromBitmask(glyph.effects);\n\n          if (glyphEffectCount < typeCfg.effectCount) {\n            return strengthToRarity(glyph.strength) - 200 * (typeCfg.effectCount - glyphEffectCount);\n          } // The missing effect count can be gotten by taking the full filter bitmask, removing only the bits which are\n          // present on both the filter and the glyph, and then counting the bits up\n\n\n          const missingEffects = countValuesFromBitmask(typeCfg.specifiedMask - (typeCfg.specifiedMask & glyph.effects));\n          return strengthToRarity(glyph.strength) - 200 * missingEffects;\n        }\n\n      case AUTO_GLYPH_SCORE.EFFECT_SCORE:\n        {\n          const effectList = getGlyphEffectsFromBitmask(glyph.effects, 0, 0).filter(effect => effect.isGenerated).map(effect => effect.bitmaskIndex);\n          const offset = this.bitmaskIndexOffset(glyph.type); // This ternary check is required to filter out any effects which may appear on the glyph which aren't normally\n          // there in typical glyph generation. Ra-Nameless 25 is the only case where this happens, but this also has the\n          // side-effect of making altered glyph generation in mods less likely to crash the game as well\n\n          const effectScore = effectList.map(e => typeCfg.effectScores[e - offset] ? typeCfg.effectScores[e - offset] : 0).sum();\n          return strengthToRarity(glyph.strength) + effectScore;\n        }\n      // Picked glyphs are never kept in Alchemy modes.\n      // Glyphs for non-unlocked or capped Alchemy Resources are assigned NEGATIVE_INFINITY\n      // to make them picked last, because we can't refine them.\n\n      case AUTO_GLYPH_SCORE.LOWEST_ALCHEMY:\n        {\n          const resource = AlchemyResource[glyph.type];\n          const refinementGain = GlyphSacrificeHandler.glyphRefinementGain(glyph);\n          return resource.isUnlocked && refinementGain > 0 ? -resource.amount : Number.NEGATIVE_INFINITY;\n        }\n\n      case AUTO_GLYPH_SCORE.ALCHEMY_VALUE:\n        return AlchemyResource[glyph.type].isUnlocked ? GlyphSacrificeHandler.glyphRefinementGain(glyph) : Number.NEGATIVE_INFINITY;\n\n      default:\n        throw new Error(\"Unknown glyph score mode in score assignment\");\n    }\n  },\n\n  // This is a mode-specific threshold which determines if selected glyphs are \"good enough\" to keep\n  thresholdValue(glyph) {\n    // Glyph filter settings are undefined for companion/cursed/reality glyphs, so we return the lowest possible\n    // value on the basis that we never want to automatically get rid of them\n    if (this.types[glyph.type] === undefined) return -Number.MAX_VALUE;\n\n    switch (this.scoreMode) {\n      case AUTO_GLYPH_SCORE.EFFECT_COUNT:\n        return player.reality.glyphs.filter.simple;\n\n      case AUTO_GLYPH_SCORE.RARITY_THRESHOLD:\n      case AUTO_GLYPH_SCORE.SPECIFIED_EFFECT:\n        return this.types[glyph.type].rarity;\n\n      case AUTO_GLYPH_SCORE.EFFECT_SCORE:\n        return this.types[glyph.type].score;\n\n      case AUTO_GLYPH_SCORE.LOWEST_SACRIFICE:\n      case AUTO_GLYPH_SCORE.LOWEST_ALCHEMY:\n      case AUTO_GLYPH_SCORE.ALCHEMY_VALUE:\n        // These modes never keep glyphs and always refine/sacrfice\n        return Number.MAX_VALUE;\n\n      default:\n        throw new Error(\"Unknown glyph score mode in threshold check\");\n    }\n  },\n\n  wouldKeep(glyph) {\n    return this.filterValue(glyph) >= this.thresholdValue(glyph);\n  },\n\n  // Given a list of glyphs, pick the one with the highest score\n  pick(glyphs) {\n    // We want to make sure to account for when glyphs are compared to different thresholds based on their type, or\n    // else we end up always picking the rarest glyph despite all filter settings. However, we need to special-case\n    // modes which never keep glyphs, or else they all become the same value and it ends up picking pseudo-randomly\n    const glyphScore = glyph => {\n      const filter = this.filterValue(glyph);\n      const threshold = this.thresholdValue(glyph);\n      return threshold === Number.MAX_VALUE ? filter : filter - threshold;\n    };\n\n    return glyphs.map(g => ({\n      glyph: g,\n      score: glyphScore(g)\n    })).reduce((x, y) => x.score > y.score ? x : y).glyph;\n  },\n\n  getRidOfGlyph(glyph) {\n    // Auto clean calls this function too, which chokes without a special case for these types\n    if (glyph.type === \"cursed\" || glyph.type === \"companion\") {\n      GlyphSacrificeHandler.deleteGlyph(glyph, true);\n      return;\n    }\n\n    switch (this.sacMode) {\n      case AUTO_GLYPH_REJECT.SACRIFICE:\n        GlyphSacrificeHandler.sacrificeGlyph(glyph, true);\n        break;\n\n      case AUTO_GLYPH_REJECT.REFINE:\n        GlyphSacrificeHandler.attemptRefineGlyph(glyph, true);\n        break;\n\n      case AUTO_GLYPH_REJECT.REFINE_TO_CAP:\n        if (GlyphSacrificeHandler.glyphRefinementGain(glyph) === 0) GlyphSacrificeHandler.sacrificeGlyph(glyph, true);else GlyphSacrificeHandler.attemptRefineGlyph(glyph, true);\n        break;\n\n      default:\n        throw new Error(\"Unknown auto Glyph Sacrifice mode\");\n    }\n  },\n\n  // Generally only used for UI in order to notify the player that they might end up retroactively getting rid of\n  // some glyphs they otherwise want to keep\n  hasNegativeEffectScore() {\n    return this.scoreMode === AUTO_GLYPH_SCORE.EFFECT_SCORE && Object.values(this.types).map(t => t.effectScores.min()).min() < 0;\n  },\n\n  // These are here because they're used in multiple UI components\n  filterModeName(id) {\n    switch (id) {\n      case AUTO_GLYPH_SCORE.LOWEST_SACRIFICE:\n        return \"Lowest Total Glyph Sacrifice\";\n\n      case AUTO_GLYPH_SCORE.EFFECT_COUNT:\n        return \"Number of Effects\";\n\n      case AUTO_GLYPH_SCORE.RARITY_THRESHOLD:\n        return \"Rarity Threshold\";\n\n      case AUTO_GLYPH_SCORE.SPECIFIED_EFFECT:\n        return \"Specified Effect\";\n\n      case AUTO_GLYPH_SCORE.EFFECT_SCORE:\n        return \"Effect Score\";\n\n      case AUTO_GLYPH_SCORE.LOWEST_ALCHEMY:\n        return \"Lowest Alchemy Resource\";\n\n      case AUTO_GLYPH_SCORE.ALCHEMY_VALUE:\n        return \"Refinement Value\";\n\n      default:\n        return \"Invalid Glyph filter mode\";\n    }\n  },\n\n  trashModeDesc(id) {\n    switch (id) {\n      case AUTO_GLYPH_REJECT.SACRIFICE:\n        return \"Always sacrifice\";\n\n      case AUTO_GLYPH_REJECT.REFINE:\n        return \"Always refine\";\n\n      case AUTO_GLYPH_REJECT.REFINE_TO_CAP:\n        return \"Refine to cap, then sacrifice\";\n\n      default:\n        return \"Invalid Glyph trash mode\";\n    }\n  }\n\n};\nexport function autoAdjustGlyphWeights() {\n  const sources = getGlyphLevelSources();\n\n  const f = x => Math.pow(Math.clampMin(1, Math.log(5 * x)), 3 / 2);\n\n  const totalWeight = Object.values(sources).map(s => f(s.value)).sum();\n\n  const scaledWeight = key => 100 * f(sources[key].value) / totalWeight; // Adjust all weights to be integer, while maintaining that they must sum to 100. We ensure it's within 1 on the\n  // weights by flooring and then taking guesses on which ones would give the largest boost when adding the lost\n  // amounts. This isn't necessarily the best integer weighting, but gives a result that's quite literally within\n  // 99.97% of the non-integer optimal settings and prevents the total from exceeding 100.\n\n\n  const weightKeys = [\"ep\", \"repl\", \"dt\", \"eternities\"];\n  const weights = [];\n\n  for (const key of weightKeys) {\n    weights.push({\n      key,\n      percent: scaledWeight(key)\n    });\n  }\n\n  const fracPart = x => x - Math.floor(x);\n\n  const priority = weights.sort((a, b) => fracPart(b.percent) - fracPart(a.percent)).map(w => w.key);\n  const missingPercent = 100 - weights.map(w => Math.floor(w.percent)).reduce((a, b) => a + b);\n\n  for (let i = 0; i < weightKeys.length; i++) {\n    const key = priority[i];\n    player.celestials.effarig.glyphWeights[key] = Math.floor(scaledWeight(key)) + (i < missingPercent ? 1 : 0);\n  }\n}\n\nfunction getGlyphLevelSources() {\n  // Glyph levels are the product of 3 or 4 sources (eternities are enabled via upgrade).\n  // Once Effarig is unlocked, these contributions can be adjusted; the math is described in detail\n  // in getGlyphLevelInputs. These *Base values are the nominal inputs, as they would be multiplied without Effarig\n  let eternityPoints = Player.canEternity ? Currency.eternityPoints.value.plus(gainedEternityPoints()) : Currency.eternityPoints.value;\n  eternityPoints = Decimal.max(player.records.thisReality.maxEP, eternityPoints);\n  const epCoeff = 0.016;\n  const epBase = Math.pow(Math.max(1, eternityPoints.pLog10()), 0.5) * epCoeff;\n  const replPow = 0.4 + getAdjustedGlyphEffect(\"replicationglyphlevel\");\n  const replCoeff = 0.025;\n  const replBase = Math.pow(Math.max(1, player.records.thisReality.maxReplicanti.log10()), replPow) * replCoeff;\n  const dtPow = 1.3 + getAdjustedGlyphEffect(\"realityDTglyph\");\n  const dtCoeff = 0.025;\n  const dtBase = Math.pow(Math.max(1, player.records.thisReality.maxDT.pLog10()), dtPow) * dtCoeff;\n  const eterBase = Effects.max(1, RealityUpgrade(18));\n  return {\n    ep: {\n      name: \"EP\",\n      value: epBase,\n      coeff: epCoeff,\n      exp: 0.5\n    },\n    repl: {\n      name: \"Replicanti\",\n      value: replBase,\n      coeff: replCoeff,\n      exp: replPow\n    },\n    dt: {\n      name: \"DT\",\n      value: dtBase,\n      coeff: dtCoeff,\n      exp: dtPow\n    },\n    eternities: {\n      name: \"Eternities\",\n      value: eterBase,\n      // These are copied from Reality Upgrade 18's gameDB entry\n      coeff: 0.45,\n      exp: 0.5\n    }\n  };\n}\n\nexport function getGlyphLevelInputs() {\n  const sources = getGlyphLevelSources();\n  const staticFactors = GameCache.staticGlyphWeights.value; // If the nomial blend of inputs is a * b * c * d, then the contribution can be tuend by\n  // changing the exponents on the terms: aⁿ¹ * bⁿ² * cⁿ³ * dⁿ⁴\n  // If n1..n4 just add up to 4, then the optimal strategy is to just max out the one over the\n  // largest term -- so probably replicants, So, instead of using the weights directly, a\n  // function of the weights is used: n_i = (4 w_i)^blendExp; put differently, the exponents\n  // don't add up to 4, but their powers do (for blendExp = 1/3, the cubes of the exponents sum to\n  // 4.\n  // The optimal weights, given a blendExp, are proportional to log(x)^(1/(1- blendExp))\n\n  const blendExp = 1 / 3; // Besides adding an exponent to a, b, c, and d, we can also scale them before exponentiation.\n  // So, we'd have (s a)ⁿ¹ * (s b)ⁿ² * (s c)ⁿ³ * (s d)ⁿ⁴\n  // Then, we can divide the result by s⁴; this does nothing for even weights\n  // This can reduce the effect that Effarig can have; consider the following examples:\n  // Inputs : 100, 1, 1, 1. Nominal result : 100\n  // blendExp = 1/3; optimal weights: 1, 0, 0, 0; result = 1493\n  // Scaling by 100: 10000, 100, 100, 100\n  //                 optimal weights: 0.485, 0.17, 0.17, 0.17; result = 191.5\n  // The degree of this effect depends on the scale of the inputs:\n  // Inputs: 1000, 1, 1, 1. Nominal result: 1000\n  //                 optimal weights: 1, 0, 0, 0; result = 57836\n  // Scaling by 100: 100000, 100, 100, 100\n  //                 optimal weights: 0.57, 0.14, 0.14, 0.14; result = 3675\n  // Scaling does allow the user to produce results less than 1\n  // 100000, 100, 100, 100 with weights of 0, 1, 0, 0 results in 1.49e-5\n  // For display purposes, each term is divided independently by s.\n\n  const preScale = 5;\n  const weights = player.celestials.effarig.glyphWeights;\n\n  const adjustFactor = (source, weight) => {\n    const input = source.value;\n    const powEffect = Math.pow(4 * weight, blendExp);\n    source.value = input > 0 ? Math.pow(input * preScale, powEffect) / preScale : 0;\n    source.coeff = Math.pow(preScale, powEffect - 1) * Math.pow(source.coeff, powEffect);\n    source.exp *= powEffect;\n  };\n\n  adjustFactor(sources.ep, weights.ep / 100);\n  adjustFactor(sources.repl, weights.repl / 100);\n  adjustFactor(sources.dt, weights.dt / 100);\n  adjustFactor(sources.eternities, weights.eternities / 100);\n  const shardFactor = Ra.unlocks.relicShardGlyphLevelBoost.effectOrDefault(0);\n  let baseLevel = sources.ep.value * sources.repl.value * sources.dt.value * sources.eternities.value * staticFactors.perkShop + shardFactor;\n  const singularityEffect = SingularityMilestone.glyphLevelFromSingularities.effectOrDefault(1);\n  baseLevel *= singularityEffect;\n  let scaledLevel = baseLevel; // The softcap starts at begin and rate determines how quickly level scales after the cap, turning a linear pre-cap\n  // increase to a quadratic post-cap increase with twice the scaling. For example, with begin = 1000 and rate = 400:\n  // - Scaled level 1400 requires +800 more base levels from the start of the cap (ie. level 1800)\n  // - Scaled level 1800 requires +1600 more base levels from scaled 1400 (ie. level 3400)\n  // - Each additional 400 scaled requires another +800 on top of the already-existing gap for base\n  // This is applied twice in a stacking way, using regular instability first and then again with hyperinstability\n  // if the newly reduced level is still above the second threshold\n\n  const instabilitySoftcap = (level, begin, rate) => {\n    if (level < begin) return level;\n    const excess = (level - begin) / rate;\n    return begin + 0.5 * rate * (Math.sqrt(1 + 4 * excess) - 1);\n  };\n\n  scaledLevel = instabilitySoftcap(scaledLevel, staticFactors.instability, 500);\n  scaledLevel = instabilitySoftcap(scaledLevel, staticFactors.hyperInstability, 400);\n  const scalePenalty = scaledLevel > 0 ? baseLevel / scaledLevel : 1;\n  const incAfterInstability = staticFactors.realityUpgrades + staticFactors.achievements;\n  baseLevel += incAfterInstability;\n  scaledLevel += incAfterInstability;\n  return {\n    ep: sources.ep,\n    repl: sources.repl,\n    dt: sources.dt,\n    eter: sources.eternities,\n    perkShop: staticFactors.perkShop,\n    scalePenalty,\n    rowFactor: staticFactors.realityUpgrades,\n    achievementFactor: staticFactors.achievements,\n    shardFactor,\n    singularityEffect,\n    rawLevel: baseLevel,\n    actualLevel: Math.max(1, scaledLevel)\n  };\n} // Calculates glyph weights which don't change over the course of a reality unless particular events occur; this is\n// stored in the GameCache and only invalidated as needed\n\nexport function staticGlyphWeights() {\n  const perkShop = Effects.max(1, PerkShopUpgrade.glyphLevel);\n  const instability = Glyphs.instabilityThreshold;\n  const hyperInstability = Glyphs.hyperInstabilityThreshold;\n  const realityUpgrades = [Array.range(1, 5).every(x => RealityUpgrade(x).boughtAmount > 0)].concat(Array.range(1, 4).map(x => Array.range(1, 5).every(y => RealityUpgrade(5 * x + y).isBought))).filter(x => x).length;\n  const achievements = Effects.sum(Achievement(148), Achievement(166));\n  return {\n    perkShop,\n    instability,\n    hyperInstability,\n    realityUpgrades,\n    achievements\n  };\n}","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/glyphs/auto-glyph-processor.js"],"names":["AutoGlyphProcessor","scoreMode","player","reality","glyphs","filter","select","value","sacMode","trash","types","bitmaskIndexOffset","type","Error","filterValue","glyph","typeCfg","includes","Infinity","AUTO_GLYPH_SCORE","LOWEST_SACRIFICE","sac","GlyphSacrifice","cap","EFFECT_COUNT","strengthToRarity","strength","getGlyphEffectsFromBitmask","effects","effect","isGenerated","length","RARITY_THRESHOLD","SPECIFIED_EFFECT","glyphEffectCount","countValuesFromBitmask","effectCount","missingEffects","specifiedMask","EFFECT_SCORE","effectList","map","bitmaskIndex","offset","effectScore","e","effectScores","sum","LOWEST_ALCHEMY","resource","AlchemyResource","refinementGain","GlyphSacrificeHandler","glyphRefinementGain","isUnlocked","amount","Number","NEGATIVE_INFINITY","ALCHEMY_VALUE","thresholdValue","undefined","MAX_VALUE","simple","rarity","score","wouldKeep","pick","glyphScore","threshold","g","reduce","x","y","getRidOfGlyph","deleteGlyph","AUTO_GLYPH_REJECT","SACRIFICE","sacrificeGlyph","REFINE","attemptRefineGlyph","REFINE_TO_CAP","hasNegativeEffectScore","Object","values","t","min","filterModeName","id","trashModeDesc","autoAdjustGlyphWeights","sources","getGlyphLevelSources","f","Math","pow","clampMin","log","totalWeight","s","scaledWeight","key","weightKeys","weights","push","percent","fracPart","floor","priority","sort","a","b","w","missingPercent","i","celestials","effarig","glyphWeights","eternityPoints","Player","canEternity","Currency","plus","gainedEternityPoints","Decimal","max","records","thisReality","maxEP","epCoeff","epBase","pLog10","replPow","getAdjustedGlyphEffect","replCoeff","replBase","maxReplicanti","log10","dtPow","dtCoeff","dtBase","maxDT","eterBase","Effects","RealityUpgrade","ep","name","coeff","exp","repl","dt","eternities","getGlyphLevelInputs","staticFactors","GameCache","staticGlyphWeights","blendExp","preScale","adjustFactor","source","weight","input","powEffect","shardFactor","Ra","unlocks","relicShardGlyphLevelBoost","effectOrDefault","baseLevel","perkShop","singularityEffect","SingularityMilestone","glyphLevelFromSingularities","scaledLevel","instabilitySoftcap","level","begin","rate","excess","sqrt","instability","hyperInstability","scalePenalty","incAfterInstability","realityUpgrades","achievements","eter","rowFactor","achievementFactor","rawLevel","actualLevel","PerkShopUpgrade","glyphLevel","Glyphs","instabilityThreshold","hyperInstabilityThreshold","Array","range","every","boughtAmount","concat","isBought","Achievement"],"mappings":"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","sourcesContent":["export const AutoGlyphProcessor = {\r\n  get scoreMode() {\r\n    return player.reality.glyphs.filter.select;\r\n  },\r\n  set scoreMode(value) {\r\n    player.reality.glyphs.filter.select = value;\r\n  },\r\n  get sacMode() {\r\n    return player.reality.glyphs.filter.trash;\r\n  },\r\n  set sacMode(value) {\r\n    player.reality.glyphs.filter.trash = value;\r\n  },\r\n  get types() {\r\n    return player.reality.glyphs.filter.types;\r\n  },\r\n  // This exists to avoid unnecessary repeated object initialization in the filtering code\r\n  bitmaskIndexOffset(type) {\r\n    switch (type) {\r\n      case \"time\":\r\n        return 0;\r\n      case \"dilation\":\r\n        return 4;\r\n      case \"replication\":\r\n        return 8;\r\n      case \"infinity\":\r\n        return 12;\r\n      case \"power\":\r\n        return 16;\r\n      case \"effarig\":\r\n        return 20;\r\n      default:\r\n        throw new Error(\"Unknown glyph type mode in bitmaskIndexOffset\");\r\n    }\r\n  },\r\n  // This function is meant to be something which assigns a value to every glyph, with the assumption that\r\n  // higher numbers correspond to better glyphs. This value is also displayed on tooltips when it depends\r\n  // on only the glyph itself and not external factors.\r\n  filterValue(glyph) {\r\n    const typeCfg = this.types[glyph.type];\r\n    if ([\"companion\", \"reality\"].includes(glyph.type)) return Infinity;\r\n    if (glyph.type === \"cursed\") return -Infinity;\r\n    switch (this.scoreMode) {\r\n      case AUTO_GLYPH_SCORE.LOWEST_SACRIFICE:\r\n        // Picked glyphs are never kept in this mode. Sacrifice cap needs to be checked since effarig caps\r\n        // at a lower value than the others and we don't want to uselessly pick that to sacrifice all the time\r\n        return player.reality.glyphs.sac[glyph.type] >= GlyphSacrifice[glyph.type].cap\r\n          ? -Infinity\r\n          : -player.reality.glyphs.sac[glyph.type];\r\n      case AUTO_GLYPH_SCORE.EFFECT_COUNT:\r\n        // Effect count, plus a very small rarity term to break ties in favor of rarer glyphs\r\n        return strengthToRarity(glyph.strength) / 1000 + getGlyphEffectsFromBitmask(glyph.effects, 0, 0)\r\n          .filter(effect => effect.isGenerated).length;\r\n      case AUTO_GLYPH_SCORE.RARITY_THRESHOLD:\r\n        return strengthToRarity(glyph.strength);\r\n      case AUTO_GLYPH_SCORE.SPECIFIED_EFFECT: {\r\n        // Value is equal to rarity but minus 200 for each missing effect. This makes all glyphs which don't\r\n        // satisfy the requirements have a negative score and generally the worse a glyph misses the requirements,\r\n        // the more negative of a score it will have\r\n        const glyphEffectCount = countValuesFromBitmask(glyph.effects);\r\n        if (glyphEffectCount < typeCfg.effectCount) {\r\n          return strengthToRarity(glyph.strength) - 200 * (typeCfg.effectCount - glyphEffectCount);\r\n        }\r\n        // The missing effect count can be gotten by taking the full filter bitmask, removing only the bits which are\r\n        // present on both the filter and the glyph, and then counting the bits up\r\n        const missingEffects = countValuesFromBitmask(typeCfg.specifiedMask - (typeCfg.specifiedMask & glyph.effects));\r\n        return strengthToRarity(glyph.strength) - 200 * missingEffects;\r\n      }\r\n      case AUTO_GLYPH_SCORE.EFFECT_SCORE: {\r\n        const effectList = getGlyphEffectsFromBitmask(glyph.effects, 0, 0)\r\n          .filter(effect => effect.isGenerated)\r\n          .map(effect => effect.bitmaskIndex);\r\n        const offset = this.bitmaskIndexOffset(glyph.type);\r\n        // This ternary check is required to filter out any effects which may appear on the glyph which aren't normally\r\n        // there in typical glyph generation. Ra-Nameless 25 is the only case where this happens, but this also has the\r\n        // side-effect of making altered glyph generation in mods less likely to crash the game as well\r\n        const effectScore = effectList\r\n          .map(e => (typeCfg.effectScores[e - offset] ? typeCfg.effectScores[e - offset] : 0))\r\n          .sum();\r\n        return strengthToRarity(glyph.strength) + effectScore;\r\n      }\r\n      // Picked glyphs are never kept in Alchemy modes.\r\n      // Glyphs for non-unlocked or capped Alchemy Resources are assigned NEGATIVE_INFINITY\r\n      // to make them picked last, because we can't refine them.\r\n      case AUTO_GLYPH_SCORE.LOWEST_ALCHEMY: {\r\n        const resource = AlchemyResource[glyph.type];\r\n        const refinementGain = GlyphSacrificeHandler.glyphRefinementGain(glyph);\r\n        return resource.isUnlocked && refinementGain > 0\r\n          ? -resource.amount\r\n          : Number.NEGATIVE_INFINITY;\r\n      }\r\n      case AUTO_GLYPH_SCORE.ALCHEMY_VALUE:\r\n        return AlchemyResource[glyph.type].isUnlocked\r\n          ? GlyphSacrificeHandler.glyphRefinementGain(glyph)\r\n          : Number.NEGATIVE_INFINITY;\r\n      default:\r\n        throw new Error(\"Unknown glyph score mode in score assignment\");\r\n    }\r\n  },\r\n  // This is a mode-specific threshold which determines if selected glyphs are \"good enough\" to keep\r\n  thresholdValue(glyph) {\r\n    // Glyph filter settings are undefined for companion/cursed/reality glyphs, so we return the lowest possible\r\n    // value on the basis that we never want to automatically get rid of them\r\n    if (this.types[glyph.type] === undefined) return -Number.MAX_VALUE;\r\n    switch (this.scoreMode) {\r\n      case AUTO_GLYPH_SCORE.EFFECT_COUNT:\r\n        return player.reality.glyphs.filter.simple;\r\n      case AUTO_GLYPH_SCORE.RARITY_THRESHOLD:\r\n      case AUTO_GLYPH_SCORE.SPECIFIED_EFFECT:\r\n        return this.types[glyph.type].rarity;\r\n      case AUTO_GLYPH_SCORE.EFFECT_SCORE:\r\n        return this.types[glyph.type].score;\r\n      case AUTO_GLYPH_SCORE.LOWEST_SACRIFICE:\r\n      case AUTO_GLYPH_SCORE.LOWEST_ALCHEMY:\r\n      case AUTO_GLYPH_SCORE.ALCHEMY_VALUE:\r\n        // These modes never keep glyphs and always refine/sacrfice\r\n        return Number.MAX_VALUE;\r\n      default:\r\n        throw new Error(\"Unknown glyph score mode in threshold check\");\r\n    }\r\n  },\r\n  wouldKeep(glyph) {\r\n    return this.filterValue(glyph) >= this.thresholdValue(glyph);\r\n  },\r\n  // Given a list of glyphs, pick the one with the highest score\r\n  pick(glyphs) {\r\n    // We want to make sure to account for when glyphs are compared to different thresholds based on their type, or\r\n    // else we end up always picking the rarest glyph despite all filter settings. However, we need to special-case\r\n    // modes which never keep glyphs, or else they all become the same value and it ends up picking pseudo-randomly\r\n    const glyphScore = glyph => {\r\n      const filter = this.filterValue(glyph);\r\n      const threshold = this.thresholdValue(glyph);\r\n      return threshold === Number.MAX_VALUE ? filter : filter - threshold;\r\n    };\r\n\r\n    return glyphs\r\n      .map(g => ({ glyph: g, score: glyphScore(g) }))\r\n      .reduce((x, y) => (x.score > y.score ? x : y))\r\n      .glyph;\r\n  },\r\n  getRidOfGlyph(glyph) {\r\n    // Auto clean calls this function too, which chokes without a special case for these types\r\n    if (glyph.type === \"cursed\" || glyph.type === \"companion\") {\r\n      GlyphSacrificeHandler.deleteGlyph(glyph, true);\r\n      return;\r\n    }\r\n\r\n    switch (this.sacMode) {\r\n      case AUTO_GLYPH_REJECT.SACRIFICE:\r\n        GlyphSacrificeHandler.sacrificeGlyph(glyph, true);\r\n        break;\r\n      case AUTO_GLYPH_REJECT.REFINE:\r\n        GlyphSacrificeHandler.attemptRefineGlyph(glyph, true);\r\n        break;\r\n      case AUTO_GLYPH_REJECT.REFINE_TO_CAP:\r\n        if (GlyphSacrificeHandler.glyphRefinementGain(glyph) === 0) GlyphSacrificeHandler.sacrificeGlyph(glyph, true);\r\n        else GlyphSacrificeHandler.attemptRefineGlyph(glyph, true);\r\n        break;\r\n      default:\r\n        throw new Error(\"Unknown auto Glyph Sacrifice mode\");\r\n    }\r\n  },\r\n  // Generally only used for UI in order to notify the player that they might end up retroactively getting rid of\r\n  // some glyphs they otherwise want to keep\r\n  hasNegativeEffectScore() {\r\n    return this.scoreMode === AUTO_GLYPH_SCORE.EFFECT_SCORE &&\r\n      Object.values(this.types).map(t => t.effectScores.min()).min() < 0;\r\n  },\r\n\r\n  // These are here because they're used in multiple UI components\r\n  filterModeName(id) {\r\n    switch (id) {\r\n      case AUTO_GLYPH_SCORE.LOWEST_SACRIFICE:\r\n        return \"Lowest Total Glyph Sacrifice\";\r\n      case AUTO_GLYPH_SCORE.EFFECT_COUNT:\r\n        return \"Number of Effects\";\r\n      case AUTO_GLYPH_SCORE.RARITY_THRESHOLD:\r\n        return \"Rarity Threshold\";\r\n      case AUTO_GLYPH_SCORE.SPECIFIED_EFFECT:\r\n        return \"Specified Effect\";\r\n      case AUTO_GLYPH_SCORE.EFFECT_SCORE:\r\n        return \"Effect Score\";\r\n      case AUTO_GLYPH_SCORE.LOWEST_ALCHEMY:\r\n        return \"Lowest Alchemy Resource\";\r\n      case AUTO_GLYPH_SCORE.ALCHEMY_VALUE:\r\n        return \"Refinement Value\";\r\n      default:\r\n        return \"Invalid Glyph filter mode\";\r\n    }\r\n  },\r\n  trashModeDesc(id) {\r\n    switch (id) {\r\n      case AUTO_GLYPH_REJECT.SACRIFICE:\r\n        return \"Always sacrifice\";\r\n      case AUTO_GLYPH_REJECT.REFINE:\r\n        return \"Always refine\";\r\n      case AUTO_GLYPH_REJECT.REFINE_TO_CAP:\r\n        return \"Refine to cap, then sacrifice\";\r\n      default:\r\n        return \"Invalid Glyph trash mode\";\r\n    }\r\n  }\r\n};\r\n\r\nexport function autoAdjustGlyphWeights() {\r\n  const sources = getGlyphLevelSources();\r\n  const f = x => Math.pow(Math.clampMin(1, Math.log(5 * x)), 3 / 2);\r\n  const totalWeight = Object.values(sources).map(s => f(s.value)).sum();\r\n  const scaledWeight = key => 100 * f(sources[key].value) / totalWeight;\r\n\r\n  // Adjust all weights to be integer, while maintaining that they must sum to 100. We ensure it's within 1 on the\r\n  // weights by flooring and then taking guesses on which ones would give the largest boost when adding the lost\r\n  // amounts. This isn't necessarily the best integer weighting, but gives a result that's quite literally within\r\n  // 99.97% of the non-integer optimal settings and prevents the total from exceeding 100.\r\n  const weightKeys = [\"ep\", \"repl\", \"dt\", \"eternities\"];\r\n  const weights = [];\r\n  for (const key of weightKeys) {\r\n    weights.push({\r\n      key,\r\n      percent: scaledWeight(key)\r\n    });\r\n  }\r\n  const fracPart = x => x - Math.floor(x);\r\n  const priority = weights.sort((a, b) => fracPart(b.percent) - fracPart(a.percent)).map(w => w.key);\r\n  const missingPercent = 100 - weights.map(w => Math.floor(w.percent)).reduce((a, b) => a + b);\r\n  for (let i = 0; i < weightKeys.length; i++) {\r\n    const key = priority[i];\r\n    player.celestials.effarig.glyphWeights[key] = Math.floor(scaledWeight(key)) + (i < missingPercent ? 1 : 0);\r\n  }\r\n}\r\n\r\nfunction getGlyphLevelSources() {\r\n  // Glyph levels are the product of 3 or 4 sources (eternities are enabled via upgrade).\r\n  // Once Effarig is unlocked, these contributions can be adjusted; the math is described in detail\r\n  // in getGlyphLevelInputs. These *Base values are the nominal inputs, as they would be multiplied without Effarig\r\n  let eternityPoints = Player.canEternity\r\n    ? Currency.eternityPoints.value.plus(gainedEternityPoints())\r\n    : Currency.eternityPoints.value;\r\n  eternityPoints = Decimal.max(player.records.thisReality.maxEP, eternityPoints);\r\n  const epCoeff = 0.016;\r\n  const epBase = Math.pow(Math.max(1, eternityPoints.pLog10()), 0.5) * epCoeff;\r\n  const replPow = 0.4 + getAdjustedGlyphEffect(\"replicationglyphlevel\");\r\n  const replCoeff = 0.025;\r\n  const replBase = Math.pow(Math.max(1, player.records.thisReality.maxReplicanti.log10()), replPow) * replCoeff;\r\n  const dtPow = 1.3 + getAdjustedGlyphEffect(\"realityDTglyph\");\r\n  const dtCoeff = 0.025;\r\n  const dtBase = Math.pow(Math.max(1, player.records.thisReality.maxDT.pLog10()), dtPow) * dtCoeff;\r\n  const eterBase = Effects.max(1, RealityUpgrade(18));\r\n  return {\r\n    ep: {\r\n      name: \"EP\",\r\n      value: epBase,\r\n      coeff: epCoeff,\r\n      exp: 0.5,\r\n    },\r\n    repl: {\r\n      name: \"Replicanti\",\r\n      value: replBase,\r\n      coeff: replCoeff,\r\n      exp: replPow,\r\n    },\r\n    dt: {\r\n      name: \"DT\",\r\n      value: dtBase,\r\n      coeff: dtCoeff,\r\n      exp: dtPow,\r\n    },\r\n    eternities: {\r\n      name: \"Eternities\",\r\n      value: eterBase,\r\n      // These are copied from Reality Upgrade 18's gameDB entry\r\n      coeff: 0.45,\r\n      exp: 0.5,\r\n    }\r\n  };\r\n}\r\n\r\nexport function getGlyphLevelInputs() {\r\n  const sources = getGlyphLevelSources();\r\n  const staticFactors = GameCache.staticGlyphWeights.value;\r\n  // If the nomial blend of inputs is a * b * c * d, then the contribution can be tuend by\r\n  // changing the exponents on the terms: aⁿ¹ * bⁿ² * cⁿ³ * dⁿ⁴\r\n  // If n1..n4 just add up to 4, then the optimal strategy is to just max out the one over the\r\n  // largest term -- so probably replicants, So, instead of using the weights directly, a\r\n  // function of the weights is used: n_i = (4 w_i)^blendExp; put differently, the exponents\r\n  // don't add up to 4, but their powers do (for blendExp = 1/3, the cubes of the exponents sum to\r\n  // 4.\r\n  // The optimal weights, given a blendExp, are proportional to log(x)^(1/(1- blendExp))\r\n  const blendExp = 1 / 3;\r\n  // Besides adding an exponent to a, b, c, and d, we can also scale them before exponentiation.\r\n  // So, we'd have (s a)ⁿ¹ * (s b)ⁿ² * (s c)ⁿ³ * (s d)ⁿ⁴\r\n  // Then, we can divide the result by s⁴; this does nothing for even weights\r\n  // This can reduce the effect that Effarig can have; consider the following examples:\r\n  // Inputs : 100, 1, 1, 1. Nominal result : 100\r\n  // blendExp = 1/3; optimal weights: 1, 0, 0, 0; result = 1493\r\n  // Scaling by 100: 10000, 100, 100, 100\r\n  //                 optimal weights: 0.485, 0.17, 0.17, 0.17; result = 191.5\r\n  // The degree of this effect depends on the scale of the inputs:\r\n  // Inputs: 1000, 1, 1, 1. Nominal result: 1000\r\n  //                 optimal weights: 1, 0, 0, 0; result = 57836\r\n  // Scaling by 100: 100000, 100, 100, 100\r\n  //                 optimal weights: 0.57, 0.14, 0.14, 0.14; result = 3675\r\n  // Scaling does allow the user to produce results less than 1\r\n  // 100000, 100, 100, 100 with weights of 0, 1, 0, 0 results in 1.49e-5\r\n  // For display purposes, each term is divided independently by s.\r\n  const preScale = 5;\r\n  const weights = player.celestials.effarig.glyphWeights;\r\n  const adjustFactor = (source, weight) => {\r\n    const input = source.value;\r\n    const powEffect = Math.pow(4 * weight, blendExp);\r\n    source.value = (input > 0 ? Math.pow(input * preScale, powEffect) / preScale : 0);\r\n    source.coeff = Math.pow(preScale, powEffect - 1) * Math.pow(source.coeff, powEffect);\r\n    source.exp *= powEffect;\r\n  };\r\n  adjustFactor(sources.ep, weights.ep / 100);\r\n  adjustFactor(sources.repl, weights.repl / 100);\r\n  adjustFactor(sources.dt, weights.dt / 100);\r\n  adjustFactor(sources.eternities, weights.eternities / 100);\r\n  const shardFactor = Ra.unlocks.relicShardGlyphLevelBoost.effectOrDefault(0);\r\n  let baseLevel = sources.ep.value * sources.repl.value * sources.dt.value * sources.eternities.value *\r\n    staticFactors.perkShop + shardFactor;\r\n\r\n  const singularityEffect = SingularityMilestone.glyphLevelFromSingularities.effectOrDefault(1);\r\n  baseLevel *= singularityEffect;\r\n\r\n  let scaledLevel = baseLevel;\r\n  // The softcap starts at begin and rate determines how quickly level scales after the cap, turning a linear pre-cap\r\n  // increase to a quadratic post-cap increase with twice the scaling. For example, with begin = 1000 and rate = 400:\r\n  // - Scaled level 1400 requires +800 more base levels from the start of the cap (ie. level 1800)\r\n  // - Scaled level 1800 requires +1600 more base levels from scaled 1400 (ie. level 3400)\r\n  // - Each additional 400 scaled requires another +800 on top of the already-existing gap for base\r\n  // This is applied twice in a stacking way, using regular instability first and then again with hyperinstability\r\n  // if the newly reduced level is still above the second threshold\r\n  const instabilitySoftcap = (level, begin, rate) => {\r\n    if (level < begin) return level;\r\n    const excess = (level - begin) / rate;\r\n    return begin + 0.5 * rate * (Math.sqrt(1 + 4 * excess) - 1);\r\n  };\r\n  scaledLevel = instabilitySoftcap(scaledLevel, staticFactors.instability, 500);\r\n  scaledLevel = instabilitySoftcap(scaledLevel, staticFactors.hyperInstability, 400);\r\n\r\n  const scalePenalty = scaledLevel > 0 ? baseLevel / scaledLevel : 1;\r\n  const incAfterInstability = staticFactors.realityUpgrades + staticFactors.achievements;\r\n  baseLevel += incAfterInstability;\r\n  scaledLevel += incAfterInstability;\r\n  return {\r\n    ep: sources.ep,\r\n    repl: sources.repl,\r\n    dt: sources.dt,\r\n    eter: sources.eternities,\r\n    perkShop: staticFactors.perkShop,\r\n    scalePenalty,\r\n    rowFactor: staticFactors.realityUpgrades,\r\n    achievementFactor: staticFactors.achievements,\r\n    shardFactor,\r\n    singularityEffect,\r\n    rawLevel: baseLevel,\r\n    actualLevel: Math.max(1, scaledLevel),\r\n  };\r\n}\r\n\r\n// Calculates glyph weights which don't change over the course of a reality unless particular events occur; this is\r\n// stored in the GameCache and only invalidated as needed\r\nexport function staticGlyphWeights() {\r\n  const perkShop = Effects.max(1, PerkShopUpgrade.glyphLevel);\r\n  const instability = Glyphs.instabilityThreshold;\r\n  const hyperInstability = Glyphs.hyperInstabilityThreshold;\r\n  const realityUpgrades = [Array.range(1, 5).every(x => RealityUpgrade(x).boughtAmount > 0)]\r\n    .concat(Array.range(1, 4).map(x => Array.range(1, 5).every(y => RealityUpgrade(5 * x + y).isBought)))\r\n    .filter(x => x)\r\n    .length;\r\n  const achievements = Effects.sum(Achievement(148), Achievement(166));\r\n  return {\r\n    perkShop,\r\n    instability,\r\n    hyperInstability,\r\n    realityUpgrades,\r\n    achievements\r\n  };\r\n}\r\n"]},"metadata":{},"sourceType":"module"}