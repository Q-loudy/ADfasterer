{"ast":null,"code":"import GlyphComponent from \"@/components/GlyphComponent\";\nimport ModalWrapperChoice from \"@/components/modals/ModalWrapperChoice\";\nimport PrimaryButton from \"@/components/PrimaryButton\";\nexport default {\n  name: \"RealityModal\",\n  components: {\n    PrimaryButton,\n    ModalWrapperChoice,\n    GlyphComponent\n  },\n\n  data() {\n    return {\n      firstReality: false,\n      hasSpace: true,\n      hasChoice: false,\n      hasFilter: false,\n      glyphs: [],\n      bestLevel: 0,\n      levelDifference: 0,\n      selectedGlyph: undefined,\n      canRefresh: false,\n      level: 0,\n      simRealities: 0,\n      realityMachines: new Decimal(),\n      shardsGained: 0,\n      effarigUnlocked: false,\n      willAutoPurge: false\n    };\n  },\n\n  computed: {\n    firstRealityText() {\n      return `Reality will reset everything except Challenge records and anything under the General header on the\n        Statistics tab. The first ${formatInt(13)} rows of Achievements are also reset,\n        but you will automatically get one Achievement back every\n        ${timeDisplayNoDecimals(30 * 60000)}. You will also gain Reality Machines based on your Eternity Points, a\n        Glyph with a level based on your Eternity Points, Replicanti, and Dilated Time, a Perk Point to spend\n        on quality of life upgrades, and unlock various upgrades.`;\n    },\n\n    canSacrifice() {\n      return RealityUpgrade(19).isEffectActive;\n    },\n\n    warnText() {\n      if (!this.hasChoice) {\n        return `You currently only have a single option for new Glyphs every\n          Reality. You can unlock the ability to choose from multiple Glyphs by canceling out of this modal and\n          purchasing the START Perk.`;\n      }\n\n      if (this.hasFilter && this.selectedGlyph === undefined) {\n        return `If you do not choose a Glyph, one will be automatically selected using your Glyph filter.`;\n      }\n\n      return this.selectedGlyph === undefined ? `You must select a Glyph in order to continue.` : null;\n    },\n\n    gained() {\n      const gainedResources = [];\n      gainedResources.push(`${quantifyInt(\"Reality\", this.simRealities)}`);\n      gainedResources.push(`${quantifyInt(\"Perk Point\", this.simRealities)}`);\n      gainedResources.push(`${quantify(\"Reality Machine\", this.realityMachines, 2)}`);\n\n      if (this.effarigUnlocked) {\n        gainedResources.push(`${quantify(\"Relic Shard\", this.shardsGained, 2)}`);\n      }\n\n      return `You will gain ${makeEnumeration(gainedResources)}`;\n    },\n\n    levelStats() {\n      // Bit annoying to read due to needing >, <, and =, with = needing a different format.\n      return `You will get a level ${formatInt(this.level)} Glyph on Reality, which is\n        ${this.level === this.bestLevel ? \"equal to\" : `\n        ${quantifyInt(\"level\", this.levelDifference)}\n        ${this.level > this.bestLevel ? \"higher\" : \"lower\"} than`} your best.`;\n    },\n\n    confirmationToDisable() {\n      return ConfirmationTypes.glyphSelection.isUnlocked() ? \"glyphSelection\" : undefined;\n    },\n\n    canConfirm() {\n      return this.firstReality || this.selectedGlyph !== undefined || this.hasFilter;\n    }\n\n  },\n\n  created() {\n    this.getGlyphs();\n    GlyphSelection.realityProps = getRealityProps(false, false);\n  },\n\n  methods: {\n    update() {\n      this.firstReality = player.realities === 0;\n      this.hasChoice = Perk.firstPerk.isEffectActive;\n      this.effarigUnlocked = TeresaUnlocks.effarig.canBeApplied;\n      this.hasFilter = EffarigUnlock.glyphFilter.isUnlocked;\n      this.level = gainedGlyphLevel().actualLevel;\n      this.simRealities = 1 + simulatedRealityCount(false);\n      this.hasSpace = GameCache.glyphInventorySpace.value >= this.simRealities;\n      const simRMGained = MachineHandler.gainedRealityMachines.times(this.simRealities);\n      this.realityMachines.copyFrom(simRMGained.clampMax(MachineHandler.distanceToRMCap));\n      this.shardsGained = Effarig.shardsGained * (simulatedRealityCount(false) + 1);\n      this.willAutoPurge = player.reality.autoAutoClean;\n      if (this.firstReality) return;\n\n      for (let i = 0; i < this.glyphs.length; ++i) {\n        const currentGlyph = this.glyphs[i];\n        const newGlyph = GlyphSelection.glyphList(GlyphSelection.choiceCount, gainedGlyphLevel(), {\n          isChoosingGlyph: false\n        })[i];\n        if (currentGlyph.level === newGlyph.level) continue;\n        currentGlyph.level = newGlyph.level;\n        currentGlyph.effects = newGlyph.effects;\n      }\n\n      this.bestLevel = player.records.bestReality.glyphLevel;\n      this.levelDifference = Math.abs(this.bestLevel - this.level);\n    },\n\n    glyphClass(index) {\n      return {\n        \"l-modal-glyph-selection__glyph\": true,\n        \"l-modal-glyph-selection__glyph--selected\": this.selectedGlyph === index\n      };\n    },\n\n    getGlyphs() {\n      this.canRefresh = true;\n      this.glyphs = GlyphSelection.upcomingGlyphs;\n    },\n\n    select(index) {\n      this.selectedGlyph = index;\n    },\n\n    confirmModal(sacrifice) {\n      if (!this.canConfirm) return;\n\n      if (sacrifice) {\n        // Sac isn't passed through confirm so we have to close it manually\n        this.emitClose();\n      }\n\n      startManualReality(sacrifice, this.selectedGlyph);\n    }\n\n  }\n};","map":{"version":3,"sources":["RealityModal.vue"],"names":[],"mappings":"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","sourcesContent":["<script>\r\nimport GlyphComponent from \"@/components/GlyphComponent\";\r\nimport ModalWrapperChoice from \"@/components/modals/ModalWrapperChoice\";\r\nimport PrimaryButton from \"@/components/PrimaryButton\";\r\n\r\nexport default {\r\n  name: \"RealityModal\",\r\n  components: {\r\n    PrimaryButton,\r\n    ModalWrapperChoice,\r\n    GlyphComponent,\r\n  },\r\n  data() {\r\n    return {\r\n      firstReality: false,\r\n      hasSpace: true,\r\n      hasChoice: false,\r\n      hasFilter: false,\r\n      glyphs: [],\r\n      bestLevel: 0,\r\n      levelDifference: 0,\r\n      selectedGlyph: undefined,\r\n      canRefresh: false,\r\n      level: 0,\r\n      simRealities: 0,\r\n      realityMachines: new Decimal(),\r\n      shardsGained: 0,\r\n      effarigUnlocked: false,\r\n      willAutoPurge: false,\r\n    };\r\n  },\r\n  computed: {\r\n    firstRealityText() {\r\n      return `Reality will reset everything except Challenge records and anything under the General header on the\r\n        Statistics tab. The first ${formatInt(13)} rows of Achievements are also reset,\r\n        but you will automatically get one Achievement back every\r\n        ${timeDisplayNoDecimals(30 * 60000)}. You will also gain Reality Machines based on your Eternity Points, a\r\n        Glyph with a level based on your Eternity Points, Replicanti, and Dilated Time, a Perk Point to spend\r\n        on quality of life upgrades, and unlock various upgrades.`;\r\n    },\r\n    canSacrifice() {\r\n      return RealityUpgrade(19).isEffectActive;\r\n    },\r\n    warnText() {\r\n      if (!this.hasChoice) {\r\n        return `You currently only have a single option for new Glyphs every\r\n          Reality. You can unlock the ability to choose from multiple Glyphs by canceling out of this modal and\r\n          purchasing the START Perk.`;\r\n      }\r\n\r\n      if (this.hasFilter && this.selectedGlyph === undefined) {\r\n        return `If you do not choose a Glyph, one will be automatically selected using your Glyph filter.`;\r\n      }\r\n      return this.selectedGlyph === undefined\r\n        ? `You must select a Glyph in order to continue.`\r\n        : null;\r\n    },\r\n    gained() {\r\n      const gainedResources = [];\r\n      gainedResources.push(`${quantifyInt(\"Reality\", this.simRealities)}`);\r\n      gainedResources.push(`${quantifyInt(\"Perk Point\", this.simRealities)}`);\r\n      gainedResources.push(`${quantify(\"Reality Machine\", this.realityMachines, 2)}`);\r\n      if (this.effarigUnlocked) {\r\n        gainedResources.push(`${quantify(\"Relic Shard\", this.shardsGained, 2)}`);\r\n      }\r\n      return `You will gain ${makeEnumeration(gainedResources)}`;\r\n    },\r\n    levelStats() {\r\n      // Bit annoying to read due to needing >, <, and =, with = needing a different format.\r\n      return `You will get a level ${formatInt(this.level)} Glyph on Reality, which is\r\n        ${this.level === this.bestLevel ? \"equal to\" : `\r\n        ${quantifyInt(\"level\", this.levelDifference)}\r\n        ${this.level > this.bestLevel ? \"higher\" : \"lower\"} than`} your best.`;\r\n    },\r\n    confirmationToDisable() {\r\n      return ConfirmationTypes.glyphSelection.isUnlocked() ? \"glyphSelection\" : undefined;\r\n    },\r\n    canConfirm() {\r\n      return this.firstReality || this.selectedGlyph !== undefined || this.hasFilter;\r\n    }\r\n  },\r\n  created() {\r\n    this.getGlyphs();\r\n    GlyphSelection.realityProps = getRealityProps(false, false);\r\n  },\r\n  methods: {\r\n    update() {\r\n      this.firstReality = player.realities === 0;\r\n      this.hasChoice = Perk.firstPerk.isEffectActive;\r\n      this.effarigUnlocked = TeresaUnlocks.effarig.canBeApplied;\r\n      this.hasFilter = EffarigUnlock.glyphFilter.isUnlocked;\r\n      this.level = gainedGlyphLevel().actualLevel;\r\n      this.simRealities = 1 + simulatedRealityCount(false);\r\n      this.hasSpace = GameCache.glyphInventorySpace.value >= this.simRealities;\r\n      const simRMGained = MachineHandler.gainedRealityMachines.times(this.simRealities);\r\n      this.realityMachines.copyFrom(simRMGained.clampMax(MachineHandler.distanceToRMCap));\r\n      this.shardsGained = Effarig.shardsGained * (simulatedRealityCount(false) + 1);\r\n      this.willAutoPurge = player.reality.autoAutoClean;\r\n      if (this.firstReality) return;\r\n      for (let i = 0; i < this.glyphs.length; ++i) {\r\n        const currentGlyph = this.glyphs[i];\r\n        const newGlyph = GlyphSelection.glyphList(\r\n          GlyphSelection.choiceCount, gainedGlyphLevel(), { isChoosingGlyph: false }\r\n        )[i];\r\n        if (currentGlyph.level === newGlyph.level) continue;\r\n        currentGlyph.level = newGlyph.level;\r\n        currentGlyph.effects = newGlyph.effects;\r\n      }\r\n      this.bestLevel = player.records.bestReality.glyphLevel;\r\n      this.levelDifference = Math.abs(this.bestLevel - this.level);\r\n    },\r\n    glyphClass(index) {\r\n      return {\r\n        \"l-modal-glyph-selection__glyph\": true,\r\n        \"l-modal-glyph-selection__glyph--selected\": this.selectedGlyph === index,\r\n      };\r\n    },\r\n    getGlyphs() {\r\n      this.canRefresh = true;\r\n      this.glyphs = GlyphSelection.upcomingGlyphs;\r\n    },\r\n    select(index) {\r\n      this.selectedGlyph = index;\r\n    },\r\n    confirmModal(sacrifice) {\r\n      if (!this.canConfirm) return;\r\n      if (sacrifice) {\r\n        // Sac isn't passed through confirm so we have to close it manually\r\n        this.emitClose();\r\n      }\r\n      startManualReality(sacrifice, this.selectedGlyph);\r\n    }\r\n  },\r\n};\r\n</script>\r\n\r\n<template>\r\n  <ModalWrapperChoice\r\n    :option=\"confirmationToDisable\"\r\n    :show-confirm=\"canConfirm\"\r\n    @confirm=\"confirmModal(false)\"\r\n  >\r\n    <template #header>\r\n      You are about to Reality\r\n    </template>\r\n    <div\r\n      v-if=\"firstReality\"\r\n      class=\"c-modal-message__text\"\r\n    >\r\n      {{ firstRealityText }}\r\n    </div>\r\n\r\n    <div class=\"c-modal-message__text\">\r\n      {{ gained }}\r\n    </div>\r\n    <div\r\n      v-if=\"!firstReality\"\r\n      class=\"l-glyph-selection__row\"\r\n    >\r\n      <GlyphComponent\r\n        v-for=\"(glyph, index) in glyphs\"\r\n        :key=\"index\"\r\n        :class=\"glyphClass(index)\"\r\n        :glyph=\"glyph\"\r\n        :is-in-modal=\"true\"\r\n        :ignore-modified-level=\"true\"\r\n        :show-sacrifice=\"canSacrifice\"\r\n        @click.native=\"select(index)\"\r\n      />\r\n    </div>\r\n    <div v-if=\"!firstReality\">\r\n      {{ levelStats }}\r\n      <br>\r\n      <b class=\"o-warning\">\r\n        {{ warnText }}\r\n      </b>\r\n    </div>\r\n    <div v-if=\"simRealities > 1\">\r\n      <br>\r\n      After choosing this Glyph the game will simulate the rest of your Realities,\r\n      <br>\r\n      automatically choosing another {{ quantifyInt(\"Glyph\", simRealities - 1) }}\r\n      based on your Glyph filter settings.\r\n    </div>\r\n    <div v-if=\"willAutoPurge\">\r\n      <br>\r\n      Auto-purge is currently enabled; your selected Glyph\r\n      <br>\r\n      may not appear in your inventory after it triggers.\r\n    </div>\r\n    <div\r\n      v-if=\"!hasSpace\"\r\n      class=\"o-warning\"\r\n    >\r\n      <span v-if=\"simRealities > 1\">\r\n        You will be simulating more Realities than you have open inventory space for;\r\n        this may result in some Glyphs being Sacrificed.\r\n      </span>\r\n      <span v-else>\r\n        You do not have any free inventory space - your selected Glyph will be automatically\r\n        {{ canSacrifice ? \"Sacrificed\" : \"deleted\" }}!\r\n      </span>\r\n    </div>\r\n    <div v-if=\"confirmationToDisable\">\r\n      <br>\r\n      You can force this modal to appear (even if disabled) by Shift-clicking the Reality button.\r\n    </div>\r\n    <template\r\n      v-if=\"canSacrifice && canConfirm\"\r\n      #extra-buttons\r\n    >\r\n      <PrimaryButton\r\n        class=\"o-primary-btn--width-medium c-modal-message__okay-btn\"\r\n        @click=\"confirmModal(true)\"\r\n      >\r\n        Sacrifice\r\n      </PrimaryButton>\r\n    </template>\r\n  </ModalWrapperChoice>\r\n</template>\r\n\r\n<style scoped>\r\n.o-warning {\r\n  color: var(--color-infinity);\r\n}\r\n</style>\r\n"],"sourceRoot":"src/components/modals/prestige"},"metadata":{},"sourceType":"module"}