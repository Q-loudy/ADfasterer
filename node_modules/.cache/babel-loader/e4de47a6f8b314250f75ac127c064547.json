{"ast":null,"code":"import \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n// This actually deals with both sacrifice and refining, but I wasn't 100% sure what to call it\nexport const GlyphSacrificeHandler = {\n  // Anything scaling on sacrifice caps at this value, even though the actual sacrifice values can go higher\n  maxSacrificeForEffects: 1e100,\n\n  // This is used for glyph UI-related things in a few places, but is handled here as a getter which is only called\n  // sparingly - that is, whenever the cache is invalidated after a glyph is sacrificed. Thus it only gets recalculated\n  // when glyphs are actually sacrificed, rather than every render cycle.\n  get logTotalSacrifice() {\n    // We check elsewhere for this equalling zero to determine if the player has ever sacrificed. Technically this\n    // should check for -Infinity, but the clampMin works in practice because the minimum possible sacrifice\n    // value is greater than 1 for even the weakest possible glyph\n    return BASIC_GLYPH_TYPES.reduce((tot, type) => tot + Math.log10(Math.clampMin(player.reality.glyphs.sac[type], 1)), 0);\n  },\n\n  get canSacrifice() {\n    return RealityUpgrade(19).isBought;\n  },\n\n  get isRefining() {\n    return Ra.unlocks.unlockGlyphAlchemy.canBeApplied && AutoGlyphProcessor.sacMode !== AUTO_GLYPH_REJECT.SACRIFICE;\n  },\n\n  handleSpecialGlyphTypes(glyph) {\n    switch (glyph.type) {\n      case \"companion\":\n        Modal.deleteCompanion.show();\n        return true;\n\n      case \"cursed\":\n        Glyphs.removeFromInventory(glyph);\n        return true;\n    }\n\n    return false;\n  },\n\n  // Removes a glyph, accounting for sacrifice unlock and alchemy state\n  removeGlyph(glyph, force = false) {\n    if (this.handleSpecialGlyphTypes(glyph)) return;\n    if (!this.canSacrifice) this.deleteGlyph(glyph, force);else if (this.isRefining) this.attemptRefineGlyph(glyph, force);else this.sacrificeGlyph(glyph, force);\n  },\n\n  deleteGlyph(glyph, force) {\n    if (force || !player.options.confirmations.glyphSacrifice) Glyphs.removeFromInventory(glyph);else Modal.glyphDelete.show({\n      idx: glyph.idx\n    });\n  },\n\n  glyphSacrificeGain(glyph) {\n    if (!this.canSacrifice || Pelle.isDoomed) return 0;\n    if (glyph.type === \"reality\") return 0.01 * glyph.level * Achievement(171).effectOrDefault(1);\n    const pre10kFactor = Math.pow(Math.clampMax(glyph.level, 10000) + 10, 2.5);\n    const post10kFactor = 1 + Math.clampMin(glyph.level - 10000, 0) / 100;\n    const power = Ra.unlocks.maxGlyphRarityAndShardSacrificeBoost.effectOrDefault(1);\n    return Math.pow(pre10kFactor * post10kFactor * glyph.strength * Teresa.runRewardMultiplier * Achievement(171).effectOrDefault(1), power);\n  },\n\n  sacrificeGlyph(glyph, force = false) {\n    if (Pelle.isDoomed) return; // This also needs to be here because this method is called directly from drag-and-drop sacrificing\n\n    if (this.handleSpecialGlyphTypes(glyph)) return;\n    const toGain = this.glyphSacrificeGain(glyph);\n    const askConfirmation = !force && player.options.confirmations.glyphSacrifice;\n\n    if (askConfirmation) {\n      Modal.glyphSacrifice.show({\n        idx: glyph.idx,\n        gain: toGain\n      });\n      return;\n    }\n\n    player.reality.glyphs.sac[glyph.type] += toGain;\n    GameCache.logTotalGlyphSacrifice.invalidate();\n    Glyphs.removeFromInventory(glyph);\n    EventHub.dispatch(GAME_EVENT.GLYPH_SACRIFICED, glyph);\n  },\n\n  glyphAlchemyResource(glyph) {\n    const type = GlyphTypes[glyph.type];\n    return AlchemyResources.all[type.alchemyResource];\n  },\n\n  // Scaling function to make refinement value ramp up with higher glyph levels\n  levelRefinementValue(level) {\n    return Math.pow(level, 3) / 1e8;\n  },\n\n  // Refined glyphs give this proportion of their maximum attainable value from their level\n  glyphRefinementEfficiency: 0.05,\n\n  glyphRawRefinementGain(glyph) {\n    if (!Ra.unlocks.unlockGlyphAlchemy.canBeApplied) return 0;\n    const glyphMaxValue = this.levelRefinementValue(glyph.level);\n    const rarityModifier = strengthToRarity(glyph.strength) / 100;\n    return this.glyphRefinementEfficiency * glyphMaxValue * rarityModifier;\n  },\n\n  glyphRefinementGain(glyph) {\n    if (!Ra.unlocks.unlockGlyphAlchemy.canBeApplied || !generatedTypes.includes(glyph.type)) return 0;\n    const resource = this.glyphAlchemyResource(glyph);\n    if (!resource.isUnlocked) return 0;\n    const glyphActualValue = this.glyphRawRefinementGain(glyph);\n    if (resource.cap === 0) return glyphActualValue;\n    const amountUntilCap = this.glyphEffectiveCap(glyph) - resource.amount;\n    return Math.clamp(amountUntilCap, 0, glyphActualValue);\n  },\n\n  // The glyph that is being refined can increase the cap, which means the effective cap\n  // will be the current resource cap or the cap after this glyph is refined, whichever is higher.\n  glyphEffectiveCap(glyph) {\n    const resource = this.glyphAlchemyResource(glyph);\n    const currentCap = resource.cap;\n    const capAfterRefinement = this.highestRefinementValue(glyph);\n    const higherCap = Math.clampMin(currentCap, capAfterRefinement);\n    return Math.clampMax(higherCap, Ra.alchemyResourceCap);\n  },\n\n  highestRefinementValue(glyph) {\n    return this.glyphRawRefinementGain(glyph) / this.glyphRefinementEfficiency;\n  },\n\n  attemptRefineGlyph(glyph, force) {\n    if (glyph.type === \"reality\") return;\n\n    if (glyph.type === \"cursed\") {\n      Glyphs.removeFromInventory(glyph);\n      return;\n    }\n\n    const decoherence = AlchemyResource.decoherence.isUnlocked;\n\n    if (!Ra.unlocks.unlockGlyphAlchemy.canBeApplied || this.glyphRefinementGain(glyph) === 0 && !decoherence || decoherence && AlchemyResources.base.every(x => x.data.amount >= Ra.alchemyResourceCap)) {\n      this.sacrificeGlyph(glyph, force);\n      return;\n    }\n\n    if (!player.options.confirmations.glyphRefine || force) {\n      this.refineGlyph(glyph);\n      return;\n    }\n\n    const resource = this.glyphAlchemyResource(glyph);\n    Modal.glyphRefine.show({\n      idx: glyph.idx,\n      resourceName: resource.name,\n      resourceAmount: resource.amount,\n      gain: this.glyphRefinementGain(glyph),\n      cap: resource.cap\n    });\n  },\n\n  refineGlyph(glyph) {\n    if (Pelle.isDoomed) return;\n    const resource = this.glyphAlchemyResource(glyph); // This technically completely trashes the glyph for no rewards if not unlocked, but this will only happen ever\n    // if the player specificially tries to do so (in which case they're made aware that it's useless) or if the\n    // Reality choices contain *only* locked glyph choices. That's a rare enough edge case that I think it's okay\n    // to just delete it instead of complicating the program flow more than it already is by attempting sacrifice.\n\n    if (!resource.isUnlocked) {\n      Glyphs.removeFromInventory(glyph);\n      return;\n    }\n\n    const rawRefinementGain = this.glyphRawRefinementGain(glyph);\n    const refinementGain = this.glyphRefinementGain(glyph);\n    resource.amount += refinementGain;\n    const decoherenceGain = rawRefinementGain * AlchemyResource.decoherence.effectValue;\n\n    for (const glyphTypeName of ALCHEMY_BASIC_GLYPH_TYPES) {\n      if (glyphTypeName !== glyph.type) {\n        const glyphType = GlyphTypes[glyphTypeName];\n        const otherResource = AlchemyResources.all[glyphType.alchemyResource];\n        const maxResource = Math.max(otherResource.cap, otherResource.amount);\n        otherResource.amount = Math.clampMax(otherResource.amount + decoherenceGain, maxResource);\n      }\n    }\n\n    if (resource.isBaseResource) {\n      resource.highestRefinementValue = this.highestRefinementValue(glyph);\n    }\n\n    Glyphs.removeFromInventory(glyph);\n  }\n\n};","map":{"version":3,"sources":["C:/Games/ADFasterer/ADfasterer/src/core/glyphs/glyph-purge-handler.js"],"names":["GlyphSacrificeHandler","maxSacrificeForEffects","logTotalSacrifice","BASIC_GLYPH_TYPES","reduce","tot","type","Math","log10","clampMin","player","reality","glyphs","sac","canSacrifice","RealityUpgrade","isBought","isRefining","Ra","unlocks","unlockGlyphAlchemy","canBeApplied","AutoGlyphProcessor","sacMode","AUTO_GLYPH_REJECT","SACRIFICE","handleSpecialGlyphTypes","glyph","Modal","deleteCompanion","show","Glyphs","removeFromInventory","removeGlyph","force","deleteGlyph","attemptRefineGlyph","sacrificeGlyph","options","confirmations","glyphSacrifice","glyphDelete","idx","glyphSacrificeGain","Pelle","isDoomed","level","Achievement","effectOrDefault","pre10kFactor","pow","clampMax","post10kFactor","power","maxGlyphRarityAndShardSacrificeBoost","strength","Teresa","runRewardMultiplier","toGain","askConfirmation","gain","GameCache","logTotalGlyphSacrifice","invalidate","EventHub","dispatch","GAME_EVENT","GLYPH_SACRIFICED","glyphAlchemyResource","GlyphTypes","AlchemyResources","all","alchemyResource","levelRefinementValue","glyphRefinementEfficiency","glyphRawRefinementGain","glyphMaxValue","rarityModifier","strengthToRarity","glyphRefinementGain","generatedTypes","includes","resource","isUnlocked","glyphActualValue","cap","amountUntilCap","glyphEffectiveCap","amount","clamp","currentCap","capAfterRefinement","highestRefinementValue","higherCap","alchemyResourceCap","decoherence","AlchemyResource","base","every","x","data","glyphRefine","refineGlyph","resourceName","name","resourceAmount","rawRefinementGain","refinementGain","decoherenceGain","effectValue","glyphTypeName","ALCHEMY_BASIC_GLYPH_TYPES","glyphType","otherResource","maxResource","max","isBaseResource"],"mappings":"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","sourcesContent":["// This actually deals with both sacrifice and refining, but I wasn't 100% sure what to call it\r\nexport const GlyphSacrificeHandler = {\r\n  // Anything scaling on sacrifice caps at this value, even though the actual sacrifice values can go higher\r\n  maxSacrificeForEffects: 1e100,\r\n  // This is used for glyph UI-related things in a few places, but is handled here as a getter which is only called\r\n  // sparingly - that is, whenever the cache is invalidated after a glyph is sacrificed. Thus it only gets recalculated\r\n  // when glyphs are actually sacrificed, rather than every render cycle.\r\n  get logTotalSacrifice() {\r\n    // We check elsewhere for this equalling zero to determine if the player has ever sacrificed. Technically this\r\n    // should check for -Infinity, but the clampMin works in practice because the minimum possible sacrifice\r\n    // value is greater than 1 for even the weakest possible glyph\r\n    return BASIC_GLYPH_TYPES.reduce(\r\n      (tot, type) => tot + Math.log10(Math.clampMin(player.reality.glyphs.sac[type], 1)), 0);\r\n  },\r\n  get canSacrifice() {\r\n    return RealityUpgrade(19).isBought;\r\n  },\r\n  get isRefining() {\r\n    return Ra.unlocks.unlockGlyphAlchemy.canBeApplied && AutoGlyphProcessor.sacMode !== AUTO_GLYPH_REJECT.SACRIFICE;\r\n  },\r\n  handleSpecialGlyphTypes(glyph) {\r\n    switch (glyph.type) {\r\n      case \"companion\":\r\n        Modal.deleteCompanion.show();\r\n        return true;\r\n      case \"cursed\":\r\n        Glyphs.removeFromInventory(glyph);\r\n        return true;\r\n    }\r\n    return false;\r\n  },\r\n  // Removes a glyph, accounting for sacrifice unlock and alchemy state\r\n  removeGlyph(glyph, force = false) {\r\n    if (this.handleSpecialGlyphTypes(glyph)) return;\r\n    if (!this.canSacrifice) this.deleteGlyph(glyph, force);\r\n    else if (this.isRefining) this.attemptRefineGlyph(glyph, force);\r\n    else this.sacrificeGlyph(glyph, force);\r\n  },\r\n  deleteGlyph(glyph, force) {\r\n    if (force || !player.options.confirmations.glyphSacrifice) Glyphs.removeFromInventory(glyph);\r\n    else Modal.glyphDelete.show({ idx: glyph.idx });\r\n  },\r\n  glyphSacrificeGain(glyph) {\r\n    if (!this.canSacrifice || Pelle.isDoomed) return 0;\r\n    if (glyph.type === \"reality\") return 0.01 * glyph.level * Achievement(171).effectOrDefault(1);\r\n    const pre10kFactor = Math.pow(Math.clampMax(glyph.level, 10000) + 10, 2.5);\r\n    const post10kFactor = 1 + Math.clampMin(glyph.level - 10000, 0) / 100;\r\n    const power = Ra.unlocks.maxGlyphRarityAndShardSacrificeBoost.effectOrDefault(1);\r\n    return Math.pow(pre10kFactor * post10kFactor * glyph.strength *\r\n      Teresa.runRewardMultiplier * Achievement(171).effectOrDefault(1), power);\r\n  },\r\n  sacrificeGlyph(glyph, force = false) {\r\n    if (Pelle.isDoomed) return;\r\n    // This also needs to be here because this method is called directly from drag-and-drop sacrificing\r\n    if (this.handleSpecialGlyphTypes(glyph)) return;\r\n    const toGain = this.glyphSacrificeGain(glyph);\r\n    const askConfirmation = !force && player.options.confirmations.glyphSacrifice;\r\n    if (askConfirmation) {\r\n      Modal.glyphSacrifice.show({ idx: glyph.idx, gain: toGain });\r\n      return;\r\n    }\r\n    player.reality.glyphs.sac[glyph.type] += toGain;\r\n    GameCache.logTotalGlyphSacrifice.invalidate();\r\n    Glyphs.removeFromInventory(glyph);\r\n    EventHub.dispatch(GAME_EVENT.GLYPH_SACRIFICED, glyph);\r\n  },\r\n  glyphAlchemyResource(glyph) {\r\n    const type = GlyphTypes[glyph.type];\r\n    return AlchemyResources.all[type.alchemyResource];\r\n  },\r\n  // Scaling function to make refinement value ramp up with higher glyph levels\r\n  levelRefinementValue(level) {\r\n    return Math.pow(level, 3) / 1e8;\r\n  },\r\n  // Refined glyphs give this proportion of their maximum attainable value from their level\r\n  glyphRefinementEfficiency: 0.05,\r\n  glyphRawRefinementGain(glyph) {\r\n    if (!Ra.unlocks.unlockGlyphAlchemy.canBeApplied) return 0;\r\n    const glyphMaxValue = this.levelRefinementValue(glyph.level);\r\n    const rarityModifier = strengthToRarity(glyph.strength) / 100;\r\n    return this.glyphRefinementEfficiency * glyphMaxValue * rarityModifier;\r\n  },\r\n  glyphRefinementGain(glyph) {\r\n    if (!Ra.unlocks.unlockGlyphAlchemy.canBeApplied || !generatedTypes.includes(glyph.type)) return 0;\r\n    const resource = this.glyphAlchemyResource(glyph);\r\n    if (!resource.isUnlocked) return 0;\r\n    const glyphActualValue = this.glyphRawRefinementGain(glyph);\r\n    if (resource.cap === 0) return glyphActualValue;\r\n    const amountUntilCap = this.glyphEffectiveCap(glyph) - resource.amount;\r\n    return Math.clamp(amountUntilCap, 0, glyphActualValue);\r\n  },\r\n  // The glyph that is being refined can increase the cap, which means the effective cap\r\n  // will be the current resource cap or the cap after this glyph is refined, whichever is higher.\r\n  glyphEffectiveCap(glyph) {\r\n    const resource = this.glyphAlchemyResource(glyph);\r\n    const currentCap = resource.cap;\r\n    const capAfterRefinement = this.highestRefinementValue(glyph);\r\n    const higherCap = Math.clampMin(currentCap, capAfterRefinement);\r\n    return Math.clampMax(higherCap, Ra.alchemyResourceCap);\r\n  },\r\n  highestRefinementValue(glyph) {\r\n    return this.glyphRawRefinementGain(glyph) / this.glyphRefinementEfficiency;\r\n  },\r\n  attemptRefineGlyph(glyph, force) {\r\n    if (glyph.type === \"reality\") return;\r\n    if (glyph.type === \"cursed\") {\r\n      Glyphs.removeFromInventory(glyph);\r\n      return;\r\n    }\r\n    const decoherence = AlchemyResource.decoherence.isUnlocked;\r\n    if (!Ra.unlocks.unlockGlyphAlchemy.canBeApplied ||\r\n        (this.glyphRefinementGain(glyph) === 0 && !decoherence) ||\r\n        (decoherence && AlchemyResources.base.every(x => x.data.amount >= Ra.alchemyResourceCap))) {\r\n      this.sacrificeGlyph(glyph, force);\r\n      return;\r\n    }\r\n\r\n    if (!player.options.confirmations.glyphRefine || force) {\r\n      this.refineGlyph(glyph);\r\n      return;\r\n    }\r\n    const resource = this.glyphAlchemyResource(glyph);\r\n    Modal.glyphRefine.show({\r\n      idx: glyph.idx,\r\n      resourceName: resource.name,\r\n      resourceAmount: resource.amount,\r\n      gain: this.glyphRefinementGain(glyph),\r\n      cap: resource.cap\r\n    });\r\n\r\n  },\r\n  refineGlyph(glyph) {\r\n    if (Pelle.isDoomed) return;\r\n    const resource = this.glyphAlchemyResource(glyph);\r\n    // This technically completely trashes the glyph for no rewards if not unlocked, but this will only happen ever\r\n    // if the player specificially tries to do so (in which case they're made aware that it's useless) or if the\r\n    // Reality choices contain *only* locked glyph choices. That's a rare enough edge case that I think it's okay\r\n    // to just delete it instead of complicating the program flow more than it already is by attempting sacrifice.\r\n    if (!resource.isUnlocked) {\r\n      Glyphs.removeFromInventory(glyph);\r\n      return;\r\n    }\r\n    const rawRefinementGain = this.glyphRawRefinementGain(glyph);\r\n    const refinementGain = this.glyphRefinementGain(glyph);\r\n    resource.amount += refinementGain;\r\n    const decoherenceGain = rawRefinementGain * AlchemyResource.decoherence.effectValue;\r\n    for (const glyphTypeName of ALCHEMY_BASIC_GLYPH_TYPES) {\r\n      if (glyphTypeName !== glyph.type) {\r\n        const glyphType = GlyphTypes[glyphTypeName];\r\n        const otherResource = AlchemyResources.all[glyphType.alchemyResource];\r\n        const maxResource = Math.max(otherResource.cap, otherResource.amount);\r\n        otherResource.amount = Math.clampMax(otherResource.amount + decoherenceGain, maxResource);\r\n      }\r\n    }\r\n    if (resource.isBaseResource) {\r\n      resource.highestRefinementValue = this.highestRefinementValue(glyph);\r\n    }\r\n    Glyphs.removeFromInventory(glyph);\r\n  }\r\n};\r\n"]},"metadata":{},"sourceType":"module"}